CCS PCM C Compiler, Version 5.076, 56587               09-mar.-20 21:45

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mtime\mtime.lst

               ROM used:   3380 words (41%)
                           Largest free fragment is 2048
               RAM used:   70 (19%) at main() level
                           97 (26%) worst case
               Stack used: 5 locations (1 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   4EB
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   5C8
0057:  BSF    0A.3
0058:  BCF    0A.4
0059:  GOTO   000
.................... #include <mtime.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 0D,00
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA A0,23
007D:  DATA F2,3A
007E:  DATA F0,37
007F:  DATA A0,20
0080:  DATA D0,26
0081:  DATA 20,14
0082:  DATA E3,14
0083:  DATA 20,19
0084:  DATA 30,19
0085:  DATA 30,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 0D,00
008A:  DATA BD,1E
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA 0D,00
009B:  DATA 42,36
009C:  DATA F5,32
009D:  DATA F4,37
009E:  DATA 6F,3A
009F:  DATA 68,10
00A0:  DATA C2,30
00A1:  DATA F3,35
00A2:  DATA 65,3A
00A3:  DATA E2,30
00A4:  DATA 6C,36
00A5:  DATA A0,29
00A6:  DATA E3,37
00A7:  DATA F2,32
00A8:  DATA 20,21
00A9:  DATA EF,30
00AA:  DATA 72,32
00AB:  DATA 0D,00
00AC:  DATA BD,1E
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA 0D,00
00BD:  DATA D6,32
00BE:  DATA F2,39
00BF:  DATA E9,37
00C0:  DATA 6E,10
00C1:  DATA A5,39
00C2:  DATA A0,16
00C3:  DATA 20,39
00C4:  DATA 65,3B
00C5:  DATA A0,12
00C6:  DATA 73,10
00C7:  DATA 0D,00
00C8:  DATA 31,17
00C9:  DATA 35,00
00CA:  DATA 44,00
00CB:  DATA 2A,15
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 0D,00
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA C4,22
00E0:  DATA D0,2A
00E1:  DATA D2,20
00E2:  DATA C3,24
00E3:  DATA 4F,27
00E4:  DATA 20,1D
00E5:  DATA 3A,10
00E6:  DATA D4,24
00E7:  DATA C5,26
00E8:  DATA D0,27
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 20,10
00EC:  DATA 0D,00
00ED:  DATA 47,39
00EE:  DATA 75,38
00EF:  DATA 6F,10
00F0:  DATA 41,28
00F1:  DATA 4D,10
00F2:  DATA A8,31
00F3:  DATA 29,10
00F4:  DATA 32,18
00F5:  DATA 32,18
00F6:  DATA 20,1D
00F7:  DATA 3A,10
00F8:  DATA 42,21
00F9:  DATA 53,21
00FA:  DATA A0,18
00FB:  DATA 2E,18
00FC:  DATA 20,39
00FD:  DATA 65,3B
00FE:  DATA A0,20
00FF:  DATA 00,00
0100:  DATA 3E,10
0101:  DATA C8,30
0102:  DATA E2,34
0103:  DATA EC,34
0104:  DATA F4,30
0105:  DATA E3,34
0106:  DATA 6F,37
0107:  DATA 20,32
0108:  DATA 65,10
0109:  DATA 49,19
010A:  DATA 43,00
010B:  DATA 3E,10
010C:  DATA C3,37
010D:  DATA 6E,33
010E:  DATA E9,33
010F:  DATA 75,39
0110:  DATA E1,31
0111:  DATA E9,37
0112:  DATA 6E,10
0113:  DATA E4,32
0114:  DATA 20,28
0115:  DATA F5,32
0116:  DATA 72,3A
0117:  DATA EF,39
0118:  DATA 00,01
0119:  DATA 3E,10
011A:  DATA C8,30
011B:  DATA E2,34
011C:  DATA EC,34
011D:  DATA F4,30
011E:  DATA E3,34
011F:  DATA 6F,37
0120:  DATA 20,32
0121:  DATA 65,10
0122:  DATA E4,34
0123:  DATA 73,38
0124:  DATA EC,30
0125:  DATA F9,39
0126:  DATA 00,01
0127:  DATA 3E,10
0128:  DATA C8,30
0129:  DATA E2,34
012A:  DATA EC,34
012B:  DATA F4,30
012C:  DATA E3,34
012D:  DATA 6F,37
012E:  DATA 20,32
012F:  DATA 65,10
0130:  DATA 69,37
0131:  DATA F4,32
0132:  DATA 72,39
0133:  DATA 75,38
0134:  DATA E3,34
0135:  DATA 6F,37
0136:  DATA E5,39
0137:  DATA 00,00
0138:  MOVF   0B,W
0139:  MOVWF  72
013A:  BCF    0B.7
013B:  BSF    03.5
013C:  BSF    03.6
013D:  BSF    0C.7
013E:  BSF    0C.0
013F:  NOP
0140:  NOP
0141:  BTFSS  72.7
0142:  GOTO   148
0143:  BCF    03.5
0144:  BCF    03.6
0145:  BSF    0B.7
0146:  BSF    03.5
0147:  BSF    03.6
0148:  BCF    03.5
0149:  MOVF   0C,W
014A:  ANDLW  7F
014B:  BTFSC  03.2
014C:  GOTO   188
014D:  MOVWF  72
014E:  MOVF   0D,W
014F:  MOVWF  73
0150:  MOVF   0F,W
0151:  MOVWF  74
0152:  MOVF   72,W
0153:  BCF    03.6
0154:  BTFSS  0C.4
0155:  GOTO   154
0156:  MOVWF  19
0157:  MOVF   73,W
0158:  BSF    03.6
0159:  MOVWF  0D
015A:  MOVF   74,W
015B:  MOVWF  0F
015C:  BCF    03.6
015D:  MOVF   0B,W
015E:  MOVWF  75
015F:  BCF    0B.7
0160:  BSF    03.5
0161:  BSF    03.6
0162:  BSF    0C.7
0163:  BSF    0C.0
0164:  NOP
0165:  NOP
0166:  BTFSS  75.7
0167:  GOTO   16D
0168:  BCF    03.5
0169:  BCF    03.6
016A:  BSF    0B.7
016B:  BSF    03.5
016C:  BSF    03.6
016D:  BCF    03.5
016E:  RLF    0C,W
016F:  RLF    0E,W
0170:  ANDLW  7F
0171:  BTFSC  03.2
0172:  GOTO   188
0173:  MOVWF  72
0174:  MOVF   0D,W
0175:  MOVWF  73
0176:  MOVF   0F,W
0177:  MOVWF  74
0178:  MOVF   72,W
0179:  BCF    03.6
017A:  BTFSS  0C.4
017B:  GOTO   17A
017C:  MOVWF  19
017D:  MOVF   73,W
017E:  BSF    03.6
017F:  MOVWF  0D
0180:  MOVF   74,W
0181:  MOVWF  0F
0182:  INCF   0D,F
0183:  BTFSC  03.2
0184:  INCF   0F,F
0185:  BCF    03.6
0186:  GOTO   138
0187:  BSF    03.6
0188:  BCF    03.6
0189:  RETURN
*
01BB:  BSF    0A.0
01BC:  BCF    0A.1
01BD:  BCF    0A.2
01BE:  ADDWF  02,F
01BF:  GOTO   191
01C0:  GOTO   195
01C1:  GOTO   199
01C2:  GOTO   19D
01C3:  GOTO   1A1
01C4:  GOTO   1A5
01C5:  GOTO   1A9
01C6:  GOTO   1AD
01C7:  GOTO   1B1
01C8:  GOTO   1B5
01C9:  MOVF   7C,W
01CA:  ANDLW  07
01CB:  MOVWF  77
01CC:  RRF    7C,W
01CD:  MOVWF  78
01CE:  RRF    78,F
01CF:  RRF    78,F
01D0:  MOVLW  1F
01D1:  ANDWF  78,F
01D2:  MOVF   78,W
01D3:  BSF    03.5
01D4:  ADDWF  20,W
01D5:  MOVWF  04
01D6:  BCF    03.7
01D7:  BTFSC  21.0
01D8:  BSF    03.7
01D9:  CLRF   78
01DA:  INCF   78,F
01DB:  INCF   77,F
01DC:  GOTO   1DE
01DD:  RLF    78,F
01DE:  DECFSZ 77,F
01DF:  GOTO   1DD
01E0:  MOVF   7D,F
01E1:  BTFSC  03.2
01E2:  GOTO   1E6
01E3:  MOVF   78,W
01E4:  IORWF  00,F
01E5:  GOTO   1E9
01E6:  COMF   78,F
01E7:  MOVF   78,W
01E8:  ANDWF  00,F
01E9:  BCF    03.5
01EA:  RETURN
*
0266:  BCF    0A.0
0267:  BSF    0A.1
0268:  BCF    0A.2
0269:  ADDWF  02,F
026A:  GOTO   1F6
026B:  GOTO   1F8
026C:  GOTO   1FA
026D:  GOTO   1FD
026E:  GOTO   1FF
026F:  GOTO   202
0270:  GOTO   205
0271:  GOTO   209
0272:  GOTO   20B
*
02A5:  BCF    0A.0
02A6:  BSF    0A.1
02A7:  BCF    0A.2
02A8:  ADDWF  02,F
02A9:  GOTO   28E
02AA:  GOTO   293
02AB:  GOTO   298
02AC:  GOTO   29D
*
05BF:  BSF    0A.0
05C0:  BCF    0A.1
05C1:  BSF    0A.2
05C2:  ADDWF  02,F
05C3:  GOTO   40B
05C4:  GOTO   41B
05C5:  GOTO   42B
05C6:  GOTO   43B
05C7:  GOTO   44B
*
0618:  MOVF   0B,W
0619:  MOVWF  69
061A:  BCF    0B.7
061B:  BSF    03.5
061C:  BSF    03.6
061D:  BSF    0C.7
061E:  BSF    0C.0
061F:  NOP
0620:  NOP
0621:  BCF    03.5
0622:  BCF    03.6
0623:  BTFSC  69.7
0624:  BSF    0B.7
0625:  BTFSC  03.0
0626:  GOTO   650
0627:  BSF    03.6
0628:  MOVF   0C,W
0629:  ANDLW  7F
062A:  BCF    03.6
062B:  MOVWF  69
062C:  BSF    03.6
062D:  MOVF   0D,W
062E:  BCF    03.6
062F:  MOVWF  6A
0630:  BSF    03.6
0631:  MOVF   0F,W
0632:  BCF    03.6
0633:  MOVWF  6B
0634:  MOVF   69,W
0635:  BTFSS  0C.4
0636:  GOTO   635
0637:  MOVWF  19
0638:  MOVF   6A,W
0639:  BSF    03.6
063A:  MOVWF  0D
063B:  BCF    03.6
063C:  MOVF   6B,W
063D:  BSF    03.6
063E:  MOVWF  0F
063F:  BCF    03.6
0640:  MOVF   0B,W
0641:  MOVWF  6C
0642:  BCF    0B.7
0643:  BSF    03.5
0644:  BSF    03.6
0645:  BSF    0C.7
0646:  BSF    0C.0
0647:  NOP
0648:  NOP
0649:  BCF    03.5
064A:  BCF    03.6
064B:  BTFSC  6C.7
064C:  BSF    0B.7
064D:  DECFSZ 68,F
064E:  GOTO   650
064F:  GOTO   670
0650:  BSF    03.6
0651:  RLF    0C,W
0652:  RLF    0E,W
0653:  ANDLW  7F
0654:  BCF    03.6
0655:  MOVWF  69
0656:  BSF    03.6
0657:  MOVF   0D,W
0658:  BCF    03.6
0659:  MOVWF  6A
065A:  BSF    03.6
065B:  MOVF   0F,W
065C:  BCF    03.6
065D:  MOVWF  6B
065E:  MOVF   69,W
065F:  BTFSS  0C.4
0660:  GOTO   65F
0661:  MOVWF  19
0662:  MOVF   6A,W
0663:  BSF    03.6
0664:  MOVWF  0D
0665:  BCF    03.6
0666:  MOVF   6B,W
0667:  BSF    03.6
0668:  MOVWF  0F
0669:  INCF   0D,F
066A:  BTFSC  03.2
066B:  INCF   0F,F
066C:  BCF    03.0
066D:  BCF    03.6
066E:  DECFSZ 68,F
066F:  GOTO   618
0670:  RETURN
0671:  BTFSC  69.7
0672:  GOTO   684
0673:  MOVLW  0F
0674:  MOVWF  77
0675:  SWAPF  68,W
0676:  ANDWF  77,F
0677:  MOVLW  0A
0678:  SUBWF  77,W
0679:  BTFSC  03.0
067A:  GOTO   67E
067B:  MOVLW  30
067C:  ADDWF  77,F
067D:  GOTO   680
067E:  MOVF   69,W
067F:  ADDWF  77,F
0680:  MOVF   77,W
0681:  BTFSS  0C.4
0682:  GOTO   681
0683:  MOVWF  19
0684:  MOVLW  0F
0685:  ANDWF  68,F
0686:  MOVLW  0A
0687:  SUBWF  68,W
0688:  BTFSC  03.0
0689:  GOTO   68C
068A:  MOVLW  30
068B:  GOTO   68E
068C:  BCF    69.7
068D:  MOVF   69,W
068E:  ADDWF  68,F
068F:  MOVF   68,W
0690:  BTFSS  0C.4
0691:  GOTO   690
0692:  MOVWF  19
0693:  RETURN
0694:  DATA 3E,10
0695:  DATA C3,37
0696:  DATA ED,36
0697:  DATA 61,37
0698:  DATA E4,37
0699:  DATA 3A,10
069A:  DATA 25,2C
069B:  DATA A0,16
069C:  DATA A0,12
069D:  DATA D8,06
069E:  DATA 80,27
069F:  DATA 3E,10
06A0:  DATA C4,34
06A1:  DATA F2,32
06A2:  DATA E3,31
06A3:  DATA E9,37
06A4:  DATA 6E,10
06A5:  DATA D4,24
06A6:  DATA CD,22
06A7:  DATA 52,00
06A8:  DATA 3E,10
06A9:  DATA C4,34
06AA:  DATA F2,32
06AB:  DATA E3,31
06AC:  DATA E9,37
06AD:  DATA 6E,10
06AE:  DATA D3,21
06AF:  DATA 4F,29
06B0:  DATA 45,00
06B1:  DATA 3E,10
06B2:  DATA 41,38
06B3:  DATA E1,33
06B4:  DATA 61,39
06B5:  DATA 20,28
06B6:  DATA 65,39
06B7:  DATA E9,37
06B8:  DATA E4,37
06B9:  DATA 73,00
06BA:  DATA 3E,10
06BB:  DATA C1,31
06BC:  DATA F4,34
06BD:  DATA F6,30
06BE:  DATA 72,10
06BF:  DATA D0,32
06C0:  DATA F2,34
06C1:  DATA 6F,32
06C2:  DATA 6F,10
06C3:  DATA 31,00
06C4:  DATA 3E,10
06C5:  DATA C1,31
06C6:  DATA F4,34
06C7:  DATA F6,30
06C8:  DATA 72,10
06C9:  DATA D0,32
06CA:  DATA F2,34
06CB:  DATA 6F,32
06CC:  DATA 6F,10
06CD:  DATA 32,00
06CE:  DATA 3E,10
06CF:  DATA C1,31
06D0:  DATA F4,34
06D1:  DATA F6,30
06D2:  DATA 72,10
06D3:  DATA D0,32
06D4:  DATA F2,34
06D5:  DATA 6F,32
06D6:  DATA 6F,10
06D7:  DATA 33,00
06D8:  DATA 3E,10
06D9:  DATA C1,31
06DA:  DATA F4,34
06DB:  DATA F6,30
06DC:  DATA 72,10
06DD:  DATA D0,32
06DE:  DATA F2,34
06DF:  DATA 6F,32
06E0:  DATA 6F,10
06E1:  DATA 34,00
06E2:  DATA 3E,10
06E3:  DATA C1,31
06E4:  DATA F4,34
06E5:  DATA F6,30
06E6:  DATA 72,10
06E7:  DATA CD,34
06E8:  DATA EE,3A
06E9:  DATA F4,37
06EA:  DATA 20,22
06EB:  DATA E5,31
06EC:  DATA 65,37
06ED:  DATA 61,00
06EE:  DATA 3E,10
06EF:  DATA C4,32
06F0:  DATA F3,30
06F1:  DATA 63,3A
06F2:  DATA 69,3B
06F3:  DATA 61,39
06F4:  DATA A0,26
06F5:  DATA 69,37
06F6:  DATA 75,3A
06F7:  DATA 6F,10
06F8:  DATA C4,32
06F9:  DATA E3,32
06FA:  DATA EE,30
06FB:  DATA 00,01
06FC:  DATA 3E,10
06FD:  DATA D4,37
06FE:  DATA F1,3A
06FF:  DATA 65,10
0700:  DATA C3,37
0701:  DATA 72,3A
0702:  DATA 6F,00
0703:  DATA 3E,10
0704:  DATA D4,37
0705:  DATA F1,3A
0706:  DATA 65,10
0707:  DATA CC,30
0708:  DATA F2,33
0709:  DATA 6F,00
070A:  DATA 3E,10
070B:  DATA D4,37
070C:  DATA F1,3A
070D:  DATA 65,10
070E:  DATA C4,37
070F:  DATA 62,36
0710:  DATA 65,00
0711:  DATA 3E,10
0712:  DATA C1,39
0713:  DATA E9,33
0714:  DATA EE,30
0715:  DATA E3,34
0716:  DATA 6F,37
0717:  DATA 20,28
0718:  DATA F5,32
0719:  DATA 72,3A
071A:  DATA 6F,10
071B:  DATA 31,00
071C:  DATA 3E,10
071D:  DATA C1,39
071E:  DATA E9,33
071F:  DATA EE,30
0720:  DATA E3,34
0721:  DATA 6F,37
0722:  DATA 20,28
0723:  DATA F5,32
0724:  DATA 72,3A
0725:  DATA 6F,10
0726:  DATA 32,00
0727:  DATA 3E,10
0728:  DATA C1,39
0729:  DATA E9,33
072A:  DATA EE,30
072B:  DATA E3,34
072C:  DATA 6F,37
072D:  DATA 20,28
072E:  DATA F5,32
072F:  DATA 72,3A
0730:  DATA 6F,10
0731:  DATA 33,00
0732:  DATA 3E,10
0733:  DATA C1,39
0734:  DATA E9,33
0735:  DATA EE,30
0736:  DATA E3,34
0737:  DATA 6F,37
0738:  DATA 20,28
0739:  DATA F5,32
073A:  DATA 72,3A
073B:  DATA 6F,10
073C:  DATA 34,00
073D:  DATA 3E,10
073E:  DATA C1,39
073F:  DATA E9,33
0740:  DATA EE,30
0741:  DATA E3,34
0742:  DATA 6F,37
0743:  DATA 20,28
0744:  DATA F5,32
0745:  DATA 72,3A
0746:  DATA 6F,10
0747:  DATA 35,00
0748:  DATA 3E,10
0749:  DATA D2,3A
074A:  DATA F4,34
074B:  DATA EE,30
074C:  DATA 20,32
074D:  DATA 65,10
074E:  DATA 70,39
074F:  DATA F5,32
0750:  DATA E2,30
0751:  DATA 00,00
0752:  DATA 0D,1F
0753:  DATA A0,20
0754:  DATA 63,3A
0755:  DATA 69,3B
0756:  DATA E1,31
0757:  DATA E9,37
0758:  DATA 6E,10
0759:  DATA ED,30
075A:  DATA EE,3A
075B:  DATA 61,36
075C:  DATA 20,32
075D:  DATA 65,10
075E:  DATA F0,3A
075F:  DATA 65,39
0760:  DATA F4,37
0761:  DATA 00,01
0762:  DATA 3E,10
0763:  DATA 41,38
0764:  DATA E1,33
0765:  DATA 61,39
0766:  DATA 20,28
0767:  DATA 65,39
0768:  DATA E9,37
0769:  DATA E4,37
076A:  DATA 73,00
076B:  DATA 3E,10
076C:  DATA C1,31
076D:  DATA F4,34
076E:  DATA F6,30
076F:  DATA 72,10
0770:  DATA D0,32
0771:  DATA F2,34
0772:  DATA 6F,32
0773:  DATA 6F,10
0774:  DATA 31,00
0775:  DATA 3E,10
0776:  DATA C1,31
0777:  DATA F4,34
0778:  DATA F6,30
0779:  DATA 72,10
077A:  DATA D0,32
077B:  DATA F2,34
077C:  DATA 6F,32
077D:  DATA 6F,10
077E:  DATA 32,00
077F:  DATA 3E,10
0780:  DATA C1,31
0781:  DATA F4,34
0782:  DATA F6,30
0783:  DATA 72,10
0784:  DATA D0,32
0785:  DATA F2,34
0786:  DATA 6F,32
0787:  DATA 6F,10
0788:  DATA 33,00
0789:  DATA 3E,10
078A:  DATA C1,31
078B:  DATA F4,34
078C:  DATA F6,30
078D:  DATA 72,10
078E:  DATA D0,32
078F:  DATA F2,34
0790:  DATA 6F,32
0791:  DATA 6F,10
0792:  DATA 34,00
0793:  DATA 3E,10
0794:  DATA C1,31
0795:  DATA F4,34
0796:  DATA F6,30
0797:  DATA 72,10
0798:  DATA CD,34
0799:  DATA EE,3A
079A:  DATA F4,37
079B:  DATA 20,22
079C:  DATA E5,31
079D:  DATA 65,37
079E:  DATA 61,00
079F:  DATA 3E,10
07A0:  DATA C4,32
07A1:  DATA F3,30
07A2:  DATA 63,3A
07A3:  DATA 69,3B
07A4:  DATA 61,39
07A5:  DATA A0,26
07A6:  DATA 69,37
07A7:  DATA 75,3A
07A8:  DATA 6F,10
07A9:  DATA C4,32
07AA:  DATA E3,32
07AB:  DATA EE,30
07AC:  DATA 00,01
07AD:  DATA 3E,10
07AE:  DATA D4,37
07AF:  DATA F1,3A
07B0:  DATA 65,10
07B1:  DATA C3,37
07B2:  DATA 72,3A
07B3:  DATA 6F,00
07B4:  DATA 3E,10
07B5:  DATA D4,37
07B6:  DATA F1,3A
07B7:  DATA 65,10
07B8:  DATA CC,30
07B9:  DATA F2,33
07BA:  DATA 6F,00
07BB:  DATA 3E,10
07BC:  DATA D4,37
07BD:  DATA F1,3A
07BE:  DATA 65,10
07BF:  DATA C4,37
07C0:  DATA 62,36
07C1:  DATA 65,00
07C2:  DATA 0D,1F
07C3:  DATA 20,29
07C4:  DATA E5,39
07C5:  DATA 65,3A
07C6:  DATA E5,37
07C7:  DATA A0,33
07C8:  DATA 65,37
07C9:  DATA 65,39
07CA:  DATA 61,36
07CB:  DATA 2E,17
07CC:  DATA AE,10
07CD:  DATA 00,01
07CE:  DATA 0D,1F
07CF:  DATA 20,14
07D0:  DATA B5,14
07D1:  DATA 00,01
07D2:  DATA 0D,1F
07D3:  DATA 20,14
07D4:  DATA B4,14
07D5:  DATA 00,01
07D6:  DATA 0D,1F
07D7:  DATA 20,14
07D8:  DATA B3,14
07D9:  DATA 00,01
07DA:  DATA 0D,1F
07DB:  DATA 20,14
07DC:  DATA B2,14
07DD:  DATA 00,01
07DE:  DATA 0D,1F
07DF:  DATA 20,14
07E0:  DATA B1,14
07E1:  DATA 00,01
07E2:  DATA 0D,1F
07E3:  DATA 20,14
07E4:  DATA B0,14
07E5:  DATA 00,00
07E6:  DATA 3E,10
07E7:  DATA D2,32
07E8:  DATA F3,32
07E9:  DATA F4,32
07EA:  DATA 61,37
07EB:  DATA E4,37
07EC:  DATA 2E,17
07ED:  DATA 2E,00
*
0AA8:  MOVF   0B,W
0AA9:  MOVWF  61
0AAA:  BCF    0B.7
0AAB:  BSF    03.5
0AAC:  BSF    03.6
0AAD:  BSF    0C.7
0AAE:  BSF    0C.0
0AAF:  NOP
0AB0:  NOP
0AB1:  BCF    03.5
0AB2:  BCF    03.6
0AB3:  BTFSC  61.7
0AB4:  BSF    0B.7
0AB5:  BSF    03.6
0AB6:  MOVF   0C,W
0AB7:  ANDLW  7F
0AB8:  BTFSC  03.2
0AB9:  GOTO   2FE
0ABA:  BCF    03.6
0ABB:  MOVWF  61
0ABC:  BSF    03.6
0ABD:  MOVF   0D,W
0ABE:  BCF    03.6
0ABF:  MOVWF  62
0AC0:  BSF    03.6
0AC1:  MOVF   0F,W
0AC2:  BCF    03.6
0AC3:  MOVWF  63
0AC4:  MOVF   61,W
0AC5:  BTFSS  0C.4
0AC6:  GOTO   2C5
0AC7:  MOVWF  19
0AC8:  MOVF   62,W
0AC9:  BSF    03.6
0ACA:  MOVWF  0D
0ACB:  BCF    03.6
0ACC:  MOVF   63,W
0ACD:  BSF    03.6
0ACE:  MOVWF  0F
0ACF:  BCF    03.6
0AD0:  MOVF   0B,W
0AD1:  MOVWF  64
0AD2:  BCF    0B.7
0AD3:  BSF    03.5
0AD4:  BSF    03.6
0AD5:  BSF    0C.7
0AD6:  BSF    0C.0
0AD7:  NOP
0AD8:  NOP
0AD9:  BCF    03.5
0ADA:  BCF    03.6
0ADB:  BTFSC  64.7
0ADC:  BSF    0B.7
0ADD:  BSF    03.6
0ADE:  RLF    0C,W
0ADF:  RLF    0E,W
0AE0:  ANDLW  7F
0AE1:  BTFSC  03.2
0AE2:  GOTO   2FE
0AE3:  BCF    03.6
0AE4:  MOVWF  61
0AE5:  BSF    03.6
0AE6:  MOVF   0D,W
0AE7:  BCF    03.6
0AE8:  MOVWF  62
0AE9:  BSF    03.6
0AEA:  MOVF   0F,W
0AEB:  BCF    03.6
0AEC:  MOVWF  63
0AED:  MOVF   61,W
0AEE:  BTFSS  0C.4
0AEF:  GOTO   2EE
0AF0:  MOVWF  19
0AF1:  MOVF   62,W
0AF2:  BSF    03.6
0AF3:  MOVWF  0D
0AF4:  BCF    03.6
0AF5:  MOVF   63,W
0AF6:  BSF    03.6
0AF7:  MOVWF  0F
0AF8:  INCF   0D,F
0AF9:  BTFSC  03.2
0AFA:  INCF   0F,F
0AFB:  BCF    03.6
0AFC:  GOTO   2A8
0AFD:  BSF    03.6
0AFE:  BCF    03.6
0AFF:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "1.5" 
.................... #define FW_REVISION  "D" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
02AD:  MOVLW  74
02AE:  MOVWF  04
02AF:  BCF    03.7
02B0:  MOVF   00,W
02B1:  BTFSC  03.2
02B2:  GOTO   2C0
02B3:  MOVLW  02
02B4:  MOVWF  78
02B5:  CLRF   77
02B6:  DECFSZ 77,F
02B7:  GOTO   2B6
02B8:  DECFSZ 78,F
02B9:  GOTO   2B5
02BA:  MOVLW  97
02BB:  MOVWF  77
02BC:  DECFSZ 77,F
02BD:  GOTO   2BC
02BE:  DECFSZ 00,F
02BF:  GOTO   2B3
02C0:  RETURN
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4,PIN_A3,PIN_A2,PIN_A1,PIN_A0 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5, PIN_C1, PIN_C0 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E3,PIN_E2,PIN_E1,PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
.................... #define PERIODO1  PIN_E1 
.................... #define PERIODO2  PIN_E2 
.................... #define PERIODO3  PIN_C0 
.................... #define PERIODO4  PIN_C1 
.................... #define MINUTOD   PIN_A0 
.................... #define BUZZER    PIN_A1 
....................  
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Slave,Fast,sda=I2C_SDA,scl=I2C_SCL, address = I2C_TIMER, FORCE_HW) 
*
0823:  MOVF   67,W
0824:  MOVWF  13
0825:  BSF    14.4
0826:  BCF    0C.3
0827:  BSF    03.5
0828:  BTFSC  14.0
0829:  GOTO   028
082A:  CLRF   78
082B:  BTFSS  11.6
082C:  INCF   78,F
....................  
.................... //-- DEFINICIONES -- 
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
....................  
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       200 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... //-- DECLARACIONES -- 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
0D27:  BCF    03.6
0D28:  CLRF   2C
0D29:  CLRF   2D
0D2A:  CLRF   2E
0D2B:  CLRF   2F
0D2C:  CLRF   30
0D2D:  CLRF   31
0D2E:  CLRF   32
0D2F:  CLRF   33
0D30:  CLRF   34
0D31:  CLRF   35
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
0D32:  CLRF   36
0D33:  CLRF   37
0D34:  CLRF   38
0D35:  CLRF   39
0D36:  CLRF   3A
0D37:  CLRF   3B
0D38:  CLRF   3C
0D39:  CLRF   3D
0D3A:  CLRF   3E
0D3B:  CLRF   3F
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... int  icmd; 
.................... int  ircmd[5] = "\0\0\0\0"; 
0D3C:  CLRF   43
0D3D:  CLRF   44
0D3E:  CLRF   45
0D3F:  CLRF   46
0D40:  CLRF   47
....................  
.................... //Puertos de Displays 
.................... tPort pTiroSU; 
.................... tPort pTiroSD; 
.................... tPort pTiempoSU; 
.................... tPort pTiempoSD; 
.................... tPort pTiempoMU; 
....................  
....................  
.................... //-- PROTOTIPOS -- 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8  char2int(char);  
.................... void doReset(void); 
.................... void parseI2CCommand(void); 
.................... void showQuarter(int8); 
.................... void buzz(int); 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
0D41:  CLRF   5C
0D42:  CLRF   5D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
0B00:  BSF    03.5
0B01:  CLRF   05
0B02:  BCF    03.5
0B03:  CLRF   05
....................    output_b(0x00); 
0B04:  BSF    03.5
0B05:  CLRF   06
0B06:  BCF    03.5
0B07:  CLRF   06
....................    output_c(0x00); 
0B08:  MOVLW  DC
0B09:  BSF    03.5
0B0A:  MOVWF  07
0B0B:  BCF    03.5
0B0C:  CLRF   07
....................    output_d(0x00); 
0B0D:  BSF    03.5
0B0E:  CLRF   08
0B0F:  BCF    03.5
0B10:  CLRF   08
....................    output_e(0x00); 
0B11:  BSF    03.5
0B12:  BCF    09.0
0B13:  BCF    09.1
0B14:  BCF    09.2
0B15:  BCF    09.3
0B16:  BCF    03.5
0B17:  CLRF   09
0B18:  CLRF   2B
0B19:  BTFSC  0B.7
0B1A:  BSF    2B.7
0B1B:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0B1C:  MOVLW  C8
0B1D:  MOVWF  74
0B1E:  BCF    0A.3
0B1F:  CALL   2AD
0B20:  BSF    0A.3
0B21:  BTFSC  2B.7
0B22:  BSF    0B.7
....................     
....................    if(DEBUG) 
0B23:  BTFSS  07.2
0B24:  GOTO   391
....................    { 
....................       fprintf(RS232,"********************************\r"); 
0B25:  MOVLW  68
0B26:  BSF    03.6
0B27:  MOVWF  0D
0B28:  MOVLW  00
0B29:  MOVWF  0F
0B2A:  BCF    03.6
0B2B:  CALL   2A8
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
0B2C:  MOVLW  79
0B2D:  BSF    03.6
0B2E:  MOVWF  0D
0B2F:  MOVLW  00
0B30:  MOVWF  0F
0B31:  BCF    03.6
0B32:  CALL   2A8
....................       fprintf(RS232,"================================\r"); 
0B33:  MOVLW  8A
0B34:  BSF    03.6
0B35:  MOVWF  0D
0B36:  MOVLW  00
0B37:  MOVWF  0F
0B38:  BCF    03.6
0B39:  CALL   2A8
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
0B3A:  MOVLW  9B
0B3B:  BSF    03.6
0B3C:  MOVWF  0D
0B3D:  MOVLW  00
0B3E:  MOVWF  0F
0B3F:  BCF    03.6
0B40:  CALL   2A8
....................       fprintf(RS232,"================================\r"); 
0B41:  MOVLW  AC
0B42:  BSF    03.6
0B43:  MOVWF  0D
0B44:  MOVLW  00
0B45:  MOVWF  0F
0B46:  BCF    03.6
0B47:  CALL   2A8
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
0B48:  MOVLW  BD
0B49:  BSF    03.6
0B4A:  MOVWF  0D
0B4B:  MOVLW  00
0B4C:  MOVWF  0F
0B4D:  BCF    03.0
0B4E:  BCF    03.6
0B4F:  CLRF   2B
0B50:  BTFSC  0B.7
0B51:  BSF    2B.7
0B52:  BCF    0B.7
0B53:  MOVLW  08
0B54:  MOVWF  68
0B55:  BCF    0A.3
0B56:  CALL   618
0B57:  BSF    0A.3
0B58:  BTFSC  2B.7
0B59:  BSF    0B.7
0B5A:  MOVLW  C8
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  00
0B5E:  MOVWF  0F
0B5F:  BCF    03.6
0B60:  CALL   2A8
0B61:  MOVLW  C2
0B62:  BSF    03.6
0B63:  MOVWF  0D
0B64:  MOVLW  00
0B65:  MOVWF  0F
0B66:  BCF    03.0
0B67:  BCF    03.6
0B68:  CLRF   2B
0B69:  BTFSC  0B.7
0B6A:  BSF    2B.7
0B6B:  BCF    0B.7
0B6C:  MOVLW  07
0B6D:  MOVWF  68
0B6E:  BCF    0A.3
0B6F:  CALL   618
0B70:  BSF    0A.3
0B71:  BTFSC  2B.7
0B72:  BSF    0B.7
0B73:  MOVLW  CA
0B74:  BSF    03.6
0B75:  MOVWF  0D
0B76:  MOVLW  00
0B77:  MOVWF  0F
0B78:  BCF    03.6
0B79:  CALL   2A8
0B7A:  MOVLW  20
0B7B:  BTFSS  0C.4
0B7C:  GOTO   37B
0B7D:  MOVWF  19
0B7E:  MOVLW  0D
0B7F:  BTFSS  0C.4
0B80:  GOTO   37F
0B81:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0B82:  MOVLW  CB
0B83:  BSF    03.6
0B84:  MOVWF  0D
0B85:  MOVLW  00
0B86:  MOVWF  0F
0B87:  BCF    03.6
0B88:  CALL   2A8
....................       fprintf(RS232,"      DEPURACION :: TIEMPO      \r"); 
0B89:  MOVLW  DC
0B8A:  BSF    03.6
0B8B:  MOVWF  0D
0B8C:  MOVLW  00
0B8D:  MOVWF  0F
0B8E:  BCF    03.6
0B8F:  CALL   2A8
....................    } 
0B90:  GOTO   3A8
....................    else 
....................    { 
....................       fputs("Grupo APM (c) 2020 :: BBSB 1.0 rev A",RS232); 
0B91:  MOVLW  ED
0B92:  BSF    03.6
0B93:  MOVWF  0D
0B94:  MOVLW  00
0B95:  MOVWF  0F
0B96:  BCF    03.6
0B97:  CLRF   2B
0B98:  BTFSC  0B.7
0B99:  BSF    2B.7
0B9A:  BCF    0B.7
0B9B:  BCF    0A.3
0B9C:  CALL   138
0B9D:  BSF    0A.3
0B9E:  BTFSC  2B.7
0B9F:  BSF    0B.7
0BA0:  MOVLW  0D
0BA1:  BTFSS  0C.4
0BA2:  GOTO   3A1
0BA3:  MOVWF  19
0BA4:  MOVLW  0A
0BA5:  BTFSS  0C.4
0BA6:  GOTO   3A5
0BA7:  MOVWF  19
....................    } 
....................     
....................    if(DEBUG) {fputs("> Habilitacion de I2C",RS232);} 
0BA8:  BTFSS  07.2
0BA9:  GOTO   3C1
0BAA:  MOVLW  00
0BAB:  BSF    03.6
0BAC:  MOVWF  0D
0BAD:  MOVLW  01
0BAE:  MOVWF  0F
0BAF:  BCF    03.6
0BB0:  CLRF   2B
0BB1:  BTFSC  0B.7
0BB2:  BSF    2B.7
0BB3:  BCF    0B.7
0BB4:  BCF    0A.3
0BB5:  CALL   138
0BB6:  BSF    0A.3
0BB7:  BTFSC  2B.7
0BB8:  BSF    0B.7
0BB9:  MOVLW  0D
0BBA:  BTFSS  0C.4
0BBB:  GOTO   3BA
0BBC:  MOVWF  19
0BBD:  MOVLW  0A
0BBE:  BTFSS  0C.4
0BBF:  GOTO   3BE
0BC0:  MOVWF  19
....................    i2c_slaveaddr(I2C_TIMER); 
0BC1:  MOVLW  0A
0BC2:  BSF    03.5
0BC3:  MOVWF  13
0BC4:  BCF    03.5
0BC5:  CLRF   2B
0BC6:  BTFSC  0B.7
0BC7:  BSF    2B.7
0BC8:  BCF    0B.7
....................    //i2c_speed(100000); 
....................     
....................    delay_ms(DEFAULT_D); 
0BC9:  MOVLW  C8
0BCA:  MOVWF  74
0BCB:  BCF    0A.3
0BCC:  CALL   2AD
0BCD:  BSF    0A.3
0BCE:  BTFSC  2B.7
0BCF:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
0BD0:  BTFSS  07.2
0BD1:  GOTO   3E9
0BD2:  MOVLW  0B
0BD3:  BSF    03.6
0BD4:  MOVWF  0D
0BD5:  MOVLW  01
0BD6:  MOVWF  0F
0BD7:  BCF    03.6
0BD8:  CLRF   2B
0BD9:  BTFSC  0B.7
0BDA:  BSF    2B.7
0BDB:  BCF    0B.7
0BDC:  BCF    0A.3
0BDD:  CALL   138
0BDE:  BSF    0A.3
0BDF:  BTFSC  2B.7
0BE0:  BSF    0B.7
0BE1:  MOVLW  0D
0BE2:  BTFSS  0C.4
0BE3:  GOTO   3E2
0BE4:  MOVWF  19
0BE5:  MOVLW  0A
0BE6:  BTFSS  0C.4
0BE7:  GOTO   3E6
0BE8:  MOVWF  19
....................    //TODO: Activar puertos 
....................    pTiroSU.a = PIN_B0; 
0BE9:  MOVLW  30
0BEA:  MOVWF  48
....................    pTiroSU.b = PIN_B1; 
0BEB:  MOVLW  31
0BEC:  MOVWF  49
....................    pTiroSU.c = PIN_B2; 
0BED:  MOVLW  32
0BEE:  MOVWF  4A
....................    pTiroSU.d = PIN_B3; 
0BEF:  MOVLW  33
0BF0:  MOVWF  4B
....................     
....................    pTiroSD.a = PIN_B4; 
0BF1:  MOVLW  34
0BF2:  MOVWF  4C
....................    pTiroSD.b = PIN_B5; 
0BF3:  MOVLW  35
0BF4:  MOVWF  4D
....................    pTiroSD.c = PIN_B6; 
0BF5:  MOVLW  36
0BF6:  MOVWF  4E
....................    pTiroSD.d = PIN_B7; 
0BF7:  MOVLW  37
0BF8:  MOVWF  4F
....................     
....................    pTiempoSU.a = PIN_D0; 
0BF9:  MOVLW  40
0BFA:  MOVWF  50
....................    pTiempoSU.b = PIN_D1; 
0BFB:  MOVLW  41
0BFC:  MOVWF  51
....................    pTiempoSU.c = PIN_D2; 
0BFD:  MOVLW  42
0BFE:  MOVWF  52
....................    pTiempoSU.d = PIN_D3; 
0BFF:  MOVLW  43
0C00:  MOVWF  53
....................     
....................    pTiempoSD.a = PIN_D4; 
0C01:  MOVLW  44
0C02:  MOVWF  54
....................    pTiempoSD.b = PIN_D5; 
0C03:  MOVLW  45
0C04:  MOVWF  55
....................    pTiempoSD.c = PIN_D6; 
0C05:  MOVLW  46
0C06:  MOVWF  56
....................    pTiempoSD.d = PIN_D7; 
0C07:  MOVLW  47
0C08:  MOVWF  57
....................     
....................    pTiempoMU.a = PIN_A4; 
0C09:  MOVLW  2C
0C0A:  MOVWF  58
....................    pTiempoMU.b = PIN_A5; 
0C0B:  MOVLW  2D
0C0C:  MOVWF  59
....................    pTiempoMU.c = PIN_A6; 
0C0D:  MOVLW  2E
0C0E:  MOVWF  5A
....................    pTiempoMU.d = PIN_A7; 
0C0F:  MOVLW  2F
0C10:  MOVWF  5B
0C11:  CLRF   2B
0C12:  BTFSC  0B.7
0C13:  BSF    2B.7
0C14:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0C15:  MOVLW  C8
0C16:  MOVWF  74
0C17:  BCF    0A.3
0C18:  CALL   2AD
0C19:  BSF    0A.3
0C1A:  BTFSC  2B.7
0C1B:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de displays",RS232);} 
0C1C:  BTFSS  07.2
0C1D:  GOTO   435
0C1E:  MOVLW  19
0C1F:  BSF    03.6
0C20:  MOVWF  0D
0C21:  MOVLW  01
0C22:  MOVWF  0F
0C23:  BCF    03.6
0C24:  CLRF   2B
0C25:  BTFSC  0B.7
0C26:  BSF    2B.7
0C27:  BCF    0B.7
0C28:  BCF    0A.3
0C29:  CALL   138
0C2A:  BSF    0A.3
0C2B:  BTFSC  2B.7
0C2C:  BSF    0B.7
0C2D:  MOVLW  0D
0C2E:  BTFSS  0C.4
0C2F:  GOTO   42E
0C30:  MOVWF  19
0C31:  MOVLW  0A
0C32:  BTFSS  0C.4
0C33:  GOTO   432
0C34:  MOVWF  19
....................    output_bit(DISPLAY, ON);  
0C35:  BSF    09.0
0C36:  MOVLW  E0
0C37:  BSF    03.5
0C38:  MOVWF  09
....................    output_bit(MINUTOD, ON);  
0C39:  BCF    03.5
0C3A:  BSF    05.0
0C3B:  MOVLW  00
0C3C:  BSF    03.5
0C3D:  MOVWF  05
....................    output_bit(PERIODO1, ON); 
0C3E:  BCF    03.5
0C3F:  BSF    09.1
0C40:  MOVLW  E0
0C41:  BSF    03.5
0C42:  MOVWF  09
....................    output_bit(PERIODO2, ON); 
0C43:  BCF    03.5
0C44:  BSF    09.2
0C45:  MOVLW  E0
0C46:  BSF    03.5
0C47:  MOVWF  09
....................    output_bit(PERIODO3, ON); 
0C48:  BCF    03.5
0C49:  BSF    07.0
0C4A:  MOVLW  DC
0C4B:  BSF    03.5
0C4C:  MOVWF  07
....................    output_bit(PERIODO4, ON); 
0C4D:  BCF    03.5
0C4E:  BSF    07.1
0C4F:  MOVLW  DC
0C50:  BSF    03.5
0C51:  MOVWF  07
0C52:  BCF    03.5
0C53:  CLRF   2B
0C54:  BTFSC  0B.7
0C55:  BSF    2B.7
0C56:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C57:  MOVLW  C8
0C58:  MOVWF  74
0C59:  BCF    0A.3
0C5A:  CALL   2AD
0C5B:  BSF    0A.3
0C5C:  BTFSC  2B.7
0C5D:  BSF    0B.7
....................    output_bit(DISPLAY, OFF); 
0C5E:  BCF    09.0
0C5F:  MOVLW  E0
0C60:  BSF    03.5
0C61:  MOVWF  09
....................    output_bit(MINUTOD, OFF); 
0C62:  BCF    03.5
0C63:  BCF    05.0
0C64:  MOVLW  00
0C65:  BSF    03.5
0C66:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0C67:  BCF    03.5
0C68:  BCF    09.1
0C69:  MOVLW  E0
0C6A:  BSF    03.5
0C6B:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0C6C:  BCF    03.5
0C6D:  BCF    09.2
0C6E:  MOVLW  E0
0C6F:  BSF    03.5
0C70:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0C71:  BCF    03.5
0C72:  BCF    07.0
0C73:  MOVLW  DC
0C74:  BSF    03.5
0C75:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0C76:  BCF    03.5
0C77:  BCF    07.1
0C78:  MOVLW  DC
0C79:  BSF    03.5
0C7A:  MOVWF  07
0C7B:  BCF    03.5
0C7C:  CLRF   2B
0C7D:  BTFSC  0B.7
0C7E:  BSF    2B.7
0C7F:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C80:  MOVLW  C8
0C81:  MOVWF  74
0C82:  BCF    0A.3
0C83:  CALL   2AD
0C84:  BSF    0A.3
0C85:  BTFSC  2B.7
0C86:  BSF    0B.7
....................    output_bit(DISPLAY, ON); 
0C87:  BSF    09.0
0C88:  MOVLW  E0
0C89:  BSF    03.5
0C8A:  MOVWF  09
....................    output_bit(MINUTOD, ON); 
0C8B:  BCF    03.5
0C8C:  BSF    05.0
0C8D:  MOVLW  00
0C8E:  BSF    03.5
0C8F:  MOVWF  05
....................    output_bit(PERIODO1, ON); 
0C90:  BCF    03.5
0C91:  BSF    09.1
0C92:  MOVLW  E0
0C93:  BSF    03.5
0C94:  MOVWF  09
....................    output_bit(PERIODO2, ON); 
0C95:  BCF    03.5
0C96:  BSF    09.2
0C97:  MOVLW  E0
0C98:  BSF    03.5
0C99:  MOVWF  09
....................    output_bit(PERIODO3, ON); 
0C9A:  BCF    03.5
0C9B:  BSF    07.0
0C9C:  MOVLW  DC
0C9D:  BSF    03.5
0C9E:  MOVWF  07
....................    output_bit(PERIODO4, ON); 
0C9F:  BCF    03.5
0CA0:  BSF    07.1
0CA1:  MOVLW  DC
0CA2:  BSF    03.5
0CA3:  MOVWF  07
0CA4:  BCF    03.5
0CA5:  CLRF   2B
0CA6:  BTFSC  0B.7
0CA7:  BSF    2B.7
0CA8:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0CA9:  MOVLW  C8
0CAA:  MOVWF  74
0CAB:  BCF    0A.3
0CAC:  CALL   2AD
0CAD:  BSF    0A.3
0CAE:  BTFSC  2B.7
0CAF:  BSF    0B.7
....................    output_bit(MINUTOD, OFF); 
0CB0:  BCF    05.0
0CB1:  MOVLW  00
0CB2:  BSF    03.5
0CB3:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0CB4:  BCF    03.5
0CB5:  BCF    09.1
0CB6:  MOVLW  E0
0CB7:  BSF    03.5
0CB8:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0CB9:  BCF    03.5
0CBA:  BCF    09.2
0CBB:  MOVLW  E0
0CBC:  BSF    03.5
0CBD:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0CBE:  BCF    03.5
0CBF:  BCF    07.0
0CC0:  MOVLW  DC
0CC1:  BSF    03.5
0CC2:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0CC3:  BCF    03.5
0CC4:  BCF    07.1
0CC5:  MOVLW  DC
0CC6:  BSF    03.5
0CC7:  MOVWF  07
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
0CC8:  BCF    03.5
0CC9:  BTFSS  07.2
0CCA:  GOTO   4E2
0CCB:  MOVLW  27
0CCC:  BSF    03.6
0CCD:  MOVWF  0D
0CCE:  MOVLW  01
0CCF:  MOVWF  0F
0CD0:  BCF    03.6
0CD1:  CLRF   2B
0CD2:  BTFSC  0B.7
0CD3:  BSF    2B.7
0CD4:  BCF    0B.7
0CD5:  BCF    0A.3
0CD6:  CALL   138
0CD7:  BSF    0A.3
0CD8:  BTFSC  2B.7
0CD9:  BSF    0B.7
0CDA:  MOVLW  0D
0CDB:  BTFSS  0C.4
0CDC:  GOTO   4DB
0CDD:  MOVWF  19
0CDE:  MOVLW  0A
0CDF:  BTFSS  0C.4
0CE0:  GOTO   4DF
0CE1:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
0CE2:  BSF    03.5
0CE3:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0CE4:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0CE5:  MOVLW  C0
0CE6:  BCF    03.5
0CE7:  IORWF  0B,F
0CE8:  BSF    0A.3
0CE9:  BCF    0A.4
0CEA:  GOTO   544 (RETURN)
.................... } 
....................  
.................... void main() 
0CEB:  MOVF   03,W
0CEC:  ANDLW  1F
0CED:  MOVWF  03
0CEE:  MOVLW  71
0CEF:  BSF    03.5
0CF0:  MOVWF  0F
0CF1:  CLRF   10
0CF2:  MOVF   0F,W
0CF3:  BSF    03.6
0CF4:  BCF    07.3
0CF5:  MOVLW  0C
0CF6:  BCF    03.6
0CF7:  MOVWF  19
0CF8:  MOVLW  A2
0CF9:  MOVWF  18
0CFA:  MOVLW  90
0CFB:  BCF    03.5
0CFC:  MOVWF  18
0CFD:  MOVLW  DC
0CFE:  BSF    03.5
0CFF:  MOVWF  07
0D00:  MOVLW  DC
0D01:  MOVWF  07
0D02:  MOVLW  0A
0D03:  MOVWF  13
0D04:  MOVLW  09
0D05:  BCF    03.5
0D06:  MOVWF  14
0D07:  MOVLW  FF
0D08:  BSF    03.5
0D09:  MOVWF  13
0D0A:  MOVLW  36
0D0B:  BCF    03.5
0D0C:  MOVWF  14
0D0D:  BSF    03.5
0D0E:  BSF    11.0
0D0F:  BSF    11.7
0D10:  BCF    03.5
0D11:  CLRF   40
0D12:  BCF    41.0
0D13:  CLRF   5F
0D14:  CLRF   5E
0D15:  MOVLW  03
0D16:  MOVWF  60
0D17:  BSF    03.5
0D18:  BSF    03.6
0D19:  MOVF   09,W
0D1A:  ANDLW  C0
0D1B:  MOVWF  09
0D1C:  BCF    03.6
0D1D:  BCF    1F.4
0D1E:  BCF    1F.5
0D1F:  MOVLW  00
0D20:  BSF    03.6
0D21:  MOVWF  08
0D22:  BCF    03.5
0D23:  CLRF   07
0D24:  CLRF   08
0D25:  CLRF   09
0D26:  BCF    03.7
.................... { 
....................    setup(); 
*
0D43:  GOTO   300
....................  
....................    while(TRUE) 
....................    { 
0D44:  GOTO   544
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
0D45:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
05C8:  BTFSS  0C.5
05C9:  GOTO   5C8
05CA:  MOVF   1A,W
05CB:  MOVWF  66
.................... if(cmdGet) 
05CC:  BTFSS  41.0
05CD:  GOTO   5FE
.................... { 
....................    if(c == '#' || c == '\r') 
05CE:  MOVF   66,W
05CF:  SUBLW  23
05D0:  BTFSC  03.2
05D1:  GOTO   5D6
05D2:  MOVF   66,W
05D3:  SUBLW  0D
05D4:  BTFSS  03.2
05D5:  GOTO   5F3
....................    { 
....................       cmdGet = false; 
05D6:  BCF    41.0
....................       strcpy(cmd, rcmd); 
05D7:  CLRF   6A
05D8:  MOVLW  36
05D9:  MOVWF  69
05DA:  CLRF   68
05DB:  MOVLW  2C
05DC:  MOVWF  67
05DD:  MOVF   69,W
05DE:  MOVWF  04
05DF:  BCF    03.7
05E0:  BTFSC  6A.0
05E1:  BSF    03.7
05E2:  MOVF   00,W
05E3:  MOVWF  6B
05E4:  MOVF   67,W
05E5:  MOVWF  04
05E6:  BCF    03.7
05E7:  BTFSC  68.0
05E8:  BSF    03.7
05E9:  MOVF   6B,W
05EA:  MOVWF  00
05EB:  MOVF   00,F
05EC:  BTFSC  03.2
05ED:  GOTO   5F1
05EE:  INCF   67,F
05EF:  INCF   69,F
05F0:  GOTO   5DD
....................       parseCommand(); 
05F1:  GOTO   3B0
....................    } 
05F2:  GOTO   5FE
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
05F3:  MOVF   40,W
05F4:  SUBLW  08
05F5:  BTFSS  03.0
05F6:  GOTO   5FE
....................       { 
....................          rcmd[cmdIndex] = c; 
05F7:  MOVLW  36
05F8:  ADDWF  40,W
05F9:  MOVWF  04
05FA:  BCF    03.7
05FB:  MOVF   66,W
05FC:  MOVWF  00
....................          cmdIndex++; 
05FD:  INCF   40,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
05FE:  MOVF   66,W
05FF:  SUBLW  2D
0600:  BTFSS  03.2
0601:  GOTO   614
....................    { 
....................        cmdGet = true;  
0602:  BSF    41.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0"; 
0603:  CLRF   67
0604:  CLRF   68
0605:  MOVLW  36
0606:  MOVWF  04
0607:  BCF    03.7
0608:  MOVF   67,W
0609:  ADDWF  04,F
060A:  MOVF   68,W
060B:  CALL   05A
060C:  MOVWF  00
060D:  IORLW  00
060E:  BTFSC  03.2
060F:  GOTO   613
0610:  INCF   68,F
0611:  INCF   67,F
0612:  GOTO   605
....................        cmdIndex = 0; 
0613:  CLRF   40
....................    } 
.................... } 
....................  
0614:  BCF    0C.5
0615:  BCF    0A.3
0616:  BCF    0A.4
0617:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
*
0800:  BSF    03.5
0801:  BTFSC  14.5
0802:  GOTO   00B
0803:  BCF    03.5
0804:  CLRF   60
0805:  BSF    03.5
0806:  BTFSS  14.2
0807:  GOTO   00B
0808:  BCF    03.5
0809:  BSF    60.7
080A:  BSF    03.5
080B:  BCF    03.5
080C:  MOVF   60,W
080D:  INCF   60,F
080E:  MOVWF  66
.................... { 
....................    int state = i2c_isr_state(); 
....................       if(state== 0 )  
080F:  MOVF   66,F
0810:  BTFSS  03.2
0811:  GOTO   019
....................          i2c_read(); 
0812:  BCF    14.6
0813:  BSF    03.5
0814:  BTFSS  14.0
0815:  GOTO   014
0816:  BCF    03.5
0817:  MOVF   13,W
0818:  BSF    14.4
....................       if(state == 0x80) 
0819:  MOVF   66,W
081A:  SUBLW  80
081B:  BTFSC  03.2
081C:  GOTO   01D
....................          i2c_read(2); 
....................       if(state >= 0x80) 
081D:  MOVF   66,W
081E:  SUBLW  7F
081F:  BTFSC  03.0
0820:  GOTO   02F
....................          i2c_write(0xFF); 
0821:  MOVLW  FF
0822:  MOVWF  67
*
082D:  GOTO   2A3
082E:  BCF    03.5
....................       else if(state > 0) 
082F:  MOVF   66,F
0830:  BTFSC  03.2
0831:  GOTO   2A2
....................       { 
....................          ircmd[state - 1] = i2c_read(); 
0832:  MOVLW  01
0833:  SUBWF  66,W
0834:  ADDLW  43
0835:  MOVWF  04
0836:  BCF    03.7
0837:  BCF    14.6
0838:  BSF    03.5
0839:  BTFSS  14.0
083A:  GOTO   039
083B:  BCF    03.5
083C:  MOVF   13,W
083D:  BSF    14.4
083E:  MOVWF  00
....................          if(DEBUG) {fprintf(RS232, "> Commando: %X - %X\r",state, ircmd[state - 1]);} 
083F:  BTFSS  07.2
0840:  GOTO   072
0841:  MOVLW  01
0842:  SUBWF  66,W
0843:  ADDLW  43
0844:  MOVWF  04
0845:  BCF    03.7
0846:  MOVF   00,W
0847:  MOVWF  67
0848:  MOVLW  94
0849:  BSF    03.6
084A:  MOVWF  0D
084B:  MOVLW  06
084C:  MOVWF  0F
084D:  BCF    03.0
084E:  MOVLW  0C
084F:  BCF    03.6
0850:  MOVWF  68
0851:  BCF    0A.3
0852:  CALL   618
0853:  BSF    0A.3
0854:  MOVF   66,W
0855:  MOVWF  68
0856:  MOVLW  37
0857:  MOVWF  69
0858:  BCF    0A.3
0859:  CALL   671
085A:  BSF    0A.3
085B:  MOVLW  20
085C:  BTFSS  0C.4
085D:  GOTO   05C
085E:  MOVWF  19
085F:  MOVLW  2D
0860:  BTFSS  0C.4
0861:  GOTO   060
0862:  MOVWF  19
0863:  MOVLW  20
0864:  BTFSS  0C.4
0865:  GOTO   064
0866:  MOVWF  19
0867:  MOVF   67,W
0868:  MOVWF  68
0869:  MOVLW  37
086A:  MOVWF  69
086B:  BCF    0A.3
086C:  CALL   671
086D:  BSF    0A.3
086E:  MOVLW  0D
086F:  BTFSS  0C.4
0870:  GOTO   06F
0871:  MOVWF  19
....................          icmd = ircmd[state - 1]; 
0872:  MOVLW  01
0873:  SUBWF  66,W
0874:  ADDLW  43
0875:  MOVWF  04
0876:  BCF    03.7
0877:  MOVF   00,W
0878:  MOVWF  42
....................          parseI2CCommand(); 
....................       } 
*
0AA3:  BCF    03.5
0AA4:  BCF    0C.3
0AA5:  BCF    0A.3
0AA6:  BCF    0A.4
0AA7:  GOTO   033
.................... } 
....................  
.................... void parseI2CCommand(void) 
*
0879:  MOVF   42,W
087A:  MOVWF  67
.................... { 
....................    int c = icmd; 
....................    switch(c) 
087B:  MOVF   67,W
087C:  XORLW  0A
087D:  BTFSC  03.2
087E:  GOTO   0A7
087F:  XORLW  06
0880:  BTFSC  03.2
0881:  GOTO   0BB
0882:  XORLW  7C
0883:  BTFSC  03.2
0884:  GOTO   0CF
0885:  XORLW  01
0886:  BTFSC  03.2
0887:  GOTO   0E7
0888:  XORLW  03
0889:  BTFSC  03.2
088A:  GOTO   100
088B:  XORLW  01
088C:  BTFSC  03.2
088D:  GOTO   119
088E:  XORLW  07
088F:  BTFSC  03.2
0890:  GOTO   132
0891:  XORLW  01
0892:  BTFSC  03.2
0893:  GOTO   14B
0894:  XORLW  03
0895:  BTFSC  03.2
0896:  GOTO   164
0897:  XORLW  F7
0898:  BTFSC  03.2
0899:  GOTO   17D
089A:  XORLW  03
089B:  BTFSC  03.2
089C:  GOTO   196
089D:  XORLW  01
089E:  BTFSC  03.2
089F:  GOTO   1AF
08A0:  XORLW  7C
08A1:  BTFSC  03.2
08A2:  GOTO   1C8
08A3:  XORLW  02
08A4:  BTFSC  03.2
08A5:  GOTO   1CC
08A6:  GOTO   1D0
....................    { 
....................       case I2C_TIMER:      if(DEBUG) {fputs("> Direccion TIMER",RS232);} 
08A7:  BTFSS  07.2
08A8:  GOTO   0BA
08A9:  MOVLW  9F
08AA:  BSF    03.6
08AB:  MOVWF  0D
08AC:  MOVLW  06
08AD:  MOVWF  0F
08AE:  BCF    0A.3
08AF:  BCF    03.6
08B0:  CALL   138
08B1:  BSF    0A.3
08B2:  MOVLW  0D
08B3:  BTFSS  0C.4
08B4:  GOTO   0B3
08B5:  MOVWF  19
08B6:  MOVLW  0A
08B7:  BTFSS  0C.4
08B8:  GOTO   0B7
08B9:  MOVWF  19
....................                            break; 
08BA:  GOTO   1D0
....................       case I2C_SCORE:      if(DEBUG) {fputs("> Direccion SCORE",RS232);} 
08BB:  BTFSS  07.2
08BC:  GOTO   0CE
08BD:  MOVLW  A8
08BE:  BSF    03.6
08BF:  MOVWF  0D
08C0:  MOVLW  06
08C1:  MOVWF  0F
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   138
08C5:  BSF    0A.3
08C6:  MOVLW  0D
08C7:  BTFSS  0C.4
08C8:  GOTO   0C7
08C9:  MOVWF  19
08CA:  MOVLW  0A
08CB:  BTFSS  0C.4
08CC:  GOTO   0CB
08CD:  MOVWF  19
....................                            break; 
08CE:  GOTO   1D0
....................       case I2C_CMD_PER0:   if(DEBUG) {fputs("> Apagar Periodos",RS232);} 
08CF:  BTFSS  07.2
08D0:  GOTO   0E2
08D1:  MOVLW  B1
08D2:  BSF    03.6
08D3:  MOVWF  0D
08D4:  MOVLW  06
08D5:  MOVWF  0F
08D6:  BCF    0A.3
08D7:  BCF    03.6
08D8:  CALL   138
08D9:  BSF    0A.3
08DA:  MOVLW  0D
08DB:  BTFSS  0C.4
08DC:  GOTO   0DB
08DD:  MOVWF  19
08DE:  MOVLW  0A
08DF:  BTFSS  0C.4
08E0:  GOTO   0DF
08E1:  MOVWF  19
....................                            showQuarter(0); 
08E2:  CLRF   72
08E3:  BCF    0A.3
08E4:  CALL   273
08E5:  BSF    0A.3
....................                            break; 
08E6:  GOTO   1D0
....................       case I2C_CMD_PER1:   if(DEBUG) {fputs("> Activar Periodo 1",RS232);} 
08E7:  BTFSS  07.2
08E8:  GOTO   0FA
08E9:  MOVLW  BA
08EA:  BSF    03.6
08EB:  MOVWF  0D
08EC:  MOVLW  06
08ED:  MOVWF  0F
08EE:  BCF    0A.3
08EF:  BCF    03.6
08F0:  CALL   138
08F1:  BSF    0A.3
08F2:  MOVLW  0D
08F3:  BTFSS  0C.4
08F4:  GOTO   0F3
08F5:  MOVWF  19
08F6:  MOVLW  0A
08F7:  BTFSS  0C.4
08F8:  GOTO   0F7
08F9:  MOVWF  19
....................                            showQuarter(1); 
08FA:  MOVLW  01
08FB:  MOVWF  72
08FC:  BCF    0A.3
08FD:  CALL   273
08FE:  BSF    0A.3
....................                            break; 
08FF:  GOTO   1D0
....................       case I2C_CMD_PER2:   if(DEBUG) {fputs("> Activar Periodo 2",RS232);} 
0900:  BTFSS  07.2
0901:  GOTO   113
0902:  MOVLW  C4
0903:  BSF    03.6
0904:  MOVWF  0D
0905:  MOVLW  06
0906:  MOVWF  0F
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   138
090A:  BSF    0A.3
090B:  MOVLW  0D
090C:  BTFSS  0C.4
090D:  GOTO   10C
090E:  MOVWF  19
090F:  MOVLW  0A
0910:  BTFSS  0C.4
0911:  GOTO   110
0912:  MOVWF  19
....................                            showQuarter(2); 
0913:  MOVLW  02
0914:  MOVWF  72
0915:  BCF    0A.3
0916:  CALL   273
0917:  BSF    0A.3
....................                            break; 
0918:  GOTO   1D0
....................       case I2C_CMD_PER3:   if(DEBUG) {fputs("> Activar Periodo 3",RS232);} 
0919:  BTFSS  07.2
091A:  GOTO   12C
091B:  MOVLW  CE
091C:  BSF    03.6
091D:  MOVWF  0D
091E:  MOVLW  06
091F:  MOVWF  0F
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   138
0923:  BSF    0A.3
0924:  MOVLW  0D
0925:  BTFSS  0C.4
0926:  GOTO   125
0927:  MOVWF  19
0928:  MOVLW  0A
0929:  BTFSS  0C.4
092A:  GOTO   129
092B:  MOVWF  19
....................                            showQuarter(3); 
092C:  MOVLW  03
092D:  MOVWF  72
092E:  BCF    0A.3
092F:  CALL   273
0930:  BSF    0A.3
....................                            break; 
0931:  GOTO   1D0
....................       case I2C_CMD_PER4:   if(DEBUG) {fputs("> Activar Periodo 4",RS232);} 
0932:  BTFSS  07.2
0933:  GOTO   145
0934:  MOVLW  D8
0935:  BSF    03.6
0936:  MOVWF  0D
0937:  MOVLW  06
0938:  MOVWF  0F
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   138
093C:  BSF    0A.3
093D:  MOVLW  0D
093E:  BTFSS  0C.4
093F:  GOTO   13E
0940:  MOVWF  19
0941:  MOVLW  0A
0942:  BTFSS  0C.4
0943:  GOTO   142
0944:  MOVWF  19
....................                            showQuarter(4); 
0945:  MOVLW  04
0946:  MOVWF  72
0947:  BCF    0A.3
0948:  CALL   273
0949:  BSF    0A.3
....................                            break; 
094A:  GOTO   1D0
....................       case I2C_CMD_MDON:   if(DEBUG) {fputs("> Activar Minuto Decena",RS232);} 
094B:  BTFSS  07.2
094C:  GOTO   15E
094D:  MOVLW  E2
094E:  BSF    03.6
094F:  MOVWF  0D
0950:  MOVLW  06
0951:  MOVWF  0F
0952:  BCF    0A.3
0953:  BCF    03.6
0954:  CALL   138
0955:  BSF    0A.3
0956:  MOVLW  0D
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
095A:  MOVLW  0A
095B:  BTFSS  0C.4
095C:  GOTO   15B
095D:  MOVWF  19
....................                            output_bit(MINUTOD, ON); 
095E:  BSF    05.0
095F:  MOVLW  00
0960:  BSF    03.5
0961:  MOVWF  05
....................                            break; 
0962:  BCF    03.5
0963:  GOTO   1D0
....................       case I2C_CMD_MDOF:   if(DEBUG) {fputs("> Desactivar Minuto Decena",RS232);} 
0964:  BTFSS  07.2
0965:  GOTO   177
0966:  MOVLW  EE
0967:  BSF    03.6
0968:  MOVWF  0D
0969:  MOVLW  06
096A:  MOVWF  0F
096B:  BCF    0A.3
096C:  BCF    03.6
096D:  CALL   138
096E:  BSF    0A.3
096F:  MOVLW  0D
0970:  BTFSS  0C.4
0971:  GOTO   170
0972:  MOVWF  19
0973:  MOVLW  0A
0974:  BTFSS  0C.4
0975:  GOTO   174
0976:  MOVWF  19
....................                            output_bit(MINUTOD, OFF); 
0977:  BCF    05.0
0978:  MOVLW  00
0979:  BSF    03.5
097A:  MOVWF  05
....................                            break; 
097B:  BCF    03.5
097C:  GOTO   1D0
....................       case I2C_CMD_BUZ1:   if(DEBUG) {fputs("> Toque Corto",RS232);} 
097D:  BTFSS  07.2
097E:  GOTO   190
097F:  MOVLW  FC
0980:  BSF    03.6
0981:  MOVWF  0D
0982:  MOVLW  06
0983:  MOVWF  0F
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   138
0987:  BSF    0A.3
0988:  MOVLW  0D
0989:  BTFSS  0C.4
098A:  GOTO   189
098B:  MOVWF  19
098C:  MOVLW  0A
098D:  BTFSS  0C.4
098E:  GOTO   18D
098F:  MOVWF  19
....................                            buzz(1); 
0990:  MOVLW  01
0991:  MOVWF  72
0992:  BCF    0A.3
0993:  CALL   2C1
0994:  BSF    0A.3
....................                            break; 
0995:  GOTO   1D0
....................       case I2C_CMD_BUZ2:   if(DEBUG) {fputs("> Toque Largo",RS232);} 
0996:  BTFSS  07.2
0997:  GOTO   1A9
0998:  MOVLW  03
0999:  BSF    03.6
099A:  MOVWF  0D
099B:  MOVLW  07
099C:  MOVWF  0F
099D:  BCF    0A.3
099E:  BCF    03.6
099F:  CALL   138
09A0:  BSF    0A.3
09A1:  MOVLW  0D
09A2:  BTFSS  0C.4
09A3:  GOTO   1A2
09A4:  MOVWF  19
09A5:  MOVLW  0A
09A6:  BTFSS  0C.4
09A7:  GOTO   1A6
09A8:  MOVWF  19
....................                            buzz(2); 
09A9:  MOVLW  02
09AA:  MOVWF  72
09AB:  BCF    0A.3
09AC:  CALL   2C1
09AD:  BSF    0A.3
....................                            break; 
09AE:  GOTO   1D0
....................       case I2C_CMD_BUZ3:   if(DEBUG) {fputs("> Toque Doble",RS232);} 
09AF:  BTFSS  07.2
09B0:  GOTO   1C2
09B1:  MOVLW  0A
09B2:  BSF    03.6
09B3:  MOVWF  0D
09B4:  MOVLW  07
09B5:  MOVWF  0F
09B6:  BCF    0A.3
09B7:  BCF    03.6
09B8:  CALL   138
09B9:  BSF    0A.3
09BA:  MOVLW  0D
09BB:  BTFSS  0C.4
09BC:  GOTO   1BB
09BD:  MOVWF  19
09BE:  MOVLW  0A
09BF:  BTFSS  0C.4
09C0:  GOTO   1BF
09C1:  MOVWF  19
....................                            buzz(3); 
09C2:  MOVLW  03
09C3:  MOVWF  72
09C4:  BCF    0A.3
09C5:  CALL   2C1
09C6:  BSF    0A.3
....................                            break; 
09C7:  GOTO   1D0
....................       case I2C_CMD_TEST:   doTest(); 
09C8:  BCF    0A.3
09C9:  CALL   322
09CA:  BSF    0A.3
....................                            break; 
09CB:  GOTO   1D0
....................       case I2C_CMD_RESET:  doReset(); 
09CC:  BCF    0A.3
09CD:  CALL   39C
09CE:  BSF    0A.3
....................                            break; 
09CF:  GOTO   1D0
....................    } 
....................     
....................    if(c > 0x0F && c < 0x1A) //0x10 - 0x19 
09D0:  MOVF   67,W
09D1:  SUBLW  0F
09D2:  BTFSC  03.0
09D3:  GOTO   1FA
09D4:  MOVF   67,W
09D5:  SUBLW  19
09D6:  BTFSS  03.0
09D7:  GOTO   1FA
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 1",RS232);} 
09D8:  BTFSS  07.2
09D9:  GOTO   1EB
09DA:  MOVLW  11
09DB:  BSF    03.6
09DC:  MOVWF  0D
09DD:  MOVLW  07
09DE:  MOVWF  0F
09DF:  BCF    0A.3
09E0:  BCF    03.6
09E1:  CALL   138
09E2:  BSF    0A.3
09E3:  MOVLW  0D
09E4:  BTFSS  0C.4
09E5:  GOTO   1E4
09E6:  MOVWF  19
09E7:  MOVLW  0A
09E8:  BTFSS  0C.4
09E9:  GOTO   1E8
09EA:  MOVWF  19
....................       showNumber(c - 0x10, pTiroSU);    
09EB:  MOVLW  10
09EC:  SUBWF  67,W
09ED:  MOVWF  68
09EE:  MOVWF  72
09EF:  MOVF   4B,W
09F0:  MOVWF  76
09F1:  MOVF   4A,W
09F2:  MOVWF  75
09F3:  MOVF   49,W
09F4:  MOVWF  74
09F5:  MOVF   48,W
09F6:  MOVWF  73
09F7:  BCF    0A.3
09F8:  CALL   1EB
09F9:  BSF    0A.3
....................    } 
....................    if(c > 0x1F && c < 0x2A) //0x20 - 0x29 
09FA:  MOVF   67,W
09FB:  SUBLW  1F
09FC:  BTFSC  03.0
09FD:  GOTO   224
09FE:  MOVF   67,W
09FF:  SUBLW  29
0A00:  BTFSS  03.0
0A01:  GOTO   224
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 2",RS232);} 
0A02:  BTFSS  07.2
0A03:  GOTO   215
0A04:  MOVLW  1C
0A05:  BSF    03.6
0A06:  MOVWF  0D
0A07:  MOVLW  07
0A08:  MOVWF  0F
0A09:  BCF    0A.3
0A0A:  BCF    03.6
0A0B:  CALL   138
0A0C:  BSF    0A.3
0A0D:  MOVLW  0D
0A0E:  BTFSS  0C.4
0A0F:  GOTO   20E
0A10:  MOVWF  19
0A11:  MOVLW  0A
0A12:  BTFSS  0C.4
0A13:  GOTO   212
0A14:  MOVWF  19
....................       showNumber(c - 0x20, pTiroSD);    
0A15:  MOVLW  20
0A16:  SUBWF  67,W
0A17:  MOVWF  68
0A18:  MOVWF  72
0A19:  MOVF   4F,W
0A1A:  MOVWF  76
0A1B:  MOVF   4E,W
0A1C:  MOVWF  75
0A1D:  MOVF   4D,W
0A1E:  MOVWF  74
0A1F:  MOVF   4C,W
0A20:  MOVWF  73
0A21:  BCF    0A.3
0A22:  CALL   1EB
0A23:  BSF    0A.3
....................    } 
....................    if(c > 0x2F && c < 0x3A) //0x30 - 0x39 
0A24:  MOVF   67,W
0A25:  SUBLW  2F
0A26:  BTFSC  03.0
0A27:  GOTO   24E
0A28:  MOVF   67,W
0A29:  SUBLW  39
0A2A:  BTFSS  03.0
0A2B:  GOTO   24E
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 3",RS232);} 
0A2C:  BTFSS  07.2
0A2D:  GOTO   23F
0A2E:  MOVLW  27
0A2F:  BSF    03.6
0A30:  MOVWF  0D
0A31:  MOVLW  07
0A32:  MOVWF  0F
0A33:  BCF    0A.3
0A34:  BCF    03.6
0A35:  CALL   138
0A36:  BSF    0A.3
0A37:  MOVLW  0D
0A38:  BTFSS  0C.4
0A39:  GOTO   238
0A3A:  MOVWF  19
0A3B:  MOVLW  0A
0A3C:  BTFSS  0C.4
0A3D:  GOTO   23C
0A3E:  MOVWF  19
....................       showNumber(c - 0x30, pTiempoSD);    
0A3F:  MOVLW  30
0A40:  SUBWF  67,W
0A41:  MOVWF  68
0A42:  MOVWF  72
0A43:  MOVF   57,W
0A44:  MOVWF  76
0A45:  MOVF   56,W
0A46:  MOVWF  75
0A47:  MOVF   55,W
0A48:  MOVWF  74
0A49:  MOVF   54,W
0A4A:  MOVWF  73
0A4B:  BCF    0A.3
0A4C:  CALL   1EB
0A4D:  BSF    0A.3
....................    } 
....................    if(c > 0x3F && c < 0x4A) //0x40 - 0x49 
0A4E:  MOVF   67,W
0A4F:  SUBLW  3F
0A50:  BTFSC  03.0
0A51:  GOTO   278
0A52:  MOVF   67,W
0A53:  SUBLW  49
0A54:  BTFSS  03.0
0A55:  GOTO   278
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 4",RS232);} 
0A56:  BTFSS  07.2
0A57:  GOTO   269
0A58:  MOVLW  32
0A59:  BSF    03.6
0A5A:  MOVWF  0D
0A5B:  MOVLW  07
0A5C:  MOVWF  0F
0A5D:  BCF    0A.3
0A5E:  BCF    03.6
0A5F:  CALL   138
0A60:  BSF    0A.3
0A61:  MOVLW  0D
0A62:  BTFSS  0C.4
0A63:  GOTO   262
0A64:  MOVWF  19
0A65:  MOVLW  0A
0A66:  BTFSS  0C.4
0A67:  GOTO   266
0A68:  MOVWF  19
....................       showNumber(c - 0x40, pTiempoSU);    
0A69:  MOVLW  40
0A6A:  SUBWF  67,W
0A6B:  MOVWF  68
0A6C:  MOVWF  72
0A6D:  MOVF   53,W
0A6E:  MOVWF  76
0A6F:  MOVF   52,W
0A70:  MOVWF  75
0A71:  MOVF   51,W
0A72:  MOVWF  74
0A73:  MOVF   50,W
0A74:  MOVWF  73
0A75:  BCF    0A.3
0A76:  CALL   1EB
0A77:  BSF    0A.3
....................    } 
....................       if(c > 0x4F && c < 0x5A) //0x50 - 0x59 
0A78:  MOVF   67,W
0A79:  SUBLW  4F
0A7A:  BTFSC  03.0
0A7B:  GOTO   2A2
0A7C:  MOVF   67,W
0A7D:  SUBLW  59
0A7E:  BTFSS  03.0
0A7F:  GOTO   2A2
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 5",RS232);} 
0A80:  BTFSS  07.2
0A81:  GOTO   293
0A82:  MOVLW  3D
0A83:  BSF    03.6
0A84:  MOVWF  0D
0A85:  MOVLW  07
0A86:  MOVWF  0F
0A87:  BCF    0A.3
0A88:  BCF    03.6
0A89:  CALL   138
0A8A:  BSF    0A.3
0A8B:  MOVLW  0D
0A8C:  BTFSS  0C.4
0A8D:  GOTO   28C
0A8E:  MOVWF  19
0A8F:  MOVLW  0A
0A90:  BTFSS  0C.4
0A91:  GOTO   290
0A92:  MOVWF  19
....................       showNumber(c - 0x50, pTiempoMU);    
0A93:  MOVLW  50
0A94:  SUBWF  67,W
0A95:  MOVWF  68
0A96:  MOVWF  72
0A97:  MOVF   5B,W
0A98:  MOVWF  76
0A99:  MOVF   5A,W
0A9A:  MOVWF  75
0A9B:  MOVF   59,W
0A9C:  MOVWF  74
0A9D:  MOVF   58,W
0A9E:  MOVWF  73
0A9F:  BCF    0A.3
0AA0:  CALL   1EB
0AA1:  BSF    0A.3
0AA2:  BSF    03.5
....................    } 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
0322:  BTFSS  07.2
0323:  GOTO   333
0324:  MOVLW  48
0325:  BSF    03.6
0326:  MOVWF  0D
0327:  MOVLW  07
0328:  MOVWF  0F
0329:  BCF    03.6
032A:  CALL   138
032B:  MOVLW  0D
032C:  BTFSS  0C.4
032D:  GOTO   32C
032E:  MOVWF  19
032F:  MOVLW  0A
0330:  BTFSS  0C.4
0331:  GOTO   330
0332:  MOVWF  19
....................    output_bit(MINUTOD, OFF); 
0333:  BCF    05.0
0334:  MOVLW  00
0335:  BSF    03.5
0336:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0337:  BCF    03.5
0338:  BCF    09.1
0339:  MOVLW  E0
033A:  BSF    03.5
033B:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
033C:  BCF    03.5
033D:  BCF    09.2
033E:  MOVLW  E0
033F:  BSF    03.5
0340:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0341:  BCF    03.5
0342:  BCF    07.0
0343:  MOVLW  DC
0344:  BSF    03.5
0345:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0346:  BCF    03.5
0347:  BCF    07.1
0348:  MOVLW  DC
0349:  BSF    03.5
034A:  MOVWF  07
....................    for(int i=0; i<10; i++) 
034B:  CLRF   71
034C:  MOVF   71,W
034D:  SUBLW  09
034E:  BTFSS  03.0
034F:  GOTO   397
....................    { 
....................       showNumber(i, pTiroSD); 
0350:  MOVF   71,W
0351:  MOVWF  72
0352:  BCF    03.5
0353:  MOVF   4F,W
0354:  MOVWF  76
0355:  MOVF   4E,W
0356:  MOVWF  75
0357:  MOVF   4D,W
0358:  MOVWF  74
0359:  MOVF   4C,W
035A:  MOVWF  73
035B:  CALL   1EB
....................       showNumber(i, pTiroSU); 
035C:  MOVF   71,W
035D:  MOVWF  72
035E:  MOVF   4B,W
035F:  MOVWF  76
0360:  MOVF   4A,W
0361:  MOVWF  75
0362:  MOVF   49,W
0363:  MOVWF  74
0364:  MOVF   48,W
0365:  MOVWF  73
0366:  CALL   1EB
....................       showNumber(i, pTiempoSD); 
0367:  MOVF   71,W
0368:  MOVWF  72
0369:  MOVF   57,W
036A:  MOVWF  76
036B:  MOVF   56,W
036C:  MOVWF  75
036D:  MOVF   55,W
036E:  MOVWF  74
036F:  MOVF   54,W
0370:  MOVWF  73
0371:  CALL   1EB
....................       showNumber(i, pTiempoSU); 
0372:  MOVF   71,W
0373:  MOVWF  72
0374:  MOVF   53,W
0375:  MOVWF  76
0376:  MOVF   52,W
0377:  MOVWF  75
0378:  MOVF   51,W
0379:  MOVWF  74
037A:  MOVF   50,W
037B:  MOVWF  73
037C:  CALL   1EB
....................       showNumber(i, pTiempoMU); 
037D:  MOVF   71,W
037E:  MOVWF  72
037F:  MOVF   5B,W
0380:  MOVWF  76
0381:  MOVF   5A,W
0382:  MOVWF  75
0383:  MOVF   59,W
0384:  MOVWF  74
0385:  MOVF   58,W
0386:  MOVWF  73
0387:  CALL   1EB
....................       output_toggle(MINUTOD); 
0388:  MOVLW  00
0389:  BSF    03.5
038A:  MOVWF  05
038B:  MOVLW  01
038C:  BCF    03.5
038D:  XORWF  05,F
....................       showQuarter(i); 
038E:  MOVF   71,W
038F:  MOVWF  72
0390:  CALL   273
....................       delay_ms(DEFAULT_D); 
0391:  MOVLW  C8
0392:  MOVWF  74
0393:  CALL   2AD
0394:  INCF   71,F
0395:  BSF    03.5
0396:  GOTO   34C
....................    } 
....................    buzz(1); 
0397:  MOVLW  01
0398:  MOVWF  72
0399:  BCF    03.5
039A:  CALL   2C1
039B:  RETURN
.................... } 
....................  
.................... void buzz(int t) 
.................... { 
....................    switch(t) 
*
02C1:  MOVF   72,W
02C2:  XORLW  01
02C3:  BTFSC  03.2
02C4:  GOTO   2CC
02C5:  XORLW  03
02C6:  BTFSC  03.2
02C7:  GOTO   2E1
02C8:  XORLW  01
02C9:  BTFSC  03.2
02CA:  GOTO   2F6
02CB:  GOTO   321
....................    { 
....................       case 1:  //TOOT 
....................                output_bit(BUZZER, ON); 
02CC:  BSF    05.1
02CD:  MOVLW  00
02CE:  BSF    03.5
02CF:  MOVWF  05
....................                delay_ms(1000); 
02D0:  MOVLW  04
02D1:  MOVWF  73
02D2:  MOVLW  FA
02D3:  MOVWF  74
02D4:  BCF    03.5
02D5:  CALL   2AD
02D6:  DECFSZ 73,F
02D7:  GOTO   2D9
02D8:  GOTO   2DB
02D9:  BSF    03.5
02DA:  GOTO   2D2
....................                output_bit(BUZZER, OFF); 
02DB:  BCF    05.1
02DC:  MOVLW  00
02DD:  BSF    03.5
02DE:  MOVWF  05
....................                break; 
02DF:  BCF    03.5
02E0:  GOTO   321
....................       case 2:  //LONG BUZZ 
....................                output_bit(BUZZER, ON); 
02E1:  BSF    05.1
02E2:  MOVLW  00
02E3:  BSF    03.5
02E4:  MOVWF  05
....................                delay_ms(3000); 
02E5:  MOVLW  0C
02E6:  MOVWF  73
02E7:  MOVLW  FA
02E8:  MOVWF  74
02E9:  BCF    03.5
02EA:  CALL   2AD
02EB:  DECFSZ 73,F
02EC:  GOTO   2EE
02ED:  GOTO   2F0
02EE:  BSF    03.5
02EF:  GOTO   2E7
....................                output_bit(BUZZER, OFF); 
02F0:  BCF    05.1
02F1:  MOVLW  00
02F2:  BSF    03.5
02F3:  MOVWF  05
....................                break; 
02F4:  BCF    03.5
02F5:  GOTO   321
....................       case 3:  //DOUBLE 
....................                output_bit(BUZZER, ON); 
02F6:  BSF    05.1
02F7:  MOVLW  00
02F8:  BSF    03.5
02F9:  MOVWF  05
....................                delay_ms(1000); 
02FA:  MOVLW  04
02FB:  MOVWF  73
02FC:  MOVLW  FA
02FD:  MOVWF  74
02FE:  BCF    03.5
02FF:  CALL   2AD
0300:  DECFSZ 73,F
0301:  GOTO   303
0302:  GOTO   305
0303:  BSF    03.5
0304:  GOTO   2FC
....................                output_bit(BUZZER, OFF); 
0305:  BCF    05.1
0306:  MOVLW  00
0307:  BSF    03.5
0308:  MOVWF  05
....................                delay_ms(250); 
0309:  MOVLW  FA
030A:  MOVWF  74
030B:  BCF    03.5
030C:  CALL   2AD
....................                output_bit(BUZZER, ON); 
030D:  BSF    05.1
030E:  MOVLW  00
030F:  BSF    03.5
0310:  MOVWF  05
....................                delay_ms(1000); 
0311:  MOVLW  04
0312:  MOVWF  73
0313:  MOVLW  FA
0314:  MOVWF  74
0315:  BCF    03.5
0316:  CALL   2AD
0317:  DECFSZ 73,F
0318:  GOTO   31A
0319:  GOTO   31C
031A:  BSF    03.5
031B:  GOTO   313
....................                output_bit(BUZZER, OFF); 
031C:  BCF    05.1
031D:  MOVLW  00
031E:  BSF    03.5
031F:  MOVWF  05
....................                break; 
0320:  BCF    03.5
....................    } 
0321:  RETURN
.................... } 
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
03B0:  CLRF   74
03B1:  MOVLW  2C
03B2:  MOVWF  73
03B3:  CLRF   72
03B4:  MOVLW  67
03B5:  MOVWF  71
03B6:  MOVF   73,W
03B7:  MOVWF  04
03B8:  BCF    03.7
03B9:  BTFSC  74.0
03BA:  BSF    03.7
03BB:  MOVF   00,W
03BC:  MOVWF  75
03BD:  MOVF   71,W
03BE:  MOVWF  04
03BF:  BCF    03.7
03C0:  BTFSC  72.0
03C1:  BSF    03.7
03C2:  MOVF   75,W
03C3:  MOVWF  00
03C4:  MOVF   00,F
03C5:  BTFSC  03.2
03C6:  GOTO   3CA
03C7:  INCF   71,F
03C8:  INCF   73,F
03C9:  GOTO   3B6
....................    switch(c[0]) 
03CA:  MOVF   67,W
03CB:  XORLW  30
03CC:  BTFSC  03.2
03CD:  GOTO   3F3
03CE:  XORLW  71
03CF:  BTFSC  03.2
03D0:  GOTO   45B
03D1:  XORLW  03
03D2:  BTFSC  03.2
03D3:  GOTO   46F
03D4:  XORLW  01
03D5:  BTFSC  03.2
03D6:  GOTO   484
03D7:  XORLW  07
03D8:  BTFSC  03.2
03D9:  GOTO   499
03DA:  XORLW  01
03DB:  BTFSC  03.2
03DC:  GOTO   4AE
03DD:  XORLW  03
03DE:  BTFSC  03.2
03DF:  GOTO   4C3
03E0:  XORLW  01
03E1:  BTFSC  03.2
03E2:  GOTO   4DA
03E3:  XORLW  0F
03E4:  BTFSC  03.2
03E5:  GOTO   4F1
03E6:  XORLW  01
03E7:  BTFSC  03.2
03E8:  GOTO   506
03E9:  XORLW  03
03EA:  BTFSC  03.2
03EB:  GOTO   51B
03EC:  XORLW  12
03ED:  BTFSC  03.2
03EE:  GOTO   530
03EF:  XORLW  02
03F0:  BTFSC  03.2
03F1:  GOTO   532
03F2:  GOTO   5BC
....................    { 
....................       case '0':   if(DEBUG) {fputs("\r> Activacion manual de puerto",RS232);} 
03F3:  BTFSS  07.2
03F4:  GOTO   404
03F5:  MOVLW  52
03F6:  BSF    03.6
03F7:  MOVWF  0D
03F8:  MOVLW  07
03F9:  MOVWF  0F
03FA:  BCF    03.6
03FB:  CALL   138
03FC:  MOVLW  0D
03FD:  BTFSS  0C.4
03FE:  GOTO   3FD
03FF:  MOVWF  19
0400:  MOVLW  0A
0401:  BTFSS  0C.4
0402:  GOTO   401
0403:  MOVWF  19
....................                   switch(c[2]) 
0404:  MOVLW  31
0405:  SUBWF  69,W
0406:  ADDLW  FB
0407:  BTFSC  03.0
0408:  GOTO   45A
0409:  ADDLW  05
040A:  GOTO   5BF
....................                   { 
....................                      case '1':   showNumber(char2int(c[3]), pTiroSU); 
040B:  MOVF   6A,W
040C:  MOVWF  71
040D:  CALL   18A
040E:  MOVF   78,W
040F:  MOVWF  71
0410:  MOVWF  72
0411:  MOVF   4B,W
0412:  MOVWF  76
0413:  MOVF   4A,W
0414:  MOVWF  75
0415:  MOVF   49,W
0416:  MOVWF  74
0417:  MOVF   48,W
0418:  MOVWF  73
0419:  CALL   1EB
....................                                  break; 
041A:  GOTO   45A
....................                      case '2':   showNumber(char2int(c[3]), pTiroSD); 
041B:  MOVF   6A,W
041C:  MOVWF  71
041D:  CALL   18A
041E:  MOVF   78,W
041F:  MOVWF  71
0420:  MOVWF  72
0421:  MOVF   4F,W
0422:  MOVWF  76
0423:  MOVF   4E,W
0424:  MOVWF  75
0425:  MOVF   4D,W
0426:  MOVWF  74
0427:  MOVF   4C,W
0428:  MOVWF  73
0429:  CALL   1EB
....................                                  break; 
042A:  GOTO   45A
....................                      case '3':   showNumber(char2int(c[3]), pTiempoSD); 
042B:  MOVF   6A,W
042C:  MOVWF  71
042D:  CALL   18A
042E:  MOVF   78,W
042F:  MOVWF  71
0430:  MOVWF  72
0431:  MOVF   57,W
0432:  MOVWF  76
0433:  MOVF   56,W
0434:  MOVWF  75
0435:  MOVF   55,W
0436:  MOVWF  74
0437:  MOVF   54,W
0438:  MOVWF  73
0439:  CALL   1EB
....................                                  break; 
043A:  GOTO   45A
....................                      case '4':   showNumber(char2int(c[3]), pTiempoSU); 
043B:  MOVF   6A,W
043C:  MOVWF  71
043D:  CALL   18A
043E:  MOVF   78,W
043F:  MOVWF  71
0440:  MOVWF  72
0441:  MOVF   53,W
0442:  MOVWF  76
0443:  MOVF   52,W
0444:  MOVWF  75
0445:  MOVF   51,W
0446:  MOVWF  74
0447:  MOVF   50,W
0448:  MOVWF  73
0449:  CALL   1EB
....................                                  break; 
044A:  GOTO   45A
....................                      case '5':   showNumber(char2int(c[3]), pTiempoMU); 
044B:  MOVF   6A,W
044C:  MOVWF  71
044D:  CALL   18A
044E:  MOVF   78,W
044F:  MOVWF  71
0450:  MOVWF  72
0451:  MOVF   5B,W
0452:  MOVWF  76
0453:  MOVF   5A,W
0454:  MOVWF  75
0455:  MOVF   59,W
0456:  MOVWF  74
0457:  MOVF   58,W
0458:  MOVWF  73
0459:  CALL   1EB
....................                                  break; 
....................                   } 
....................                   break; 
045A:  GOTO   5BC
....................       case 'A':   if(DEBUG) {fputs("> Apagar Periodos",RS232);} 
045B:  BTFSS  07.2
045C:  GOTO   46C
045D:  MOVLW  62
045E:  BSF    03.6
045F:  MOVWF  0D
0460:  MOVLW  07
0461:  MOVWF  0F
0462:  BCF    03.6
0463:  CALL   138
0464:  MOVLW  0D
0465:  BTFSS  0C.4
0466:  GOTO   465
0467:  MOVWF  19
0468:  MOVLW  0A
0469:  BTFSS  0C.4
046A:  GOTO   469
046B:  MOVWF  19
....................                            showQuarter(0); 
046C:  CLRF   72
046D:  CALL   273
....................                            break; 
046E:  GOTO   5BC
....................       case 'B':   if(DEBUG) {fputs("> Activar Periodo 1",RS232);} 
046F:  BTFSS  07.2
0470:  GOTO   480
0471:  MOVLW  6B
0472:  BSF    03.6
0473:  MOVWF  0D
0474:  MOVLW  07
0475:  MOVWF  0F
0476:  BCF    03.6
0477:  CALL   138
0478:  MOVLW  0D
0479:  BTFSS  0C.4
047A:  GOTO   479
047B:  MOVWF  19
047C:  MOVLW  0A
047D:  BTFSS  0C.4
047E:  GOTO   47D
047F:  MOVWF  19
....................                            showQuarter(1); 
0480:  MOVLW  01
0481:  MOVWF  72
0482:  CALL   273
....................                            break; 
0483:  GOTO   5BC
....................       case 'C':   if(DEBUG) {fputs("> Activar Periodo 2",RS232);} 
0484:  BTFSS  07.2
0485:  GOTO   495
0486:  MOVLW  75
0487:  BSF    03.6
0488:  MOVWF  0D
0489:  MOVLW  07
048A:  MOVWF  0F
048B:  BCF    03.6
048C:  CALL   138
048D:  MOVLW  0D
048E:  BTFSS  0C.4
048F:  GOTO   48E
0490:  MOVWF  19
0491:  MOVLW  0A
0492:  BTFSS  0C.4
0493:  GOTO   492
0494:  MOVWF  19
....................                            showQuarter(2); 
0495:  MOVLW  02
0496:  MOVWF  72
0497:  CALL   273
....................                            break; 
0498:  GOTO   5BC
....................       case 'D':   if(DEBUG) {fputs("> Activar Periodo 3",RS232);} 
0499:  BTFSS  07.2
049A:  GOTO   4AA
049B:  MOVLW  7F
049C:  BSF    03.6
049D:  MOVWF  0D
049E:  MOVLW  07
049F:  MOVWF  0F
04A0:  BCF    03.6
04A1:  CALL   138
04A2:  MOVLW  0D
04A3:  BTFSS  0C.4
04A4:  GOTO   4A3
04A5:  MOVWF  19
04A6:  MOVLW  0A
04A7:  BTFSS  0C.4
04A8:  GOTO   4A7
04A9:  MOVWF  19
....................                            showQuarter(3); 
04AA:  MOVLW  03
04AB:  MOVWF  72
04AC:  CALL   273
....................                            break; 
04AD:  GOTO   5BC
....................       case 'E':   if(DEBUG) {fputs("> Activar Periodo 4",RS232);} 
04AE:  BTFSS  07.2
04AF:  GOTO   4BF
04B0:  MOVLW  89
04B1:  BSF    03.6
04B2:  MOVWF  0D
04B3:  MOVLW  07
04B4:  MOVWF  0F
04B5:  BCF    03.6
04B6:  CALL   138
04B7:  MOVLW  0D
04B8:  BTFSS  0C.4
04B9:  GOTO   4B8
04BA:  MOVWF  19
04BB:  MOVLW  0A
04BC:  BTFSS  0C.4
04BD:  GOTO   4BC
04BE:  MOVWF  19
....................                            showQuarter(4); 
04BF:  MOVLW  04
04C0:  MOVWF  72
04C1:  CALL   273
....................                            break; 
04C2:  GOTO   5BC
....................       case 'F':   if(DEBUG) {fputs("> Activar Minuto Decena",RS232);} 
04C3:  BTFSS  07.2
04C4:  GOTO   4D4
04C5:  MOVLW  93
04C6:  BSF    03.6
04C7:  MOVWF  0D
04C8:  MOVLW  07
04C9:  MOVWF  0F
04CA:  BCF    03.6
04CB:  CALL   138
04CC:  MOVLW  0D
04CD:  BTFSS  0C.4
04CE:  GOTO   4CD
04CF:  MOVWF  19
04D0:  MOVLW  0A
04D1:  BTFSS  0C.4
04D2:  GOTO   4D1
04D3:  MOVWF  19
....................                            output_bit(MINUTOD, ON); 
04D4:  BSF    05.0
04D5:  MOVLW  00
04D6:  BSF    03.5
04D7:  MOVWF  05
....................                            break; 
04D8:  BCF    03.5
04D9:  GOTO   5BC
....................       case 'G':   if(DEBUG) {fputs("> Desactivar Minuto Decena",RS232);} 
04DA:  BTFSS  07.2
04DB:  GOTO   4EB
04DC:  MOVLW  9F
04DD:  BSF    03.6
04DE:  MOVWF  0D
04DF:  MOVLW  07
04E0:  MOVWF  0F
04E1:  BCF    03.6
04E2:  CALL   138
04E3:  MOVLW  0D
04E4:  BTFSS  0C.4
04E5:  GOTO   4E4
04E6:  MOVWF  19
04E7:  MOVLW  0A
04E8:  BTFSS  0C.4
04E9:  GOTO   4E8
04EA:  MOVWF  19
....................                            output_bit(MINUTOD, OFF); 
04EB:  BCF    05.0
04EC:  MOVLW  00
04ED:  BSF    03.5
04EE:  MOVWF  05
....................                            break;             
04EF:  BCF    03.5
04F0:  GOTO   5BC
....................       case 'H':   if(DEBUG) {fputs("> Toque Corto",RS232);} 
04F1:  BTFSS  07.2
04F2:  GOTO   502
04F3:  MOVLW  AD
04F4:  BSF    03.6
04F5:  MOVWF  0D
04F6:  MOVLW  07
04F7:  MOVWF  0F
04F8:  BCF    03.6
04F9:  CALL   138
04FA:  MOVLW  0D
04FB:  BTFSS  0C.4
04FC:  GOTO   4FB
04FD:  MOVWF  19
04FE:  MOVLW  0A
04FF:  BTFSS  0C.4
0500:  GOTO   4FF
0501:  MOVWF  19
....................                            buzz(1); 
0502:  MOVLW  01
0503:  MOVWF  72
0504:  CALL   2C1
....................                            break; 
0505:  GOTO   5BC
....................       case 'I':   if(DEBUG) {fputs("> Toque Largo",RS232);} 
0506:  BTFSS  07.2
0507:  GOTO   517
0508:  MOVLW  B4
0509:  BSF    03.6
050A:  MOVWF  0D
050B:  MOVLW  07
050C:  MOVWF  0F
050D:  BCF    03.6
050E:  CALL   138
050F:  MOVLW  0D
0510:  BTFSS  0C.4
0511:  GOTO   510
0512:  MOVWF  19
0513:  MOVLW  0A
0514:  BTFSS  0C.4
0515:  GOTO   514
0516:  MOVWF  19
....................                            buzz(2); 
0517:  MOVLW  02
0518:  MOVWF  72
0519:  CALL   2C1
....................                            break; 
051A:  GOTO   5BC
....................       case 'J':   if(DEBUG) {fputs("> Toque Doble",RS232);} 
051B:  BTFSS  07.2
051C:  GOTO   52C
051D:  MOVLW  BB
051E:  BSF    03.6
051F:  MOVWF  0D
0520:  MOVLW  07
0521:  MOVWF  0F
0522:  BCF    03.6
0523:  CALL   138
0524:  MOVLW  0D
0525:  BTFSS  0C.4
0526:  GOTO   525
0527:  MOVWF  19
0528:  MOVLW  0A
0529:  BTFSS  0C.4
052A:  GOTO   529
052B:  MOVWF  19
....................                            buzz(3); 
052C:  MOVLW  03
052D:  MOVWF  72
052E:  CALL   2C1
....................                            break; 
052F:  GOTO   5BC
....................       case 'X':   doTest(); //Rutina de prueba 
0530:  CALL   322
....................                   break; 
0531:  GOTO   5BC
....................       case 'Z':   if(DEBUG) {fputs("\r> Reseteo general...!",RS232);} 
0532:  BTFSS  07.2
0533:  GOTO   543
0534:  MOVLW  C2
0535:  BSF    03.6
0536:  MOVWF  0D
0537:  MOVLW  07
0538:  MOVWF  0F
0539:  BCF    03.6
053A:  CALL   138
053B:  MOVLW  0D
053C:  BTFSS  0C.4
053D:  GOTO   53C
053E:  MOVWF  19
053F:  MOVLW  0A
0540:  BTFSS  0C.4
0541:  GOTO   540
0542:  MOVWF  19
....................                   delay_ms(100); 
0543:  MOVLW  64
0544:  MOVWF  74
0545:  CALL   2AD
....................                   if(DEBUG) {fputs("\r> (5)",RS232);} 
0546:  BTFSS  07.2
0547:  GOTO   557
0548:  MOVLW  CE
0549:  BSF    03.6
054A:  MOVWF  0D
054B:  MOVLW  07
054C:  MOVWF  0F
054D:  BCF    03.6
054E:  CALL   138
054F:  MOVLW  0D
0550:  BTFSS  0C.4
0551:  GOTO   550
0552:  MOVWF  19
0553:  MOVLW  0A
0554:  BTFSS  0C.4
0555:  GOTO   554
0556:  MOVWF  19
....................                   delay_ms(100); 
0557:  MOVLW  64
0558:  MOVWF  74
0559:  CALL   2AD
....................                   if(DEBUG) {fputs("\r> (4)",RS232);} 
055A:  BTFSS  07.2
055B:  GOTO   56B
055C:  MOVLW  D2
055D:  BSF    03.6
055E:  MOVWF  0D
055F:  MOVLW  07
0560:  MOVWF  0F
0561:  BCF    03.6
0562:  CALL   138
0563:  MOVLW  0D
0564:  BTFSS  0C.4
0565:  GOTO   564
0566:  MOVWF  19
0567:  MOVLW  0A
0568:  BTFSS  0C.4
0569:  GOTO   568
056A:  MOVWF  19
....................                   delay_ms(100); 
056B:  MOVLW  64
056C:  MOVWF  74
056D:  CALL   2AD
....................                   if(DEBUG) {fputs("\r> (3)",RS232);} 
056E:  BTFSS  07.2
056F:  GOTO   57F
0570:  MOVLW  D6
0571:  BSF    03.6
0572:  MOVWF  0D
0573:  MOVLW  07
0574:  MOVWF  0F
0575:  BCF    03.6
0576:  CALL   138
0577:  MOVLW  0D
0578:  BTFSS  0C.4
0579:  GOTO   578
057A:  MOVWF  19
057B:  MOVLW  0A
057C:  BTFSS  0C.4
057D:  GOTO   57C
057E:  MOVWF  19
....................                   delay_ms(100); 
057F:  MOVLW  64
0580:  MOVWF  74
0581:  CALL   2AD
....................                   if(DEBUG) {fputs("\r> (2)",RS232);} 
0582:  BTFSS  07.2
0583:  GOTO   593
0584:  MOVLW  DA
0585:  BSF    03.6
0586:  MOVWF  0D
0587:  MOVLW  07
0588:  MOVWF  0F
0589:  BCF    03.6
058A:  CALL   138
058B:  MOVLW  0D
058C:  BTFSS  0C.4
058D:  GOTO   58C
058E:  MOVWF  19
058F:  MOVLW  0A
0590:  BTFSS  0C.4
0591:  GOTO   590
0592:  MOVWF  19
....................                   delay_ms(100); 
0593:  MOVLW  64
0594:  MOVWF  74
0595:  CALL   2AD
....................                   if(DEBUG) {fputs("\r> (1)",RS232);} 
0596:  BTFSS  07.2
0597:  GOTO   5A7
0598:  MOVLW  DE
0599:  BSF    03.6
059A:  MOVWF  0D
059B:  MOVLW  07
059C:  MOVWF  0F
059D:  BCF    03.6
059E:  CALL   138
059F:  MOVLW  0D
05A0:  BTFSS  0C.4
05A1:  GOTO   5A0
05A2:  MOVWF  19
05A3:  MOVLW  0A
05A4:  BTFSS  0C.4
05A5:  GOTO   5A4
05A6:  MOVWF  19
....................                   delay_ms(100); 
05A7:  MOVLW  64
05A8:  MOVWF  74
05A9:  CALL   2AD
....................                   if(DEBUG) {fputs("\r> (0)",RS232);} 
05AA:  BTFSS  07.2
05AB:  GOTO   5BB
05AC:  MOVLW  E2
05AD:  BSF    03.6
05AE:  MOVWF  0D
05AF:  MOVLW  07
05B0:  MOVWF  0F
05B1:  BCF    03.6
05B2:  CALL   138
05B3:  MOVLW  0D
05B4:  BTFSS  0C.4
05B5:  GOTO   5B4
05B6:  MOVWF  19
05B7:  MOVLW  0A
05B8:  BTFSS  0C.4
05B9:  GOTO   5B8
05BA:  MOVWF  19
....................                   doReset(); 
05BB:  CALL   39C
....................                    
....................    } 
05BC:  BCF    0A.3
05BD:  BCF    0A.4
05BE:  GOTO   5F2 (RETURN)
.................... } 
....................  
.................... void showQuarter(int8 n) 
.................... { 
....................    output_bit(PERIODO1, OFF); 
*
0273:  BCF    09.1
0274:  MOVLW  E0
0275:  BSF    03.5
0276:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0277:  BCF    03.5
0278:  BCF    09.2
0279:  MOVLW  E0
027A:  BSF    03.5
027B:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
027C:  BCF    03.5
027D:  BCF    07.0
027E:  MOVLW  DC
027F:  BSF    03.5
0280:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0281:  BCF    03.5
0282:  BCF    07.1
0283:  MOVLW  DC
0284:  BSF    03.5
0285:  MOVWF  07
....................     
....................    switch(n) 
0286:  MOVLW  01
0287:  SUBWF  72,W
0288:  ADDLW  FC
0289:  BTFSC  03.0
028A:  GOTO   2A3
028B:  ADDLW  04
028C:  BCF    03.5
028D:  GOTO   2A5
....................    { 
....................       case 1: output_bit(PERIODO1, ON); break; 
028E:  BSF    09.1
028F:  MOVLW  E0
0290:  BSF    03.5
0291:  MOVWF  09
0292:  GOTO   2A3
....................       case 2: output_bit(PERIODO2, ON); break; 
0293:  BSF    09.2
0294:  MOVLW  E0
0295:  BSF    03.5
0296:  MOVWF  09
0297:  GOTO   2A3
....................       case 3: output_bit(PERIODO3, ON); break; 
0298:  BSF    07.0
0299:  MOVLW  DC
029A:  BSF    03.5
029B:  MOVWF  07
029C:  GOTO   2A3
....................       case 4: output_bit(PERIODO4, ON); break; 
029D:  BSF    07.1
029E:  MOVLW  DC
029F:  BSF    03.5
02A0:  MOVWF  07
02A1:  GOTO   2A3
02A2:  BSF    03.5
....................    } 
02A3:  BCF    03.5
02A4:  RETURN
.................... } 
.................... void showNumber(int8 n, tPort p) 
*
01EB:  BCF    7B.0
01EC:  BCF    7B.1
01ED:  BCF    7B.2
01EE:  BCF    7B.3
.................... { 
....................    int1 a=0, b=0, c=0, d=0; 
....................    switch(n) 
01EF:  MOVLW  01
01F0:  SUBWF  72,W
01F1:  ADDLW  F7
01F2:  BTFSC  03.0
01F3:  GOTO   20D
01F4:  ADDLW  09
01F5:  GOTO   266
....................    { 
....................       case 1:  a=1; 
01F6:  BSF    7B.0
....................                break; 
01F7:  GOTO   20D
....................       case 2:  b=1; 
01F8:  BSF    7B.1
....................                break; 
01F9:  GOTO   20D
....................       case 3:  a=1; b=1; 
01FA:  BSF    7B.0
01FB:  BSF    7B.1
....................                break; 
01FC:  GOTO   20D
....................       case 4:  c=1; 
01FD:  BSF    7B.2
....................                break; 
01FE:  GOTO   20D
....................       case 5:  c=1; a=1; 
01FF:  BSF    7B.2
0200:  BSF    7B.0
....................                break; 
0201:  GOTO   20D
....................       case 6:  c=1; b=1; 
0202:  BSF    7B.2
0203:  BSF    7B.1
....................                break; 
0204:  GOTO   20D
....................       case 7:  c=1; b=1; a=1; 
0205:  BSF    7B.2
0206:  BSF    7B.1
0207:  BSF    7B.0
....................                break; 
0208:  GOTO   20D
....................       case 8:  d=1; 
0209:  BSF    7B.3
....................                break; 
020A:  GOTO   20D
....................       case 9:  d=1; a=1; 
020B:  BSF    7B.3
020C:  BSF    7B.0
....................                break; 
....................    } 
....................    output_bit(p.a, a); 
020D:  MOVLW  00
020E:  BTFSC  7B.0
020F:  MOVLW  01
0210:  MOVWF  77
0211:  MOVF   73,W
0212:  MOVWF  7C
0213:  MOVF   77,W
0214:  MOVWF  7D
0215:  BSF    03.5
0216:  CLRF   21
0217:  CLRF   20
0218:  BCF    03.5
0219:  CALL   1C9
021A:  MOVF   73,W
021B:  MOVWF  7C
021C:  CLRF   7D
021D:  BSF    03.5
021E:  CLRF   21
021F:  MOVLW  80
0220:  MOVWF  20
0221:  BCF    03.5
0222:  CALL   1C9
....................    output_bit(p.b, b); 
0223:  MOVLW  00
0224:  BTFSC  7B.1
0225:  MOVLW  01
0226:  MOVWF  77
0227:  MOVF   74,W
0228:  MOVWF  7C
0229:  MOVF   77,W
022A:  MOVWF  7D
022B:  BSF    03.5
022C:  CLRF   21
022D:  CLRF   20
022E:  BCF    03.5
022F:  CALL   1C9
0230:  MOVF   74,W
0231:  MOVWF  7C
0232:  CLRF   7D
0233:  BSF    03.5
0234:  CLRF   21
0235:  MOVLW  80
0236:  MOVWF  20
0237:  BCF    03.5
0238:  CALL   1C9
....................    output_bit(p.c, c); 
0239:  MOVLW  00
023A:  BTFSC  7B.2
023B:  MOVLW  01
023C:  MOVWF  77
023D:  MOVF   75,W
023E:  MOVWF  7C
023F:  MOVF   77,W
0240:  MOVWF  7D
0241:  BSF    03.5
0242:  CLRF   21
0243:  CLRF   20
0244:  BCF    03.5
0245:  CALL   1C9
0246:  MOVF   75,W
0247:  MOVWF  7C
0248:  CLRF   7D
0249:  BSF    03.5
024A:  CLRF   21
024B:  MOVLW  80
024C:  MOVWF  20
024D:  BCF    03.5
024E:  CALL   1C9
....................    output_bit(p.d, d); 
024F:  MOVLW  00
0250:  BTFSC  7B.3
0251:  MOVLW  01
0252:  MOVWF  77
0253:  MOVF   76,W
0254:  MOVWF  7C
0255:  MOVF   77,W
0256:  MOVWF  7D
0257:  BSF    03.5
0258:  CLRF   21
0259:  CLRF   20
025A:  BCF    03.5
025B:  CALL   1C9
025C:  MOVF   76,W
025D:  MOVWF  7C
025E:  CLRF   7D
025F:  BSF    03.5
0260:  CLRF   21
0261:  MOVLW  80
0262:  MOVWF  20
0263:  BCF    03.5
0264:  CALL   1C9
0265:  RETURN
.................... } 
....................  
.................... int8 char2int(char c) 
.................... { 
....................    switch(c) 
*
018A:  MOVLW  30
018B:  SUBWF  71,W
018C:  ADDLW  F6
018D:  BTFSC  03.0
018E:  GOTO   1B8
018F:  ADDLW  0A
0190:  GOTO   1BB
....................    { 
....................       case '0':   return 0; 
0191:  MOVLW  00
0192:  MOVWF  78
0193:  GOTO   1BA
....................                   break; 
0194:  GOTO   1B8
....................       case '1':   return 1; 
0195:  MOVLW  01
0196:  MOVWF  78
0197:  GOTO   1BA
....................                   break; 
0198:  GOTO   1B8
....................       case '2':   return 2; 
0199:  MOVLW  02
019A:  MOVWF  78
019B:  GOTO   1BA
....................                   break; 
019C:  GOTO   1B8
....................       case '3':   return 3; 
019D:  MOVLW  03
019E:  MOVWF  78
019F:  GOTO   1BA
....................                   break; 
01A0:  GOTO   1B8
....................       case '4':   return 4; 
01A1:  MOVLW  04
01A2:  MOVWF  78
01A3:  GOTO   1BA
....................                   break; 
01A4:  GOTO   1B8
....................       case '5':   return 5; 
01A5:  MOVLW  05
01A6:  MOVWF  78
01A7:  GOTO   1BA
....................                   break; 
01A8:  GOTO   1B8
....................       case '6':   return 6; 
01A9:  MOVLW  06
01AA:  MOVWF  78
01AB:  GOTO   1BA
....................                   break; 
01AC:  GOTO   1B8
....................       case '7':   return 7; 
01AD:  MOVLW  07
01AE:  MOVWF  78
01AF:  GOTO   1BA
....................                   break; 
01B0:  GOTO   1B8
....................       case '8':   return 8; 
01B1:  MOVLW  08
01B2:  MOVWF  78
01B3:  GOTO   1BA
....................                   break; 
01B4:  GOTO   1B8
....................       case '9':   return 9; 
01B5:  MOVLW  09
01B6:  MOVWF  78
01B7:  GOTO   1BA
....................                   break; 
....................    } 
....................    return 0; 
01B8:  MOVLW  00
01B9:  MOVWF  78
01BA:  RETURN
.................... } 
....................  
.................... void doReset(void) 
.................... { 
....................    if(DEBUG) {fputs("> Reseteando...",RS232);} 
*
039C:  BTFSS  07.2
039D:  GOTO   3AD
039E:  MOVLW  E6
039F:  BSF    03.6
03A0:  MOVWF  0D
03A1:  MOVLW  07
03A2:  MOVWF  0F
03A3:  BCF    03.6
03A4:  CALL   138
03A5:  MOVLW  0D
03A6:  BTFSS  0C.4
03A7:  GOTO   3A6
03A8:  MOVWF  19
03A9:  MOVLW  0A
03AA:  BTFSS  0C.4
03AB:  GOTO   3AA
03AC:  MOVWF  19
....................    reset_cpu(); 
03AD:  CLRF   0A
03AE:  GOTO   000
03AF:  RETURN
.................... } 
....................  

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

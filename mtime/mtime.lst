CCS PCM C Compiler, Version 5.049, 5967               16-nov.-21 00:37

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mtime\mtime.lst

               ROM used:   3329 words (41%)
                           Largest free fragment is 2048
               RAM used:   70 (19%) at main() level
                           97 (26%) worst case
               Stack used: 5 locations (1 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   4CC
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   5B5
0057:  BSF    0A.3
0058:  BCF    0A.4
0059:  GOTO   000
.................... #include <mtime.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 0D,00
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA A0,23
007D:  DATA F2,3A
007E:  DATA F0,37
007F:  DATA A0,20
0080:  DATA D0,26
0081:  DATA 20,14
0082:  DATA E3,14
0083:  DATA 20,19
0084:  DATA 30,19
0085:  DATA 30,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 0D,00
008A:  DATA BD,1E
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA 0D,00
009B:  DATA 42,36
009C:  DATA F5,32
009D:  DATA F4,37
009E:  DATA 6F,3A
009F:  DATA 68,10
00A0:  DATA C2,30
00A1:  DATA F3,35
00A2:  DATA 65,3A
00A3:  DATA E2,30
00A4:  DATA 6C,36
00A5:  DATA A0,29
00A6:  DATA E3,37
00A7:  DATA F2,32
00A8:  DATA 20,21
00A9:  DATA EF,30
00AA:  DATA 72,32
00AB:  DATA 0D,00
00AC:  DATA BD,1E
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA 0D,00
00BD:  DATA D6,32
00BE:  DATA F2,39
00BF:  DATA E9,37
00C0:  DATA 6E,10
00C1:  DATA A5,39
00C2:  DATA A0,16
00C3:  DATA 20,39
00C4:  DATA 65,3B
00C5:  DATA A0,12
00C6:  DATA 73,10
00C7:  DATA 0D,00
00C8:  DATA 32,17
00C9:  DATA 30,00
00CA:  DATA 46,00
00CB:  DATA 2A,15
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 0D,00
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA C4,22
00E0:  DATA D0,2A
00E1:  DATA D2,20
00E2:  DATA C3,24
00E3:  DATA 4F,27
00E4:  DATA 20,1D
00E5:  DATA 3A,10
00E6:  DATA D4,24
00E7:  DATA C5,26
00E8:  DATA D0,27
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 20,10
00EC:  DATA 0D,00
00ED:  DATA 3E,10
00EE:  DATA C8,30
00EF:  DATA E2,34
00F0:  DATA EC,34
00F1:  DATA F4,30
00F2:  DATA E3,34
00F3:  DATA 6F,37
00F4:  DATA 20,32
00F5:  DATA 65,10
00F6:  DATA 49,19
00F7:  DATA 43,00
00F8:  DATA 3E,10
00F9:  DATA C3,37
00FA:  DATA 6E,33
00FB:  DATA E9,33
00FC:  DATA 75,39
00FD:  DATA E1,31
00FE:  DATA E9,37
00FF:  DATA 6E,10
0100:  DATA E4,32
0101:  DATA 20,28
0102:  DATA F5,32
0103:  DATA 72,3A
0104:  DATA EF,39
0105:  DATA 00,01
0106:  DATA 3E,10
0107:  DATA C8,30
0108:  DATA E2,34
0109:  DATA EC,34
010A:  DATA F4,30
010B:  DATA E3,34
010C:  DATA 6F,37
010D:  DATA 20,32
010E:  DATA 65,10
010F:  DATA E4,34
0110:  DATA 73,38
0111:  DATA EC,30
0112:  DATA F9,39
0113:  DATA 00,01
0114:  DATA 3E,10
0115:  DATA C8,30
0116:  DATA E2,34
0117:  DATA EC,34
0118:  DATA F4,30
0119:  DATA E3,34
011A:  DATA 6F,37
011B:  DATA 20,32
011C:  DATA 65,10
011D:  DATA 69,37
011E:  DATA F4,32
011F:  DATA 72,39
0120:  DATA 75,38
0121:  DATA E3,34
0122:  DATA 6F,37
0123:  DATA E5,39
0124:  DATA 00,00
0125:  MOVF   0B,W
0126:  MOVWF  72
0127:  BCF    0B.7
0128:  BSF    03.5
0129:  BSF    03.6
012A:  BSF    0C.7
012B:  BSF    0C.0
012C:  NOP
012D:  NOP
012E:  BTFSS  72.7
012F:  GOTO   135
0130:  BCF    03.5
0131:  BCF    03.6
0132:  BSF    0B.7
0133:  BSF    03.5
0134:  BSF    03.6
0135:  BCF    03.5
0136:  MOVF   0C,W
0137:  ANDLW  7F
0138:  BTFSC  03.2
0139:  GOTO   175
013A:  MOVWF  72
013B:  MOVF   0D,W
013C:  MOVWF  73
013D:  MOVF   0F,W
013E:  MOVWF  74
013F:  MOVF   72,W
0140:  BCF    03.6
0141:  BTFSS  0C.4
0142:  GOTO   141
0143:  MOVWF  19
0144:  MOVF   73,W
0145:  BSF    03.6
0146:  MOVWF  0D
0147:  MOVF   74,W
0148:  MOVWF  0F
0149:  BCF    03.6
014A:  MOVF   0B,W
014B:  MOVWF  75
014C:  BCF    0B.7
014D:  BSF    03.5
014E:  BSF    03.6
014F:  BSF    0C.7
0150:  BSF    0C.0
0151:  NOP
0152:  NOP
0153:  BTFSS  75.7
0154:  GOTO   15A
0155:  BCF    03.5
0156:  BCF    03.6
0157:  BSF    0B.7
0158:  BSF    03.5
0159:  BSF    03.6
015A:  BCF    03.5
015B:  RLF    0C,W
015C:  RLF    0E,W
015D:  ANDLW  7F
015E:  BTFSC  03.2
015F:  GOTO   175
0160:  MOVWF  72
0161:  MOVF   0D,W
0162:  MOVWF  73
0163:  MOVF   0F,W
0164:  MOVWF  74
0165:  MOVF   72,W
0166:  BCF    03.6
0167:  BTFSS  0C.4
0168:  GOTO   167
0169:  MOVWF  19
016A:  MOVF   73,W
016B:  BSF    03.6
016C:  MOVWF  0D
016D:  MOVF   74,W
016E:  MOVWF  0F
016F:  INCF   0D,F
0170:  BTFSC  03.2
0171:  INCF   0F,F
0172:  BCF    03.6
0173:  GOTO   125
0174:  BSF    03.6
0175:  BCF    03.6
0176:  RETURN
*
01A8:  BSF    0A.0
01A9:  BCF    0A.1
01AA:  BCF    0A.2
01AB:  ADDWF  02,F
01AC:  GOTO   17E
01AD:  GOTO   182
01AE:  GOTO   186
01AF:  GOTO   18A
01B0:  GOTO   18E
01B1:  GOTO   192
01B2:  GOTO   196
01B3:  GOTO   19A
01B4:  GOTO   19E
01B5:  GOTO   1A2
01B6:  MOVF   7C,W
01B7:  ANDLW  07
01B8:  MOVWF  77
01B9:  RRF    7C,W
01BA:  MOVWF  78
01BB:  RRF    78,F
01BC:  RRF    78,F
01BD:  MOVLW  1F
01BE:  ANDWF  78,F
01BF:  MOVF   78,W
01C0:  BSF    03.5
01C1:  ADDWF  20,W
01C2:  MOVWF  04
01C3:  BCF    03.7
01C4:  BTFSC  21.0
01C5:  BSF    03.7
01C6:  CLRF   78
01C7:  INCF   78,F
01C8:  INCF   77,F
01C9:  GOTO   1CB
01CA:  RLF    78,F
01CB:  DECFSZ 77,F
01CC:  GOTO   1CA
01CD:  MOVF   7D,F
01CE:  BTFSC  03.2
01CF:  GOTO   1D3
01D0:  MOVF   78,W
01D1:  IORWF  00,F
01D2:  GOTO   1D6
01D3:  COMF   78,F
01D4:  MOVF   78,W
01D5:  ANDWF  00,F
01D6:  BCF    03.5
01D7:  RETURN
*
0253:  BCF    0A.0
0254:  BSF    0A.1
0255:  BCF    0A.2
0256:  ADDWF  02,F
0257:  GOTO   1E3
0258:  GOTO   1E5
0259:  GOTO   1E7
025A:  GOTO   1EA
025B:  GOTO   1EC
025C:  GOTO   1EF
025D:  GOTO   1F2
025E:  GOTO   1F6
025F:  GOTO   1F8
*
0292:  BCF    0A.0
0293:  BSF    0A.1
0294:  BCF    0A.2
0295:  ADDWF  02,F
0296:  GOTO   27B
0297:  GOTO   280
0298:  GOTO   285
0299:  GOTO   28A
*
05AC:  BSF    0A.0
05AD:  BCF    0A.1
05AE:  BSF    0A.2
05AF:  ADDWF  02,F
05B0:  GOTO   3F8
05B1:  GOTO   408
05B2:  GOTO   418
05B3:  GOTO   428
05B4:  GOTO   438
*
0605:  MOVF   0B,W
0606:  MOVWF  69
0607:  BCF    0B.7
0608:  BSF    03.5
0609:  BSF    03.6
060A:  BSF    0C.7
060B:  BSF    0C.0
060C:  NOP
060D:  NOP
060E:  BCF    03.5
060F:  BCF    03.6
0610:  BTFSC  69.7
0611:  BSF    0B.7
0612:  BTFSC  03.0
0613:  GOTO   63D
0614:  BSF    03.6
0615:  MOVF   0C,W
0616:  ANDLW  7F
0617:  BCF    03.6
0618:  MOVWF  69
0619:  BSF    03.6
061A:  MOVF   0D,W
061B:  BCF    03.6
061C:  MOVWF  6A
061D:  BSF    03.6
061E:  MOVF   0F,W
061F:  BCF    03.6
0620:  MOVWF  6B
0621:  MOVF   69,W
0622:  BTFSS  0C.4
0623:  GOTO   622
0624:  MOVWF  19
0625:  MOVF   6A,W
0626:  BSF    03.6
0627:  MOVWF  0D
0628:  BCF    03.6
0629:  MOVF   6B,W
062A:  BSF    03.6
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  MOVF   0B,W
062E:  MOVWF  6C
062F:  BCF    0B.7
0630:  BSF    03.5
0631:  BSF    03.6
0632:  BSF    0C.7
0633:  BSF    0C.0
0634:  NOP
0635:  NOP
0636:  BCF    03.5
0637:  BCF    03.6
0638:  BTFSC  6C.7
0639:  BSF    0B.7
063A:  DECFSZ 68,F
063B:  GOTO   63D
063C:  GOTO   65D
063D:  BSF    03.6
063E:  RLF    0C,W
063F:  RLF    0E,W
0640:  ANDLW  7F
0641:  BCF    03.6
0642:  MOVWF  69
0643:  BSF    03.6
0644:  MOVF   0D,W
0645:  BCF    03.6
0646:  MOVWF  6A
0647:  BSF    03.6
0648:  MOVF   0F,W
0649:  BCF    03.6
064A:  MOVWF  6B
064B:  MOVF   69,W
064C:  BTFSS  0C.4
064D:  GOTO   64C
064E:  MOVWF  19
064F:  MOVF   6A,W
0650:  BSF    03.6
0651:  MOVWF  0D
0652:  BCF    03.6
0653:  MOVF   6B,W
0654:  BSF    03.6
0655:  MOVWF  0F
0656:  INCF   0D,F
0657:  BTFSC  03.2
0658:  INCF   0F,F
0659:  BCF    03.0
065A:  BCF    03.6
065B:  DECFSZ 68,F
065C:  GOTO   605
065D:  RETURN
065E:  BTFSC  69.7
065F:  GOTO   671
0660:  MOVLW  0F
0661:  MOVWF  77
0662:  SWAPF  68,W
0663:  ANDWF  77,F
0664:  MOVLW  0A
0665:  SUBWF  77,W
0666:  BTFSC  03.0
0667:  GOTO   66B
0668:  MOVLW  30
0669:  ADDWF  77,F
066A:  GOTO   66D
066B:  MOVF   69,W
066C:  ADDWF  77,F
066D:  MOVF   77,W
066E:  BTFSS  0C.4
066F:  GOTO   66E
0670:  MOVWF  19
0671:  MOVLW  0F
0672:  ANDWF  68,F
0673:  MOVLW  0A
0674:  SUBWF  68,W
0675:  BTFSC  03.0
0676:  GOTO   679
0677:  MOVLW  30
0678:  GOTO   67B
0679:  BCF    69.7
067A:  MOVF   69,W
067B:  ADDWF  68,F
067C:  MOVF   68,W
067D:  BTFSS  0C.4
067E:  GOTO   67D
067F:  MOVWF  19
0680:  RETURN
0681:  DATA 3E,10
0682:  DATA C3,37
0683:  DATA ED,36
0684:  DATA 61,37
0685:  DATA E4,37
0686:  DATA 3A,10
0687:  DATA 25,2C
0688:  DATA A0,16
0689:  DATA A0,12
068A:  DATA D8,06
068B:  DATA 80,27
068C:  DATA 3E,10
068D:  DATA C4,34
068E:  DATA F2,32
068F:  DATA E3,31
0690:  DATA E9,37
0691:  DATA 6E,10
0692:  DATA D4,24
0693:  DATA CD,22
0694:  DATA 52,00
0695:  DATA 3E,10
0696:  DATA C4,34
0697:  DATA F2,32
0698:  DATA E3,31
0699:  DATA E9,37
069A:  DATA 6E,10
069B:  DATA D3,21
069C:  DATA 4F,29
069D:  DATA 45,00
069E:  DATA 3E,10
069F:  DATA 41,38
06A0:  DATA E1,33
06A1:  DATA 61,39
06A2:  DATA 20,28
06A3:  DATA 65,39
06A4:  DATA E9,37
06A5:  DATA E4,37
06A6:  DATA 73,00
06A7:  DATA 3E,10
06A8:  DATA C1,31
06A9:  DATA F4,34
06AA:  DATA F6,30
06AB:  DATA 72,10
06AC:  DATA D0,32
06AD:  DATA F2,34
06AE:  DATA 6F,32
06AF:  DATA 6F,10
06B0:  DATA 31,00
06B1:  DATA 3E,10
06B2:  DATA C1,31
06B3:  DATA F4,34
06B4:  DATA F6,30
06B5:  DATA 72,10
06B6:  DATA D0,32
06B7:  DATA F2,34
06B8:  DATA 6F,32
06B9:  DATA 6F,10
06BA:  DATA 32,00
06BB:  DATA 3E,10
06BC:  DATA C1,31
06BD:  DATA F4,34
06BE:  DATA F6,30
06BF:  DATA 72,10
06C0:  DATA D0,32
06C1:  DATA F2,34
06C2:  DATA 6F,32
06C3:  DATA 6F,10
06C4:  DATA 33,00
06C5:  DATA 3E,10
06C6:  DATA C1,31
06C7:  DATA F4,34
06C8:  DATA F6,30
06C9:  DATA 72,10
06CA:  DATA D0,32
06CB:  DATA F2,34
06CC:  DATA 6F,32
06CD:  DATA 6F,10
06CE:  DATA 34,00
06CF:  DATA 3E,10
06D0:  DATA C1,31
06D1:  DATA F4,34
06D2:  DATA F6,30
06D3:  DATA 72,10
06D4:  DATA CD,34
06D5:  DATA EE,3A
06D6:  DATA F4,37
06D7:  DATA 20,22
06D8:  DATA E5,31
06D9:  DATA 65,37
06DA:  DATA 61,00
06DB:  DATA 3E,10
06DC:  DATA C4,32
06DD:  DATA F3,30
06DE:  DATA 63,3A
06DF:  DATA 69,3B
06E0:  DATA 61,39
06E1:  DATA A0,26
06E2:  DATA 69,37
06E3:  DATA 75,3A
06E4:  DATA 6F,10
06E5:  DATA C4,32
06E6:  DATA E3,32
06E7:  DATA EE,30
06E8:  DATA 00,01
06E9:  DATA 3E,10
06EA:  DATA D4,37
06EB:  DATA F1,3A
06EC:  DATA 65,10
06ED:  DATA C3,37
06EE:  DATA 72,3A
06EF:  DATA 6F,00
06F0:  DATA 3E,10
06F1:  DATA D4,37
06F2:  DATA F1,3A
06F3:  DATA 65,10
06F4:  DATA CC,30
06F5:  DATA F2,33
06F6:  DATA 6F,00
06F7:  DATA 3E,10
06F8:  DATA D4,37
06F9:  DATA F1,3A
06FA:  DATA 65,10
06FB:  DATA C4,37
06FC:  DATA 62,36
06FD:  DATA 65,00
06FE:  DATA 3E,10
06FF:  DATA C1,39
0700:  DATA E9,33
0701:  DATA EE,30
0702:  DATA E3,34
0703:  DATA 6F,37
0704:  DATA 20,28
0705:  DATA F5,32
0706:  DATA 72,3A
0707:  DATA 6F,10
0708:  DATA 31,00
0709:  DATA 3E,10
070A:  DATA C1,39
070B:  DATA E9,33
070C:  DATA EE,30
070D:  DATA E3,34
070E:  DATA 6F,37
070F:  DATA 20,28
0710:  DATA F5,32
0711:  DATA 72,3A
0712:  DATA 6F,10
0713:  DATA 32,00
0714:  DATA 3E,10
0715:  DATA C1,39
0716:  DATA E9,33
0717:  DATA EE,30
0718:  DATA E3,34
0719:  DATA 6F,37
071A:  DATA 20,28
071B:  DATA F5,32
071C:  DATA 72,3A
071D:  DATA 6F,10
071E:  DATA 33,00
071F:  DATA 3E,10
0720:  DATA C1,39
0721:  DATA E9,33
0722:  DATA EE,30
0723:  DATA E3,34
0724:  DATA 6F,37
0725:  DATA 20,28
0726:  DATA F5,32
0727:  DATA 72,3A
0728:  DATA 6F,10
0729:  DATA 34,00
072A:  DATA 3E,10
072B:  DATA C1,39
072C:  DATA E9,33
072D:  DATA EE,30
072E:  DATA E3,34
072F:  DATA 6F,37
0730:  DATA 20,28
0731:  DATA F5,32
0732:  DATA 72,3A
0733:  DATA 6F,10
0734:  DATA 35,00
0735:  DATA 3E,10
0736:  DATA D2,3A
0737:  DATA F4,34
0738:  DATA EE,30
0739:  DATA 20,32
073A:  DATA 65,10
073B:  DATA 70,39
073C:  DATA F5,32
073D:  DATA E2,30
073E:  DATA 00,00
073F:  DATA 0D,1F
0740:  DATA A0,20
0741:  DATA 63,3A
0742:  DATA 69,3B
0743:  DATA E1,31
0744:  DATA E9,37
0745:  DATA 6E,10
0746:  DATA ED,30
0747:  DATA EE,3A
0748:  DATA 61,36
0749:  DATA 20,32
074A:  DATA 65,10
074B:  DATA F0,3A
074C:  DATA 65,39
074D:  DATA F4,37
074E:  DATA 00,01
074F:  DATA 3E,10
0750:  DATA 41,38
0751:  DATA E1,33
0752:  DATA 61,39
0753:  DATA 20,28
0754:  DATA 65,39
0755:  DATA E9,37
0756:  DATA E4,37
0757:  DATA 73,00
0758:  DATA 3E,10
0759:  DATA C1,31
075A:  DATA F4,34
075B:  DATA F6,30
075C:  DATA 72,10
075D:  DATA D0,32
075E:  DATA F2,34
075F:  DATA 6F,32
0760:  DATA 6F,10
0761:  DATA 31,00
0762:  DATA 3E,10
0763:  DATA C1,31
0764:  DATA F4,34
0765:  DATA F6,30
0766:  DATA 72,10
0767:  DATA D0,32
0768:  DATA F2,34
0769:  DATA 6F,32
076A:  DATA 6F,10
076B:  DATA 32,00
076C:  DATA 3E,10
076D:  DATA C1,31
076E:  DATA F4,34
076F:  DATA F6,30
0770:  DATA 72,10
0771:  DATA D0,32
0772:  DATA F2,34
0773:  DATA 6F,32
0774:  DATA 6F,10
0775:  DATA 33,00
0776:  DATA 3E,10
0777:  DATA C1,31
0778:  DATA F4,34
0779:  DATA F6,30
077A:  DATA 72,10
077B:  DATA D0,32
077C:  DATA F2,34
077D:  DATA 6F,32
077E:  DATA 6F,10
077F:  DATA 34,00
0780:  DATA 3E,10
0781:  DATA C1,31
0782:  DATA F4,34
0783:  DATA F6,30
0784:  DATA 72,10
0785:  DATA CD,34
0786:  DATA EE,3A
0787:  DATA F4,37
0788:  DATA 20,22
0789:  DATA E5,31
078A:  DATA 65,37
078B:  DATA 61,00
078C:  DATA 3E,10
078D:  DATA C4,32
078E:  DATA F3,30
078F:  DATA 63,3A
0790:  DATA 69,3B
0791:  DATA 61,39
0792:  DATA A0,26
0793:  DATA 69,37
0794:  DATA 75,3A
0795:  DATA 6F,10
0796:  DATA C4,32
0797:  DATA E3,32
0798:  DATA EE,30
0799:  DATA 00,01
079A:  DATA 3E,10
079B:  DATA D4,37
079C:  DATA F1,3A
079D:  DATA 65,10
079E:  DATA C3,37
079F:  DATA 72,3A
07A0:  DATA 6F,00
07A1:  DATA 3E,10
07A2:  DATA D4,37
07A3:  DATA F1,3A
07A4:  DATA 65,10
07A5:  DATA CC,30
07A6:  DATA F2,33
07A7:  DATA 6F,00
07A8:  DATA 3E,10
07A9:  DATA D4,37
07AA:  DATA F1,3A
07AB:  DATA 65,10
07AC:  DATA C4,37
07AD:  DATA 62,36
07AE:  DATA 65,00
07AF:  DATA 0D,1F
07B0:  DATA 20,29
07B1:  DATA E5,39
07B2:  DATA 65,3A
07B3:  DATA E5,37
07B4:  DATA A0,33
07B5:  DATA 65,37
07B6:  DATA 65,39
07B7:  DATA 61,36
07B8:  DATA 2E,17
07B9:  DATA AE,10
07BA:  DATA 00,01
07BB:  DATA 0D,1F
07BC:  DATA 20,14
07BD:  DATA B5,14
07BE:  DATA 00,01
07BF:  DATA 0D,1F
07C0:  DATA 20,14
07C1:  DATA B4,14
07C2:  DATA 00,01
07C3:  DATA 0D,1F
07C4:  DATA 20,14
07C5:  DATA B3,14
07C6:  DATA 00,01
07C7:  DATA 0D,1F
07C8:  DATA 20,14
07C9:  DATA B2,14
07CA:  DATA 00,01
07CB:  DATA 0D,1F
07CC:  DATA 20,14
07CD:  DATA B1,14
07CE:  DATA 00,01
07CF:  DATA 0D,1F
07D0:  DATA 20,14
07D1:  DATA B0,14
07D2:  DATA 00,00
07D3:  DATA 3E,10
07D4:  DATA D2,32
07D5:  DATA F3,32
07D6:  DATA F4,32
07D7:  DATA 61,37
07D8:  DATA E4,37
07D9:  DATA 2E,17
07DA:  DATA 2E,00
*
0AA1:  MOVF   0B,W
0AA2:  MOVWF  61
0AA3:  BCF    0B.7
0AA4:  BSF    03.5
0AA5:  BSF    03.6
0AA6:  BSF    0C.7
0AA7:  BSF    0C.0
0AA8:  NOP
0AA9:  NOP
0AAA:  BCF    03.5
0AAB:  BCF    03.6
0AAC:  BTFSC  61.7
0AAD:  BSF    0B.7
0AAE:  BSF    03.6
0AAF:  MOVF   0C,W
0AB0:  ANDLW  7F
0AB1:  BTFSC  03.2
0AB2:  GOTO   2F7
0AB3:  BCF    03.6
0AB4:  MOVWF  61
0AB5:  BSF    03.6
0AB6:  MOVF   0D,W
0AB7:  BCF    03.6
0AB8:  MOVWF  62
0AB9:  BSF    03.6
0ABA:  MOVF   0F,W
0ABB:  BCF    03.6
0ABC:  MOVWF  63
0ABD:  MOVF   61,W
0ABE:  BTFSS  0C.4
0ABF:  GOTO   2BE
0AC0:  MOVWF  19
0AC1:  MOVF   62,W
0AC2:  BSF    03.6
0AC3:  MOVWF  0D
0AC4:  BCF    03.6
0AC5:  MOVF   63,W
0AC6:  BSF    03.6
0AC7:  MOVWF  0F
0AC8:  BCF    03.6
0AC9:  MOVF   0B,W
0ACA:  MOVWF  64
0ACB:  BCF    0B.7
0ACC:  BSF    03.5
0ACD:  BSF    03.6
0ACE:  BSF    0C.7
0ACF:  BSF    0C.0
0AD0:  NOP
0AD1:  NOP
0AD2:  BCF    03.5
0AD3:  BCF    03.6
0AD4:  BTFSC  64.7
0AD5:  BSF    0B.7
0AD6:  BSF    03.6
0AD7:  RLF    0C,W
0AD8:  RLF    0E,W
0AD9:  ANDLW  7F
0ADA:  BTFSC  03.2
0ADB:  GOTO   2F7
0ADC:  BCF    03.6
0ADD:  MOVWF  61
0ADE:  BSF    03.6
0ADF:  MOVF   0D,W
0AE0:  BCF    03.6
0AE1:  MOVWF  62
0AE2:  BSF    03.6
0AE3:  MOVF   0F,W
0AE4:  BCF    03.6
0AE5:  MOVWF  63
0AE6:  MOVF   61,W
0AE7:  BTFSS  0C.4
0AE8:  GOTO   2E7
0AE9:  MOVWF  19
0AEA:  MOVF   62,W
0AEB:  BSF    03.6
0AEC:  MOVWF  0D
0AED:  BCF    03.6
0AEE:  MOVF   63,W
0AEF:  BSF    03.6
0AF0:  MOVWF  0F
0AF1:  INCF   0D,F
0AF2:  BTFSC  03.2
0AF3:  INCF   0F,F
0AF4:  BCF    03.6
0AF5:  GOTO   2A1
0AF6:  BSF    03.6
0AF7:  BCF    03.6
0AF8:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
029A:  MOVLW  74
029B:  MOVWF  04
029C:  BCF    03.7
029D:  MOVF   00,W
029E:  BTFSC  03.2
029F:  GOTO   2AD
02A0:  MOVLW  02
02A1:  MOVWF  78
02A2:  CLRF   77
02A3:  DECFSZ 77,F
02A4:  GOTO   2A3
02A5:  DECFSZ 78,F
02A6:  GOTO   2A2
02A7:  MOVLW  97
02A8:  MOVWF  77
02A9:  DECFSZ 77,F
02AA:  GOTO   2A9
02AB:  DECFSZ 00,F
02AC:  GOTO   2A0
02AD:  RETURN
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4,PIN_A3,PIN_A2,PIN_A1,PIN_A0 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5, PIN_C1, PIN_C0 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E3,PIN_E2,PIN_E1,PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
.................... #define PERIODO1  PIN_E1 
.................... #define PERIODO2  PIN_E2 
.................... #define PERIODO3  PIN_C0 
.................... #define PERIODO4  PIN_C1 
.................... #define MINUTOD   PIN_A0 
.................... #define BUZZER    PIN_A1 
....................  
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Slave,Fast,sda=I2C_SDA,scl=I2C_SCL, address = I2C_TIMER, FORCE_HW) 
*
0821:  MOVF   67,W
0822:  MOVWF  13
0823:  BSF    14.4
0824:  BCF    0C.3
0825:  BSF    03.5
0826:  BTFSC  14.0
0827:  GOTO   026
0828:  CLRF   78
0829:  BCF    03.5
082A:  BTFSC  14.4
082B:  INCF   78,F
....................  
.................... //-- DEFINICIONES -- 
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
....................  
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       200 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... //-- DECLARACIONES -- 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
0D07:  BCF    03.6
0D08:  CLRF   2C
0D09:  CLRF   2D
0D0A:  CLRF   2E
0D0B:  CLRF   2F
0D0C:  CLRF   30
0D0D:  CLRF   31
0D0E:  CLRF   32
0D0F:  CLRF   33
0D10:  CLRF   34
0D11:  CLRF   35
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
0D12:  CLRF   36
0D13:  CLRF   37
0D14:  CLRF   38
0D15:  CLRF   39
0D16:  CLRF   3A
0D17:  CLRF   3B
0D18:  CLRF   3C
0D19:  CLRF   3D
0D1A:  CLRF   3E
0D1B:  CLRF   3F
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... int  icmd; 
.................... int  ircmd[5] = "\0\0\0\0"; 
0D1C:  CLRF   43
0D1D:  CLRF   44
0D1E:  CLRF   45
0D1F:  CLRF   46
0D20:  CLRF   47
....................  
.................... //Puertos de Displays 
.................... tPort pTiroSU; 
.................... tPort pTiroSD; 
.................... tPort pTiempoSU; 
.................... tPort pTiempoSD; 
.................... tPort pTiempoMU; 
....................  
....................  
.................... //-- PROTOTIPOS -- 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8  char2int(char);  
.................... void doReset(void); 
.................... void parseI2CCommand(void); 
.................... void showQuarter(int8); 
.................... void buzz(int); 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
0D21:  CLRF   5C
0D22:  CLRF   5D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
0AF9:  BSF    03.5
0AFA:  CLRF   05
0AFB:  BCF    03.5
0AFC:  CLRF   05
....................    output_b(0x00); 
0AFD:  BSF    03.5
0AFE:  CLRF   06
0AFF:  BCF    03.5
0B00:  CLRF   06
....................    output_c(0x00); 
0B01:  MOVLW  DC
0B02:  BSF    03.5
0B03:  MOVWF  07
0B04:  BCF    03.5
0B05:  CLRF   07
....................    output_d(0x00); 
0B06:  BSF    03.5
0B07:  CLRF   08
0B08:  BCF    03.5
0B09:  CLRF   08
....................    output_e(0x00); 
0B0A:  BSF    03.5
0B0B:  BCF    09.0
0B0C:  BCF    09.1
0B0D:  BCF    09.2
0B0E:  BCF    09.3
0B0F:  BCF    03.5
0B10:  CLRF   09
0B11:  CLRF   2B
0B12:  BTFSC  0B.7
0B13:  BSF    2B.7
0B14:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0B15:  MOVLW  C8
0B16:  MOVWF  74
0B17:  BCF    0A.3
0B18:  CALL   29A
0B19:  BSF    0A.3
0B1A:  BTFSC  2B.7
0B1B:  BSF    0B.7
....................     
....................    if(DEBUG) 
0B1C:  BTFSS  07.2
0B1D:  GOTO   389
....................    { 
....................       fprintf(RS232,"********************************\r"); 
0B1E:  MOVLW  68
0B1F:  BSF    03.6
0B20:  MOVWF  0D
0B21:  MOVLW  00
0B22:  MOVWF  0F
0B23:  BCF    03.6
0B24:  CALL   2A1
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
0B25:  MOVLW  79
0B26:  BSF    03.6
0B27:  MOVWF  0D
0B28:  MOVLW  00
0B29:  MOVWF  0F
0B2A:  BCF    03.6
0B2B:  CALL   2A1
....................       fprintf(RS232,"================================\r"); 
0B2C:  MOVLW  8A
0B2D:  BSF    03.6
0B2E:  MOVWF  0D
0B2F:  MOVLW  00
0B30:  MOVWF  0F
0B31:  BCF    03.6
0B32:  CALL   2A1
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
0B33:  MOVLW  9B
0B34:  BSF    03.6
0B35:  MOVWF  0D
0B36:  MOVLW  00
0B37:  MOVWF  0F
0B38:  BCF    03.6
0B39:  CALL   2A1
....................       fprintf(RS232,"================================\r"); 
0B3A:  MOVLW  AC
0B3B:  BSF    03.6
0B3C:  MOVWF  0D
0B3D:  MOVLW  00
0B3E:  MOVWF  0F
0B3F:  BCF    03.6
0B40:  CALL   2A1
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
0B41:  MOVLW  BD
0B42:  BSF    03.6
0B43:  MOVWF  0D
0B44:  MOVLW  00
0B45:  MOVWF  0F
0B46:  BCF    03.0
0B47:  BCF    03.6
0B48:  CLRF   2B
0B49:  BTFSC  0B.7
0B4A:  BSF    2B.7
0B4B:  BCF    0B.7
0B4C:  MOVLW  08
0B4D:  MOVWF  68
0B4E:  BCF    0A.3
0B4F:  CALL   605
0B50:  BSF    0A.3
0B51:  BTFSC  2B.7
0B52:  BSF    0B.7
0B53:  MOVLW  C8
0B54:  BSF    03.6
0B55:  MOVWF  0D
0B56:  MOVLW  00
0B57:  MOVWF  0F
0B58:  BCF    03.6
0B59:  CALL   2A1
0B5A:  MOVLW  C2
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  00
0B5E:  MOVWF  0F
0B5F:  BCF    03.0
0B60:  BCF    03.6
0B61:  CLRF   2B
0B62:  BTFSC  0B.7
0B63:  BSF    2B.7
0B64:  BCF    0B.7
0B65:  MOVLW  07
0B66:  MOVWF  68
0B67:  BCF    0A.3
0B68:  CALL   605
0B69:  BSF    0A.3
0B6A:  BTFSC  2B.7
0B6B:  BSF    0B.7
0B6C:  MOVLW  CA
0B6D:  BSF    03.6
0B6E:  MOVWF  0D
0B6F:  MOVLW  00
0B70:  MOVWF  0F
0B71:  BCF    03.6
0B72:  CALL   2A1
0B73:  MOVLW  20
0B74:  BTFSS  0C.4
0B75:  GOTO   374
0B76:  MOVWF  19
0B77:  MOVLW  0D
0B78:  BTFSS  0C.4
0B79:  GOTO   378
0B7A:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0B7B:  MOVLW  CB
0B7C:  BSF    03.6
0B7D:  MOVWF  0D
0B7E:  MOVLW  00
0B7F:  MOVWF  0F
0B80:  BCF    03.6
0B81:  CALL   2A1
....................       fprintf(RS232,"      DEPURACION :: TIEMPO      \r"); 
0B82:  MOVLW  DC
0B83:  BSF    03.6
0B84:  MOVWF  0D
0B85:  MOVLW  00
0B86:  MOVWF  0F
0B87:  BCF    03.6
0B88:  CALL   2A1
....................    } 
....................     
....................    if(DEBUG) {fputs("> Habilitacion de I2C",RS232);} 
0B89:  BTFSS  07.2
0B8A:  GOTO   3A2
0B8B:  MOVLW  ED
0B8C:  BSF    03.6
0B8D:  MOVWF  0D
0B8E:  MOVLW  00
0B8F:  MOVWF  0F
0B90:  BCF    03.6
0B91:  CLRF   2B
0B92:  BTFSC  0B.7
0B93:  BSF    2B.7
0B94:  BCF    0B.7
0B95:  BCF    0A.3
0B96:  CALL   125
0B97:  BSF    0A.3
0B98:  BTFSC  2B.7
0B99:  BSF    0B.7
0B9A:  MOVLW  0D
0B9B:  BTFSS  0C.4
0B9C:  GOTO   39B
0B9D:  MOVWF  19
0B9E:  MOVLW  0A
0B9F:  BTFSS  0C.4
0BA0:  GOTO   39F
0BA1:  MOVWF  19
....................    i2c_slaveaddr(I2C_TIMER); 
0BA2:  MOVLW  0A
0BA3:  BSF    03.5
0BA4:  MOVWF  13
0BA5:  BCF    03.5
0BA6:  CLRF   2B
0BA7:  BTFSC  0B.7
0BA8:  BSF    2B.7
0BA9:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0BAA:  MOVLW  C8
0BAB:  MOVWF  74
0BAC:  BCF    0A.3
0BAD:  CALL   29A
0BAE:  BSF    0A.3
0BAF:  BTFSC  2B.7
0BB0:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
0BB1:  BTFSS  07.2
0BB2:  GOTO   3CA
0BB3:  MOVLW  F8
0BB4:  BSF    03.6
0BB5:  MOVWF  0D
0BB6:  MOVLW  00
0BB7:  MOVWF  0F
0BB8:  BCF    03.6
0BB9:  CLRF   2B
0BBA:  BTFSC  0B.7
0BBB:  BSF    2B.7
0BBC:  BCF    0B.7
0BBD:  BCF    0A.3
0BBE:  CALL   125
0BBF:  BSF    0A.3
0BC0:  BTFSC  2B.7
0BC1:  BSF    0B.7
0BC2:  MOVLW  0D
0BC3:  BTFSS  0C.4
0BC4:  GOTO   3C3
0BC5:  MOVWF  19
0BC6:  MOVLW  0A
0BC7:  BTFSS  0C.4
0BC8:  GOTO   3C7
0BC9:  MOVWF  19
....................    //TODO: Activar puertos 
....................    pTiroSU.a = PIN_B0; 
0BCA:  MOVLW  30
0BCB:  MOVWF  48
....................    pTiroSU.b = PIN_B1; 
0BCC:  MOVLW  31
0BCD:  MOVWF  49
....................    pTiroSU.c = PIN_B2; 
0BCE:  MOVLW  32
0BCF:  MOVWF  4A
....................    pTiroSU.d = PIN_B3; 
0BD0:  MOVLW  33
0BD1:  MOVWF  4B
....................     
....................    pTiroSD.a = PIN_B4; 
0BD2:  MOVLW  34
0BD3:  MOVWF  4C
....................    pTiroSD.b = PIN_B5; 
0BD4:  MOVLW  35
0BD5:  MOVWF  4D
....................    pTiroSD.c = PIN_B6; 
0BD6:  MOVLW  36
0BD7:  MOVWF  4E
....................    pTiroSD.d = PIN_B7; 
0BD8:  MOVLW  37
0BD9:  MOVWF  4F
....................     
....................    pTiempoSU.a = PIN_D0; 
0BDA:  MOVLW  40
0BDB:  MOVWF  50
....................    pTiempoSU.b = PIN_D1; 
0BDC:  MOVLW  41
0BDD:  MOVWF  51
....................    pTiempoSU.c = PIN_D2; 
0BDE:  MOVLW  42
0BDF:  MOVWF  52
....................    pTiempoSU.d = PIN_D3; 
0BE0:  MOVLW  43
0BE1:  MOVWF  53
....................     
....................    pTiempoSD.a = PIN_D4; 
0BE2:  MOVLW  44
0BE3:  MOVWF  54
....................    pTiempoSD.b = PIN_D5; 
0BE4:  MOVLW  45
0BE5:  MOVWF  55
....................    pTiempoSD.c = PIN_D6; 
0BE6:  MOVLW  46
0BE7:  MOVWF  56
....................    pTiempoSD.d = PIN_D7; 
0BE8:  MOVLW  47
0BE9:  MOVWF  57
....................     
....................    pTiempoMU.a = PIN_A4; 
0BEA:  MOVLW  2C
0BEB:  MOVWF  58
....................    pTiempoMU.b = PIN_A5; 
0BEC:  MOVLW  2D
0BED:  MOVWF  59
....................    pTiempoMU.c = PIN_A6; 
0BEE:  MOVLW  2E
0BEF:  MOVWF  5A
....................    pTiempoMU.d = PIN_A7; 
0BF0:  MOVLW  2F
0BF1:  MOVWF  5B
0BF2:  CLRF   2B
0BF3:  BTFSC  0B.7
0BF4:  BSF    2B.7
0BF5:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0BF6:  MOVLW  C8
0BF7:  MOVWF  74
0BF8:  BCF    0A.3
0BF9:  CALL   29A
0BFA:  BSF    0A.3
0BFB:  BTFSC  2B.7
0BFC:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de displays",RS232);} 
0BFD:  BTFSS  07.2
0BFE:  GOTO   416
0BFF:  MOVLW  06
0C00:  BSF    03.6
0C01:  MOVWF  0D
0C02:  MOVLW  01
0C03:  MOVWF  0F
0C04:  BCF    03.6
0C05:  CLRF   2B
0C06:  BTFSC  0B.7
0C07:  BSF    2B.7
0C08:  BCF    0B.7
0C09:  BCF    0A.3
0C0A:  CALL   125
0C0B:  BSF    0A.3
0C0C:  BTFSC  2B.7
0C0D:  BSF    0B.7
0C0E:  MOVLW  0D
0C0F:  BTFSS  0C.4
0C10:  GOTO   40F
0C11:  MOVWF  19
0C12:  MOVLW  0A
0C13:  BTFSS  0C.4
0C14:  GOTO   413
0C15:  MOVWF  19
....................    output_bit(DISPLAY, ON);  
0C16:  BSF    09.0
0C17:  MOVLW  E0
0C18:  BSF    03.5
0C19:  MOVWF  09
....................    output_bit(MINUTOD, ON);  
0C1A:  BCF    03.5
0C1B:  BSF    05.0
0C1C:  MOVLW  00
0C1D:  BSF    03.5
0C1E:  MOVWF  05
....................    output_bit(PERIODO1, ON); 
0C1F:  BCF    03.5
0C20:  BSF    09.1
0C21:  MOVLW  E0
0C22:  BSF    03.5
0C23:  MOVWF  09
....................    output_bit(PERIODO2, ON); 
0C24:  BCF    03.5
0C25:  BSF    09.2
0C26:  MOVLW  E0
0C27:  BSF    03.5
0C28:  MOVWF  09
....................    output_bit(PERIODO3, ON); 
0C29:  BCF    03.5
0C2A:  BSF    07.0
0C2B:  MOVLW  DC
0C2C:  BSF    03.5
0C2D:  MOVWF  07
....................    output_bit(PERIODO4, ON); 
0C2E:  BCF    03.5
0C2F:  BSF    07.1
0C30:  MOVLW  DC
0C31:  BSF    03.5
0C32:  MOVWF  07
0C33:  BCF    03.5
0C34:  CLRF   2B
0C35:  BTFSC  0B.7
0C36:  BSF    2B.7
0C37:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C38:  MOVLW  C8
0C39:  MOVWF  74
0C3A:  BCF    0A.3
0C3B:  CALL   29A
0C3C:  BSF    0A.3
0C3D:  BTFSC  2B.7
0C3E:  BSF    0B.7
....................    output_bit(DISPLAY, OFF); 
0C3F:  BCF    09.0
0C40:  MOVLW  E0
0C41:  BSF    03.5
0C42:  MOVWF  09
....................    output_bit(MINUTOD, OFF); 
0C43:  BCF    03.5
0C44:  BCF    05.0
0C45:  MOVLW  00
0C46:  BSF    03.5
0C47:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0C48:  BCF    03.5
0C49:  BCF    09.1
0C4A:  MOVLW  E0
0C4B:  BSF    03.5
0C4C:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0C4D:  BCF    03.5
0C4E:  BCF    09.2
0C4F:  MOVLW  E0
0C50:  BSF    03.5
0C51:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0C52:  BCF    03.5
0C53:  BCF    07.0
0C54:  MOVLW  DC
0C55:  BSF    03.5
0C56:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0C57:  BCF    03.5
0C58:  BCF    07.1
0C59:  MOVLW  DC
0C5A:  BSF    03.5
0C5B:  MOVWF  07
0C5C:  BCF    03.5
0C5D:  CLRF   2B
0C5E:  BTFSC  0B.7
0C5F:  BSF    2B.7
0C60:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C61:  MOVLW  C8
0C62:  MOVWF  74
0C63:  BCF    0A.3
0C64:  CALL   29A
0C65:  BSF    0A.3
0C66:  BTFSC  2B.7
0C67:  BSF    0B.7
....................    output_bit(DISPLAY, ON); 
0C68:  BSF    09.0
0C69:  MOVLW  E0
0C6A:  BSF    03.5
0C6B:  MOVWF  09
....................    output_bit(MINUTOD, ON); 
0C6C:  BCF    03.5
0C6D:  BSF    05.0
0C6E:  MOVLW  00
0C6F:  BSF    03.5
0C70:  MOVWF  05
....................    output_bit(PERIODO1, ON); 
0C71:  BCF    03.5
0C72:  BSF    09.1
0C73:  MOVLW  E0
0C74:  BSF    03.5
0C75:  MOVWF  09
....................    output_bit(PERIODO2, ON); 
0C76:  BCF    03.5
0C77:  BSF    09.2
0C78:  MOVLW  E0
0C79:  BSF    03.5
0C7A:  MOVWF  09
....................    output_bit(PERIODO3, ON); 
0C7B:  BCF    03.5
0C7C:  BSF    07.0
0C7D:  MOVLW  DC
0C7E:  BSF    03.5
0C7F:  MOVWF  07
....................    output_bit(PERIODO4, ON); 
0C80:  BCF    03.5
0C81:  BSF    07.1
0C82:  MOVLW  DC
0C83:  BSF    03.5
0C84:  MOVWF  07
0C85:  BCF    03.5
0C86:  CLRF   2B
0C87:  BTFSC  0B.7
0C88:  BSF    2B.7
0C89:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C8A:  MOVLW  C8
0C8B:  MOVWF  74
0C8C:  BCF    0A.3
0C8D:  CALL   29A
0C8E:  BSF    0A.3
0C8F:  BTFSC  2B.7
0C90:  BSF    0B.7
....................    output_bit(MINUTOD, OFF); 
0C91:  BCF    05.0
0C92:  MOVLW  00
0C93:  BSF    03.5
0C94:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0C95:  BCF    03.5
0C96:  BCF    09.1
0C97:  MOVLW  E0
0C98:  BSF    03.5
0C99:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0C9A:  BCF    03.5
0C9B:  BCF    09.2
0C9C:  MOVLW  E0
0C9D:  BSF    03.5
0C9E:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0C9F:  BCF    03.5
0CA0:  BCF    07.0
0CA1:  MOVLW  DC
0CA2:  BSF    03.5
0CA3:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0CA4:  BCF    03.5
0CA5:  BCF    07.1
0CA6:  MOVLW  DC
0CA7:  BSF    03.5
0CA8:  MOVWF  07
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
0CA9:  BCF    03.5
0CAA:  BTFSS  07.2
0CAB:  GOTO   4C3
0CAC:  MOVLW  14
0CAD:  BSF    03.6
0CAE:  MOVWF  0D
0CAF:  MOVLW  01
0CB0:  MOVWF  0F
0CB1:  BCF    03.6
0CB2:  CLRF   2B
0CB3:  BTFSC  0B.7
0CB4:  BSF    2B.7
0CB5:  BCF    0B.7
0CB6:  BCF    0A.3
0CB7:  CALL   125
0CB8:  BSF    0A.3
0CB9:  BTFSC  2B.7
0CBA:  BSF    0B.7
0CBB:  MOVLW  0D
0CBC:  BTFSS  0C.4
0CBD:  GOTO   4BC
0CBE:  MOVWF  19
0CBF:  MOVLW  0A
0CC0:  BTFSS  0C.4
0CC1:  GOTO   4C0
0CC2:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
0CC3:  BSF    03.5
0CC4:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0CC5:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0CC6:  MOVLW  C0
0CC7:  BCF    03.5
0CC8:  IORWF  0B,F
0CC9:  BSF    0A.3
0CCA:  BCF    0A.4
0CCB:  GOTO   524 (RETURN)
.................... } 
....................  
.................... void main() 
0CCC:  MOVF   03,W
0CCD:  ANDLW  1F
0CCE:  MOVWF  03
0CCF:  MOVLW  71
0CD0:  BSF    03.5
0CD1:  MOVWF  0F
0CD2:  CLRF   10
0CD3:  MOVF   0F,W
0CD4:  BSF    03.6
0CD5:  BCF    07.3
0CD6:  MOVLW  0C
0CD7:  BCF    03.6
0CD8:  MOVWF  19
0CD9:  MOVLW  A2
0CDA:  MOVWF  18
0CDB:  MOVLW  90
0CDC:  BCF    03.5
0CDD:  MOVWF  18
0CDE:  MOVLW  DC
0CDF:  BSF    03.5
0CE0:  MOVWF  07
0CE1:  MOVLW  DC
0CE2:  MOVWF  07
0CE3:  MOVLW  0A
0CE4:  MOVWF  13
0CE5:  MOVLW  09
0CE6:  BCF    03.5
0CE7:  MOVWF  14
0CE8:  MOVLW  FF
0CE9:  BSF    03.5
0CEA:  MOVWF  13
0CEB:  MOVLW  36
0CEC:  BCF    03.5
0CED:  MOVWF  14
0CEE:  BSF    03.5
0CEF:  BSF    11.0
0CF0:  BCF    03.5
0CF1:  CLRF   40
0CF2:  BCF    41.0
0CF3:  CLRF   5F
0CF4:  CLRF   5E
0CF5:  MOVLW  03
0CF6:  MOVWF  60
0CF7:  BSF    03.5
0CF8:  BSF    03.6
0CF9:  MOVF   09,W
0CFA:  ANDLW  C0
0CFB:  MOVWF  09
0CFC:  BCF    03.6
0CFD:  BCF    1F.4
0CFE:  BCF    1F.5
0CFF:  MOVLW  00
0D00:  BSF    03.6
0D01:  MOVWF  08
0D02:  BCF    03.5
0D03:  CLRF   07
0D04:  CLRF   08
0D05:  CLRF   09
0D06:  BCF    03.7
.................... { 
....................    setup(); 
*
0D23:  GOTO   2F9
....................  
....................    while(TRUE) 
....................    { 
0D24:  GOTO   524
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
0D25:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
05B5:  BTFSS  0C.5
05B6:  GOTO   5B5
05B7:  MOVF   1A,W
05B8:  MOVWF  66
.................... if(cmdGet) 
05B9:  BTFSS  41.0
05BA:  GOTO   5EB
.................... { 
....................    if(c == '#' || c == '\r') 
05BB:  MOVF   66,W
05BC:  SUBLW  23
05BD:  BTFSC  03.2
05BE:  GOTO   5C3
05BF:  MOVF   66,W
05C0:  SUBLW  0D
05C1:  BTFSS  03.2
05C2:  GOTO   5E0
....................    { 
....................       cmdGet = false; 
05C3:  BCF    41.0
....................       strcpy(cmd, rcmd); 
05C4:  CLRF   6A
05C5:  MOVLW  36
05C6:  MOVWF  69
05C7:  CLRF   68
05C8:  MOVLW  2C
05C9:  MOVWF  67
05CA:  MOVF   69,W
05CB:  MOVWF  04
05CC:  BCF    03.7
05CD:  BTFSC  6A.0
05CE:  BSF    03.7
05CF:  MOVF   00,W
05D0:  MOVWF  6B
05D1:  MOVF   67,W
05D2:  MOVWF  04
05D3:  BCF    03.7
05D4:  BTFSC  68.0
05D5:  BSF    03.7
05D6:  MOVF   6B,W
05D7:  MOVWF  00
05D8:  MOVF   00,F
05D9:  BTFSC  03.2
05DA:  GOTO   5DE
05DB:  INCF   67,F
05DC:  INCF   69,F
05DD:  GOTO   5CA
....................       parseCommand(); 
05DE:  GOTO   39D
....................    } 
05DF:  GOTO   5EB
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
05E0:  MOVF   40,W
05E1:  SUBLW  08
05E2:  BTFSS  03.0
05E3:  GOTO   5EB
....................       { 
....................          rcmd[cmdIndex] = c; 
05E4:  MOVLW  36
05E5:  ADDWF  40,W
05E6:  MOVWF  04
05E7:  BCF    03.7
05E8:  MOVF   66,W
05E9:  MOVWF  00
....................          cmdIndex++; 
05EA:  INCF   40,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
05EB:  MOVF   66,W
05EC:  SUBLW  2D
05ED:  BTFSS  03.2
05EE:  GOTO   601
....................    { 
....................        cmdGet = true;  
05EF:  BSF    41.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0"; 
05F0:  CLRF   67
05F1:  CLRF   68
05F2:  MOVLW  36
05F3:  MOVWF  04
05F4:  BCF    03.7
05F5:  MOVF   67,W
05F6:  ADDWF  04,F
05F7:  MOVF   68,W
05F8:  CALL   05A
05F9:  MOVWF  00
05FA:  IORLW  00
05FB:  BTFSC  03.2
05FC:  GOTO   600
05FD:  INCF   68,F
05FE:  INCF   67,F
05FF:  GOTO   5F2
....................        cmdIndex = 0; 
0600:  CLRF   40
....................    } 
.................... } 
....................  
0601:  BCF    0C.5
0602:  BCF    0A.3
0603:  BCF    0A.4
0604:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
*
0800:  BSF    03.5
0801:  BTFSC  14.5
0802:  GOTO   00B
0803:  BCF    03.5
0804:  CLRF   60
0805:  BSF    03.5
0806:  BTFSS  14.2
0807:  GOTO   00B
0808:  BCF    03.5
0809:  BSF    60.7
080A:  BSF    03.5
080B:  BCF    03.5
080C:  MOVF   60,W
080D:  INCF   60,F
080E:  MOVWF  66
.................... { 
....................    int state = i2c_isr_state(); 
....................       if(state== 0 )  
080F:  MOVF   66,F
0810:  BTFSS  03.2
0811:  GOTO   017
....................          i2c_read(); 
0812:  BCF    14.6
0813:  BTFSS  0C.3
0814:  GOTO   013
0815:  MOVF   13,W
0816:  BSF    14.4
....................       if(state == 0x80) 
0817:  MOVF   66,W
0818:  SUBLW  80
0819:  BTFSC  03.2
081A:  GOTO   01B
....................          i2c_read(2); 
....................       if(state >= 0x80) 
081B:  MOVF   66,W
081C:  SUBLW  7F
081D:  BTFSC  03.0
081E:  GOTO   02D
....................          i2c_write(0xFF); 
081F:  MOVLW  FF
0820:  MOVWF  67
*
082C:  GOTO   29D
....................       else if(state > 0) 
082D:  MOVF   66,F
082E:  BTFSC  03.2
082F:  GOTO   29D
....................       { 
....................          ircmd[state - 1] = i2c_read(); 
0830:  MOVLW  01
0831:  SUBWF  66,W
0832:  ADDLW  43
0833:  MOVWF  04
0834:  BCF    03.7
0835:  BCF    14.6
0836:  BTFSS  0C.3
0837:  GOTO   036
0838:  MOVF   13,W
0839:  BSF    14.4
083A:  MOVWF  00
....................          if(DEBUG) {fprintf(RS232, "> Commando: %X - %X\r",state, ircmd[state - 1]);} 
083B:  BTFSS  07.2
083C:  GOTO   06E
083D:  MOVLW  01
083E:  SUBWF  66,W
083F:  ADDLW  43
0840:  MOVWF  04
0841:  BCF    03.7
0842:  MOVF   00,W
0843:  MOVWF  67
0844:  MOVLW  81
0845:  BSF    03.6
0846:  MOVWF  0D
0847:  MOVLW  06
0848:  MOVWF  0F
0849:  BCF    03.0
084A:  MOVLW  0C
084B:  BCF    03.6
084C:  MOVWF  68
084D:  BCF    0A.3
084E:  CALL   605
084F:  BSF    0A.3
0850:  MOVF   66,W
0851:  MOVWF  68
0852:  MOVLW  37
0853:  MOVWF  69
0854:  BCF    0A.3
0855:  CALL   65E
0856:  BSF    0A.3
0857:  MOVLW  20
0858:  BTFSS  0C.4
0859:  GOTO   058
085A:  MOVWF  19
085B:  MOVLW  2D
085C:  BTFSS  0C.4
085D:  GOTO   05C
085E:  MOVWF  19
085F:  MOVLW  20
0860:  BTFSS  0C.4
0861:  GOTO   060
0862:  MOVWF  19
0863:  MOVF   67,W
0864:  MOVWF  68
0865:  MOVLW  37
0866:  MOVWF  69
0867:  BCF    0A.3
0868:  CALL   65E
0869:  BSF    0A.3
086A:  MOVLW  0D
086B:  BTFSS  0C.4
086C:  GOTO   06B
086D:  MOVWF  19
....................          icmd = ircmd[state - 1]; 
086E:  MOVLW  01
086F:  SUBWF  66,W
0870:  ADDLW  43
0871:  MOVWF  04
0872:  BCF    03.7
0873:  MOVF   00,W
0874:  MOVWF  42
....................          parseI2CCommand(); 
....................       } 
*
0A9D:  BCF    0C.3
0A9E:  BCF    0A.3
0A9F:  BCF    0A.4
0AA0:  GOTO   033
.................... } 
....................  
.................... void parseI2CCommand(void) 
*
0875:  MOVF   42,W
0876:  MOVWF  67
.................... { 
....................    int c = icmd; 
....................    switch(c) 
0877:  MOVF   67,W
0878:  XORLW  0A
0879:  BTFSC  03.2
087A:  GOTO   0A3
087B:  XORLW  06
087C:  BTFSC  03.2
087D:  GOTO   0B7
087E:  XORLW  7C
087F:  BTFSC  03.2
0880:  GOTO   0CB
0881:  XORLW  01
0882:  BTFSC  03.2
0883:  GOTO   0E3
0884:  XORLW  03
0885:  BTFSC  03.2
0886:  GOTO   0FC
0887:  XORLW  01
0888:  BTFSC  03.2
0889:  GOTO   115
088A:  XORLW  07
088B:  BTFSC  03.2
088C:  GOTO   12E
088D:  XORLW  01
088E:  BTFSC  03.2
088F:  GOTO   147
0890:  XORLW  03
0891:  BTFSC  03.2
0892:  GOTO   160
0893:  XORLW  F7
0894:  BTFSC  03.2
0895:  GOTO   179
0896:  XORLW  03
0897:  BTFSC  03.2
0898:  GOTO   192
0899:  XORLW  01
089A:  BTFSC  03.2
089B:  GOTO   1AB
089C:  XORLW  7C
089D:  BTFSC  03.2
089E:  GOTO   1C4
089F:  XORLW  02
08A0:  BTFSC  03.2
08A1:  GOTO   1C8
08A2:  GOTO   1CB
....................    { 
....................       case I2C_TIMER:      if(DEBUG) {fputs("> Direccion TIMER",RS232);} 
08A3:  BTFSS  07.2
08A4:  GOTO   0B6
08A5:  MOVLW  8C
08A6:  BSF    03.6
08A7:  MOVWF  0D
08A8:  MOVLW  06
08A9:  MOVWF  0F
08AA:  BCF    0A.3
08AB:  BCF    03.6
08AC:  CALL   125
08AD:  BSF    0A.3
08AE:  MOVLW  0D
08AF:  BTFSS  0C.4
08B0:  GOTO   0AF
08B1:  MOVWF  19
08B2:  MOVLW  0A
08B3:  BTFSS  0C.4
08B4:  GOTO   0B3
08B5:  MOVWF  19
....................                            break; 
08B6:  GOTO   1CB
....................       case I2C_SCORE:      if(DEBUG) {fputs("> Direccion SCORE",RS232);} 
08B7:  BTFSS  07.2
08B8:  GOTO   0CA
08B9:  MOVLW  95
08BA:  BSF    03.6
08BB:  MOVWF  0D
08BC:  MOVLW  06
08BD:  MOVWF  0F
08BE:  BCF    0A.3
08BF:  BCF    03.6
08C0:  CALL   125
08C1:  BSF    0A.3
08C2:  MOVLW  0D
08C3:  BTFSS  0C.4
08C4:  GOTO   0C3
08C5:  MOVWF  19
08C6:  MOVLW  0A
08C7:  BTFSS  0C.4
08C8:  GOTO   0C7
08C9:  MOVWF  19
....................                            break; 
08CA:  GOTO   1CB
....................       case I2C_CMD_PER0:   if(DEBUG) {fputs("> Apagar Periodos",RS232);} 
08CB:  BTFSS  07.2
08CC:  GOTO   0DE
08CD:  MOVLW  9E
08CE:  BSF    03.6
08CF:  MOVWF  0D
08D0:  MOVLW  06
08D1:  MOVWF  0F
08D2:  BCF    0A.3
08D3:  BCF    03.6
08D4:  CALL   125
08D5:  BSF    0A.3
08D6:  MOVLW  0D
08D7:  BTFSS  0C.4
08D8:  GOTO   0D7
08D9:  MOVWF  19
08DA:  MOVLW  0A
08DB:  BTFSS  0C.4
08DC:  GOTO   0DB
08DD:  MOVWF  19
....................                            showQuarter(0); 
08DE:  CLRF   72
08DF:  BCF    0A.3
08E0:  CALL   260
08E1:  BSF    0A.3
....................                            break; 
08E2:  GOTO   1CB
....................       case I2C_CMD_PER1:   if(DEBUG) {fputs("> Activar Periodo 1",RS232);} 
08E3:  BTFSS  07.2
08E4:  GOTO   0F6
08E5:  MOVLW  A7
08E6:  BSF    03.6
08E7:  MOVWF  0D
08E8:  MOVLW  06
08E9:  MOVWF  0F
08EA:  BCF    0A.3
08EB:  BCF    03.6
08EC:  CALL   125
08ED:  BSF    0A.3
08EE:  MOVLW  0D
08EF:  BTFSS  0C.4
08F0:  GOTO   0EF
08F1:  MOVWF  19
08F2:  MOVLW  0A
08F3:  BTFSS  0C.4
08F4:  GOTO   0F3
08F5:  MOVWF  19
....................                            showQuarter(1); 
08F6:  MOVLW  01
08F7:  MOVWF  72
08F8:  BCF    0A.3
08F9:  CALL   260
08FA:  BSF    0A.3
....................                            break; 
08FB:  GOTO   1CB
....................       case I2C_CMD_PER2:   if(DEBUG) {fputs("> Activar Periodo 2",RS232);} 
08FC:  BTFSS  07.2
08FD:  GOTO   10F
08FE:  MOVLW  B1
08FF:  BSF    03.6
0900:  MOVWF  0D
0901:  MOVLW  06
0902:  MOVWF  0F
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   125
0906:  BSF    0A.3
0907:  MOVLW  0D
0908:  BTFSS  0C.4
0909:  GOTO   108
090A:  MOVWF  19
090B:  MOVLW  0A
090C:  BTFSS  0C.4
090D:  GOTO   10C
090E:  MOVWF  19
....................                            showQuarter(2); 
090F:  MOVLW  02
0910:  MOVWF  72
0911:  BCF    0A.3
0912:  CALL   260
0913:  BSF    0A.3
....................                            break; 
0914:  GOTO   1CB
....................       case I2C_CMD_PER3:   if(DEBUG) {fputs("> Activar Periodo 3",RS232);} 
0915:  BTFSS  07.2
0916:  GOTO   128
0917:  MOVLW  BB
0918:  BSF    03.6
0919:  MOVWF  0D
091A:  MOVLW  06
091B:  MOVWF  0F
091C:  BCF    0A.3
091D:  BCF    03.6
091E:  CALL   125
091F:  BSF    0A.3
0920:  MOVLW  0D
0921:  BTFSS  0C.4
0922:  GOTO   121
0923:  MOVWF  19
0924:  MOVLW  0A
0925:  BTFSS  0C.4
0926:  GOTO   125
0927:  MOVWF  19
....................                            showQuarter(3); 
0928:  MOVLW  03
0929:  MOVWF  72
092A:  BCF    0A.3
092B:  CALL   260
092C:  BSF    0A.3
....................                            break; 
092D:  GOTO   1CB
....................       case I2C_CMD_PER4:   if(DEBUG) {fputs("> Activar Periodo 4",RS232);} 
092E:  BTFSS  07.2
092F:  GOTO   141
0930:  MOVLW  C5
0931:  BSF    03.6
0932:  MOVWF  0D
0933:  MOVLW  06
0934:  MOVWF  0F
0935:  BCF    0A.3
0936:  BCF    03.6
0937:  CALL   125
0938:  BSF    0A.3
0939:  MOVLW  0D
093A:  BTFSS  0C.4
093B:  GOTO   13A
093C:  MOVWF  19
093D:  MOVLW  0A
093E:  BTFSS  0C.4
093F:  GOTO   13E
0940:  MOVWF  19
....................                            showQuarter(4); 
0941:  MOVLW  04
0942:  MOVWF  72
0943:  BCF    0A.3
0944:  CALL   260
0945:  BSF    0A.3
....................                            break; 
0946:  GOTO   1CB
....................       case I2C_CMD_MDON:   if(DEBUG) {fputs("> Activar Minuto Decena",RS232);} 
0947:  BTFSS  07.2
0948:  GOTO   15A
0949:  MOVLW  CF
094A:  BSF    03.6
094B:  MOVWF  0D
094C:  MOVLW  06
094D:  MOVWF  0F
094E:  BCF    0A.3
094F:  BCF    03.6
0950:  CALL   125
0951:  BSF    0A.3
0952:  MOVLW  0D
0953:  BTFSS  0C.4
0954:  GOTO   153
0955:  MOVWF  19
0956:  MOVLW  0A
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
....................                            output_bit(MINUTOD, ON); 
095A:  BSF    05.0
095B:  MOVLW  00
095C:  BSF    03.5
095D:  MOVWF  05
....................                            break; 
095E:  BCF    03.5
095F:  GOTO   1CB
....................       case I2C_CMD_MDOF:   if(DEBUG) {fputs("> Desactivar Minuto Decena",RS232);} 
0960:  BTFSS  07.2
0961:  GOTO   173
0962:  MOVLW  DB
0963:  BSF    03.6
0964:  MOVWF  0D
0965:  MOVLW  06
0966:  MOVWF  0F
0967:  BCF    0A.3
0968:  BCF    03.6
0969:  CALL   125
096A:  BSF    0A.3
096B:  MOVLW  0D
096C:  BTFSS  0C.4
096D:  GOTO   16C
096E:  MOVWF  19
096F:  MOVLW  0A
0970:  BTFSS  0C.4
0971:  GOTO   170
0972:  MOVWF  19
....................                            output_bit(MINUTOD, OFF); 
0973:  BCF    05.0
0974:  MOVLW  00
0975:  BSF    03.5
0976:  MOVWF  05
....................                            break; 
0977:  BCF    03.5
0978:  GOTO   1CB
....................       case I2C_CMD_BUZ1:   if(DEBUG) {fputs("> Toque Corto",RS232);} 
0979:  BTFSS  07.2
097A:  GOTO   18C
097B:  MOVLW  E9
097C:  BSF    03.6
097D:  MOVWF  0D
097E:  MOVLW  06
097F:  MOVWF  0F
0980:  BCF    0A.3
0981:  BCF    03.6
0982:  CALL   125
0983:  BSF    0A.3
0984:  MOVLW  0D
0985:  BTFSS  0C.4
0986:  GOTO   185
0987:  MOVWF  19
0988:  MOVLW  0A
0989:  BTFSS  0C.4
098A:  GOTO   189
098B:  MOVWF  19
....................                            buzz(1); 
098C:  MOVLW  01
098D:  MOVWF  72
098E:  BCF    0A.3
098F:  CALL   2AE
0990:  BSF    0A.3
....................                            break; 
0991:  GOTO   1CB
....................       case I2C_CMD_BUZ2:   if(DEBUG) {fputs("> Toque Largo",RS232);} 
0992:  BTFSS  07.2
0993:  GOTO   1A5
0994:  MOVLW  F0
0995:  BSF    03.6
0996:  MOVWF  0D
0997:  MOVLW  06
0998:  MOVWF  0F
0999:  BCF    0A.3
099A:  BCF    03.6
099B:  CALL   125
099C:  BSF    0A.3
099D:  MOVLW  0D
099E:  BTFSS  0C.4
099F:  GOTO   19E
09A0:  MOVWF  19
09A1:  MOVLW  0A
09A2:  BTFSS  0C.4
09A3:  GOTO   1A2
09A4:  MOVWF  19
....................                            buzz(2); 
09A5:  MOVLW  02
09A6:  MOVWF  72
09A7:  BCF    0A.3
09A8:  CALL   2AE
09A9:  BSF    0A.3
....................                            break; 
09AA:  GOTO   1CB
....................       case I2C_CMD_BUZ3:   if(DEBUG) {fputs("> Toque Doble",RS232);} 
09AB:  BTFSS  07.2
09AC:  GOTO   1BE
09AD:  MOVLW  F7
09AE:  BSF    03.6
09AF:  MOVWF  0D
09B0:  MOVLW  06
09B1:  MOVWF  0F
09B2:  BCF    0A.3
09B3:  BCF    03.6
09B4:  CALL   125
09B5:  BSF    0A.3
09B6:  MOVLW  0D
09B7:  BTFSS  0C.4
09B8:  GOTO   1B7
09B9:  MOVWF  19
09BA:  MOVLW  0A
09BB:  BTFSS  0C.4
09BC:  GOTO   1BB
09BD:  MOVWF  19
....................                            buzz(3); 
09BE:  MOVLW  03
09BF:  MOVWF  72
09C0:  BCF    0A.3
09C1:  CALL   2AE
09C2:  BSF    0A.3
....................                            break; 
09C3:  GOTO   1CB
....................       case I2C_CMD_TEST:   doTest(); 
09C4:  BCF    0A.3
09C5:  CALL   30F
09C6:  BSF    0A.3
....................                            break; 
09C7:  GOTO   1CB
....................       case I2C_CMD_RESET:  doReset(); 
09C8:  BCF    0A.3
09C9:  CALL   389
09CA:  BSF    0A.3
....................                            break; 
....................    } 
....................     
....................    if(c > 0x0F && c < 0x1A) //0x10 - 0x19 
09CB:  MOVF   67,W
09CC:  SUBLW  0F
09CD:  BTFSC  03.0
09CE:  GOTO   1F5
09CF:  MOVF   67,W
09D0:  SUBLW  19
09D1:  BTFSS  03.0
09D2:  GOTO   1F5
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 1",RS232);} 
09D3:  BTFSS  07.2
09D4:  GOTO   1E6
09D5:  MOVLW  FE
09D6:  BSF    03.6
09D7:  MOVWF  0D
09D8:  MOVLW  06
09D9:  MOVWF  0F
09DA:  BCF    0A.3
09DB:  BCF    03.6
09DC:  CALL   125
09DD:  BSF    0A.3
09DE:  MOVLW  0D
09DF:  BTFSS  0C.4
09E0:  GOTO   1DF
09E1:  MOVWF  19
09E2:  MOVLW  0A
09E3:  BTFSS  0C.4
09E4:  GOTO   1E3
09E5:  MOVWF  19
....................       showNumber(c - 0x10, pTiroSU);    
09E6:  MOVLW  10
09E7:  SUBWF  67,W
09E8:  MOVWF  68
09E9:  MOVWF  72
09EA:  MOVF   4B,W
09EB:  MOVWF  76
09EC:  MOVF   4A,W
09ED:  MOVWF  75
09EE:  MOVF   49,W
09EF:  MOVWF  74
09F0:  MOVF   48,W
09F1:  MOVWF  73
09F2:  BCF    0A.3
09F3:  CALL   1D8
09F4:  BSF    0A.3
....................    } 
....................    if(c > 0x1F && c < 0x2A) //0x20 - 0x29 
09F5:  MOVF   67,W
09F6:  SUBLW  1F
09F7:  BTFSC  03.0
09F8:  GOTO   21F
09F9:  MOVF   67,W
09FA:  SUBLW  29
09FB:  BTFSS  03.0
09FC:  GOTO   21F
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 2",RS232);} 
09FD:  BTFSS  07.2
09FE:  GOTO   210
09FF:  MOVLW  09
0A00:  BSF    03.6
0A01:  MOVWF  0D
0A02:  MOVLW  07
0A03:  MOVWF  0F
0A04:  BCF    0A.3
0A05:  BCF    03.6
0A06:  CALL   125
0A07:  BSF    0A.3
0A08:  MOVLW  0D
0A09:  BTFSS  0C.4
0A0A:  GOTO   209
0A0B:  MOVWF  19
0A0C:  MOVLW  0A
0A0D:  BTFSS  0C.4
0A0E:  GOTO   20D
0A0F:  MOVWF  19
....................       showNumber(c - 0x20, pTiroSD);    
0A10:  MOVLW  20
0A11:  SUBWF  67,W
0A12:  MOVWF  68
0A13:  MOVWF  72
0A14:  MOVF   4F,W
0A15:  MOVWF  76
0A16:  MOVF   4E,W
0A17:  MOVWF  75
0A18:  MOVF   4D,W
0A19:  MOVWF  74
0A1A:  MOVF   4C,W
0A1B:  MOVWF  73
0A1C:  BCF    0A.3
0A1D:  CALL   1D8
0A1E:  BSF    0A.3
....................    } 
....................    if(c > 0x2F && c < 0x3A) //0x30 - 0x39 
0A1F:  MOVF   67,W
0A20:  SUBLW  2F
0A21:  BTFSC  03.0
0A22:  GOTO   249
0A23:  MOVF   67,W
0A24:  SUBLW  39
0A25:  BTFSS  03.0
0A26:  GOTO   249
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 3",RS232);} 
0A27:  BTFSS  07.2
0A28:  GOTO   23A
0A29:  MOVLW  14
0A2A:  BSF    03.6
0A2B:  MOVWF  0D
0A2C:  MOVLW  07
0A2D:  MOVWF  0F
0A2E:  BCF    0A.3
0A2F:  BCF    03.6
0A30:  CALL   125
0A31:  BSF    0A.3
0A32:  MOVLW  0D
0A33:  BTFSS  0C.4
0A34:  GOTO   233
0A35:  MOVWF  19
0A36:  MOVLW  0A
0A37:  BTFSS  0C.4
0A38:  GOTO   237
0A39:  MOVWF  19
....................       showNumber(c - 0x30, pTiempoSD);    
0A3A:  MOVLW  30
0A3B:  SUBWF  67,W
0A3C:  MOVWF  68
0A3D:  MOVWF  72
0A3E:  MOVF   57,W
0A3F:  MOVWF  76
0A40:  MOVF   56,W
0A41:  MOVWF  75
0A42:  MOVF   55,W
0A43:  MOVWF  74
0A44:  MOVF   54,W
0A45:  MOVWF  73
0A46:  BCF    0A.3
0A47:  CALL   1D8
0A48:  BSF    0A.3
....................    } 
....................    if(c > 0x3F && c < 0x4A) //0x40 - 0x49 
0A49:  MOVF   67,W
0A4A:  SUBLW  3F
0A4B:  BTFSC  03.0
0A4C:  GOTO   273
0A4D:  MOVF   67,W
0A4E:  SUBLW  49
0A4F:  BTFSS  03.0
0A50:  GOTO   273
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 4",RS232);} 
0A51:  BTFSS  07.2
0A52:  GOTO   264
0A53:  MOVLW  1F
0A54:  BSF    03.6
0A55:  MOVWF  0D
0A56:  MOVLW  07
0A57:  MOVWF  0F
0A58:  BCF    0A.3
0A59:  BCF    03.6
0A5A:  CALL   125
0A5B:  BSF    0A.3
0A5C:  MOVLW  0D
0A5D:  BTFSS  0C.4
0A5E:  GOTO   25D
0A5F:  MOVWF  19
0A60:  MOVLW  0A
0A61:  BTFSS  0C.4
0A62:  GOTO   261
0A63:  MOVWF  19
....................       showNumber(c - 0x40, pTiempoSU);    
0A64:  MOVLW  40
0A65:  SUBWF  67,W
0A66:  MOVWF  68
0A67:  MOVWF  72
0A68:  MOVF   53,W
0A69:  MOVWF  76
0A6A:  MOVF   52,W
0A6B:  MOVWF  75
0A6C:  MOVF   51,W
0A6D:  MOVWF  74
0A6E:  MOVF   50,W
0A6F:  MOVWF  73
0A70:  BCF    0A.3
0A71:  CALL   1D8
0A72:  BSF    0A.3
....................    } 
....................       if(c > 0x4F && c < 0x5A) //0x50 - 0x59 
0A73:  MOVF   67,W
0A74:  SUBLW  4F
0A75:  BTFSC  03.0
0A76:  GOTO   29D
0A77:  MOVF   67,W
0A78:  SUBLW  59
0A79:  BTFSS  03.0
0A7A:  GOTO   29D
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 5",RS232);} 
0A7B:  BTFSS  07.2
0A7C:  GOTO   28E
0A7D:  MOVLW  2A
0A7E:  BSF    03.6
0A7F:  MOVWF  0D
0A80:  MOVLW  07
0A81:  MOVWF  0F
0A82:  BCF    0A.3
0A83:  BCF    03.6
0A84:  CALL   125
0A85:  BSF    0A.3
0A86:  MOVLW  0D
0A87:  BTFSS  0C.4
0A88:  GOTO   287
0A89:  MOVWF  19
0A8A:  MOVLW  0A
0A8B:  BTFSS  0C.4
0A8C:  GOTO   28B
0A8D:  MOVWF  19
....................       showNumber(c - 0x50, pTiempoMU);    
0A8E:  MOVLW  50
0A8F:  SUBWF  67,W
0A90:  MOVWF  68
0A91:  MOVWF  72
0A92:  MOVF   5B,W
0A93:  MOVWF  76
0A94:  MOVF   5A,W
0A95:  MOVWF  75
0A96:  MOVF   59,W
0A97:  MOVWF  74
0A98:  MOVF   58,W
0A99:  MOVWF  73
0A9A:  BCF    0A.3
0A9B:  CALL   1D8
0A9C:  BSF    0A.3
....................    } 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
030F:  BTFSS  07.2
0310:  GOTO   320
0311:  MOVLW  35
0312:  BSF    03.6
0313:  MOVWF  0D
0314:  MOVLW  07
0315:  MOVWF  0F
0316:  BCF    03.6
0317:  CALL   125
0318:  MOVLW  0D
0319:  BTFSS  0C.4
031A:  GOTO   319
031B:  MOVWF  19
031C:  MOVLW  0A
031D:  BTFSS  0C.4
031E:  GOTO   31D
031F:  MOVWF  19
....................    output_bit(MINUTOD, OFF); 
0320:  BCF    05.0
0321:  MOVLW  00
0322:  BSF    03.5
0323:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0324:  BCF    03.5
0325:  BCF    09.1
0326:  MOVLW  E0
0327:  BSF    03.5
0328:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0329:  BCF    03.5
032A:  BCF    09.2
032B:  MOVLW  E0
032C:  BSF    03.5
032D:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
032E:  BCF    03.5
032F:  BCF    07.0
0330:  MOVLW  DC
0331:  BSF    03.5
0332:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0333:  BCF    03.5
0334:  BCF    07.1
0335:  MOVLW  DC
0336:  BSF    03.5
0337:  MOVWF  07
....................    for(int i=0; i<10; i++) 
0338:  CLRF   71
0339:  MOVF   71,W
033A:  SUBLW  09
033B:  BTFSS  03.0
033C:  GOTO   384
....................    { 
....................       showNumber(i, pTiroSD); 
033D:  MOVF   71,W
033E:  MOVWF  72
033F:  BCF    03.5
0340:  MOVF   4F,W
0341:  MOVWF  76
0342:  MOVF   4E,W
0343:  MOVWF  75
0344:  MOVF   4D,W
0345:  MOVWF  74
0346:  MOVF   4C,W
0347:  MOVWF  73
0348:  CALL   1D8
....................       showNumber(i, pTiroSU); 
0349:  MOVF   71,W
034A:  MOVWF  72
034B:  MOVF   4B,W
034C:  MOVWF  76
034D:  MOVF   4A,W
034E:  MOVWF  75
034F:  MOVF   49,W
0350:  MOVWF  74
0351:  MOVF   48,W
0352:  MOVWF  73
0353:  CALL   1D8
....................       showNumber(i, pTiempoSD); 
0354:  MOVF   71,W
0355:  MOVWF  72
0356:  MOVF   57,W
0357:  MOVWF  76
0358:  MOVF   56,W
0359:  MOVWF  75
035A:  MOVF   55,W
035B:  MOVWF  74
035C:  MOVF   54,W
035D:  MOVWF  73
035E:  CALL   1D8
....................       showNumber(i, pTiempoSU); 
035F:  MOVF   71,W
0360:  MOVWF  72
0361:  MOVF   53,W
0362:  MOVWF  76
0363:  MOVF   52,W
0364:  MOVWF  75
0365:  MOVF   51,W
0366:  MOVWF  74
0367:  MOVF   50,W
0368:  MOVWF  73
0369:  CALL   1D8
....................       showNumber(i, pTiempoMU); 
036A:  MOVF   71,W
036B:  MOVWF  72
036C:  MOVF   5B,W
036D:  MOVWF  76
036E:  MOVF   5A,W
036F:  MOVWF  75
0370:  MOVF   59,W
0371:  MOVWF  74
0372:  MOVF   58,W
0373:  MOVWF  73
0374:  CALL   1D8
....................       output_toggle(MINUTOD); 
0375:  MOVLW  00
0376:  BSF    03.5
0377:  MOVWF  05
0378:  MOVLW  01
0379:  BCF    03.5
037A:  XORWF  05,F
....................       showQuarter(i); 
037B:  MOVF   71,W
037C:  MOVWF  72
037D:  CALL   260
....................       delay_ms(DEFAULT_D); 
037E:  MOVLW  C8
037F:  MOVWF  74
0380:  CALL   29A
0381:  INCF   71,F
0382:  BSF    03.5
0383:  GOTO   339
....................    } 
....................    buzz(1); 
0384:  MOVLW  01
0385:  MOVWF  72
0386:  BCF    03.5
0387:  CALL   2AE
0388:  RETURN
.................... } 
....................  
.................... void buzz(int t) 
.................... { 
....................    switch(t) 
*
02AE:  MOVF   72,W
02AF:  XORLW  01
02B0:  BTFSC  03.2
02B1:  GOTO   2B9
02B2:  XORLW  03
02B3:  BTFSC  03.2
02B4:  GOTO   2CE
02B5:  XORLW  01
02B6:  BTFSC  03.2
02B7:  GOTO   2E3
02B8:  GOTO   30E
....................    { 
....................       case 1:  //TOOT 
....................                output_bit(BUZZER, ON); 
02B9:  BSF    05.1
02BA:  MOVLW  00
02BB:  BSF    03.5
02BC:  MOVWF  05
....................                delay_ms(1000); 
02BD:  MOVLW  04
02BE:  MOVWF  73
02BF:  MOVLW  FA
02C0:  MOVWF  74
02C1:  BCF    03.5
02C2:  CALL   29A
02C3:  DECFSZ 73,F
02C4:  GOTO   2C6
02C5:  GOTO   2C8
02C6:  BSF    03.5
02C7:  GOTO   2BF
....................                output_bit(BUZZER, OFF); 
02C8:  BCF    05.1
02C9:  MOVLW  00
02CA:  BSF    03.5
02CB:  MOVWF  05
....................                break; 
02CC:  BCF    03.5
02CD:  GOTO   30E
....................       case 2:  //LONG BUZZ 
....................                output_bit(BUZZER, ON); 
02CE:  BSF    05.1
02CF:  MOVLW  00
02D0:  BSF    03.5
02D1:  MOVWF  05
....................                delay_ms(3000); 
02D2:  MOVLW  0C
02D3:  MOVWF  73
02D4:  MOVLW  FA
02D5:  MOVWF  74
02D6:  BCF    03.5
02D7:  CALL   29A
02D8:  DECFSZ 73,F
02D9:  GOTO   2DB
02DA:  GOTO   2DD
02DB:  BSF    03.5
02DC:  GOTO   2D4
....................                output_bit(BUZZER, OFF); 
02DD:  BCF    05.1
02DE:  MOVLW  00
02DF:  BSF    03.5
02E0:  MOVWF  05
....................                break; 
02E1:  BCF    03.5
02E2:  GOTO   30E
....................       case 3:  //DOUBLE 
....................                output_bit(BUZZER, ON); 
02E3:  BSF    05.1
02E4:  MOVLW  00
02E5:  BSF    03.5
02E6:  MOVWF  05
....................                delay_ms(1000); 
02E7:  MOVLW  04
02E8:  MOVWF  73
02E9:  MOVLW  FA
02EA:  MOVWF  74
02EB:  BCF    03.5
02EC:  CALL   29A
02ED:  DECFSZ 73,F
02EE:  GOTO   2F0
02EF:  GOTO   2F2
02F0:  BSF    03.5
02F1:  GOTO   2E9
....................                output_bit(BUZZER, OFF); 
02F2:  BCF    05.1
02F3:  MOVLW  00
02F4:  BSF    03.5
02F5:  MOVWF  05
....................                delay_ms(250); 
02F6:  MOVLW  FA
02F7:  MOVWF  74
02F8:  BCF    03.5
02F9:  CALL   29A
....................                output_bit(BUZZER, ON); 
02FA:  BSF    05.1
02FB:  MOVLW  00
02FC:  BSF    03.5
02FD:  MOVWF  05
....................                delay_ms(1000); 
02FE:  MOVLW  04
02FF:  MOVWF  73
0300:  MOVLW  FA
0301:  MOVWF  74
0302:  BCF    03.5
0303:  CALL   29A
0304:  DECFSZ 73,F
0305:  GOTO   307
0306:  GOTO   309
0307:  BSF    03.5
0308:  GOTO   300
....................                output_bit(BUZZER, OFF); 
0309:  BCF    05.1
030A:  MOVLW  00
030B:  BSF    03.5
030C:  MOVWF  05
....................                break; 
030D:  BCF    03.5
....................    } 
030E:  RETURN
.................... } 
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
039D:  CLRF   74
039E:  MOVLW  2C
039F:  MOVWF  73
03A0:  CLRF   72
03A1:  MOVLW  67
03A2:  MOVWF  71
03A3:  MOVF   73,W
03A4:  MOVWF  04
03A5:  BCF    03.7
03A6:  BTFSC  74.0
03A7:  BSF    03.7
03A8:  MOVF   00,W
03A9:  MOVWF  75
03AA:  MOVF   71,W
03AB:  MOVWF  04
03AC:  BCF    03.7
03AD:  BTFSC  72.0
03AE:  BSF    03.7
03AF:  MOVF   75,W
03B0:  MOVWF  00
03B1:  MOVF   00,F
03B2:  BTFSC  03.2
03B3:  GOTO   3B7
03B4:  INCF   71,F
03B5:  INCF   73,F
03B6:  GOTO   3A3
....................    switch(c[0]) 
03B7:  MOVF   67,W
03B8:  XORLW  30
03B9:  BTFSC  03.2
03BA:  GOTO   3E0
03BB:  XORLW  71
03BC:  BTFSC  03.2
03BD:  GOTO   448
03BE:  XORLW  03
03BF:  BTFSC  03.2
03C0:  GOTO   45C
03C1:  XORLW  01
03C2:  BTFSC  03.2
03C3:  GOTO   471
03C4:  XORLW  07
03C5:  BTFSC  03.2
03C6:  GOTO   486
03C7:  XORLW  01
03C8:  BTFSC  03.2
03C9:  GOTO   49B
03CA:  XORLW  03
03CB:  BTFSC  03.2
03CC:  GOTO   4B0
03CD:  XORLW  01
03CE:  BTFSC  03.2
03CF:  GOTO   4C7
03D0:  XORLW  0F
03D1:  BTFSC  03.2
03D2:  GOTO   4DE
03D3:  XORLW  01
03D4:  BTFSC  03.2
03D5:  GOTO   4F3
03D6:  XORLW  03
03D7:  BTFSC  03.2
03D8:  GOTO   508
03D9:  XORLW  12
03DA:  BTFSC  03.2
03DB:  GOTO   51D
03DC:  XORLW  02
03DD:  BTFSC  03.2
03DE:  GOTO   51F
03DF:  GOTO   5A9
....................    { 
....................       case '0':   if(DEBUG) {fputs("\r> Activacion manual de puerto",RS232);} 
03E0:  BTFSS  07.2
03E1:  GOTO   3F1
03E2:  MOVLW  3F
03E3:  BSF    03.6
03E4:  MOVWF  0D
03E5:  MOVLW  07
03E6:  MOVWF  0F
03E7:  BCF    03.6
03E8:  CALL   125
03E9:  MOVLW  0D
03EA:  BTFSS  0C.4
03EB:  GOTO   3EA
03EC:  MOVWF  19
03ED:  MOVLW  0A
03EE:  BTFSS  0C.4
03EF:  GOTO   3EE
03F0:  MOVWF  19
....................                   switch(c[2]) 
03F1:  MOVLW  31
03F2:  SUBWF  69,W
03F3:  ADDLW  FB
03F4:  BTFSC  03.0
03F5:  GOTO   447
03F6:  ADDLW  05
03F7:  GOTO   5AC
....................                   { 
....................                      case '1':   showNumber(char2int(c[3]), pTiroSU); 
03F8:  MOVF   6A,W
03F9:  MOVWF  71
03FA:  CALL   177
03FB:  MOVF   78,W
03FC:  MOVWF  71
03FD:  MOVWF  72
03FE:  MOVF   4B,W
03FF:  MOVWF  76
0400:  MOVF   4A,W
0401:  MOVWF  75
0402:  MOVF   49,W
0403:  MOVWF  74
0404:  MOVF   48,W
0405:  MOVWF  73
0406:  CALL   1D8
....................                                  break; 
0407:  GOTO   447
....................                      case '2':   showNumber(char2int(c[3]), pTiroSD); 
0408:  MOVF   6A,W
0409:  MOVWF  71
040A:  CALL   177
040B:  MOVF   78,W
040C:  MOVWF  71
040D:  MOVWF  72
040E:  MOVF   4F,W
040F:  MOVWF  76
0410:  MOVF   4E,W
0411:  MOVWF  75
0412:  MOVF   4D,W
0413:  MOVWF  74
0414:  MOVF   4C,W
0415:  MOVWF  73
0416:  CALL   1D8
....................                                  break; 
0417:  GOTO   447
....................                      case '3':   showNumber(char2int(c[3]), pTiempoSD); 
0418:  MOVF   6A,W
0419:  MOVWF  71
041A:  CALL   177
041B:  MOVF   78,W
041C:  MOVWF  71
041D:  MOVWF  72
041E:  MOVF   57,W
041F:  MOVWF  76
0420:  MOVF   56,W
0421:  MOVWF  75
0422:  MOVF   55,W
0423:  MOVWF  74
0424:  MOVF   54,W
0425:  MOVWF  73
0426:  CALL   1D8
....................                                  break; 
0427:  GOTO   447
....................                      case '4':   showNumber(char2int(c[3]), pTiempoSU); 
0428:  MOVF   6A,W
0429:  MOVWF  71
042A:  CALL   177
042B:  MOVF   78,W
042C:  MOVWF  71
042D:  MOVWF  72
042E:  MOVF   53,W
042F:  MOVWF  76
0430:  MOVF   52,W
0431:  MOVWF  75
0432:  MOVF   51,W
0433:  MOVWF  74
0434:  MOVF   50,W
0435:  MOVWF  73
0436:  CALL   1D8
....................                                  break; 
0437:  GOTO   447
....................                      case '5':   showNumber(char2int(c[3]), pTiempoMU); 
0438:  MOVF   6A,W
0439:  MOVWF  71
043A:  CALL   177
043B:  MOVF   78,W
043C:  MOVWF  71
043D:  MOVWF  72
043E:  MOVF   5B,W
043F:  MOVWF  76
0440:  MOVF   5A,W
0441:  MOVWF  75
0442:  MOVF   59,W
0443:  MOVWF  74
0444:  MOVF   58,W
0445:  MOVWF  73
0446:  CALL   1D8
....................                                  break; 
....................                   } 
....................                   break; 
0447:  GOTO   5A9
....................       case 'A':   if(DEBUG) {fputs("> Apagar Periodos",RS232);} 
0448:  BTFSS  07.2
0449:  GOTO   459
044A:  MOVLW  4F
044B:  BSF    03.6
044C:  MOVWF  0D
044D:  MOVLW  07
044E:  MOVWF  0F
044F:  BCF    03.6
0450:  CALL   125
0451:  MOVLW  0D
0452:  BTFSS  0C.4
0453:  GOTO   452
0454:  MOVWF  19
0455:  MOVLW  0A
0456:  BTFSS  0C.4
0457:  GOTO   456
0458:  MOVWF  19
....................                            showQuarter(0); 
0459:  CLRF   72
045A:  CALL   260
....................                            break; 
045B:  GOTO   5A9
....................       case 'B':   if(DEBUG) {fputs("> Activar Periodo 1",RS232);} 
045C:  BTFSS  07.2
045D:  GOTO   46D
045E:  MOVLW  58
045F:  BSF    03.6
0460:  MOVWF  0D
0461:  MOVLW  07
0462:  MOVWF  0F
0463:  BCF    03.6
0464:  CALL   125
0465:  MOVLW  0D
0466:  BTFSS  0C.4
0467:  GOTO   466
0468:  MOVWF  19
0469:  MOVLW  0A
046A:  BTFSS  0C.4
046B:  GOTO   46A
046C:  MOVWF  19
....................                            showQuarter(1); 
046D:  MOVLW  01
046E:  MOVWF  72
046F:  CALL   260
....................                            break; 
0470:  GOTO   5A9
....................       case 'C':   if(DEBUG) {fputs("> Activar Periodo 2",RS232);} 
0471:  BTFSS  07.2
0472:  GOTO   482
0473:  MOVLW  62
0474:  BSF    03.6
0475:  MOVWF  0D
0476:  MOVLW  07
0477:  MOVWF  0F
0478:  BCF    03.6
0479:  CALL   125
047A:  MOVLW  0D
047B:  BTFSS  0C.4
047C:  GOTO   47B
047D:  MOVWF  19
047E:  MOVLW  0A
047F:  BTFSS  0C.4
0480:  GOTO   47F
0481:  MOVWF  19
....................                            showQuarter(2); 
0482:  MOVLW  02
0483:  MOVWF  72
0484:  CALL   260
....................                            break; 
0485:  GOTO   5A9
....................       case 'D':   if(DEBUG) {fputs("> Activar Periodo 3",RS232);} 
0486:  BTFSS  07.2
0487:  GOTO   497
0488:  MOVLW  6C
0489:  BSF    03.6
048A:  MOVWF  0D
048B:  MOVLW  07
048C:  MOVWF  0F
048D:  BCF    03.6
048E:  CALL   125
048F:  MOVLW  0D
0490:  BTFSS  0C.4
0491:  GOTO   490
0492:  MOVWF  19
0493:  MOVLW  0A
0494:  BTFSS  0C.4
0495:  GOTO   494
0496:  MOVWF  19
....................                            showQuarter(3); 
0497:  MOVLW  03
0498:  MOVWF  72
0499:  CALL   260
....................                            break; 
049A:  GOTO   5A9
....................       case 'E':   if(DEBUG) {fputs("> Activar Periodo 4",RS232);} 
049B:  BTFSS  07.2
049C:  GOTO   4AC
049D:  MOVLW  76
049E:  BSF    03.6
049F:  MOVWF  0D
04A0:  MOVLW  07
04A1:  MOVWF  0F
04A2:  BCF    03.6
04A3:  CALL   125
04A4:  MOVLW  0D
04A5:  BTFSS  0C.4
04A6:  GOTO   4A5
04A7:  MOVWF  19
04A8:  MOVLW  0A
04A9:  BTFSS  0C.4
04AA:  GOTO   4A9
04AB:  MOVWF  19
....................                            showQuarter(4); 
04AC:  MOVLW  04
04AD:  MOVWF  72
04AE:  CALL   260
....................                            break; 
04AF:  GOTO   5A9
....................       case 'F':   if(DEBUG) {fputs("> Activar Minuto Decena",RS232);} 
04B0:  BTFSS  07.2
04B1:  GOTO   4C1
04B2:  MOVLW  80
04B3:  BSF    03.6
04B4:  MOVWF  0D
04B5:  MOVLW  07
04B6:  MOVWF  0F
04B7:  BCF    03.6
04B8:  CALL   125
04B9:  MOVLW  0D
04BA:  BTFSS  0C.4
04BB:  GOTO   4BA
04BC:  MOVWF  19
04BD:  MOVLW  0A
04BE:  BTFSS  0C.4
04BF:  GOTO   4BE
04C0:  MOVWF  19
....................                            output_bit(MINUTOD, ON); 
04C1:  BSF    05.0
04C2:  MOVLW  00
04C3:  BSF    03.5
04C4:  MOVWF  05
....................                            break; 
04C5:  BCF    03.5
04C6:  GOTO   5A9
....................       case 'G':   if(DEBUG) {fputs("> Desactivar Minuto Decena",RS232);} 
04C7:  BTFSS  07.2
04C8:  GOTO   4D8
04C9:  MOVLW  8C
04CA:  BSF    03.6
04CB:  MOVWF  0D
04CC:  MOVLW  07
04CD:  MOVWF  0F
04CE:  BCF    03.6
04CF:  CALL   125
04D0:  MOVLW  0D
04D1:  BTFSS  0C.4
04D2:  GOTO   4D1
04D3:  MOVWF  19
04D4:  MOVLW  0A
04D5:  BTFSS  0C.4
04D6:  GOTO   4D5
04D7:  MOVWF  19
....................                            output_bit(MINUTOD, OFF); 
04D8:  BCF    05.0
04D9:  MOVLW  00
04DA:  BSF    03.5
04DB:  MOVWF  05
....................                            break;             
04DC:  BCF    03.5
04DD:  GOTO   5A9
....................       case 'H':   if(DEBUG) {fputs("> Toque Corto",RS232);} 
04DE:  BTFSS  07.2
04DF:  GOTO   4EF
04E0:  MOVLW  9A
04E1:  BSF    03.6
04E2:  MOVWF  0D
04E3:  MOVLW  07
04E4:  MOVWF  0F
04E5:  BCF    03.6
04E6:  CALL   125
04E7:  MOVLW  0D
04E8:  BTFSS  0C.4
04E9:  GOTO   4E8
04EA:  MOVWF  19
04EB:  MOVLW  0A
04EC:  BTFSS  0C.4
04ED:  GOTO   4EC
04EE:  MOVWF  19
....................                            buzz(1); 
04EF:  MOVLW  01
04F0:  MOVWF  72
04F1:  CALL   2AE
....................                            break; 
04F2:  GOTO   5A9
....................       case 'I':   if(DEBUG) {fputs("> Toque Largo",RS232);} 
04F3:  BTFSS  07.2
04F4:  GOTO   504
04F5:  MOVLW  A1
04F6:  BSF    03.6
04F7:  MOVWF  0D
04F8:  MOVLW  07
04F9:  MOVWF  0F
04FA:  BCF    03.6
04FB:  CALL   125
04FC:  MOVLW  0D
04FD:  BTFSS  0C.4
04FE:  GOTO   4FD
04FF:  MOVWF  19
0500:  MOVLW  0A
0501:  BTFSS  0C.4
0502:  GOTO   501
0503:  MOVWF  19
....................                            buzz(2); 
0504:  MOVLW  02
0505:  MOVWF  72
0506:  CALL   2AE
....................                            break; 
0507:  GOTO   5A9
....................       case 'J':   if(DEBUG) {fputs("> Toque Doble",RS232);} 
0508:  BTFSS  07.2
0509:  GOTO   519
050A:  MOVLW  A8
050B:  BSF    03.6
050C:  MOVWF  0D
050D:  MOVLW  07
050E:  MOVWF  0F
050F:  BCF    03.6
0510:  CALL   125
0511:  MOVLW  0D
0512:  BTFSS  0C.4
0513:  GOTO   512
0514:  MOVWF  19
0515:  MOVLW  0A
0516:  BTFSS  0C.4
0517:  GOTO   516
0518:  MOVWF  19
....................                            buzz(3); 
0519:  MOVLW  03
051A:  MOVWF  72
051B:  CALL   2AE
....................                            break; 
051C:  GOTO   5A9
....................       case 'X':   doTest(); //Rutina de prueba 
051D:  CALL   30F
....................                   break; 
051E:  GOTO   5A9
....................       case 'Z':   if(DEBUG) {fputs("\r> Reseteo general...!",RS232);} 
051F:  BTFSS  07.2
0520:  GOTO   530
0521:  MOVLW  AF
0522:  BSF    03.6
0523:  MOVWF  0D
0524:  MOVLW  07
0525:  MOVWF  0F
0526:  BCF    03.6
0527:  CALL   125
0528:  MOVLW  0D
0529:  BTFSS  0C.4
052A:  GOTO   529
052B:  MOVWF  19
052C:  MOVLW  0A
052D:  BTFSS  0C.4
052E:  GOTO   52D
052F:  MOVWF  19
....................                   delay_ms(100); 
0530:  MOVLW  64
0531:  MOVWF  74
0532:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (5)",RS232);} 
0533:  BTFSS  07.2
0534:  GOTO   544
0535:  MOVLW  BB
0536:  BSF    03.6
0537:  MOVWF  0D
0538:  MOVLW  07
0539:  MOVWF  0F
053A:  BCF    03.6
053B:  CALL   125
053C:  MOVLW  0D
053D:  BTFSS  0C.4
053E:  GOTO   53D
053F:  MOVWF  19
0540:  MOVLW  0A
0541:  BTFSS  0C.4
0542:  GOTO   541
0543:  MOVWF  19
....................                   delay_ms(100); 
0544:  MOVLW  64
0545:  MOVWF  74
0546:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (4)",RS232);} 
0547:  BTFSS  07.2
0548:  GOTO   558
0549:  MOVLW  BF
054A:  BSF    03.6
054B:  MOVWF  0D
054C:  MOVLW  07
054D:  MOVWF  0F
054E:  BCF    03.6
054F:  CALL   125
0550:  MOVLW  0D
0551:  BTFSS  0C.4
0552:  GOTO   551
0553:  MOVWF  19
0554:  MOVLW  0A
0555:  BTFSS  0C.4
0556:  GOTO   555
0557:  MOVWF  19
....................                   delay_ms(100); 
0558:  MOVLW  64
0559:  MOVWF  74
055A:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (3)",RS232);} 
055B:  BTFSS  07.2
055C:  GOTO   56C
055D:  MOVLW  C3
055E:  BSF    03.6
055F:  MOVWF  0D
0560:  MOVLW  07
0561:  MOVWF  0F
0562:  BCF    03.6
0563:  CALL   125
0564:  MOVLW  0D
0565:  BTFSS  0C.4
0566:  GOTO   565
0567:  MOVWF  19
0568:  MOVLW  0A
0569:  BTFSS  0C.4
056A:  GOTO   569
056B:  MOVWF  19
....................                   delay_ms(100); 
056C:  MOVLW  64
056D:  MOVWF  74
056E:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (2)",RS232);} 
056F:  BTFSS  07.2
0570:  GOTO   580
0571:  MOVLW  C7
0572:  BSF    03.6
0573:  MOVWF  0D
0574:  MOVLW  07
0575:  MOVWF  0F
0576:  BCF    03.6
0577:  CALL   125
0578:  MOVLW  0D
0579:  BTFSS  0C.4
057A:  GOTO   579
057B:  MOVWF  19
057C:  MOVLW  0A
057D:  BTFSS  0C.4
057E:  GOTO   57D
057F:  MOVWF  19
....................                   delay_ms(100); 
0580:  MOVLW  64
0581:  MOVWF  74
0582:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (1)",RS232);} 
0583:  BTFSS  07.2
0584:  GOTO   594
0585:  MOVLW  CB
0586:  BSF    03.6
0587:  MOVWF  0D
0588:  MOVLW  07
0589:  MOVWF  0F
058A:  BCF    03.6
058B:  CALL   125
058C:  MOVLW  0D
058D:  BTFSS  0C.4
058E:  GOTO   58D
058F:  MOVWF  19
0590:  MOVLW  0A
0591:  BTFSS  0C.4
0592:  GOTO   591
0593:  MOVWF  19
....................                   delay_ms(100); 
0594:  MOVLW  64
0595:  MOVWF  74
0596:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (0)",RS232);} 
0597:  BTFSS  07.2
0598:  GOTO   5A8
0599:  MOVLW  CF
059A:  BSF    03.6
059B:  MOVWF  0D
059C:  MOVLW  07
059D:  MOVWF  0F
059E:  BCF    03.6
059F:  CALL   125
05A0:  MOVLW  0D
05A1:  BTFSS  0C.4
05A2:  GOTO   5A1
05A3:  MOVWF  19
05A4:  MOVLW  0A
05A5:  BTFSS  0C.4
05A6:  GOTO   5A5
05A7:  MOVWF  19
....................                   doReset(); 
05A8:  CALL   389
....................                    
....................    } 
05A9:  BCF    0A.3
05AA:  BCF    0A.4
05AB:  GOTO   5DF (RETURN)
.................... } 
....................  
.................... void showQuarter(int8 n) 
.................... { 
....................    output_bit(PERIODO1, OFF); 
*
0260:  BCF    09.1
0261:  MOVLW  E0
0262:  BSF    03.5
0263:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0264:  BCF    03.5
0265:  BCF    09.2
0266:  MOVLW  E0
0267:  BSF    03.5
0268:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0269:  BCF    03.5
026A:  BCF    07.0
026B:  MOVLW  DC
026C:  BSF    03.5
026D:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
026E:  BCF    03.5
026F:  BCF    07.1
0270:  MOVLW  DC
0271:  BSF    03.5
0272:  MOVWF  07
....................     
....................    switch(n) 
0273:  MOVLW  01
0274:  SUBWF  72,W
0275:  ADDLW  FC
0276:  BTFSC  03.0
0277:  GOTO   290
0278:  ADDLW  04
0279:  BCF    03.5
027A:  GOTO   292
....................    { 
....................       case 1: output_bit(PERIODO1, ON); break; 
027B:  BSF    09.1
027C:  MOVLW  E0
027D:  BSF    03.5
027E:  MOVWF  09
027F:  GOTO   290
....................       case 2: output_bit(PERIODO2, ON); break; 
0280:  BSF    09.2
0281:  MOVLW  E0
0282:  BSF    03.5
0283:  MOVWF  09
0284:  GOTO   290
....................       case 3: output_bit(PERIODO3, ON); break; 
0285:  BSF    07.0
0286:  MOVLW  DC
0287:  BSF    03.5
0288:  MOVWF  07
0289:  GOTO   290
....................       case 4: output_bit(PERIODO4, ON); break; 
028A:  BSF    07.1
028B:  MOVLW  DC
028C:  BSF    03.5
028D:  MOVWF  07
028E:  GOTO   290
028F:  BSF    03.5
....................    } 
0290:  BCF    03.5
0291:  RETURN
.................... } 
.................... void showNumber(int8 n, tPort p) 
*
01D8:  BCF    7B.0
01D9:  BCF    7B.1
01DA:  BCF    7B.2
01DB:  BCF    7B.3
.................... { 
....................    int1 a=0, b=0, c=0, d=0; 
....................    switch(n) 
01DC:  MOVLW  01
01DD:  SUBWF  72,W
01DE:  ADDLW  F7
01DF:  BTFSC  03.0
01E0:  GOTO   1FA
01E1:  ADDLW  09
01E2:  GOTO   253
....................    { 
....................       case 1:  a=1; 
01E3:  BSF    7B.0
....................                break; 
01E4:  GOTO   1FA
....................       case 2:  b=1; 
01E5:  BSF    7B.1
....................                break; 
01E6:  GOTO   1FA
....................       case 3:  a=1; b=1; 
01E7:  BSF    7B.0
01E8:  BSF    7B.1
....................                break; 
01E9:  GOTO   1FA
....................       case 4:  c=1; 
01EA:  BSF    7B.2
....................                break; 
01EB:  GOTO   1FA
....................       case 5:  c=1; a=1; 
01EC:  BSF    7B.2
01ED:  BSF    7B.0
....................                break; 
01EE:  GOTO   1FA
....................       case 6:  c=1; b=1; 
01EF:  BSF    7B.2
01F0:  BSF    7B.1
....................                break; 
01F1:  GOTO   1FA
....................       case 7:  c=1; b=1; a=1; 
01F2:  BSF    7B.2
01F3:  BSF    7B.1
01F4:  BSF    7B.0
....................                break; 
01F5:  GOTO   1FA
....................       case 8:  d=1; 
01F6:  BSF    7B.3
....................                break; 
01F7:  GOTO   1FA
....................       case 9:  d=1; a=1; 
01F8:  BSF    7B.3
01F9:  BSF    7B.0
....................                break; 
....................    } 
....................    output_bit(p.a, a); 
01FA:  MOVLW  00
01FB:  BTFSC  7B.0
01FC:  MOVLW  01
01FD:  MOVWF  77
01FE:  MOVF   73,W
01FF:  MOVWF  7C
0200:  MOVF   77,W
0201:  MOVWF  7D
0202:  BSF    03.5
0203:  CLRF   21
0204:  CLRF   20
0205:  BCF    03.5
0206:  CALL   1B6
0207:  MOVF   73,W
0208:  MOVWF  7C
0209:  CLRF   7D
020A:  BSF    03.5
020B:  CLRF   21
020C:  MOVLW  80
020D:  MOVWF  20
020E:  BCF    03.5
020F:  CALL   1B6
....................    output_bit(p.b, b); 
0210:  MOVLW  00
0211:  BTFSC  7B.1
0212:  MOVLW  01
0213:  MOVWF  77
0214:  MOVF   74,W
0215:  MOVWF  7C
0216:  MOVF   77,W
0217:  MOVWF  7D
0218:  BSF    03.5
0219:  CLRF   21
021A:  CLRF   20
021B:  BCF    03.5
021C:  CALL   1B6
021D:  MOVF   74,W
021E:  MOVWF  7C
021F:  CLRF   7D
0220:  BSF    03.5
0221:  CLRF   21
0222:  MOVLW  80
0223:  MOVWF  20
0224:  BCF    03.5
0225:  CALL   1B6
....................    output_bit(p.c, c); 
0226:  MOVLW  00
0227:  BTFSC  7B.2
0228:  MOVLW  01
0229:  MOVWF  77
022A:  MOVF   75,W
022B:  MOVWF  7C
022C:  MOVF   77,W
022D:  MOVWF  7D
022E:  BSF    03.5
022F:  CLRF   21
0230:  CLRF   20
0231:  BCF    03.5
0232:  CALL   1B6
0233:  MOVF   75,W
0234:  MOVWF  7C
0235:  CLRF   7D
0236:  BSF    03.5
0237:  CLRF   21
0238:  MOVLW  80
0239:  MOVWF  20
023A:  BCF    03.5
023B:  CALL   1B6
....................    output_bit(p.d, d); 
023C:  MOVLW  00
023D:  BTFSC  7B.3
023E:  MOVLW  01
023F:  MOVWF  77
0240:  MOVF   76,W
0241:  MOVWF  7C
0242:  MOVF   77,W
0243:  MOVWF  7D
0244:  BSF    03.5
0245:  CLRF   21
0246:  CLRF   20
0247:  BCF    03.5
0248:  CALL   1B6
0249:  MOVF   76,W
024A:  MOVWF  7C
024B:  CLRF   7D
024C:  BSF    03.5
024D:  CLRF   21
024E:  MOVLW  80
024F:  MOVWF  20
0250:  BCF    03.5
0251:  CALL   1B6
0252:  RETURN
.................... } 
....................  
.................... int8 char2int(char c) 
.................... { 
....................    switch(c) 
*
0177:  MOVLW  30
0178:  SUBWF  71,W
0179:  ADDLW  F6
017A:  BTFSC  03.0
017B:  GOTO   1A5
017C:  ADDLW  0A
017D:  GOTO   1A8
....................    { 
....................       case '0':   return 0; 
017E:  MOVLW  00
017F:  MOVWF  78
0180:  GOTO   1A7
....................                   break; 
0181:  GOTO   1A5
....................       case '1':   return 1; 
0182:  MOVLW  01
0183:  MOVWF  78
0184:  GOTO   1A7
....................                   break; 
0185:  GOTO   1A5
....................       case '2':   return 2; 
0186:  MOVLW  02
0187:  MOVWF  78
0188:  GOTO   1A7
....................                   break; 
0189:  GOTO   1A5
....................       case '3':   return 3; 
018A:  MOVLW  03
018B:  MOVWF  78
018C:  GOTO   1A7
....................                   break; 
018D:  GOTO   1A5
....................       case '4':   return 4; 
018E:  MOVLW  04
018F:  MOVWF  78
0190:  GOTO   1A7
....................                   break; 
0191:  GOTO   1A5
....................       case '5':   return 5; 
0192:  MOVLW  05
0193:  MOVWF  78
0194:  GOTO   1A7
....................                   break; 
0195:  GOTO   1A5
....................       case '6':   return 6; 
0196:  MOVLW  06
0197:  MOVWF  78
0198:  GOTO   1A7
....................                   break; 
0199:  GOTO   1A5
....................       case '7':   return 7; 
019A:  MOVLW  07
019B:  MOVWF  78
019C:  GOTO   1A7
....................                   break; 
019D:  GOTO   1A5
....................       case '8':   return 8; 
019E:  MOVLW  08
019F:  MOVWF  78
01A0:  GOTO   1A7
....................                   break; 
01A1:  GOTO   1A5
....................       case '9':   return 9; 
01A2:  MOVLW  09
01A3:  MOVWF  78
01A4:  GOTO   1A7
....................                   break; 
....................    } 
....................    return 0; 
01A5:  MOVLW  00
01A6:  MOVWF  78
01A7:  RETURN
.................... } 
....................  
.................... void doReset(void) 
.................... { 
....................    if(DEBUG) {fputs("> Reseteando...",RS232);} 
*
0389:  BTFSS  07.2
038A:  GOTO   39A
038B:  MOVLW  D3
038C:  BSF    03.6
038D:  MOVWF  0D
038E:  MOVLW  07
038F:  MOVWF  0F
0390:  BCF    03.6
0391:  CALL   125
0392:  MOVLW  0D
0393:  BTFSS  0C.4
0394:  GOTO   393
0395:  MOVWF  19
0396:  MOVLW  0A
0397:  BTFSS  0C.4
0398:  GOTO   397
0399:  MOVWF  19
....................    reset_cpu(); 
039A:  CLRF   0A
039B:  GOTO   000
039C:  RETURN
.................... } 
....................  

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 0700   BORV40 NOWRT

CCS PCM C Compiler, Version 5.076, 56587               11-mar.-20 22:18

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mtime\mtime.lst

               ROM used:   3337 words (41%)
                           Largest free fragment is 2048
               RAM used:   70 (19%) at main() level
                           97 (26%) worst case
               Stack used: 5 locations (1 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   4D3
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   5B5
0057:  BSF    0A.3
0058:  BCF    0A.4
0059:  GOTO   000
.................... #include <mtime.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 0D,00
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA A0,23
007D:  DATA F2,3A
007E:  DATA F0,37
007F:  DATA A0,20
0080:  DATA D0,26
0081:  DATA 20,14
0082:  DATA E3,14
0083:  DATA 20,19
0084:  DATA 30,19
0085:  DATA 30,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 0D,00
008A:  DATA BD,1E
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA 0D,00
009B:  DATA 42,36
009C:  DATA F5,32
009D:  DATA F4,37
009E:  DATA 6F,3A
009F:  DATA 68,10
00A0:  DATA C2,30
00A1:  DATA F3,35
00A2:  DATA 65,3A
00A3:  DATA E2,30
00A4:  DATA 6C,36
00A5:  DATA A0,29
00A6:  DATA E3,37
00A7:  DATA F2,32
00A8:  DATA 20,21
00A9:  DATA EF,30
00AA:  DATA 72,32
00AB:  DATA 0D,00
00AC:  DATA BD,1E
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA 0D,00
00BD:  DATA D6,32
00BE:  DATA F2,39
00BF:  DATA E9,37
00C0:  DATA 6E,10
00C1:  DATA A5,39
00C2:  DATA A0,16
00C3:  DATA 20,39
00C4:  DATA 65,3B
00C5:  DATA A0,12
00C6:  DATA 73,10
00C7:  DATA 0D,00
00C8:  DATA 32,17
00C9:  DATA 30,00
00CA:  DATA 46,00
00CB:  DATA 2A,15
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 0D,00
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA C4,22
00E0:  DATA D0,2A
00E1:  DATA D2,20
00E2:  DATA C3,24
00E3:  DATA 4F,27
00E4:  DATA 20,1D
00E5:  DATA 3A,10
00E6:  DATA D4,24
00E7:  DATA C5,26
00E8:  DATA D0,27
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 20,10
00EC:  DATA 0D,00
00ED:  DATA 3E,10
00EE:  DATA C8,30
00EF:  DATA E2,34
00F0:  DATA EC,34
00F1:  DATA F4,30
00F2:  DATA E3,34
00F3:  DATA 6F,37
00F4:  DATA 20,32
00F5:  DATA 65,10
00F6:  DATA 49,19
00F7:  DATA 43,00
00F8:  DATA 3E,10
00F9:  DATA C3,37
00FA:  DATA 6E,33
00FB:  DATA E9,33
00FC:  DATA 75,39
00FD:  DATA E1,31
00FE:  DATA E9,37
00FF:  DATA 6E,10
0100:  DATA E4,32
0101:  DATA 20,28
0102:  DATA F5,32
0103:  DATA 72,3A
0104:  DATA EF,39
0105:  DATA 00,01
0106:  DATA 3E,10
0107:  DATA C8,30
0108:  DATA E2,34
0109:  DATA EC,34
010A:  DATA F4,30
010B:  DATA E3,34
010C:  DATA 6F,37
010D:  DATA 20,32
010E:  DATA 65,10
010F:  DATA E4,34
0110:  DATA 73,38
0111:  DATA EC,30
0112:  DATA F9,39
0113:  DATA 00,01
0114:  DATA 3E,10
0115:  DATA C8,30
0116:  DATA E2,34
0117:  DATA EC,34
0118:  DATA F4,30
0119:  DATA E3,34
011A:  DATA 6F,37
011B:  DATA 20,32
011C:  DATA 65,10
011D:  DATA 69,37
011E:  DATA F4,32
011F:  DATA 72,39
0120:  DATA 75,38
0121:  DATA E3,34
0122:  DATA 6F,37
0123:  DATA E5,39
0124:  DATA 00,00
0125:  MOVF   0B,W
0126:  MOVWF  72
0127:  BCF    0B.7
0128:  BSF    03.5
0129:  BSF    03.6
012A:  BSF    0C.7
012B:  BSF    0C.0
012C:  NOP
012D:  NOP
012E:  BTFSS  72.7
012F:  GOTO   135
0130:  BCF    03.5
0131:  BCF    03.6
0132:  BSF    0B.7
0133:  BSF    03.5
0134:  BSF    03.6
0135:  BCF    03.5
0136:  MOVF   0C,W
0137:  ANDLW  7F
0138:  BTFSC  03.2
0139:  GOTO   175
013A:  MOVWF  72
013B:  MOVF   0D,W
013C:  MOVWF  73
013D:  MOVF   0F,W
013E:  MOVWF  74
013F:  MOVF   72,W
0140:  BCF    03.6
0141:  BTFSS  0C.4
0142:  GOTO   141
0143:  MOVWF  19
0144:  MOVF   73,W
0145:  BSF    03.6
0146:  MOVWF  0D
0147:  MOVF   74,W
0148:  MOVWF  0F
0149:  BCF    03.6
014A:  MOVF   0B,W
014B:  MOVWF  75
014C:  BCF    0B.7
014D:  BSF    03.5
014E:  BSF    03.6
014F:  BSF    0C.7
0150:  BSF    0C.0
0151:  NOP
0152:  NOP
0153:  BTFSS  75.7
0154:  GOTO   15A
0155:  BCF    03.5
0156:  BCF    03.6
0157:  BSF    0B.7
0158:  BSF    03.5
0159:  BSF    03.6
015A:  BCF    03.5
015B:  RLF    0C,W
015C:  RLF    0E,W
015D:  ANDLW  7F
015E:  BTFSC  03.2
015F:  GOTO   175
0160:  MOVWF  72
0161:  MOVF   0D,W
0162:  MOVWF  73
0163:  MOVF   0F,W
0164:  MOVWF  74
0165:  MOVF   72,W
0166:  BCF    03.6
0167:  BTFSS  0C.4
0168:  GOTO   167
0169:  MOVWF  19
016A:  MOVF   73,W
016B:  BSF    03.6
016C:  MOVWF  0D
016D:  MOVF   74,W
016E:  MOVWF  0F
016F:  INCF   0D,F
0170:  BTFSC  03.2
0171:  INCF   0F,F
0172:  BCF    03.6
0173:  GOTO   125
0174:  BSF    03.6
0175:  BCF    03.6
0176:  RETURN
*
01A8:  BSF    0A.0
01A9:  BCF    0A.1
01AA:  BCF    0A.2
01AB:  ADDWF  02,F
01AC:  GOTO   17E
01AD:  GOTO   182
01AE:  GOTO   186
01AF:  GOTO   18A
01B0:  GOTO   18E
01B1:  GOTO   192
01B2:  GOTO   196
01B3:  GOTO   19A
01B4:  GOTO   19E
01B5:  GOTO   1A2
01B6:  MOVF   7C,W
01B7:  ANDLW  07
01B8:  MOVWF  77
01B9:  RRF    7C,W
01BA:  MOVWF  78
01BB:  RRF    78,F
01BC:  RRF    78,F
01BD:  MOVLW  1F
01BE:  ANDWF  78,F
01BF:  MOVF   78,W
01C0:  BSF    03.5
01C1:  ADDWF  20,W
01C2:  MOVWF  04
01C3:  BCF    03.7
01C4:  BTFSC  21.0
01C5:  BSF    03.7
01C6:  CLRF   78
01C7:  INCF   78,F
01C8:  INCF   77,F
01C9:  GOTO   1CB
01CA:  RLF    78,F
01CB:  DECFSZ 77,F
01CC:  GOTO   1CA
01CD:  MOVF   7D,F
01CE:  BTFSC  03.2
01CF:  GOTO   1D3
01D0:  MOVF   78,W
01D1:  IORWF  00,F
01D2:  GOTO   1D6
01D3:  COMF   78,F
01D4:  MOVF   78,W
01D5:  ANDWF  00,F
01D6:  BCF    03.5
01D7:  RETURN
*
0253:  BCF    0A.0
0254:  BSF    0A.1
0255:  BCF    0A.2
0256:  ADDWF  02,F
0257:  GOTO   1E3
0258:  GOTO   1E5
0259:  GOTO   1E7
025A:  GOTO   1EA
025B:  GOTO   1EC
025C:  GOTO   1EF
025D:  GOTO   1F2
025E:  GOTO   1F6
025F:  GOTO   1F8
*
0292:  BCF    0A.0
0293:  BSF    0A.1
0294:  BCF    0A.2
0295:  ADDWF  02,F
0296:  GOTO   27B
0297:  GOTO   280
0298:  GOTO   285
0299:  GOTO   28A
*
05AC:  BSF    0A.0
05AD:  BCF    0A.1
05AE:  BSF    0A.2
05AF:  ADDWF  02,F
05B0:  GOTO   3F8
05B1:  GOTO   408
05B2:  GOTO   418
05B3:  GOTO   428
05B4:  GOTO   438
*
0605:  MOVF   0B,W
0606:  MOVWF  69
0607:  BCF    0B.7
0608:  BSF    03.5
0609:  BSF    03.6
060A:  BSF    0C.7
060B:  BSF    0C.0
060C:  NOP
060D:  NOP
060E:  BCF    03.5
060F:  BCF    03.6
0610:  BTFSC  69.7
0611:  BSF    0B.7
0612:  BTFSC  03.0
0613:  GOTO   63D
0614:  BSF    03.6
0615:  MOVF   0C,W
0616:  ANDLW  7F
0617:  BCF    03.6
0618:  MOVWF  69
0619:  BSF    03.6
061A:  MOVF   0D,W
061B:  BCF    03.6
061C:  MOVWF  6A
061D:  BSF    03.6
061E:  MOVF   0F,W
061F:  BCF    03.6
0620:  MOVWF  6B
0621:  MOVF   69,W
0622:  BTFSS  0C.4
0623:  GOTO   622
0624:  MOVWF  19
0625:  MOVF   6A,W
0626:  BSF    03.6
0627:  MOVWF  0D
0628:  BCF    03.6
0629:  MOVF   6B,W
062A:  BSF    03.6
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  MOVF   0B,W
062E:  MOVWF  6C
062F:  BCF    0B.7
0630:  BSF    03.5
0631:  BSF    03.6
0632:  BSF    0C.7
0633:  BSF    0C.0
0634:  NOP
0635:  NOP
0636:  BCF    03.5
0637:  BCF    03.6
0638:  BTFSC  6C.7
0639:  BSF    0B.7
063A:  DECFSZ 68,F
063B:  GOTO   63D
063C:  GOTO   65D
063D:  BSF    03.6
063E:  RLF    0C,W
063F:  RLF    0E,W
0640:  ANDLW  7F
0641:  BCF    03.6
0642:  MOVWF  69
0643:  BSF    03.6
0644:  MOVF   0D,W
0645:  BCF    03.6
0646:  MOVWF  6A
0647:  BSF    03.6
0648:  MOVF   0F,W
0649:  BCF    03.6
064A:  MOVWF  6B
064B:  MOVF   69,W
064C:  BTFSS  0C.4
064D:  GOTO   64C
064E:  MOVWF  19
064F:  MOVF   6A,W
0650:  BSF    03.6
0651:  MOVWF  0D
0652:  BCF    03.6
0653:  MOVF   6B,W
0654:  BSF    03.6
0655:  MOVWF  0F
0656:  INCF   0D,F
0657:  BTFSC  03.2
0658:  INCF   0F,F
0659:  BCF    03.0
065A:  BCF    03.6
065B:  DECFSZ 68,F
065C:  GOTO   605
065D:  RETURN
065E:  BTFSC  69.7
065F:  GOTO   671
0660:  MOVLW  0F
0661:  MOVWF  77
0662:  SWAPF  68,W
0663:  ANDWF  77,F
0664:  MOVLW  0A
0665:  SUBWF  77,W
0666:  BTFSC  03.0
0667:  GOTO   66B
0668:  MOVLW  30
0669:  ADDWF  77,F
066A:  GOTO   66D
066B:  MOVF   69,W
066C:  ADDWF  77,F
066D:  MOVF   77,W
066E:  BTFSS  0C.4
066F:  GOTO   66E
0670:  MOVWF  19
0671:  MOVLW  0F
0672:  ANDWF  68,F
0673:  MOVLW  0A
0674:  SUBWF  68,W
0675:  BTFSC  03.0
0676:  GOTO   679
0677:  MOVLW  30
0678:  GOTO   67B
0679:  BCF    69.7
067A:  MOVF   69,W
067B:  ADDWF  68,F
067C:  MOVF   68,W
067D:  BTFSS  0C.4
067E:  GOTO   67D
067F:  MOVWF  19
0680:  RETURN
0681:  DATA 3E,10
0682:  DATA C3,37
0683:  DATA ED,36
0684:  DATA 61,37
0685:  DATA E4,37
0686:  DATA 3A,10
0687:  DATA 25,2C
0688:  DATA A0,16
0689:  DATA A0,12
068A:  DATA D8,06
068B:  DATA 80,27
068C:  DATA 3E,10
068D:  DATA C4,34
068E:  DATA F2,32
068F:  DATA E3,31
0690:  DATA E9,37
0691:  DATA 6E,10
0692:  DATA D4,24
0693:  DATA CD,22
0694:  DATA 52,00
0695:  DATA 3E,10
0696:  DATA C4,34
0697:  DATA F2,32
0698:  DATA E3,31
0699:  DATA E9,37
069A:  DATA 6E,10
069B:  DATA D3,21
069C:  DATA 4F,29
069D:  DATA 45,00
069E:  DATA 3E,10
069F:  DATA 41,38
06A0:  DATA E1,33
06A1:  DATA 61,39
06A2:  DATA 20,28
06A3:  DATA 65,39
06A4:  DATA E9,37
06A5:  DATA E4,37
06A6:  DATA 73,00
06A7:  DATA 3E,10
06A8:  DATA C1,31
06A9:  DATA F4,34
06AA:  DATA F6,30
06AB:  DATA 72,10
06AC:  DATA D0,32
06AD:  DATA F2,34
06AE:  DATA 6F,32
06AF:  DATA 6F,10
06B0:  DATA 31,00
06B1:  DATA 3E,10
06B2:  DATA C1,31
06B3:  DATA F4,34
06B4:  DATA F6,30
06B5:  DATA 72,10
06B6:  DATA D0,32
06B7:  DATA F2,34
06B8:  DATA 6F,32
06B9:  DATA 6F,10
06BA:  DATA 32,00
06BB:  DATA 3E,10
06BC:  DATA C1,31
06BD:  DATA F4,34
06BE:  DATA F6,30
06BF:  DATA 72,10
06C0:  DATA D0,32
06C1:  DATA F2,34
06C2:  DATA 6F,32
06C3:  DATA 6F,10
06C4:  DATA 33,00
06C5:  DATA 3E,10
06C6:  DATA C1,31
06C7:  DATA F4,34
06C8:  DATA F6,30
06C9:  DATA 72,10
06CA:  DATA D0,32
06CB:  DATA F2,34
06CC:  DATA 6F,32
06CD:  DATA 6F,10
06CE:  DATA 34,00
06CF:  DATA 3E,10
06D0:  DATA C1,31
06D1:  DATA F4,34
06D2:  DATA F6,30
06D3:  DATA 72,10
06D4:  DATA CD,34
06D5:  DATA EE,3A
06D6:  DATA F4,37
06D7:  DATA 20,22
06D8:  DATA E5,31
06D9:  DATA 65,37
06DA:  DATA 61,00
06DB:  DATA 3E,10
06DC:  DATA C4,32
06DD:  DATA F3,30
06DE:  DATA 63,3A
06DF:  DATA 69,3B
06E0:  DATA 61,39
06E1:  DATA A0,26
06E2:  DATA 69,37
06E3:  DATA 75,3A
06E4:  DATA 6F,10
06E5:  DATA C4,32
06E6:  DATA E3,32
06E7:  DATA EE,30
06E8:  DATA 00,01
06E9:  DATA 3E,10
06EA:  DATA D4,37
06EB:  DATA F1,3A
06EC:  DATA 65,10
06ED:  DATA C3,37
06EE:  DATA 72,3A
06EF:  DATA 6F,00
06F0:  DATA 3E,10
06F1:  DATA D4,37
06F2:  DATA F1,3A
06F3:  DATA 65,10
06F4:  DATA CC,30
06F5:  DATA F2,33
06F6:  DATA 6F,00
06F7:  DATA 3E,10
06F8:  DATA D4,37
06F9:  DATA F1,3A
06FA:  DATA 65,10
06FB:  DATA C4,37
06FC:  DATA 62,36
06FD:  DATA 65,00
06FE:  DATA 3E,10
06FF:  DATA C1,39
0700:  DATA E9,33
0701:  DATA EE,30
0702:  DATA E3,34
0703:  DATA 6F,37
0704:  DATA 20,28
0705:  DATA F5,32
0706:  DATA 72,3A
0707:  DATA 6F,10
0708:  DATA 31,00
0709:  DATA 3E,10
070A:  DATA C1,39
070B:  DATA E9,33
070C:  DATA EE,30
070D:  DATA E3,34
070E:  DATA 6F,37
070F:  DATA 20,28
0710:  DATA F5,32
0711:  DATA 72,3A
0712:  DATA 6F,10
0713:  DATA 32,00
0714:  DATA 3E,10
0715:  DATA C1,39
0716:  DATA E9,33
0717:  DATA EE,30
0718:  DATA E3,34
0719:  DATA 6F,37
071A:  DATA 20,28
071B:  DATA F5,32
071C:  DATA 72,3A
071D:  DATA 6F,10
071E:  DATA 33,00
071F:  DATA 3E,10
0720:  DATA C1,39
0721:  DATA E9,33
0722:  DATA EE,30
0723:  DATA E3,34
0724:  DATA 6F,37
0725:  DATA 20,28
0726:  DATA F5,32
0727:  DATA 72,3A
0728:  DATA 6F,10
0729:  DATA 34,00
072A:  DATA 3E,10
072B:  DATA C1,39
072C:  DATA E9,33
072D:  DATA EE,30
072E:  DATA E3,34
072F:  DATA 6F,37
0730:  DATA 20,28
0731:  DATA F5,32
0732:  DATA 72,3A
0733:  DATA 6F,10
0734:  DATA 35,00
0735:  DATA 3E,10
0736:  DATA D2,3A
0737:  DATA F4,34
0738:  DATA EE,30
0739:  DATA 20,32
073A:  DATA 65,10
073B:  DATA 70,39
073C:  DATA F5,32
073D:  DATA E2,30
073E:  DATA 00,00
073F:  DATA 0D,1F
0740:  DATA A0,20
0741:  DATA 63,3A
0742:  DATA 69,3B
0743:  DATA E1,31
0744:  DATA E9,37
0745:  DATA 6E,10
0746:  DATA ED,30
0747:  DATA EE,3A
0748:  DATA 61,36
0749:  DATA 20,32
074A:  DATA 65,10
074B:  DATA F0,3A
074C:  DATA 65,39
074D:  DATA F4,37
074E:  DATA 00,01
074F:  DATA 3E,10
0750:  DATA 41,38
0751:  DATA E1,33
0752:  DATA 61,39
0753:  DATA 20,28
0754:  DATA 65,39
0755:  DATA E9,37
0756:  DATA E4,37
0757:  DATA 73,00
0758:  DATA 3E,10
0759:  DATA C1,31
075A:  DATA F4,34
075B:  DATA F6,30
075C:  DATA 72,10
075D:  DATA D0,32
075E:  DATA F2,34
075F:  DATA 6F,32
0760:  DATA 6F,10
0761:  DATA 31,00
0762:  DATA 3E,10
0763:  DATA C1,31
0764:  DATA F4,34
0765:  DATA F6,30
0766:  DATA 72,10
0767:  DATA D0,32
0768:  DATA F2,34
0769:  DATA 6F,32
076A:  DATA 6F,10
076B:  DATA 32,00
076C:  DATA 3E,10
076D:  DATA C1,31
076E:  DATA F4,34
076F:  DATA F6,30
0770:  DATA 72,10
0771:  DATA D0,32
0772:  DATA F2,34
0773:  DATA 6F,32
0774:  DATA 6F,10
0775:  DATA 33,00
0776:  DATA 3E,10
0777:  DATA C1,31
0778:  DATA F4,34
0779:  DATA F6,30
077A:  DATA 72,10
077B:  DATA D0,32
077C:  DATA F2,34
077D:  DATA 6F,32
077E:  DATA 6F,10
077F:  DATA 34,00
0780:  DATA 3E,10
0781:  DATA C1,31
0782:  DATA F4,34
0783:  DATA F6,30
0784:  DATA 72,10
0785:  DATA CD,34
0786:  DATA EE,3A
0787:  DATA F4,37
0788:  DATA 20,22
0789:  DATA E5,31
078A:  DATA 65,37
078B:  DATA 61,00
078C:  DATA 3E,10
078D:  DATA C4,32
078E:  DATA F3,30
078F:  DATA 63,3A
0790:  DATA 69,3B
0791:  DATA 61,39
0792:  DATA A0,26
0793:  DATA 69,37
0794:  DATA 75,3A
0795:  DATA 6F,10
0796:  DATA C4,32
0797:  DATA E3,32
0798:  DATA EE,30
0799:  DATA 00,01
079A:  DATA 3E,10
079B:  DATA D4,37
079C:  DATA F1,3A
079D:  DATA 65,10
079E:  DATA C3,37
079F:  DATA 72,3A
07A0:  DATA 6F,00
07A1:  DATA 3E,10
07A2:  DATA D4,37
07A3:  DATA F1,3A
07A4:  DATA 65,10
07A5:  DATA CC,30
07A6:  DATA F2,33
07A7:  DATA 6F,00
07A8:  DATA 3E,10
07A9:  DATA D4,37
07AA:  DATA F1,3A
07AB:  DATA 65,10
07AC:  DATA C4,37
07AD:  DATA 62,36
07AE:  DATA 65,00
07AF:  DATA 0D,1F
07B0:  DATA 20,29
07B1:  DATA E5,39
07B2:  DATA 65,3A
07B3:  DATA E5,37
07B4:  DATA A0,33
07B5:  DATA 65,37
07B6:  DATA 65,39
07B7:  DATA 61,36
07B8:  DATA 2E,17
07B9:  DATA AE,10
07BA:  DATA 00,01
07BB:  DATA 0D,1F
07BC:  DATA 20,14
07BD:  DATA B5,14
07BE:  DATA 00,01
07BF:  DATA 0D,1F
07C0:  DATA 20,14
07C1:  DATA B4,14
07C2:  DATA 00,01
07C3:  DATA 0D,1F
07C4:  DATA 20,14
07C5:  DATA B3,14
07C6:  DATA 00,01
07C7:  DATA 0D,1F
07C8:  DATA 20,14
07C9:  DATA B2,14
07CA:  DATA 00,01
07CB:  DATA 0D,1F
07CC:  DATA 20,14
07CD:  DATA B1,14
07CE:  DATA 00,01
07CF:  DATA 0D,1F
07D0:  DATA 20,14
07D1:  DATA B0,14
07D2:  DATA 00,00
07D3:  DATA 3E,10
07D4:  DATA D2,32
07D5:  DATA F3,32
07D6:  DATA F4,32
07D7:  DATA 61,37
07D8:  DATA E4,37
07D9:  DATA 2E,17
07DA:  DATA 2E,00
*
0AA8:  MOVF   0B,W
0AA9:  MOVWF  61
0AAA:  BCF    0B.7
0AAB:  BSF    03.5
0AAC:  BSF    03.6
0AAD:  BSF    0C.7
0AAE:  BSF    0C.0
0AAF:  NOP
0AB0:  NOP
0AB1:  BCF    03.5
0AB2:  BCF    03.6
0AB3:  BTFSC  61.7
0AB4:  BSF    0B.7
0AB5:  BSF    03.6
0AB6:  MOVF   0C,W
0AB7:  ANDLW  7F
0AB8:  BTFSC  03.2
0AB9:  GOTO   2FE
0ABA:  BCF    03.6
0ABB:  MOVWF  61
0ABC:  BSF    03.6
0ABD:  MOVF   0D,W
0ABE:  BCF    03.6
0ABF:  MOVWF  62
0AC0:  BSF    03.6
0AC1:  MOVF   0F,W
0AC2:  BCF    03.6
0AC3:  MOVWF  63
0AC4:  MOVF   61,W
0AC5:  BTFSS  0C.4
0AC6:  GOTO   2C5
0AC7:  MOVWF  19
0AC8:  MOVF   62,W
0AC9:  BSF    03.6
0ACA:  MOVWF  0D
0ACB:  BCF    03.6
0ACC:  MOVF   63,W
0ACD:  BSF    03.6
0ACE:  MOVWF  0F
0ACF:  BCF    03.6
0AD0:  MOVF   0B,W
0AD1:  MOVWF  64
0AD2:  BCF    0B.7
0AD3:  BSF    03.5
0AD4:  BSF    03.6
0AD5:  BSF    0C.7
0AD6:  BSF    0C.0
0AD7:  NOP
0AD8:  NOP
0AD9:  BCF    03.5
0ADA:  BCF    03.6
0ADB:  BTFSC  64.7
0ADC:  BSF    0B.7
0ADD:  BSF    03.6
0ADE:  RLF    0C,W
0ADF:  RLF    0E,W
0AE0:  ANDLW  7F
0AE1:  BTFSC  03.2
0AE2:  GOTO   2FE
0AE3:  BCF    03.6
0AE4:  MOVWF  61
0AE5:  BSF    03.6
0AE6:  MOVF   0D,W
0AE7:  BCF    03.6
0AE8:  MOVWF  62
0AE9:  BSF    03.6
0AEA:  MOVF   0F,W
0AEB:  BCF    03.6
0AEC:  MOVWF  63
0AED:  MOVF   61,W
0AEE:  BTFSS  0C.4
0AEF:  GOTO   2EE
0AF0:  MOVWF  19
0AF1:  MOVF   62,W
0AF2:  BSF    03.6
0AF3:  MOVWF  0D
0AF4:  BCF    03.6
0AF5:  MOVF   63,W
0AF6:  BSF    03.6
0AF7:  MOVWF  0F
0AF8:  INCF   0D,F
0AF9:  BTFSC  03.2
0AFA:  INCF   0F,F
0AFB:  BCF    03.6
0AFC:  GOTO   2A8
0AFD:  BSF    03.6
0AFE:  BCF    03.6
0AFF:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
029A:  MOVLW  74
029B:  MOVWF  04
029C:  BCF    03.7
029D:  MOVF   00,W
029E:  BTFSC  03.2
029F:  GOTO   2AD
02A0:  MOVLW  02
02A1:  MOVWF  78
02A2:  CLRF   77
02A3:  DECFSZ 77,F
02A4:  GOTO   2A3
02A5:  DECFSZ 78,F
02A6:  GOTO   2A2
02A7:  MOVLW  97
02A8:  MOVWF  77
02A9:  DECFSZ 77,F
02AA:  GOTO   2A9
02AB:  DECFSZ 00,F
02AC:  GOTO   2A0
02AD:  RETURN
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4,PIN_A3,PIN_A2,PIN_A1,PIN_A0 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5, PIN_C1, PIN_C0 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E3,PIN_E2,PIN_E1,PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
.................... #define PERIODO1  PIN_E1 
.................... #define PERIODO2  PIN_E2 
.................... #define PERIODO3  PIN_C0 
.................... #define PERIODO4  PIN_C1 
.................... #define MINUTOD   PIN_A0 
.................... #define BUZZER    PIN_A1 
....................  
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Slave,Fast,sda=I2C_SDA,scl=I2C_SCL, address = I2C_TIMER, FORCE_HW) 
*
0823:  MOVF   67,W
0824:  MOVWF  13
0825:  BSF    14.4
0826:  BCF    0C.3
0827:  BSF    03.5
0828:  BTFSC  14.0
0829:  GOTO   028
082A:  CLRF   78
082B:  BTFSS  11.6
082C:  INCF   78,F
....................  
.................... //-- DEFINICIONES -- 
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
....................  
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       200 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... //-- DECLARACIONES -- 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
0D0F:  BCF    03.6
0D10:  CLRF   2C
0D11:  CLRF   2D
0D12:  CLRF   2E
0D13:  CLRF   2F
0D14:  CLRF   30
0D15:  CLRF   31
0D16:  CLRF   32
0D17:  CLRF   33
0D18:  CLRF   34
0D19:  CLRF   35
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
0D1A:  CLRF   36
0D1B:  CLRF   37
0D1C:  CLRF   38
0D1D:  CLRF   39
0D1E:  CLRF   3A
0D1F:  CLRF   3B
0D20:  CLRF   3C
0D21:  CLRF   3D
0D22:  CLRF   3E
0D23:  CLRF   3F
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... int  icmd; 
.................... int  ircmd[5] = "\0\0\0\0"; 
0D24:  CLRF   43
0D25:  CLRF   44
0D26:  CLRF   45
0D27:  CLRF   46
0D28:  CLRF   47
....................  
.................... //Puertos de Displays 
.................... tPort pTiroSU; 
.................... tPort pTiroSD; 
.................... tPort pTiempoSU; 
.................... tPort pTiempoSD; 
.................... tPort pTiempoMU; 
....................  
....................  
.................... //-- PROTOTIPOS -- 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8  char2int(char);  
.................... void doReset(void); 
.................... void parseI2CCommand(void); 
.................... void showQuarter(int8); 
.................... void buzz(int); 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
0D29:  CLRF   5C
0D2A:  CLRF   5D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
0B00:  BSF    03.5
0B01:  CLRF   05
0B02:  BCF    03.5
0B03:  CLRF   05
....................    output_b(0x00); 
0B04:  BSF    03.5
0B05:  CLRF   06
0B06:  BCF    03.5
0B07:  CLRF   06
....................    output_c(0x00); 
0B08:  MOVLW  DC
0B09:  BSF    03.5
0B0A:  MOVWF  07
0B0B:  BCF    03.5
0B0C:  CLRF   07
....................    output_d(0x00); 
0B0D:  BSF    03.5
0B0E:  CLRF   08
0B0F:  BCF    03.5
0B10:  CLRF   08
....................    output_e(0x00); 
0B11:  BSF    03.5
0B12:  BCF    09.0
0B13:  BCF    09.1
0B14:  BCF    09.2
0B15:  BCF    09.3
0B16:  BCF    03.5
0B17:  CLRF   09
0B18:  CLRF   2B
0B19:  BTFSC  0B.7
0B1A:  BSF    2B.7
0B1B:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0B1C:  MOVLW  C8
0B1D:  MOVWF  74
0B1E:  BCF    0A.3
0B1F:  CALL   29A
0B20:  BSF    0A.3
0B21:  BTFSC  2B.7
0B22:  BSF    0B.7
....................     
....................    if(DEBUG) 
0B23:  BTFSS  07.2
0B24:  GOTO   390
....................    { 
....................       fprintf(RS232,"********************************\r"); 
0B25:  MOVLW  68
0B26:  BSF    03.6
0B27:  MOVWF  0D
0B28:  MOVLW  00
0B29:  MOVWF  0F
0B2A:  BCF    03.6
0B2B:  CALL   2A8
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
0B2C:  MOVLW  79
0B2D:  BSF    03.6
0B2E:  MOVWF  0D
0B2F:  MOVLW  00
0B30:  MOVWF  0F
0B31:  BCF    03.6
0B32:  CALL   2A8
....................       fprintf(RS232,"================================\r"); 
0B33:  MOVLW  8A
0B34:  BSF    03.6
0B35:  MOVWF  0D
0B36:  MOVLW  00
0B37:  MOVWF  0F
0B38:  BCF    03.6
0B39:  CALL   2A8
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
0B3A:  MOVLW  9B
0B3B:  BSF    03.6
0B3C:  MOVWF  0D
0B3D:  MOVLW  00
0B3E:  MOVWF  0F
0B3F:  BCF    03.6
0B40:  CALL   2A8
....................       fprintf(RS232,"================================\r"); 
0B41:  MOVLW  AC
0B42:  BSF    03.6
0B43:  MOVWF  0D
0B44:  MOVLW  00
0B45:  MOVWF  0F
0B46:  BCF    03.6
0B47:  CALL   2A8
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
0B48:  MOVLW  BD
0B49:  BSF    03.6
0B4A:  MOVWF  0D
0B4B:  MOVLW  00
0B4C:  MOVWF  0F
0B4D:  BCF    03.0
0B4E:  BCF    03.6
0B4F:  CLRF   2B
0B50:  BTFSC  0B.7
0B51:  BSF    2B.7
0B52:  BCF    0B.7
0B53:  MOVLW  08
0B54:  MOVWF  68
0B55:  BCF    0A.3
0B56:  CALL   605
0B57:  BSF    0A.3
0B58:  BTFSC  2B.7
0B59:  BSF    0B.7
0B5A:  MOVLW  C8
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  00
0B5E:  MOVWF  0F
0B5F:  BCF    03.6
0B60:  CALL   2A8
0B61:  MOVLW  C2
0B62:  BSF    03.6
0B63:  MOVWF  0D
0B64:  MOVLW  00
0B65:  MOVWF  0F
0B66:  BCF    03.0
0B67:  BCF    03.6
0B68:  CLRF   2B
0B69:  BTFSC  0B.7
0B6A:  BSF    2B.7
0B6B:  BCF    0B.7
0B6C:  MOVLW  07
0B6D:  MOVWF  68
0B6E:  BCF    0A.3
0B6F:  CALL   605
0B70:  BSF    0A.3
0B71:  BTFSC  2B.7
0B72:  BSF    0B.7
0B73:  MOVLW  CA
0B74:  BSF    03.6
0B75:  MOVWF  0D
0B76:  MOVLW  00
0B77:  MOVWF  0F
0B78:  BCF    03.6
0B79:  CALL   2A8
0B7A:  MOVLW  20
0B7B:  BTFSS  0C.4
0B7C:  GOTO   37B
0B7D:  MOVWF  19
0B7E:  MOVLW  0D
0B7F:  BTFSS  0C.4
0B80:  GOTO   37F
0B81:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0B82:  MOVLW  CB
0B83:  BSF    03.6
0B84:  MOVWF  0D
0B85:  MOVLW  00
0B86:  MOVWF  0F
0B87:  BCF    03.6
0B88:  CALL   2A8
....................       fprintf(RS232,"      DEPURACION :: TIEMPO      \r"); 
0B89:  MOVLW  DC
0B8A:  BSF    03.6
0B8B:  MOVWF  0D
0B8C:  MOVLW  00
0B8D:  MOVWF  0F
0B8E:  BCF    03.6
0B8F:  CALL   2A8
....................    } 
....................     
....................    if(DEBUG) {fputs("> Habilitacion de I2C",RS232);} 
0B90:  BTFSS  07.2
0B91:  GOTO   3A9
0B92:  MOVLW  ED
0B93:  BSF    03.6
0B94:  MOVWF  0D
0B95:  MOVLW  00
0B96:  MOVWF  0F
0B97:  BCF    03.6
0B98:  CLRF   2B
0B99:  BTFSC  0B.7
0B9A:  BSF    2B.7
0B9B:  BCF    0B.7
0B9C:  BCF    0A.3
0B9D:  CALL   125
0B9E:  BSF    0A.3
0B9F:  BTFSC  2B.7
0BA0:  BSF    0B.7
0BA1:  MOVLW  0D
0BA2:  BTFSS  0C.4
0BA3:  GOTO   3A2
0BA4:  MOVWF  19
0BA5:  MOVLW  0A
0BA6:  BTFSS  0C.4
0BA7:  GOTO   3A6
0BA8:  MOVWF  19
....................    i2c_slaveaddr(I2C_TIMER); 
0BA9:  MOVLW  0A
0BAA:  BSF    03.5
0BAB:  MOVWF  13
0BAC:  BCF    03.5
0BAD:  CLRF   2B
0BAE:  BTFSC  0B.7
0BAF:  BSF    2B.7
0BB0:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0BB1:  MOVLW  C8
0BB2:  MOVWF  74
0BB3:  BCF    0A.3
0BB4:  CALL   29A
0BB5:  BSF    0A.3
0BB6:  BTFSC  2B.7
0BB7:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
0BB8:  BTFSS  07.2
0BB9:  GOTO   3D1
0BBA:  MOVLW  F8
0BBB:  BSF    03.6
0BBC:  MOVWF  0D
0BBD:  MOVLW  00
0BBE:  MOVWF  0F
0BBF:  BCF    03.6
0BC0:  CLRF   2B
0BC1:  BTFSC  0B.7
0BC2:  BSF    2B.7
0BC3:  BCF    0B.7
0BC4:  BCF    0A.3
0BC5:  CALL   125
0BC6:  BSF    0A.3
0BC7:  BTFSC  2B.7
0BC8:  BSF    0B.7
0BC9:  MOVLW  0D
0BCA:  BTFSS  0C.4
0BCB:  GOTO   3CA
0BCC:  MOVWF  19
0BCD:  MOVLW  0A
0BCE:  BTFSS  0C.4
0BCF:  GOTO   3CE
0BD0:  MOVWF  19
....................    //TODO: Activar puertos 
....................    pTiroSU.a = PIN_B0; 
0BD1:  MOVLW  30
0BD2:  MOVWF  48
....................    pTiroSU.b = PIN_B1; 
0BD3:  MOVLW  31
0BD4:  MOVWF  49
....................    pTiroSU.c = PIN_B2; 
0BD5:  MOVLW  32
0BD6:  MOVWF  4A
....................    pTiroSU.d = PIN_B3; 
0BD7:  MOVLW  33
0BD8:  MOVWF  4B
....................     
....................    pTiroSD.a = PIN_B4; 
0BD9:  MOVLW  34
0BDA:  MOVWF  4C
....................    pTiroSD.b = PIN_B5; 
0BDB:  MOVLW  35
0BDC:  MOVWF  4D
....................    pTiroSD.c = PIN_B6; 
0BDD:  MOVLW  36
0BDE:  MOVWF  4E
....................    pTiroSD.d = PIN_B7; 
0BDF:  MOVLW  37
0BE0:  MOVWF  4F
....................     
....................    pTiempoSU.a = PIN_D0; 
0BE1:  MOVLW  40
0BE2:  MOVWF  50
....................    pTiempoSU.b = PIN_D1; 
0BE3:  MOVLW  41
0BE4:  MOVWF  51
....................    pTiempoSU.c = PIN_D2; 
0BE5:  MOVLW  42
0BE6:  MOVWF  52
....................    pTiempoSU.d = PIN_D3; 
0BE7:  MOVLW  43
0BE8:  MOVWF  53
....................     
....................    pTiempoSD.a = PIN_D4; 
0BE9:  MOVLW  44
0BEA:  MOVWF  54
....................    pTiempoSD.b = PIN_D5; 
0BEB:  MOVLW  45
0BEC:  MOVWF  55
....................    pTiempoSD.c = PIN_D6; 
0BED:  MOVLW  46
0BEE:  MOVWF  56
....................    pTiempoSD.d = PIN_D7; 
0BEF:  MOVLW  47
0BF0:  MOVWF  57
....................     
....................    pTiempoMU.a = PIN_A4; 
0BF1:  MOVLW  2C
0BF2:  MOVWF  58
....................    pTiempoMU.b = PIN_A5; 
0BF3:  MOVLW  2D
0BF4:  MOVWF  59
....................    pTiempoMU.c = PIN_A6; 
0BF5:  MOVLW  2E
0BF6:  MOVWF  5A
....................    pTiempoMU.d = PIN_A7; 
0BF7:  MOVLW  2F
0BF8:  MOVWF  5B
0BF9:  CLRF   2B
0BFA:  BTFSC  0B.7
0BFB:  BSF    2B.7
0BFC:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0BFD:  MOVLW  C8
0BFE:  MOVWF  74
0BFF:  BCF    0A.3
0C00:  CALL   29A
0C01:  BSF    0A.3
0C02:  BTFSC  2B.7
0C03:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de displays",RS232);} 
0C04:  BTFSS  07.2
0C05:  GOTO   41D
0C06:  MOVLW  06
0C07:  BSF    03.6
0C08:  MOVWF  0D
0C09:  MOVLW  01
0C0A:  MOVWF  0F
0C0B:  BCF    03.6
0C0C:  CLRF   2B
0C0D:  BTFSC  0B.7
0C0E:  BSF    2B.7
0C0F:  BCF    0B.7
0C10:  BCF    0A.3
0C11:  CALL   125
0C12:  BSF    0A.3
0C13:  BTFSC  2B.7
0C14:  BSF    0B.7
0C15:  MOVLW  0D
0C16:  BTFSS  0C.4
0C17:  GOTO   416
0C18:  MOVWF  19
0C19:  MOVLW  0A
0C1A:  BTFSS  0C.4
0C1B:  GOTO   41A
0C1C:  MOVWF  19
....................    output_bit(DISPLAY, ON);  
0C1D:  BSF    09.0
0C1E:  MOVLW  E0
0C1F:  BSF    03.5
0C20:  MOVWF  09
....................    output_bit(MINUTOD, ON);  
0C21:  BCF    03.5
0C22:  BSF    05.0
0C23:  MOVLW  00
0C24:  BSF    03.5
0C25:  MOVWF  05
....................    output_bit(PERIODO1, ON); 
0C26:  BCF    03.5
0C27:  BSF    09.1
0C28:  MOVLW  E0
0C29:  BSF    03.5
0C2A:  MOVWF  09
....................    output_bit(PERIODO2, ON); 
0C2B:  BCF    03.5
0C2C:  BSF    09.2
0C2D:  MOVLW  E0
0C2E:  BSF    03.5
0C2F:  MOVWF  09
....................    output_bit(PERIODO3, ON); 
0C30:  BCF    03.5
0C31:  BSF    07.0
0C32:  MOVLW  DC
0C33:  BSF    03.5
0C34:  MOVWF  07
....................    output_bit(PERIODO4, ON); 
0C35:  BCF    03.5
0C36:  BSF    07.1
0C37:  MOVLW  DC
0C38:  BSF    03.5
0C39:  MOVWF  07
0C3A:  BCF    03.5
0C3B:  CLRF   2B
0C3C:  BTFSC  0B.7
0C3D:  BSF    2B.7
0C3E:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C3F:  MOVLW  C8
0C40:  MOVWF  74
0C41:  BCF    0A.3
0C42:  CALL   29A
0C43:  BSF    0A.3
0C44:  BTFSC  2B.7
0C45:  BSF    0B.7
....................    output_bit(DISPLAY, OFF); 
0C46:  BCF    09.0
0C47:  MOVLW  E0
0C48:  BSF    03.5
0C49:  MOVWF  09
....................    output_bit(MINUTOD, OFF); 
0C4A:  BCF    03.5
0C4B:  BCF    05.0
0C4C:  MOVLW  00
0C4D:  BSF    03.5
0C4E:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0C4F:  BCF    03.5
0C50:  BCF    09.1
0C51:  MOVLW  E0
0C52:  BSF    03.5
0C53:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0C54:  BCF    03.5
0C55:  BCF    09.2
0C56:  MOVLW  E0
0C57:  BSF    03.5
0C58:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0C59:  BCF    03.5
0C5A:  BCF    07.0
0C5B:  MOVLW  DC
0C5C:  BSF    03.5
0C5D:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0C5E:  BCF    03.5
0C5F:  BCF    07.1
0C60:  MOVLW  DC
0C61:  BSF    03.5
0C62:  MOVWF  07
0C63:  BCF    03.5
0C64:  CLRF   2B
0C65:  BTFSC  0B.7
0C66:  BSF    2B.7
0C67:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C68:  MOVLW  C8
0C69:  MOVWF  74
0C6A:  BCF    0A.3
0C6B:  CALL   29A
0C6C:  BSF    0A.3
0C6D:  BTFSC  2B.7
0C6E:  BSF    0B.7
....................    output_bit(DISPLAY, ON); 
0C6F:  BSF    09.0
0C70:  MOVLW  E0
0C71:  BSF    03.5
0C72:  MOVWF  09
....................    output_bit(MINUTOD, ON); 
0C73:  BCF    03.5
0C74:  BSF    05.0
0C75:  MOVLW  00
0C76:  BSF    03.5
0C77:  MOVWF  05
....................    output_bit(PERIODO1, ON); 
0C78:  BCF    03.5
0C79:  BSF    09.1
0C7A:  MOVLW  E0
0C7B:  BSF    03.5
0C7C:  MOVWF  09
....................    output_bit(PERIODO2, ON); 
0C7D:  BCF    03.5
0C7E:  BSF    09.2
0C7F:  MOVLW  E0
0C80:  BSF    03.5
0C81:  MOVWF  09
....................    output_bit(PERIODO3, ON); 
0C82:  BCF    03.5
0C83:  BSF    07.0
0C84:  MOVLW  DC
0C85:  BSF    03.5
0C86:  MOVWF  07
....................    output_bit(PERIODO4, ON); 
0C87:  BCF    03.5
0C88:  BSF    07.1
0C89:  MOVLW  DC
0C8A:  BSF    03.5
0C8B:  MOVWF  07
0C8C:  BCF    03.5
0C8D:  CLRF   2B
0C8E:  BTFSC  0B.7
0C8F:  BSF    2B.7
0C90:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C91:  MOVLW  C8
0C92:  MOVWF  74
0C93:  BCF    0A.3
0C94:  CALL   29A
0C95:  BSF    0A.3
0C96:  BTFSC  2B.7
0C97:  BSF    0B.7
....................    output_bit(MINUTOD, OFF); 
0C98:  BCF    05.0
0C99:  MOVLW  00
0C9A:  BSF    03.5
0C9B:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0C9C:  BCF    03.5
0C9D:  BCF    09.1
0C9E:  MOVLW  E0
0C9F:  BSF    03.5
0CA0:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0CA1:  BCF    03.5
0CA2:  BCF    09.2
0CA3:  MOVLW  E0
0CA4:  BSF    03.5
0CA5:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0CA6:  BCF    03.5
0CA7:  BCF    07.0
0CA8:  MOVLW  DC
0CA9:  BSF    03.5
0CAA:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0CAB:  BCF    03.5
0CAC:  BCF    07.1
0CAD:  MOVLW  DC
0CAE:  BSF    03.5
0CAF:  MOVWF  07
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
0CB0:  BCF    03.5
0CB1:  BTFSS  07.2
0CB2:  GOTO   4CA
0CB3:  MOVLW  14
0CB4:  BSF    03.6
0CB5:  MOVWF  0D
0CB6:  MOVLW  01
0CB7:  MOVWF  0F
0CB8:  BCF    03.6
0CB9:  CLRF   2B
0CBA:  BTFSC  0B.7
0CBB:  BSF    2B.7
0CBC:  BCF    0B.7
0CBD:  BCF    0A.3
0CBE:  CALL   125
0CBF:  BSF    0A.3
0CC0:  BTFSC  2B.7
0CC1:  BSF    0B.7
0CC2:  MOVLW  0D
0CC3:  BTFSS  0C.4
0CC4:  GOTO   4C3
0CC5:  MOVWF  19
0CC6:  MOVLW  0A
0CC7:  BTFSS  0C.4
0CC8:  GOTO   4C7
0CC9:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
0CCA:  BSF    03.5
0CCB:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0CCC:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0CCD:  MOVLW  C0
0CCE:  BCF    03.5
0CCF:  IORWF  0B,F
0CD0:  BSF    0A.3
0CD1:  BCF    0A.4
0CD2:  GOTO   52C (RETURN)
.................... } 
....................  
.................... void main() 
0CD3:  MOVF   03,W
0CD4:  ANDLW  1F
0CD5:  MOVWF  03
0CD6:  MOVLW  71
0CD7:  BSF    03.5
0CD8:  MOVWF  0F
0CD9:  CLRF   10
0CDA:  MOVF   0F,W
0CDB:  BSF    03.6
0CDC:  BCF    07.3
0CDD:  MOVLW  0C
0CDE:  BCF    03.6
0CDF:  MOVWF  19
0CE0:  MOVLW  A2
0CE1:  MOVWF  18
0CE2:  MOVLW  90
0CE3:  BCF    03.5
0CE4:  MOVWF  18
0CE5:  MOVLW  DC
0CE6:  BSF    03.5
0CE7:  MOVWF  07
0CE8:  MOVLW  DC
0CE9:  MOVWF  07
0CEA:  MOVLW  0A
0CEB:  MOVWF  13
0CEC:  MOVLW  09
0CED:  BCF    03.5
0CEE:  MOVWF  14
0CEF:  MOVLW  FF
0CF0:  BSF    03.5
0CF1:  MOVWF  13
0CF2:  MOVLW  36
0CF3:  BCF    03.5
0CF4:  MOVWF  14
0CF5:  BSF    03.5
0CF6:  BSF    11.0
0CF7:  BSF    11.7
0CF8:  BCF    03.5
0CF9:  CLRF   40
0CFA:  BCF    41.0
0CFB:  CLRF   5F
0CFC:  CLRF   5E
0CFD:  MOVLW  03
0CFE:  MOVWF  60
0CFF:  BSF    03.5
0D00:  BSF    03.6
0D01:  MOVF   09,W
0D02:  ANDLW  C0
0D03:  MOVWF  09
0D04:  BCF    03.6
0D05:  BCF    1F.4
0D06:  BCF    1F.5
0D07:  MOVLW  00
0D08:  BSF    03.6
0D09:  MOVWF  08
0D0A:  BCF    03.5
0D0B:  CLRF   07
0D0C:  CLRF   08
0D0D:  CLRF   09
0D0E:  BCF    03.7
.................... { 
....................    setup(); 
*
0D2B:  GOTO   300
....................  
....................    while(TRUE) 
....................    { 
0D2C:  GOTO   52C
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
0D2D:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
05B5:  BTFSS  0C.5
05B6:  GOTO   5B5
05B7:  MOVF   1A,W
05B8:  MOVWF  66
.................... if(cmdGet) 
05B9:  BTFSS  41.0
05BA:  GOTO   5EB
.................... { 
....................    if(c == '#' || c == '\r') 
05BB:  MOVF   66,W
05BC:  SUBLW  23
05BD:  BTFSC  03.2
05BE:  GOTO   5C3
05BF:  MOVF   66,W
05C0:  SUBLW  0D
05C1:  BTFSS  03.2
05C2:  GOTO   5E0
....................    { 
....................       cmdGet = false; 
05C3:  BCF    41.0
....................       strcpy(cmd, rcmd); 
05C4:  CLRF   6A
05C5:  MOVLW  36
05C6:  MOVWF  69
05C7:  CLRF   68
05C8:  MOVLW  2C
05C9:  MOVWF  67
05CA:  MOVF   69,W
05CB:  MOVWF  04
05CC:  BCF    03.7
05CD:  BTFSC  6A.0
05CE:  BSF    03.7
05CF:  MOVF   00,W
05D0:  MOVWF  6B
05D1:  MOVF   67,W
05D2:  MOVWF  04
05D3:  BCF    03.7
05D4:  BTFSC  68.0
05D5:  BSF    03.7
05D6:  MOVF   6B,W
05D7:  MOVWF  00
05D8:  MOVF   00,F
05D9:  BTFSC  03.2
05DA:  GOTO   5DE
05DB:  INCF   67,F
05DC:  INCF   69,F
05DD:  GOTO   5CA
....................       parseCommand(); 
05DE:  GOTO   39D
....................    } 
05DF:  GOTO   5EB
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
05E0:  MOVF   40,W
05E1:  SUBLW  08
05E2:  BTFSS  03.0
05E3:  GOTO   5EB
....................       { 
....................          rcmd[cmdIndex] = c; 
05E4:  MOVLW  36
05E5:  ADDWF  40,W
05E6:  MOVWF  04
05E7:  BCF    03.7
05E8:  MOVF   66,W
05E9:  MOVWF  00
....................          cmdIndex++; 
05EA:  INCF   40,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
05EB:  MOVF   66,W
05EC:  SUBLW  2D
05ED:  BTFSS  03.2
05EE:  GOTO   601
....................    { 
....................        cmdGet = true;  
05EF:  BSF    41.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0"; 
05F0:  CLRF   67
05F1:  CLRF   68
05F2:  MOVLW  36
05F3:  MOVWF  04
05F4:  BCF    03.7
05F5:  MOVF   67,W
05F6:  ADDWF  04,F
05F7:  MOVF   68,W
05F8:  CALL   05A
05F9:  MOVWF  00
05FA:  IORLW  00
05FB:  BTFSC  03.2
05FC:  GOTO   600
05FD:  INCF   68,F
05FE:  INCF   67,F
05FF:  GOTO   5F2
....................        cmdIndex = 0; 
0600:  CLRF   40
....................    } 
.................... } 
....................  
0601:  BCF    0C.5
0602:  BCF    0A.3
0603:  BCF    0A.4
0604:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
*
0800:  BSF    03.5
0801:  BTFSC  14.5
0802:  GOTO   00B
0803:  BCF    03.5
0804:  CLRF   60
0805:  BSF    03.5
0806:  BTFSS  14.2
0807:  GOTO   00B
0808:  BCF    03.5
0809:  BSF    60.7
080A:  BSF    03.5
080B:  BCF    03.5
080C:  MOVF   60,W
080D:  INCF   60,F
080E:  MOVWF  66
.................... { 
....................    int state = i2c_isr_state(); 
....................       if(state== 0 )  
080F:  MOVF   66,F
0810:  BTFSS  03.2
0811:  GOTO   019
....................          i2c_read(); 
0812:  BCF    14.6
0813:  BSF    03.5
0814:  BTFSS  14.0
0815:  GOTO   014
0816:  BCF    03.5
0817:  MOVF   13,W
0818:  BSF    14.4
....................       if(state == 0x80) 
0819:  MOVF   66,W
081A:  SUBLW  80
081B:  BTFSC  03.2
081C:  GOTO   01D
....................          i2c_read(2); 
....................       if(state >= 0x80) 
081D:  MOVF   66,W
081E:  SUBLW  7F
081F:  BTFSC  03.0
0820:  GOTO   02F
....................          i2c_write(0xFF); 
0821:  MOVLW  FF
0822:  MOVWF  67
*
082D:  GOTO   2A3
082E:  BCF    03.5
....................       else if(state > 0) 
082F:  MOVF   66,F
0830:  BTFSC  03.2
0831:  GOTO   2A2
....................       { 
....................          ircmd[state - 1] = i2c_read(); 
0832:  MOVLW  01
0833:  SUBWF  66,W
0834:  ADDLW  43
0835:  MOVWF  04
0836:  BCF    03.7
0837:  BCF    14.6
0838:  BSF    03.5
0839:  BTFSS  14.0
083A:  GOTO   039
083B:  BCF    03.5
083C:  MOVF   13,W
083D:  BSF    14.4
083E:  MOVWF  00
....................          if(DEBUG) {fprintf(RS232, "> Commando: %X - %X\r",state, ircmd[state - 1]);} 
083F:  BTFSS  07.2
0840:  GOTO   072
0841:  MOVLW  01
0842:  SUBWF  66,W
0843:  ADDLW  43
0844:  MOVWF  04
0845:  BCF    03.7
0846:  MOVF   00,W
0847:  MOVWF  67
0848:  MOVLW  81
0849:  BSF    03.6
084A:  MOVWF  0D
084B:  MOVLW  06
084C:  MOVWF  0F
084D:  BCF    03.0
084E:  MOVLW  0C
084F:  BCF    03.6
0850:  MOVWF  68
0851:  BCF    0A.3
0852:  CALL   605
0853:  BSF    0A.3
0854:  MOVF   66,W
0855:  MOVWF  68
0856:  MOVLW  37
0857:  MOVWF  69
0858:  BCF    0A.3
0859:  CALL   65E
085A:  BSF    0A.3
085B:  MOVLW  20
085C:  BTFSS  0C.4
085D:  GOTO   05C
085E:  MOVWF  19
085F:  MOVLW  2D
0860:  BTFSS  0C.4
0861:  GOTO   060
0862:  MOVWF  19
0863:  MOVLW  20
0864:  BTFSS  0C.4
0865:  GOTO   064
0866:  MOVWF  19
0867:  MOVF   67,W
0868:  MOVWF  68
0869:  MOVLW  37
086A:  MOVWF  69
086B:  BCF    0A.3
086C:  CALL   65E
086D:  BSF    0A.3
086E:  MOVLW  0D
086F:  BTFSS  0C.4
0870:  GOTO   06F
0871:  MOVWF  19
....................          icmd = ircmd[state - 1]; 
0872:  MOVLW  01
0873:  SUBWF  66,W
0874:  ADDLW  43
0875:  MOVWF  04
0876:  BCF    03.7
0877:  MOVF   00,W
0878:  MOVWF  42
....................          parseI2CCommand(); 
....................       } 
*
0AA3:  BCF    03.5
0AA4:  BCF    0C.3
0AA5:  BCF    0A.3
0AA6:  BCF    0A.4
0AA7:  GOTO   033
.................... } 
....................  
.................... void parseI2CCommand(void) 
*
0879:  MOVF   42,W
087A:  MOVWF  67
.................... { 
....................    int c = icmd; 
....................    switch(c) 
087B:  MOVF   67,W
087C:  XORLW  0A
087D:  BTFSC  03.2
087E:  GOTO   0A7
087F:  XORLW  06
0880:  BTFSC  03.2
0881:  GOTO   0BB
0882:  XORLW  7C
0883:  BTFSC  03.2
0884:  GOTO   0CF
0885:  XORLW  01
0886:  BTFSC  03.2
0887:  GOTO   0E7
0888:  XORLW  03
0889:  BTFSC  03.2
088A:  GOTO   100
088B:  XORLW  01
088C:  BTFSC  03.2
088D:  GOTO   119
088E:  XORLW  07
088F:  BTFSC  03.2
0890:  GOTO   132
0891:  XORLW  01
0892:  BTFSC  03.2
0893:  GOTO   14B
0894:  XORLW  03
0895:  BTFSC  03.2
0896:  GOTO   164
0897:  XORLW  F7
0898:  BTFSC  03.2
0899:  GOTO   17D
089A:  XORLW  03
089B:  BTFSC  03.2
089C:  GOTO   196
089D:  XORLW  01
089E:  BTFSC  03.2
089F:  GOTO   1AF
08A0:  XORLW  7C
08A1:  BTFSC  03.2
08A2:  GOTO   1C8
08A3:  XORLW  02
08A4:  BTFSC  03.2
08A5:  GOTO   1CC
08A6:  GOTO   1D0
....................    { 
....................       case I2C_TIMER:      if(DEBUG) {fputs("> Direccion TIMER",RS232);} 
08A7:  BTFSS  07.2
08A8:  GOTO   0BA
08A9:  MOVLW  8C
08AA:  BSF    03.6
08AB:  MOVWF  0D
08AC:  MOVLW  06
08AD:  MOVWF  0F
08AE:  BCF    0A.3
08AF:  BCF    03.6
08B0:  CALL   125
08B1:  BSF    0A.3
08B2:  MOVLW  0D
08B3:  BTFSS  0C.4
08B4:  GOTO   0B3
08B5:  MOVWF  19
08B6:  MOVLW  0A
08B7:  BTFSS  0C.4
08B8:  GOTO   0B7
08B9:  MOVWF  19
....................                            break; 
08BA:  GOTO   1D0
....................       case I2C_SCORE:      if(DEBUG) {fputs("> Direccion SCORE",RS232);} 
08BB:  BTFSS  07.2
08BC:  GOTO   0CE
08BD:  MOVLW  95
08BE:  BSF    03.6
08BF:  MOVWF  0D
08C0:  MOVLW  06
08C1:  MOVWF  0F
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   125
08C5:  BSF    0A.3
08C6:  MOVLW  0D
08C7:  BTFSS  0C.4
08C8:  GOTO   0C7
08C9:  MOVWF  19
08CA:  MOVLW  0A
08CB:  BTFSS  0C.4
08CC:  GOTO   0CB
08CD:  MOVWF  19
....................                            break; 
08CE:  GOTO   1D0
....................       case I2C_CMD_PER0:   if(DEBUG) {fputs("> Apagar Periodos",RS232);} 
08CF:  BTFSS  07.2
08D0:  GOTO   0E2
08D1:  MOVLW  9E
08D2:  BSF    03.6
08D3:  MOVWF  0D
08D4:  MOVLW  06
08D5:  MOVWF  0F
08D6:  BCF    0A.3
08D7:  BCF    03.6
08D8:  CALL   125
08D9:  BSF    0A.3
08DA:  MOVLW  0D
08DB:  BTFSS  0C.4
08DC:  GOTO   0DB
08DD:  MOVWF  19
08DE:  MOVLW  0A
08DF:  BTFSS  0C.4
08E0:  GOTO   0DF
08E1:  MOVWF  19
....................                            showQuarter(0); 
08E2:  CLRF   72
08E3:  BCF    0A.3
08E4:  CALL   260
08E5:  BSF    0A.3
....................                            break; 
08E6:  GOTO   1D0
....................       case I2C_CMD_PER1:   if(DEBUG) {fputs("> Activar Periodo 1",RS232);} 
08E7:  BTFSS  07.2
08E8:  GOTO   0FA
08E9:  MOVLW  A7
08EA:  BSF    03.6
08EB:  MOVWF  0D
08EC:  MOVLW  06
08ED:  MOVWF  0F
08EE:  BCF    0A.3
08EF:  BCF    03.6
08F0:  CALL   125
08F1:  BSF    0A.3
08F2:  MOVLW  0D
08F3:  BTFSS  0C.4
08F4:  GOTO   0F3
08F5:  MOVWF  19
08F6:  MOVLW  0A
08F7:  BTFSS  0C.4
08F8:  GOTO   0F7
08F9:  MOVWF  19
....................                            showQuarter(1); 
08FA:  MOVLW  01
08FB:  MOVWF  72
08FC:  BCF    0A.3
08FD:  CALL   260
08FE:  BSF    0A.3
....................                            break; 
08FF:  GOTO   1D0
....................       case I2C_CMD_PER2:   if(DEBUG) {fputs("> Activar Periodo 2",RS232);} 
0900:  BTFSS  07.2
0901:  GOTO   113
0902:  MOVLW  B1
0903:  BSF    03.6
0904:  MOVWF  0D
0905:  MOVLW  06
0906:  MOVWF  0F
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   125
090A:  BSF    0A.3
090B:  MOVLW  0D
090C:  BTFSS  0C.4
090D:  GOTO   10C
090E:  MOVWF  19
090F:  MOVLW  0A
0910:  BTFSS  0C.4
0911:  GOTO   110
0912:  MOVWF  19
....................                            showQuarter(2); 
0913:  MOVLW  02
0914:  MOVWF  72
0915:  BCF    0A.3
0916:  CALL   260
0917:  BSF    0A.3
....................                            break; 
0918:  GOTO   1D0
....................       case I2C_CMD_PER3:   if(DEBUG) {fputs("> Activar Periodo 3",RS232);} 
0919:  BTFSS  07.2
091A:  GOTO   12C
091B:  MOVLW  BB
091C:  BSF    03.6
091D:  MOVWF  0D
091E:  MOVLW  06
091F:  MOVWF  0F
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   125
0923:  BSF    0A.3
0924:  MOVLW  0D
0925:  BTFSS  0C.4
0926:  GOTO   125
0927:  MOVWF  19
0928:  MOVLW  0A
0929:  BTFSS  0C.4
092A:  GOTO   129
092B:  MOVWF  19
....................                            showQuarter(3); 
092C:  MOVLW  03
092D:  MOVWF  72
092E:  BCF    0A.3
092F:  CALL   260
0930:  BSF    0A.3
....................                            break; 
0931:  GOTO   1D0
....................       case I2C_CMD_PER4:   if(DEBUG) {fputs("> Activar Periodo 4",RS232);} 
0932:  BTFSS  07.2
0933:  GOTO   145
0934:  MOVLW  C5
0935:  BSF    03.6
0936:  MOVWF  0D
0937:  MOVLW  06
0938:  MOVWF  0F
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   125
093C:  BSF    0A.3
093D:  MOVLW  0D
093E:  BTFSS  0C.4
093F:  GOTO   13E
0940:  MOVWF  19
0941:  MOVLW  0A
0942:  BTFSS  0C.4
0943:  GOTO   142
0944:  MOVWF  19
....................                            showQuarter(4); 
0945:  MOVLW  04
0946:  MOVWF  72
0947:  BCF    0A.3
0948:  CALL   260
0949:  BSF    0A.3
....................                            break; 
094A:  GOTO   1D0
....................       case I2C_CMD_MDON:   if(DEBUG) {fputs("> Activar Minuto Decena",RS232);} 
094B:  BTFSS  07.2
094C:  GOTO   15E
094D:  MOVLW  CF
094E:  BSF    03.6
094F:  MOVWF  0D
0950:  MOVLW  06
0951:  MOVWF  0F
0952:  BCF    0A.3
0953:  BCF    03.6
0954:  CALL   125
0955:  BSF    0A.3
0956:  MOVLW  0D
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
095A:  MOVLW  0A
095B:  BTFSS  0C.4
095C:  GOTO   15B
095D:  MOVWF  19
....................                            output_bit(MINUTOD, ON); 
095E:  BSF    05.0
095F:  MOVLW  00
0960:  BSF    03.5
0961:  MOVWF  05
....................                            break; 
0962:  BCF    03.5
0963:  GOTO   1D0
....................       case I2C_CMD_MDOF:   if(DEBUG) {fputs("> Desactivar Minuto Decena",RS232);} 
0964:  BTFSS  07.2
0965:  GOTO   177
0966:  MOVLW  DB
0967:  BSF    03.6
0968:  MOVWF  0D
0969:  MOVLW  06
096A:  MOVWF  0F
096B:  BCF    0A.3
096C:  BCF    03.6
096D:  CALL   125
096E:  BSF    0A.3
096F:  MOVLW  0D
0970:  BTFSS  0C.4
0971:  GOTO   170
0972:  MOVWF  19
0973:  MOVLW  0A
0974:  BTFSS  0C.4
0975:  GOTO   174
0976:  MOVWF  19
....................                            output_bit(MINUTOD, OFF); 
0977:  BCF    05.0
0978:  MOVLW  00
0979:  BSF    03.5
097A:  MOVWF  05
....................                            break; 
097B:  BCF    03.5
097C:  GOTO   1D0
....................       case I2C_CMD_BUZ1:   if(DEBUG) {fputs("> Toque Corto",RS232);} 
097D:  BTFSS  07.2
097E:  GOTO   190
097F:  MOVLW  E9
0980:  BSF    03.6
0981:  MOVWF  0D
0982:  MOVLW  06
0983:  MOVWF  0F
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   125
0987:  BSF    0A.3
0988:  MOVLW  0D
0989:  BTFSS  0C.4
098A:  GOTO   189
098B:  MOVWF  19
098C:  MOVLW  0A
098D:  BTFSS  0C.4
098E:  GOTO   18D
098F:  MOVWF  19
....................                            buzz(1); 
0990:  MOVLW  01
0991:  MOVWF  72
0992:  BCF    0A.3
0993:  CALL   2AE
0994:  BSF    0A.3
....................                            break; 
0995:  GOTO   1D0
....................       case I2C_CMD_BUZ2:   if(DEBUG) {fputs("> Toque Largo",RS232);} 
0996:  BTFSS  07.2
0997:  GOTO   1A9
0998:  MOVLW  F0
0999:  BSF    03.6
099A:  MOVWF  0D
099B:  MOVLW  06
099C:  MOVWF  0F
099D:  BCF    0A.3
099E:  BCF    03.6
099F:  CALL   125
09A0:  BSF    0A.3
09A1:  MOVLW  0D
09A2:  BTFSS  0C.4
09A3:  GOTO   1A2
09A4:  MOVWF  19
09A5:  MOVLW  0A
09A6:  BTFSS  0C.4
09A7:  GOTO   1A6
09A8:  MOVWF  19
....................                            buzz(2); 
09A9:  MOVLW  02
09AA:  MOVWF  72
09AB:  BCF    0A.3
09AC:  CALL   2AE
09AD:  BSF    0A.3
....................                            break; 
09AE:  GOTO   1D0
....................       case I2C_CMD_BUZ3:   if(DEBUG) {fputs("> Toque Doble",RS232);} 
09AF:  BTFSS  07.2
09B0:  GOTO   1C2
09B1:  MOVLW  F7
09B2:  BSF    03.6
09B3:  MOVWF  0D
09B4:  MOVLW  06
09B5:  MOVWF  0F
09B6:  BCF    0A.3
09B7:  BCF    03.6
09B8:  CALL   125
09B9:  BSF    0A.3
09BA:  MOVLW  0D
09BB:  BTFSS  0C.4
09BC:  GOTO   1BB
09BD:  MOVWF  19
09BE:  MOVLW  0A
09BF:  BTFSS  0C.4
09C0:  GOTO   1BF
09C1:  MOVWF  19
....................                            buzz(3); 
09C2:  MOVLW  03
09C3:  MOVWF  72
09C4:  BCF    0A.3
09C5:  CALL   2AE
09C6:  BSF    0A.3
....................                            break; 
09C7:  GOTO   1D0
....................       case I2C_CMD_TEST:   doTest(); 
09C8:  BCF    0A.3
09C9:  CALL   30F
09CA:  BSF    0A.3
....................                            break; 
09CB:  GOTO   1D0
....................       case I2C_CMD_RESET:  doReset(); 
09CC:  BCF    0A.3
09CD:  CALL   389
09CE:  BSF    0A.3
....................                            break; 
09CF:  GOTO   1D0
....................    } 
....................     
....................    if(c > 0x0F && c < 0x1A) //0x10 - 0x19 
09D0:  MOVF   67,W
09D1:  SUBLW  0F
09D2:  BTFSC  03.0
09D3:  GOTO   1FA
09D4:  MOVF   67,W
09D5:  SUBLW  19
09D6:  BTFSS  03.0
09D7:  GOTO   1FA
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 1",RS232);} 
09D8:  BTFSS  07.2
09D9:  GOTO   1EB
09DA:  MOVLW  FE
09DB:  BSF    03.6
09DC:  MOVWF  0D
09DD:  MOVLW  06
09DE:  MOVWF  0F
09DF:  BCF    0A.3
09E0:  BCF    03.6
09E1:  CALL   125
09E2:  BSF    0A.3
09E3:  MOVLW  0D
09E4:  BTFSS  0C.4
09E5:  GOTO   1E4
09E6:  MOVWF  19
09E7:  MOVLW  0A
09E8:  BTFSS  0C.4
09E9:  GOTO   1E8
09EA:  MOVWF  19
....................       showNumber(c - 0x10, pTiroSU);    
09EB:  MOVLW  10
09EC:  SUBWF  67,W
09ED:  MOVWF  68
09EE:  MOVWF  72
09EF:  MOVF   4B,W
09F0:  MOVWF  76
09F1:  MOVF   4A,W
09F2:  MOVWF  75
09F3:  MOVF   49,W
09F4:  MOVWF  74
09F5:  MOVF   48,W
09F6:  MOVWF  73
09F7:  BCF    0A.3
09F8:  CALL   1D8
09F9:  BSF    0A.3
....................    } 
....................    if(c > 0x1F && c < 0x2A) //0x20 - 0x29 
09FA:  MOVF   67,W
09FB:  SUBLW  1F
09FC:  BTFSC  03.0
09FD:  GOTO   224
09FE:  MOVF   67,W
09FF:  SUBLW  29
0A00:  BTFSS  03.0
0A01:  GOTO   224
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 2",RS232);} 
0A02:  BTFSS  07.2
0A03:  GOTO   215
0A04:  MOVLW  09
0A05:  BSF    03.6
0A06:  MOVWF  0D
0A07:  MOVLW  07
0A08:  MOVWF  0F
0A09:  BCF    0A.3
0A0A:  BCF    03.6
0A0B:  CALL   125
0A0C:  BSF    0A.3
0A0D:  MOVLW  0D
0A0E:  BTFSS  0C.4
0A0F:  GOTO   20E
0A10:  MOVWF  19
0A11:  MOVLW  0A
0A12:  BTFSS  0C.4
0A13:  GOTO   212
0A14:  MOVWF  19
....................       showNumber(c - 0x20, pTiroSD);    
0A15:  MOVLW  20
0A16:  SUBWF  67,W
0A17:  MOVWF  68
0A18:  MOVWF  72
0A19:  MOVF   4F,W
0A1A:  MOVWF  76
0A1B:  MOVF   4E,W
0A1C:  MOVWF  75
0A1D:  MOVF   4D,W
0A1E:  MOVWF  74
0A1F:  MOVF   4C,W
0A20:  MOVWF  73
0A21:  BCF    0A.3
0A22:  CALL   1D8
0A23:  BSF    0A.3
....................    } 
....................    if(c > 0x2F && c < 0x3A) //0x30 - 0x39 
0A24:  MOVF   67,W
0A25:  SUBLW  2F
0A26:  BTFSC  03.0
0A27:  GOTO   24E
0A28:  MOVF   67,W
0A29:  SUBLW  39
0A2A:  BTFSS  03.0
0A2B:  GOTO   24E
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 3",RS232);} 
0A2C:  BTFSS  07.2
0A2D:  GOTO   23F
0A2E:  MOVLW  14
0A2F:  BSF    03.6
0A30:  MOVWF  0D
0A31:  MOVLW  07
0A32:  MOVWF  0F
0A33:  BCF    0A.3
0A34:  BCF    03.6
0A35:  CALL   125
0A36:  BSF    0A.3
0A37:  MOVLW  0D
0A38:  BTFSS  0C.4
0A39:  GOTO   238
0A3A:  MOVWF  19
0A3B:  MOVLW  0A
0A3C:  BTFSS  0C.4
0A3D:  GOTO   23C
0A3E:  MOVWF  19
....................       showNumber(c - 0x30, pTiempoSD);    
0A3F:  MOVLW  30
0A40:  SUBWF  67,W
0A41:  MOVWF  68
0A42:  MOVWF  72
0A43:  MOVF   57,W
0A44:  MOVWF  76
0A45:  MOVF   56,W
0A46:  MOVWF  75
0A47:  MOVF   55,W
0A48:  MOVWF  74
0A49:  MOVF   54,W
0A4A:  MOVWF  73
0A4B:  BCF    0A.3
0A4C:  CALL   1D8
0A4D:  BSF    0A.3
....................    } 
....................    if(c > 0x3F && c < 0x4A) //0x40 - 0x49 
0A4E:  MOVF   67,W
0A4F:  SUBLW  3F
0A50:  BTFSC  03.0
0A51:  GOTO   278
0A52:  MOVF   67,W
0A53:  SUBLW  49
0A54:  BTFSS  03.0
0A55:  GOTO   278
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 4",RS232);} 
0A56:  BTFSS  07.2
0A57:  GOTO   269
0A58:  MOVLW  1F
0A59:  BSF    03.6
0A5A:  MOVWF  0D
0A5B:  MOVLW  07
0A5C:  MOVWF  0F
0A5D:  BCF    0A.3
0A5E:  BCF    03.6
0A5F:  CALL   125
0A60:  BSF    0A.3
0A61:  MOVLW  0D
0A62:  BTFSS  0C.4
0A63:  GOTO   262
0A64:  MOVWF  19
0A65:  MOVLW  0A
0A66:  BTFSS  0C.4
0A67:  GOTO   266
0A68:  MOVWF  19
....................       showNumber(c - 0x40, pTiempoSU);    
0A69:  MOVLW  40
0A6A:  SUBWF  67,W
0A6B:  MOVWF  68
0A6C:  MOVWF  72
0A6D:  MOVF   53,W
0A6E:  MOVWF  76
0A6F:  MOVF   52,W
0A70:  MOVWF  75
0A71:  MOVF   51,W
0A72:  MOVWF  74
0A73:  MOVF   50,W
0A74:  MOVWF  73
0A75:  BCF    0A.3
0A76:  CALL   1D8
0A77:  BSF    0A.3
....................    } 
....................       if(c > 0x4F && c < 0x5A) //0x50 - 0x59 
0A78:  MOVF   67,W
0A79:  SUBLW  4F
0A7A:  BTFSC  03.0
0A7B:  GOTO   2A2
0A7C:  MOVF   67,W
0A7D:  SUBLW  59
0A7E:  BTFSS  03.0
0A7F:  GOTO   2A2
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 5",RS232);} 
0A80:  BTFSS  07.2
0A81:  GOTO   293
0A82:  MOVLW  2A
0A83:  BSF    03.6
0A84:  MOVWF  0D
0A85:  MOVLW  07
0A86:  MOVWF  0F
0A87:  BCF    0A.3
0A88:  BCF    03.6
0A89:  CALL   125
0A8A:  BSF    0A.3
0A8B:  MOVLW  0D
0A8C:  BTFSS  0C.4
0A8D:  GOTO   28C
0A8E:  MOVWF  19
0A8F:  MOVLW  0A
0A90:  BTFSS  0C.4
0A91:  GOTO   290
0A92:  MOVWF  19
....................       showNumber(c - 0x50, pTiempoMU);    
0A93:  MOVLW  50
0A94:  SUBWF  67,W
0A95:  MOVWF  68
0A96:  MOVWF  72
0A97:  MOVF   5B,W
0A98:  MOVWF  76
0A99:  MOVF   5A,W
0A9A:  MOVWF  75
0A9B:  MOVF   59,W
0A9C:  MOVWF  74
0A9D:  MOVF   58,W
0A9E:  MOVWF  73
0A9F:  BCF    0A.3
0AA0:  CALL   1D8
0AA1:  BSF    0A.3
0AA2:  BSF    03.5
....................    } 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
030F:  BTFSS  07.2
0310:  GOTO   320
0311:  MOVLW  35
0312:  BSF    03.6
0313:  MOVWF  0D
0314:  MOVLW  07
0315:  MOVWF  0F
0316:  BCF    03.6
0317:  CALL   125
0318:  MOVLW  0D
0319:  BTFSS  0C.4
031A:  GOTO   319
031B:  MOVWF  19
031C:  MOVLW  0A
031D:  BTFSS  0C.4
031E:  GOTO   31D
031F:  MOVWF  19
....................    output_bit(MINUTOD, OFF); 
0320:  BCF    05.0
0321:  MOVLW  00
0322:  BSF    03.5
0323:  MOVWF  05
....................    output_bit(PERIODO1, OFF); 
0324:  BCF    03.5
0325:  BCF    09.1
0326:  MOVLW  E0
0327:  BSF    03.5
0328:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0329:  BCF    03.5
032A:  BCF    09.2
032B:  MOVLW  E0
032C:  BSF    03.5
032D:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
032E:  BCF    03.5
032F:  BCF    07.0
0330:  MOVLW  DC
0331:  BSF    03.5
0332:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
0333:  BCF    03.5
0334:  BCF    07.1
0335:  MOVLW  DC
0336:  BSF    03.5
0337:  MOVWF  07
....................    for(int i=0; i<10; i++) 
0338:  CLRF   71
0339:  MOVF   71,W
033A:  SUBLW  09
033B:  BTFSS  03.0
033C:  GOTO   384
....................    { 
....................       showNumber(i, pTiroSD); 
033D:  MOVF   71,W
033E:  MOVWF  72
033F:  BCF    03.5
0340:  MOVF   4F,W
0341:  MOVWF  76
0342:  MOVF   4E,W
0343:  MOVWF  75
0344:  MOVF   4D,W
0345:  MOVWF  74
0346:  MOVF   4C,W
0347:  MOVWF  73
0348:  CALL   1D8
....................       showNumber(i, pTiroSU); 
0349:  MOVF   71,W
034A:  MOVWF  72
034B:  MOVF   4B,W
034C:  MOVWF  76
034D:  MOVF   4A,W
034E:  MOVWF  75
034F:  MOVF   49,W
0350:  MOVWF  74
0351:  MOVF   48,W
0352:  MOVWF  73
0353:  CALL   1D8
....................       showNumber(i, pTiempoSD); 
0354:  MOVF   71,W
0355:  MOVWF  72
0356:  MOVF   57,W
0357:  MOVWF  76
0358:  MOVF   56,W
0359:  MOVWF  75
035A:  MOVF   55,W
035B:  MOVWF  74
035C:  MOVF   54,W
035D:  MOVWF  73
035E:  CALL   1D8
....................       showNumber(i, pTiempoSU); 
035F:  MOVF   71,W
0360:  MOVWF  72
0361:  MOVF   53,W
0362:  MOVWF  76
0363:  MOVF   52,W
0364:  MOVWF  75
0365:  MOVF   51,W
0366:  MOVWF  74
0367:  MOVF   50,W
0368:  MOVWF  73
0369:  CALL   1D8
....................       showNumber(i, pTiempoMU); 
036A:  MOVF   71,W
036B:  MOVWF  72
036C:  MOVF   5B,W
036D:  MOVWF  76
036E:  MOVF   5A,W
036F:  MOVWF  75
0370:  MOVF   59,W
0371:  MOVWF  74
0372:  MOVF   58,W
0373:  MOVWF  73
0374:  CALL   1D8
....................       output_toggle(MINUTOD); 
0375:  MOVLW  00
0376:  BSF    03.5
0377:  MOVWF  05
0378:  MOVLW  01
0379:  BCF    03.5
037A:  XORWF  05,F
....................       showQuarter(i); 
037B:  MOVF   71,W
037C:  MOVWF  72
037D:  CALL   260
....................       delay_ms(DEFAULT_D); 
037E:  MOVLW  C8
037F:  MOVWF  74
0380:  CALL   29A
0381:  INCF   71,F
0382:  BSF    03.5
0383:  GOTO   339
....................    } 
....................    buzz(1); 
0384:  MOVLW  01
0385:  MOVWF  72
0386:  BCF    03.5
0387:  CALL   2AE
0388:  RETURN
.................... } 
....................  
.................... void buzz(int t) 
.................... { 
....................    switch(t) 
*
02AE:  MOVF   72,W
02AF:  XORLW  01
02B0:  BTFSC  03.2
02B1:  GOTO   2B9
02B2:  XORLW  03
02B3:  BTFSC  03.2
02B4:  GOTO   2CE
02B5:  XORLW  01
02B6:  BTFSC  03.2
02B7:  GOTO   2E3
02B8:  GOTO   30E
....................    { 
....................       case 1:  //TOOT 
....................                output_bit(BUZZER, ON); 
02B9:  BSF    05.1
02BA:  MOVLW  00
02BB:  BSF    03.5
02BC:  MOVWF  05
....................                delay_ms(1000); 
02BD:  MOVLW  04
02BE:  MOVWF  73
02BF:  MOVLW  FA
02C0:  MOVWF  74
02C1:  BCF    03.5
02C2:  CALL   29A
02C3:  DECFSZ 73,F
02C4:  GOTO   2C6
02C5:  GOTO   2C8
02C6:  BSF    03.5
02C7:  GOTO   2BF
....................                output_bit(BUZZER, OFF); 
02C8:  BCF    05.1
02C9:  MOVLW  00
02CA:  BSF    03.5
02CB:  MOVWF  05
....................                break; 
02CC:  BCF    03.5
02CD:  GOTO   30E
....................       case 2:  //LONG BUZZ 
....................                output_bit(BUZZER, ON); 
02CE:  BSF    05.1
02CF:  MOVLW  00
02D0:  BSF    03.5
02D1:  MOVWF  05
....................                delay_ms(3000); 
02D2:  MOVLW  0C
02D3:  MOVWF  73
02D4:  MOVLW  FA
02D5:  MOVWF  74
02D6:  BCF    03.5
02D7:  CALL   29A
02D8:  DECFSZ 73,F
02D9:  GOTO   2DB
02DA:  GOTO   2DD
02DB:  BSF    03.5
02DC:  GOTO   2D4
....................                output_bit(BUZZER, OFF); 
02DD:  BCF    05.1
02DE:  MOVLW  00
02DF:  BSF    03.5
02E0:  MOVWF  05
....................                break; 
02E1:  BCF    03.5
02E2:  GOTO   30E
....................       case 3:  //DOUBLE 
....................                output_bit(BUZZER, ON); 
02E3:  BSF    05.1
02E4:  MOVLW  00
02E5:  BSF    03.5
02E6:  MOVWF  05
....................                delay_ms(1000); 
02E7:  MOVLW  04
02E8:  MOVWF  73
02E9:  MOVLW  FA
02EA:  MOVWF  74
02EB:  BCF    03.5
02EC:  CALL   29A
02ED:  DECFSZ 73,F
02EE:  GOTO   2F0
02EF:  GOTO   2F2
02F0:  BSF    03.5
02F1:  GOTO   2E9
....................                output_bit(BUZZER, OFF); 
02F2:  BCF    05.1
02F3:  MOVLW  00
02F4:  BSF    03.5
02F5:  MOVWF  05
....................                delay_ms(250); 
02F6:  MOVLW  FA
02F7:  MOVWF  74
02F8:  BCF    03.5
02F9:  CALL   29A
....................                output_bit(BUZZER, ON); 
02FA:  BSF    05.1
02FB:  MOVLW  00
02FC:  BSF    03.5
02FD:  MOVWF  05
....................                delay_ms(1000); 
02FE:  MOVLW  04
02FF:  MOVWF  73
0300:  MOVLW  FA
0301:  MOVWF  74
0302:  BCF    03.5
0303:  CALL   29A
0304:  DECFSZ 73,F
0305:  GOTO   307
0306:  GOTO   309
0307:  BSF    03.5
0308:  GOTO   300
....................                output_bit(BUZZER, OFF); 
0309:  BCF    05.1
030A:  MOVLW  00
030B:  BSF    03.5
030C:  MOVWF  05
....................                break; 
030D:  BCF    03.5
....................    } 
030E:  RETURN
.................... } 
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
039D:  CLRF   74
039E:  MOVLW  2C
039F:  MOVWF  73
03A0:  CLRF   72
03A1:  MOVLW  67
03A2:  MOVWF  71
03A3:  MOVF   73,W
03A4:  MOVWF  04
03A5:  BCF    03.7
03A6:  BTFSC  74.0
03A7:  BSF    03.7
03A8:  MOVF   00,W
03A9:  MOVWF  75
03AA:  MOVF   71,W
03AB:  MOVWF  04
03AC:  BCF    03.7
03AD:  BTFSC  72.0
03AE:  BSF    03.7
03AF:  MOVF   75,W
03B0:  MOVWF  00
03B1:  MOVF   00,F
03B2:  BTFSC  03.2
03B3:  GOTO   3B7
03B4:  INCF   71,F
03B5:  INCF   73,F
03B6:  GOTO   3A3
....................    switch(c[0]) 
03B7:  MOVF   67,W
03B8:  XORLW  30
03B9:  BTFSC  03.2
03BA:  GOTO   3E0
03BB:  XORLW  71
03BC:  BTFSC  03.2
03BD:  GOTO   448
03BE:  XORLW  03
03BF:  BTFSC  03.2
03C0:  GOTO   45C
03C1:  XORLW  01
03C2:  BTFSC  03.2
03C3:  GOTO   471
03C4:  XORLW  07
03C5:  BTFSC  03.2
03C6:  GOTO   486
03C7:  XORLW  01
03C8:  BTFSC  03.2
03C9:  GOTO   49B
03CA:  XORLW  03
03CB:  BTFSC  03.2
03CC:  GOTO   4B0
03CD:  XORLW  01
03CE:  BTFSC  03.2
03CF:  GOTO   4C7
03D0:  XORLW  0F
03D1:  BTFSC  03.2
03D2:  GOTO   4DE
03D3:  XORLW  01
03D4:  BTFSC  03.2
03D5:  GOTO   4F3
03D6:  XORLW  03
03D7:  BTFSC  03.2
03D8:  GOTO   508
03D9:  XORLW  12
03DA:  BTFSC  03.2
03DB:  GOTO   51D
03DC:  XORLW  02
03DD:  BTFSC  03.2
03DE:  GOTO   51F
03DF:  GOTO   5A9
....................    { 
....................       case '0':   if(DEBUG) {fputs("\r> Activacion manual de puerto",RS232);} 
03E0:  BTFSS  07.2
03E1:  GOTO   3F1
03E2:  MOVLW  3F
03E3:  BSF    03.6
03E4:  MOVWF  0D
03E5:  MOVLW  07
03E6:  MOVWF  0F
03E7:  BCF    03.6
03E8:  CALL   125
03E9:  MOVLW  0D
03EA:  BTFSS  0C.4
03EB:  GOTO   3EA
03EC:  MOVWF  19
03ED:  MOVLW  0A
03EE:  BTFSS  0C.4
03EF:  GOTO   3EE
03F0:  MOVWF  19
....................                   switch(c[2]) 
03F1:  MOVLW  31
03F2:  SUBWF  69,W
03F3:  ADDLW  FB
03F4:  BTFSC  03.0
03F5:  GOTO   447
03F6:  ADDLW  05
03F7:  GOTO   5AC
....................                   { 
....................                      case '1':   showNumber(char2int(c[3]), pTiroSU); 
03F8:  MOVF   6A,W
03F9:  MOVWF  71
03FA:  CALL   177
03FB:  MOVF   78,W
03FC:  MOVWF  71
03FD:  MOVWF  72
03FE:  MOVF   4B,W
03FF:  MOVWF  76
0400:  MOVF   4A,W
0401:  MOVWF  75
0402:  MOVF   49,W
0403:  MOVWF  74
0404:  MOVF   48,W
0405:  MOVWF  73
0406:  CALL   1D8
....................                                  break; 
0407:  GOTO   447
....................                      case '2':   showNumber(char2int(c[3]), pTiroSD); 
0408:  MOVF   6A,W
0409:  MOVWF  71
040A:  CALL   177
040B:  MOVF   78,W
040C:  MOVWF  71
040D:  MOVWF  72
040E:  MOVF   4F,W
040F:  MOVWF  76
0410:  MOVF   4E,W
0411:  MOVWF  75
0412:  MOVF   4D,W
0413:  MOVWF  74
0414:  MOVF   4C,W
0415:  MOVWF  73
0416:  CALL   1D8
....................                                  break; 
0417:  GOTO   447
....................                      case '3':   showNumber(char2int(c[3]), pTiempoSD); 
0418:  MOVF   6A,W
0419:  MOVWF  71
041A:  CALL   177
041B:  MOVF   78,W
041C:  MOVWF  71
041D:  MOVWF  72
041E:  MOVF   57,W
041F:  MOVWF  76
0420:  MOVF   56,W
0421:  MOVWF  75
0422:  MOVF   55,W
0423:  MOVWF  74
0424:  MOVF   54,W
0425:  MOVWF  73
0426:  CALL   1D8
....................                                  break; 
0427:  GOTO   447
....................                      case '4':   showNumber(char2int(c[3]), pTiempoSU); 
0428:  MOVF   6A,W
0429:  MOVWF  71
042A:  CALL   177
042B:  MOVF   78,W
042C:  MOVWF  71
042D:  MOVWF  72
042E:  MOVF   53,W
042F:  MOVWF  76
0430:  MOVF   52,W
0431:  MOVWF  75
0432:  MOVF   51,W
0433:  MOVWF  74
0434:  MOVF   50,W
0435:  MOVWF  73
0436:  CALL   1D8
....................                                  break; 
0437:  GOTO   447
....................                      case '5':   showNumber(char2int(c[3]), pTiempoMU); 
0438:  MOVF   6A,W
0439:  MOVWF  71
043A:  CALL   177
043B:  MOVF   78,W
043C:  MOVWF  71
043D:  MOVWF  72
043E:  MOVF   5B,W
043F:  MOVWF  76
0440:  MOVF   5A,W
0441:  MOVWF  75
0442:  MOVF   59,W
0443:  MOVWF  74
0444:  MOVF   58,W
0445:  MOVWF  73
0446:  CALL   1D8
....................                                  break; 
....................                   } 
....................                   break; 
0447:  GOTO   5A9
....................       case 'A':   if(DEBUG) {fputs("> Apagar Periodos",RS232);} 
0448:  BTFSS  07.2
0449:  GOTO   459
044A:  MOVLW  4F
044B:  BSF    03.6
044C:  MOVWF  0D
044D:  MOVLW  07
044E:  MOVWF  0F
044F:  BCF    03.6
0450:  CALL   125
0451:  MOVLW  0D
0452:  BTFSS  0C.4
0453:  GOTO   452
0454:  MOVWF  19
0455:  MOVLW  0A
0456:  BTFSS  0C.4
0457:  GOTO   456
0458:  MOVWF  19
....................                            showQuarter(0); 
0459:  CLRF   72
045A:  CALL   260
....................                            break; 
045B:  GOTO   5A9
....................       case 'B':   if(DEBUG) {fputs("> Activar Periodo 1",RS232);} 
045C:  BTFSS  07.2
045D:  GOTO   46D
045E:  MOVLW  58
045F:  BSF    03.6
0460:  MOVWF  0D
0461:  MOVLW  07
0462:  MOVWF  0F
0463:  BCF    03.6
0464:  CALL   125
0465:  MOVLW  0D
0466:  BTFSS  0C.4
0467:  GOTO   466
0468:  MOVWF  19
0469:  MOVLW  0A
046A:  BTFSS  0C.4
046B:  GOTO   46A
046C:  MOVWF  19
....................                            showQuarter(1); 
046D:  MOVLW  01
046E:  MOVWF  72
046F:  CALL   260
....................                            break; 
0470:  GOTO   5A9
....................       case 'C':   if(DEBUG) {fputs("> Activar Periodo 2",RS232);} 
0471:  BTFSS  07.2
0472:  GOTO   482
0473:  MOVLW  62
0474:  BSF    03.6
0475:  MOVWF  0D
0476:  MOVLW  07
0477:  MOVWF  0F
0478:  BCF    03.6
0479:  CALL   125
047A:  MOVLW  0D
047B:  BTFSS  0C.4
047C:  GOTO   47B
047D:  MOVWF  19
047E:  MOVLW  0A
047F:  BTFSS  0C.4
0480:  GOTO   47F
0481:  MOVWF  19
....................                            showQuarter(2); 
0482:  MOVLW  02
0483:  MOVWF  72
0484:  CALL   260
....................                            break; 
0485:  GOTO   5A9
....................       case 'D':   if(DEBUG) {fputs("> Activar Periodo 3",RS232);} 
0486:  BTFSS  07.2
0487:  GOTO   497
0488:  MOVLW  6C
0489:  BSF    03.6
048A:  MOVWF  0D
048B:  MOVLW  07
048C:  MOVWF  0F
048D:  BCF    03.6
048E:  CALL   125
048F:  MOVLW  0D
0490:  BTFSS  0C.4
0491:  GOTO   490
0492:  MOVWF  19
0493:  MOVLW  0A
0494:  BTFSS  0C.4
0495:  GOTO   494
0496:  MOVWF  19
....................                            showQuarter(3); 
0497:  MOVLW  03
0498:  MOVWF  72
0499:  CALL   260
....................                            break; 
049A:  GOTO   5A9
....................       case 'E':   if(DEBUG) {fputs("> Activar Periodo 4",RS232);} 
049B:  BTFSS  07.2
049C:  GOTO   4AC
049D:  MOVLW  76
049E:  BSF    03.6
049F:  MOVWF  0D
04A0:  MOVLW  07
04A1:  MOVWF  0F
04A2:  BCF    03.6
04A3:  CALL   125
04A4:  MOVLW  0D
04A5:  BTFSS  0C.4
04A6:  GOTO   4A5
04A7:  MOVWF  19
04A8:  MOVLW  0A
04A9:  BTFSS  0C.4
04AA:  GOTO   4A9
04AB:  MOVWF  19
....................                            showQuarter(4); 
04AC:  MOVLW  04
04AD:  MOVWF  72
04AE:  CALL   260
....................                            break; 
04AF:  GOTO   5A9
....................       case 'F':   if(DEBUG) {fputs("> Activar Minuto Decena",RS232);} 
04B0:  BTFSS  07.2
04B1:  GOTO   4C1
04B2:  MOVLW  80
04B3:  BSF    03.6
04B4:  MOVWF  0D
04B5:  MOVLW  07
04B6:  MOVWF  0F
04B7:  BCF    03.6
04B8:  CALL   125
04B9:  MOVLW  0D
04BA:  BTFSS  0C.4
04BB:  GOTO   4BA
04BC:  MOVWF  19
04BD:  MOVLW  0A
04BE:  BTFSS  0C.4
04BF:  GOTO   4BE
04C0:  MOVWF  19
....................                            output_bit(MINUTOD, ON); 
04C1:  BSF    05.0
04C2:  MOVLW  00
04C3:  BSF    03.5
04C4:  MOVWF  05
....................                            break; 
04C5:  BCF    03.5
04C6:  GOTO   5A9
....................       case 'G':   if(DEBUG) {fputs("> Desactivar Minuto Decena",RS232);} 
04C7:  BTFSS  07.2
04C8:  GOTO   4D8
04C9:  MOVLW  8C
04CA:  BSF    03.6
04CB:  MOVWF  0D
04CC:  MOVLW  07
04CD:  MOVWF  0F
04CE:  BCF    03.6
04CF:  CALL   125
04D0:  MOVLW  0D
04D1:  BTFSS  0C.4
04D2:  GOTO   4D1
04D3:  MOVWF  19
04D4:  MOVLW  0A
04D5:  BTFSS  0C.4
04D6:  GOTO   4D5
04D7:  MOVWF  19
....................                            output_bit(MINUTOD, OFF); 
04D8:  BCF    05.0
04D9:  MOVLW  00
04DA:  BSF    03.5
04DB:  MOVWF  05
....................                            break;             
04DC:  BCF    03.5
04DD:  GOTO   5A9
....................       case 'H':   if(DEBUG) {fputs("> Toque Corto",RS232);} 
04DE:  BTFSS  07.2
04DF:  GOTO   4EF
04E0:  MOVLW  9A
04E1:  BSF    03.6
04E2:  MOVWF  0D
04E3:  MOVLW  07
04E4:  MOVWF  0F
04E5:  BCF    03.6
04E6:  CALL   125
04E7:  MOVLW  0D
04E8:  BTFSS  0C.4
04E9:  GOTO   4E8
04EA:  MOVWF  19
04EB:  MOVLW  0A
04EC:  BTFSS  0C.4
04ED:  GOTO   4EC
04EE:  MOVWF  19
....................                            buzz(1); 
04EF:  MOVLW  01
04F0:  MOVWF  72
04F1:  CALL   2AE
....................                            break; 
04F2:  GOTO   5A9
....................       case 'I':   if(DEBUG) {fputs("> Toque Largo",RS232);} 
04F3:  BTFSS  07.2
04F4:  GOTO   504
04F5:  MOVLW  A1
04F6:  BSF    03.6
04F7:  MOVWF  0D
04F8:  MOVLW  07
04F9:  MOVWF  0F
04FA:  BCF    03.6
04FB:  CALL   125
04FC:  MOVLW  0D
04FD:  BTFSS  0C.4
04FE:  GOTO   4FD
04FF:  MOVWF  19
0500:  MOVLW  0A
0501:  BTFSS  0C.4
0502:  GOTO   501
0503:  MOVWF  19
....................                            buzz(2); 
0504:  MOVLW  02
0505:  MOVWF  72
0506:  CALL   2AE
....................                            break; 
0507:  GOTO   5A9
....................       case 'J':   if(DEBUG) {fputs("> Toque Doble",RS232);} 
0508:  BTFSS  07.2
0509:  GOTO   519
050A:  MOVLW  A8
050B:  BSF    03.6
050C:  MOVWF  0D
050D:  MOVLW  07
050E:  MOVWF  0F
050F:  BCF    03.6
0510:  CALL   125
0511:  MOVLW  0D
0512:  BTFSS  0C.4
0513:  GOTO   512
0514:  MOVWF  19
0515:  MOVLW  0A
0516:  BTFSS  0C.4
0517:  GOTO   516
0518:  MOVWF  19
....................                            buzz(3); 
0519:  MOVLW  03
051A:  MOVWF  72
051B:  CALL   2AE
....................                            break; 
051C:  GOTO   5A9
....................       case 'X':   doTest(); //Rutina de prueba 
051D:  CALL   30F
....................                   break; 
051E:  GOTO   5A9
....................       case 'Z':   if(DEBUG) {fputs("\r> Reseteo general...!",RS232);} 
051F:  BTFSS  07.2
0520:  GOTO   530
0521:  MOVLW  AF
0522:  BSF    03.6
0523:  MOVWF  0D
0524:  MOVLW  07
0525:  MOVWF  0F
0526:  BCF    03.6
0527:  CALL   125
0528:  MOVLW  0D
0529:  BTFSS  0C.4
052A:  GOTO   529
052B:  MOVWF  19
052C:  MOVLW  0A
052D:  BTFSS  0C.4
052E:  GOTO   52D
052F:  MOVWF  19
....................                   delay_ms(100); 
0530:  MOVLW  64
0531:  MOVWF  74
0532:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (5)",RS232);} 
0533:  BTFSS  07.2
0534:  GOTO   544
0535:  MOVLW  BB
0536:  BSF    03.6
0537:  MOVWF  0D
0538:  MOVLW  07
0539:  MOVWF  0F
053A:  BCF    03.6
053B:  CALL   125
053C:  MOVLW  0D
053D:  BTFSS  0C.4
053E:  GOTO   53D
053F:  MOVWF  19
0540:  MOVLW  0A
0541:  BTFSS  0C.4
0542:  GOTO   541
0543:  MOVWF  19
....................                   delay_ms(100); 
0544:  MOVLW  64
0545:  MOVWF  74
0546:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (4)",RS232);} 
0547:  BTFSS  07.2
0548:  GOTO   558
0549:  MOVLW  BF
054A:  BSF    03.6
054B:  MOVWF  0D
054C:  MOVLW  07
054D:  MOVWF  0F
054E:  BCF    03.6
054F:  CALL   125
0550:  MOVLW  0D
0551:  BTFSS  0C.4
0552:  GOTO   551
0553:  MOVWF  19
0554:  MOVLW  0A
0555:  BTFSS  0C.4
0556:  GOTO   555
0557:  MOVWF  19
....................                   delay_ms(100); 
0558:  MOVLW  64
0559:  MOVWF  74
055A:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (3)",RS232);} 
055B:  BTFSS  07.2
055C:  GOTO   56C
055D:  MOVLW  C3
055E:  BSF    03.6
055F:  MOVWF  0D
0560:  MOVLW  07
0561:  MOVWF  0F
0562:  BCF    03.6
0563:  CALL   125
0564:  MOVLW  0D
0565:  BTFSS  0C.4
0566:  GOTO   565
0567:  MOVWF  19
0568:  MOVLW  0A
0569:  BTFSS  0C.4
056A:  GOTO   569
056B:  MOVWF  19
....................                   delay_ms(100); 
056C:  MOVLW  64
056D:  MOVWF  74
056E:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (2)",RS232);} 
056F:  BTFSS  07.2
0570:  GOTO   580
0571:  MOVLW  C7
0572:  BSF    03.6
0573:  MOVWF  0D
0574:  MOVLW  07
0575:  MOVWF  0F
0576:  BCF    03.6
0577:  CALL   125
0578:  MOVLW  0D
0579:  BTFSS  0C.4
057A:  GOTO   579
057B:  MOVWF  19
057C:  MOVLW  0A
057D:  BTFSS  0C.4
057E:  GOTO   57D
057F:  MOVWF  19
....................                   delay_ms(100); 
0580:  MOVLW  64
0581:  MOVWF  74
0582:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (1)",RS232);} 
0583:  BTFSS  07.2
0584:  GOTO   594
0585:  MOVLW  CB
0586:  BSF    03.6
0587:  MOVWF  0D
0588:  MOVLW  07
0589:  MOVWF  0F
058A:  BCF    03.6
058B:  CALL   125
058C:  MOVLW  0D
058D:  BTFSS  0C.4
058E:  GOTO   58D
058F:  MOVWF  19
0590:  MOVLW  0A
0591:  BTFSS  0C.4
0592:  GOTO   591
0593:  MOVWF  19
....................                   delay_ms(100); 
0594:  MOVLW  64
0595:  MOVWF  74
0596:  CALL   29A
....................                   if(DEBUG) {fputs("\r> (0)",RS232);} 
0597:  BTFSS  07.2
0598:  GOTO   5A8
0599:  MOVLW  CF
059A:  BSF    03.6
059B:  MOVWF  0D
059C:  MOVLW  07
059D:  MOVWF  0F
059E:  BCF    03.6
059F:  CALL   125
05A0:  MOVLW  0D
05A1:  BTFSS  0C.4
05A2:  GOTO   5A1
05A3:  MOVWF  19
05A4:  MOVLW  0A
05A5:  BTFSS  0C.4
05A6:  GOTO   5A5
05A7:  MOVWF  19
....................                   doReset(); 
05A8:  CALL   389
....................                    
....................    } 
05A9:  BCF    0A.3
05AA:  BCF    0A.4
05AB:  GOTO   5DF (RETURN)
.................... } 
....................  
.................... void showQuarter(int8 n) 
.................... { 
....................    output_bit(PERIODO1, OFF); 
*
0260:  BCF    09.1
0261:  MOVLW  E0
0262:  BSF    03.5
0263:  MOVWF  09
....................    output_bit(PERIODO2, OFF); 
0264:  BCF    03.5
0265:  BCF    09.2
0266:  MOVLW  E0
0267:  BSF    03.5
0268:  MOVWF  09
....................    output_bit(PERIODO3, OFF); 
0269:  BCF    03.5
026A:  BCF    07.0
026B:  MOVLW  DC
026C:  BSF    03.5
026D:  MOVWF  07
....................    output_bit(PERIODO4, OFF); 
026E:  BCF    03.5
026F:  BCF    07.1
0270:  MOVLW  DC
0271:  BSF    03.5
0272:  MOVWF  07
....................     
....................    switch(n) 
0273:  MOVLW  01
0274:  SUBWF  72,W
0275:  ADDLW  FC
0276:  BTFSC  03.0
0277:  GOTO   290
0278:  ADDLW  04
0279:  BCF    03.5
027A:  GOTO   292
....................    { 
....................       case 1: output_bit(PERIODO1, ON); break; 
027B:  BSF    09.1
027C:  MOVLW  E0
027D:  BSF    03.5
027E:  MOVWF  09
027F:  GOTO   290
....................       case 2: output_bit(PERIODO2, ON); break; 
0280:  BSF    09.2
0281:  MOVLW  E0
0282:  BSF    03.5
0283:  MOVWF  09
0284:  GOTO   290
....................       case 3: output_bit(PERIODO3, ON); break; 
0285:  BSF    07.0
0286:  MOVLW  DC
0287:  BSF    03.5
0288:  MOVWF  07
0289:  GOTO   290
....................       case 4: output_bit(PERIODO4, ON); break; 
028A:  BSF    07.1
028B:  MOVLW  DC
028C:  BSF    03.5
028D:  MOVWF  07
028E:  GOTO   290
028F:  BSF    03.5
....................    } 
0290:  BCF    03.5
0291:  RETURN
.................... } 
.................... void showNumber(int8 n, tPort p) 
*
01D8:  BCF    7B.0
01D9:  BCF    7B.1
01DA:  BCF    7B.2
01DB:  BCF    7B.3
.................... { 
....................    int1 a=0, b=0, c=0, d=0; 
....................    switch(n) 
01DC:  MOVLW  01
01DD:  SUBWF  72,W
01DE:  ADDLW  F7
01DF:  BTFSC  03.0
01E0:  GOTO   1FA
01E1:  ADDLW  09
01E2:  GOTO   253
....................    { 
....................       case 1:  a=1; 
01E3:  BSF    7B.0
....................                break; 
01E4:  GOTO   1FA
....................       case 2:  b=1; 
01E5:  BSF    7B.1
....................                break; 
01E6:  GOTO   1FA
....................       case 3:  a=1; b=1; 
01E7:  BSF    7B.0
01E8:  BSF    7B.1
....................                break; 
01E9:  GOTO   1FA
....................       case 4:  c=1; 
01EA:  BSF    7B.2
....................                break; 
01EB:  GOTO   1FA
....................       case 5:  c=1; a=1; 
01EC:  BSF    7B.2
01ED:  BSF    7B.0
....................                break; 
01EE:  GOTO   1FA
....................       case 6:  c=1; b=1; 
01EF:  BSF    7B.2
01F0:  BSF    7B.1
....................                break; 
01F1:  GOTO   1FA
....................       case 7:  c=1; b=1; a=1; 
01F2:  BSF    7B.2
01F3:  BSF    7B.1
01F4:  BSF    7B.0
....................                break; 
01F5:  GOTO   1FA
....................       case 8:  d=1; 
01F6:  BSF    7B.3
....................                break; 
01F7:  GOTO   1FA
....................       case 9:  d=1; a=1; 
01F8:  BSF    7B.3
01F9:  BSF    7B.0
....................                break; 
....................    } 
....................    output_bit(p.a, a); 
01FA:  MOVLW  00
01FB:  BTFSC  7B.0
01FC:  MOVLW  01
01FD:  MOVWF  77
01FE:  MOVF   73,W
01FF:  MOVWF  7C
0200:  MOVF   77,W
0201:  MOVWF  7D
0202:  BSF    03.5
0203:  CLRF   21
0204:  CLRF   20
0205:  BCF    03.5
0206:  CALL   1B6
0207:  MOVF   73,W
0208:  MOVWF  7C
0209:  CLRF   7D
020A:  BSF    03.5
020B:  CLRF   21
020C:  MOVLW  80
020D:  MOVWF  20
020E:  BCF    03.5
020F:  CALL   1B6
....................    output_bit(p.b, b); 
0210:  MOVLW  00
0211:  BTFSC  7B.1
0212:  MOVLW  01
0213:  MOVWF  77
0214:  MOVF   74,W
0215:  MOVWF  7C
0216:  MOVF   77,W
0217:  MOVWF  7D
0218:  BSF    03.5
0219:  CLRF   21
021A:  CLRF   20
021B:  BCF    03.5
021C:  CALL   1B6
021D:  MOVF   74,W
021E:  MOVWF  7C
021F:  CLRF   7D
0220:  BSF    03.5
0221:  CLRF   21
0222:  MOVLW  80
0223:  MOVWF  20
0224:  BCF    03.5
0225:  CALL   1B6
....................    output_bit(p.c, c); 
0226:  MOVLW  00
0227:  BTFSC  7B.2
0228:  MOVLW  01
0229:  MOVWF  77
022A:  MOVF   75,W
022B:  MOVWF  7C
022C:  MOVF   77,W
022D:  MOVWF  7D
022E:  BSF    03.5
022F:  CLRF   21
0230:  CLRF   20
0231:  BCF    03.5
0232:  CALL   1B6
0233:  MOVF   75,W
0234:  MOVWF  7C
0235:  CLRF   7D
0236:  BSF    03.5
0237:  CLRF   21
0238:  MOVLW  80
0239:  MOVWF  20
023A:  BCF    03.5
023B:  CALL   1B6
....................    output_bit(p.d, d); 
023C:  MOVLW  00
023D:  BTFSC  7B.3
023E:  MOVLW  01
023F:  MOVWF  77
0240:  MOVF   76,W
0241:  MOVWF  7C
0242:  MOVF   77,W
0243:  MOVWF  7D
0244:  BSF    03.5
0245:  CLRF   21
0246:  CLRF   20
0247:  BCF    03.5
0248:  CALL   1B6
0249:  MOVF   76,W
024A:  MOVWF  7C
024B:  CLRF   7D
024C:  BSF    03.5
024D:  CLRF   21
024E:  MOVLW  80
024F:  MOVWF  20
0250:  BCF    03.5
0251:  CALL   1B6
0252:  RETURN
.................... } 
....................  
.................... int8 char2int(char c) 
.................... { 
....................    switch(c) 
*
0177:  MOVLW  30
0178:  SUBWF  71,W
0179:  ADDLW  F6
017A:  BTFSC  03.0
017B:  GOTO   1A5
017C:  ADDLW  0A
017D:  GOTO   1A8
....................    { 
....................       case '0':   return 0; 
017E:  MOVLW  00
017F:  MOVWF  78
0180:  GOTO   1A7
....................                   break; 
0181:  GOTO   1A5
....................       case '1':   return 1; 
0182:  MOVLW  01
0183:  MOVWF  78
0184:  GOTO   1A7
....................                   break; 
0185:  GOTO   1A5
....................       case '2':   return 2; 
0186:  MOVLW  02
0187:  MOVWF  78
0188:  GOTO   1A7
....................                   break; 
0189:  GOTO   1A5
....................       case '3':   return 3; 
018A:  MOVLW  03
018B:  MOVWF  78
018C:  GOTO   1A7
....................                   break; 
018D:  GOTO   1A5
....................       case '4':   return 4; 
018E:  MOVLW  04
018F:  MOVWF  78
0190:  GOTO   1A7
....................                   break; 
0191:  GOTO   1A5
....................       case '5':   return 5; 
0192:  MOVLW  05
0193:  MOVWF  78
0194:  GOTO   1A7
....................                   break; 
0195:  GOTO   1A5
....................       case '6':   return 6; 
0196:  MOVLW  06
0197:  MOVWF  78
0198:  GOTO   1A7
....................                   break; 
0199:  GOTO   1A5
....................       case '7':   return 7; 
019A:  MOVLW  07
019B:  MOVWF  78
019C:  GOTO   1A7
....................                   break; 
019D:  GOTO   1A5
....................       case '8':   return 8; 
019E:  MOVLW  08
019F:  MOVWF  78
01A0:  GOTO   1A7
....................                   break; 
01A1:  GOTO   1A5
....................       case '9':   return 9; 
01A2:  MOVLW  09
01A3:  MOVWF  78
01A4:  GOTO   1A7
....................                   break; 
....................    } 
....................    return 0; 
01A5:  MOVLW  00
01A6:  MOVWF  78
01A7:  RETURN
.................... } 
....................  
.................... void doReset(void) 
.................... { 
....................    if(DEBUG) {fputs("> Reseteando...",RS232);} 
*
0389:  BTFSS  07.2
038A:  GOTO   39A
038B:  MOVLW  D3
038C:  BSF    03.6
038D:  MOVWF  0D
038E:  MOVLW  07
038F:  MOVWF  0F
0390:  BCF    03.6
0391:  CALL   125
0392:  MOVLW  0D
0393:  BTFSS  0C.4
0394:  GOTO   393
0395:  MOVWF  19
0396:  MOVLW  0A
0397:  BTFSS  0C.4
0398:  GOTO   397
0399:  MOVWF  19
....................    reset_cpu(); 
039A:  CLRF   0A
039B:  GOTO   000
039C:  RETURN
.................... } 
....................  

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

CCS PCM C Compiler, Version 5.076, 56587               11-mar.-20 22:15

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mcoms\mcoms.lst

               ROM used:   4693 words (57%)
                           Largest free fragment is 2048
               RAM used:   85 (23%) at main() level
                           121 (33%) worst case
               Stack used: 6 locations (2 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  07
0001:  MOVWF  0A
0002:  GOTO   71B
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   465
....................  
.................... /**:COPYRIGHT 
....................            _ / _ /  
....................         _ / _ / _ / _/_/ 
....................          _ / _ /  
....................         _ / _ /  
....................        _ / _ / _/_ / _ / 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo APM 
....................      
....................  */ 
....................  // * AUTOR: Victor Noguedad 
....................  // * ARCHIVO: mscoms.c 
....................  // * RESUMEN: Programa principal del modulo de comunicaciones 
....................  // ::[CABECERAS]:: 
.................... #include <mcoms.h> 
.................... /**:COPYRIGHT 
....................  
....................            _/       _/ 
....................         _/_/_/   _/_/ 
....................          _/       _/ 
....................         _/       _/ 
....................        _/_/   _/_/_/ 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo  APM 
....................      
....................  */ 
....................   
....................  // *AUTOR:    Victor Noguedad 
....................  // *ARCHIVO:  mscoms.c 
....................  // *RESUMEN:  Programa principal del modulo de comunicaciones 
....................   
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  00
0056:  RETLW  00
0057:  RETLW  00
0058:  RETLW  00
0059:  RETLW  00
005A:  RETLW  00
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  00
005F:  DATA 2A,15
0060:  DATA 2A,15
0061:  DATA 2A,15
0062:  DATA 2A,15
0063:  DATA 2A,15
0064:  DATA 2A,15
0065:  DATA 2A,15
0066:  DATA 2A,15
0067:  DATA 2A,15
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 0D,00
0070:  DATA A0,23
0071:  DATA F2,3A
0072:  DATA F0,37
0073:  DATA A0,20
0074:  DATA D0,26
0075:  DATA 20,14
0076:  DATA E3,14
0077:  DATA 20,19
0078:  DATA 30,19
0079:  DATA 30,10
007A:  DATA 0D,00
007B:  DATA BD,1E
007C:  DATA BD,1E
007D:  DATA BD,1E
007E:  DATA BD,1E
007F:  DATA BD,1E
0080:  DATA BD,1E
0081:  DATA BD,1E
0082:  DATA BD,1E
0083:  DATA BD,1E
0084:  DATA BD,1E
0085:  DATA BD,1E
0086:  DATA BD,1E
0087:  DATA BD,1E
0088:  DATA BD,1E
0089:  DATA BD,1E
008A:  DATA BD,1E
008B:  DATA 0D,00
008C:  DATA 42,36
008D:  DATA F5,32
008E:  DATA F4,37
008F:  DATA 6F,3A
0090:  DATA 68,10
0091:  DATA C2,30
0092:  DATA F3,35
0093:  DATA 65,3A
0094:  DATA E2,30
0095:  DATA 6C,36
0096:  DATA A0,29
0097:  DATA E3,37
0098:  DATA F2,32
0099:  DATA 20,21
009A:  DATA EF,30
009B:  DATA 72,32
009C:  DATA 0D,00
009D:  DATA BD,1E
009E:  DATA BD,1E
009F:  DATA BD,1E
00A0:  DATA BD,1E
00A1:  DATA BD,1E
00A2:  DATA BD,1E
00A3:  DATA BD,1E
00A4:  DATA BD,1E
00A5:  DATA BD,1E
00A6:  DATA BD,1E
00A7:  DATA BD,1E
00A8:  DATA BD,1E
00A9:  DATA BD,1E
00AA:  DATA BD,1E
00AB:  DATA BD,1E
00AC:  DATA BD,1E
00AD:  DATA 0D,00
00AE:  DATA D6,32
00AF:  DATA F2,39
00B0:  DATA E9,37
00B1:  DATA 6E,10
00B2:  DATA A5,39
00B3:  DATA A0,16
00B4:  DATA 20,39
00B5:  DATA 65,3B
00B6:  DATA A0,12
00B7:  DATA 73,10
00B8:  DATA 0D,00
00B9:  DATA 32,17
00BA:  DATA 30,00
00BB:  DATA 46,00
00BC:  DATA 2A,15
00BD:  DATA 2A,15
00BE:  DATA 2A,15
00BF:  DATA 2A,15
00C0:  DATA 2A,15
00C1:  DATA 2A,15
00C2:  DATA 2A,15
00C3:  DATA 2A,15
00C4:  DATA 2A,15
00C5:  DATA 2A,15
00C6:  DATA 2A,15
00C7:  DATA 2A,15
00C8:  DATA 2A,15
00C9:  DATA 2A,15
00CA:  DATA 2A,15
00CB:  DATA 2A,15
00CC:  DATA 0D,00
00CD:  DATA 20,22
00CE:  DATA 45,28
00CF:  DATA 55,29
00D0:  DATA C1,21
00D1:  DATA C9,27
00D2:  DATA 4E,10
00D3:  DATA 3A,1D
00D4:  DATA A0,21
00D5:  DATA CF,26
00D6:  DATA 55,27
00D7:  DATA C9,21
00D8:  DATA C1,21
00D9:  DATA C9,27
00DA:  DATA CE,22
00DB:  DATA 53,10
00DC:  DATA 0D,00
00DD:  DATA 20,1F
00DE:  DATA A0,21
00DF:  DATA 6F,37
00E0:  DATA E6,34
00E1:  DATA E7,3A
00E2:  DATA F2,30
00E3:  DATA E3,34
00E4:  DATA 6F,37
00E5:  DATA 20,32
00E6:  DATA 65,10
00E7:  DATA D0,3A
00E8:  DATA 65,39
00E9:  DATA F4,37
00EA:  DATA 73,00
00EB:  DATA 20,1F
00EC:  DATA A0,24
00ED:  DATA EE,34
00EE:  DATA E3,34
00EF:  DATA 61,36
00F0:  DATA 69,3D
00F1:  DATA E1,31
00F2:  DATA E9,37
00F3:  DATA 6E,10
00F4:  DATA E4,32
00F5:  DATA A0,24
00F6:  DATA B2,21
00F7:  DATA 00,01
00F8:  DATA 20,1F
00F9:  DATA 20,24
00FA:  DATA 61,31
00FB:  DATA 69,36
00FC:  DATA 69,3A
00FD:  DATA E1,31
00FE:  DATA E9,37
00FF:  DATA 6E,10
0100:  DATA E4,32
0101:  DATA 20,32
0102:  DATA E9,39
0103:  DATA 70,36
0104:  DATA E1,3C
0105:  DATA 73,00
0106:  DATA 20,1F
0107:  DATA 20,24
0108:  DATA 61,31
0109:  DATA 69,36
010A:  DATA 69,3A
010B:  DATA E1,31
010C:  DATA E9,37
010D:  DATA 6E,10
010E:  DATA E4,32
010F:  DATA A0,34
0110:  DATA 6E,3A
0111:  DATA 65,39
0112:  DATA F2,3A
0113:  DATA F0,31
0114:  DATA E9,37
0115:  DATA EE,32
0116:  DATA 73,00
0117:  MOVF   0B,W
0118:  BSF    03.5
0119:  MOVWF  2B
011A:  BCF    03.5
011B:  BCF    0B.7
011C:  BSF    03.5
011D:  BSF    03.6
011E:  BSF    0C.7
011F:  BSF    0C.0
0120:  NOP
0121:  NOP
0122:  BCF    03.6
0123:  BTFSS  2B.7
0124:  GOTO   128
0125:  BCF    03.5
0126:  BSF    0B.7
0127:  BSF    03.5
0128:  BCF    03.5
0129:  BSF    03.6
012A:  MOVF   0C,W
012B:  ANDLW  7F
012C:  BTFSC  03.2
012D:  GOTO   18B
012E:  BSF    03.5
012F:  BCF    03.6
0130:  MOVWF  2B
0131:  BCF    03.5
0132:  BSF    03.6
0133:  MOVF   0D,W
0134:  BSF    03.5
0135:  BCF    03.6
0136:  MOVWF  2C
0137:  BCF    03.5
0138:  BSF    03.6
0139:  MOVF   0F,W
013A:  BSF    03.5
013B:  BCF    03.6
013C:  MOVWF  2D
013D:  MOVF   2B,W
013E:  BCF    03.5
013F:  BTFSS  0C.4
0140:  GOTO   13F
0141:  MOVWF  19
0142:  BSF    03.5
0143:  MOVF   2C,W
0144:  BCF    03.5
0145:  BSF    03.6
0146:  MOVWF  0D
0147:  BSF    03.5
0148:  BCF    03.6
0149:  MOVF   2D,W
014A:  BCF    03.5
014B:  BSF    03.6
014C:  MOVWF  0F
014D:  BCF    03.6
014E:  MOVF   0B,W
014F:  BSF    03.5
0150:  MOVWF  2E
0151:  BCF    03.5
0152:  BCF    0B.7
0153:  BSF    03.5
0154:  BSF    03.6
0155:  BSF    0C.7
0156:  BSF    0C.0
0157:  NOP
0158:  NOP
0159:  BCF    03.6
015A:  BTFSS  2E.7
015B:  GOTO   15F
015C:  BCF    03.5
015D:  BSF    0B.7
015E:  BSF    03.5
015F:  BCF    03.5
0160:  BSF    03.6
0161:  RLF    0C,W
0162:  RLF    0E,W
0163:  ANDLW  7F
0164:  BTFSC  03.2
0165:  GOTO   18B
0166:  BSF    03.5
0167:  BCF    03.6
0168:  MOVWF  2B
0169:  BCF    03.5
016A:  BSF    03.6
016B:  MOVF   0D,W
016C:  BSF    03.5
016D:  BCF    03.6
016E:  MOVWF  2C
016F:  BCF    03.5
0170:  BSF    03.6
0171:  MOVF   0F,W
0172:  BSF    03.5
0173:  BCF    03.6
0174:  MOVWF  2D
0175:  MOVF   2B,W
0176:  BCF    03.5
0177:  BTFSS  0C.4
0178:  GOTO   177
0179:  MOVWF  19
017A:  BSF    03.5
017B:  MOVF   2C,W
017C:  BCF    03.5
017D:  BSF    03.6
017E:  MOVWF  0D
017F:  BSF    03.5
0180:  BCF    03.6
0181:  MOVF   2D,W
0182:  BCF    03.5
0183:  BSF    03.6
0184:  MOVWF  0F
0185:  INCF   0D,F
0186:  BTFSC  03.2
0187:  INCF   0F,F
0188:  BCF    03.6
0189:  GOTO   117
018A:  BSF    03.6
018B:  BCF    03.6
018C:  RETURN
*
01CD:  BSF    0A.0
01CE:  BCF    0A.1
01CF:  BCF    0A.2
01D0:  ADDWF  02,F
01D1:  GOTO   196
01D2:  GOTO   19B
01D3:  GOTO   1A0
01D4:  GOTO   1A5
01D5:  GOTO   1AA
01D6:  GOTO   1AF
01D7:  GOTO   1B4
01D8:  GOTO   1B9
01D9:  GOTO   1BE
01DA:  GOTO   1C3
01DB:  BSF    03.5
01DC:  MOVF   31,W
01DD:  ANDLW  07
01DE:  MOVWF  77
01DF:  RRF    31,W
01E0:  MOVWF  78
01E1:  RRF    78,F
01E2:  RRF    78,F
01E3:  MOVLW  1F
01E4:  ANDWF  78,F
01E5:  MOVF   78,W
01E6:  ADDWF  33,W
01E7:  MOVWF  04
01E8:  BCF    03.7
01E9:  BTFSC  34.0
01EA:  BSF    03.7
01EB:  CLRF   78
01EC:  INCF   78,F
01ED:  INCF   77,F
01EE:  GOTO   1F0
01EF:  RLF    78,F
01F0:  DECFSZ 77,F
01F1:  GOTO   1EF
01F2:  MOVF   32,F
01F3:  BTFSC  03.2
01F4:  GOTO   1F8
01F5:  MOVF   78,W
01F6:  IORWF  00,F
01F7:  GOTO   1FB
01F8:  COMF   78,F
01F9:  MOVF   78,W
01FA:  ANDWF  00,F
01FB:  BCF    03.5
01FC:  RETURN
*
0284:  BCF    0A.0
0285:  BSF    0A.1
0286:  BCF    0A.2
0287:  ADDWF  02,F
0288:  GOTO   20A
0289:  GOTO   20D
028A:  GOTO   210
028B:  GOTO   214
028C:  GOTO   217
028D:  GOTO   21B
028E:  GOTO   21F
028F:  GOTO   224
0290:  GOTO   227
*
04BD:  DATA 20,1F
04BE:  DATA 20,29
04BF:  DATA 75,3A
04C0:  DATA 69,37
04C1:  DATA 61,10
04C2:  DATA E4,32
04C3:  DATA 20,38
04C4:  DATA F2,3A
04C5:  DATA 65,31
04C6:  DATA 61,00
04C7:  DATA 20,1F
04C8:  DATA 20,28
04C9:  DATA F2,37
04CA:  DATA E2,30
04CB:  DATA 6E,32
04CC:  DATA 6F,10
04CD:  DATA ED,37
04CE:  DATA E4,3A
04CF:  DATA EC,37
04D0:  DATA 20,3A
04D1:  DATA E9,32
04D2:  DATA 6D,38
04D3:  DATA 6F,00
04D4:  DATA 20,1F
04D5:  DATA 20,28
04D6:  DATA F2,37
04D7:  DATA E2,30
04D8:  DATA 6E,32
04D9:  DATA 6F,10
04DA:  DATA ED,37
04DB:  DATA E4,3A
04DC:  DATA EC,37
04DD:  DATA 20,38
04DE:  DATA 75,37
04DF:  DATA F4,37
04E0:  DATA 73,00
04E1:  DATA 20,1F
04E2:  DATA 20,28
04E3:  DATA F2,37
04E4:  DATA E2,30
04E5:  DATA 6E,32
04E6:  DATA 6F,10
04E7:  DATA ED,37
04E8:  DATA E4,3A
04E9:  DATA EC,37
04EA:  DATA A0,31
04EB:  DATA EF,36
04EC:  DATA 75,37
04ED:  DATA E9,31
04EE:  DATA E1,31
04EF:  DATA E9,37
04F0:  DATA EE,32
04F1:  DATA 73,00
04F2:  DATA 0D,10
04F3:  DATA 3E,10
04F4:  DATA C1,31
04F5:  DATA F4,34
04F6:  DATA F6,30
04F7:  DATA E3,34
04F8:  DATA 6F,37
04F9:  DATA A0,36
04FA:  DATA 61,37
04FB:  DATA F5,30
04FC:  DATA 6C,10
04FD:  DATA E4,32
04FE:  DATA 20,38
04FF:  DATA F5,32
0500:  DATA 72,3A
0501:  DATA 6F,00
0502:  DATA 0D,10
0503:  DATA 3E,10
0504:  DATA D4,37
0505:  DATA F1,3A
0506:  DATA 65,10
0507:  DATA E3,37
0508:  DATA 72,3A
0509:  DATA 6F,00
050A:  DATA 0D,10
050B:  DATA 3E,10
050C:  DATA D4,37
050D:  DATA F1,3A
050E:  DATA 65,10
050F:  DATA EC,30
0510:  DATA F2,33
0511:  DATA 6F,00
0512:  DATA 0D,10
0513:  DATA 3E,10
0514:  DATA D4,37
0515:  DATA F1,3A
0516:  DATA 65,10
0517:  DATA E4,37
0518:  DATA 62,36
0519:  DATA 65,00
051A:  DATA 0D,10
051B:  DATA 3E,10
051C:  DATA C1,39
051D:  DATA E9,33
051E:  DATA EE,30
051F:  DATA 72,10
0520:  DATA E6,30
0521:  DATA 6C,3A
0522:  DATA E1,39
0523:  DATA 00,01
0524:  DATA 0D,10
0525:  DATA 3E,10
0526:  DATA C1,39
0527:  DATA E9,33
0528:  DATA EE,30
0529:  DATA 72,10
052A:  DATA EA,3A
052B:  DATA E7,30
052C:  DATA E4,37
052D:  DATA 72,00
052E:  DATA 0D,10
052F:  DATA 3E,10
0530:  DATA D2,32
0531:  DATA F3,32
0532:  DATA F4,32
0533:  DATA 61,10
0534:  DATA 61,10
0535:  DATA 30,00
0536:  DATA 0D,10
0537:  DATA 3E,10
0538:  DATA 49,37
0539:  DATA 63,39
053A:  DATA E5,36
053B:  DATA 65,37
053C:  DATA F4,30
053D:  DATA 72,10
053E:  DATA F0,37
053F:  DATA 72,10
0540:  DATA 31,00
0541:  DATA 0D,10
0542:  DATA 3E,10
0543:  DATA 49,37
0544:  DATA 63,39
0545:  DATA E5,36
0546:  DATA 65,37
0547:  DATA F4,30
0548:  DATA 72,10
0549:  DATA F0,37
054A:  DATA 72,10
054B:  DATA 32,00
054C:  DATA 0D,10
054D:  DATA 3E,10
054E:  DATA 49,37
054F:  DATA 63,39
0550:  DATA E5,36
0551:  DATA 65,37
0552:  DATA F4,30
0553:  DATA 72,10
0554:  DATA F0,37
0555:  DATA 72,10
0556:  DATA 33,00
0557:  DATA 0D,10
0558:  DATA 3E,10
0559:  DATA C4,32
055A:  DATA 63,39
055B:  DATA E5,36
055C:  DATA 65,37
055D:  DATA F4,30
055E:  DATA 72,10
055F:  DATA F0,37
0560:  DATA 72,10
0561:  DATA 31,00
0562:  DATA 0D,10
0563:  DATA 3E,10
0564:  DATA C1,39
0565:  DATA E9,33
0566:  DATA EE,30
0567:  DATA 72,10
0568:  DATA E6,30
0569:  DATA 6C,3A
056A:  DATA E1,39
056B:  DATA 00,01
056C:  DATA 0D,10
056D:  DATA 3E,10
056E:  DATA 49,37
056F:  DATA E9,31
0570:  DATA E9,30
0571:  DATA EC,34
0572:  DATA FA,30
0573:  DATA 72,00
0574:  DATA 0D,10
0575:  DATA 3E,10
0576:  DATA C1,39
0577:  DATA E9,33
0578:  DATA EE,30
0579:  DATA 72,10
057A:  DATA F0,37
057B:  DATA F3,34
057C:  DATA E3,34
057D:  DATA 6F,37
057E:  DATA 00,01
057F:  DATA 0D,10
0580:  DATA 3E,10
0581:  DATA D0,30
0582:  DATA F5,39
0583:  DATA 61,39
0584:  DATA 20,3A
0585:  DATA E9,32
0586:  DATA 6D,38
0587:  DATA 6F,00
0588:  DATA 0D,10
0589:  DATA 3E,10
058A:  DATA D2,32
058B:  DATA EE,3A
058C:  DATA E4,30
058D:  DATA 72,10
058E:  DATA F4,34
058F:  DATA E5,36
0590:  DATA F0,37
0591:  DATA 00,01
0592:  DATA 0D,10
0593:  DATA 3E,10
0594:  DATA 41,38
0595:  DATA E1,33
0596:  DATA 61,39
0597:  DATA 20,28
0598:  DATA 65,39
0599:  DATA E9,37
059A:  DATA E4,37
059B:  DATA 73,00
059C:  DATA 0D,10
059D:  DATA 3E,10
059E:  DATA D0,32
059F:  DATA F2,34
05A0:  DATA 6F,32
05A1:  DATA 6F,10
05A2:  DATA 31,00
05A3:  DATA 0D,10
05A4:  DATA 3E,10
05A5:  DATA D0,32
05A6:  DATA F2,34
05A7:  DATA 6F,32
05A8:  DATA 6F,10
05A9:  DATA 32,00
05AA:  DATA 0D,10
05AB:  DATA 3E,10
05AC:  DATA D0,32
05AD:  DATA F2,34
05AE:  DATA 6F,32
05AF:  DATA 6F,10
05B0:  DATA 33,00
05B1:  DATA 0D,10
05B2:  DATA 3E,10
05B3:  DATA D0,32
05B4:  DATA F2,34
05B5:  DATA 6F,32
05B6:  DATA 6F,10
05B7:  DATA 34,00
05B8:  DATA 0D,10
05B9:  DATA 3E,10
05BA:  DATA C3,37
05BB:  DATA 6E,33
05BC:  DATA E9,33
05BD:  DATA 75,39
05BE:  DATA E1,31
05BF:  DATA E9,37
05C0:  DATA 6E,10
05C1:  DATA E4,32
05C2:  DATA 20,3A
05C3:  DATA 69,39
05C4:  DATA 6F,00
05C5:  DATA 0D,10
05C6:  DATA 3E,10
05C7:  DATA C3,37
05C8:  DATA 6E,33
05C9:  DATA E9,33
05CA:  DATA 75,39
05CB:  DATA E1,31
05CC:  DATA E9,37
05CD:  DATA 6E,10
05CE:  DATA E4,32
05CF:  DATA 20,3A
05D0:  DATA E9,32
05D1:  DATA 6D,38
05D2:  DATA 6F,00
05D3:  DATA 0D,10
05D4:  DATA 3E,10
05D5:  DATA D2,32
05D6:  DATA F3,32
05D7:  DATA F4,32
05D8:  DATA 61,10
05D9:  DATA 61,10
05DA:  DATA 30,00
05DB:  DATA 0D,10
05DC:  DATA 3E,10
05DD:  DATA 49,37
05DE:  DATA 63,39
05DF:  DATA E5,36
05E0:  DATA 65,37
05E1:  DATA F4,30
05E2:  DATA 72,10
05E3:  DATA F0,37
05E4:  DATA 72,10
05E5:  DATA 31,00
05E6:  DATA 0D,10
05E7:  DATA 3E,10
05E8:  DATA 49,37
05E9:  DATA 63,39
05EA:  DATA E5,36
05EB:  DATA 65,37
05EC:  DATA F4,30
05ED:  DATA 72,10
05EE:  DATA F0,37
05EF:  DATA 72,10
05F0:  DATA 32,00
05F1:  DATA 0D,10
05F2:  DATA 3E,10
05F3:  DATA 49,37
05F4:  DATA 63,39
05F5:  DATA E5,36
05F6:  DATA 65,37
05F7:  DATA F4,30
05F8:  DATA 72,10
05F9:  DATA F0,37
05FA:  DATA 72,10
05FB:  DATA 33,00
05FC:  DATA 0D,10
05FD:  DATA 3E,10
05FE:  DATA C4,32
05FF:  DATA 63,39
0600:  DATA E5,36
0601:  DATA 65,37
0602:  DATA F4,30
0603:  DATA 72,10
0604:  DATA F0,37
0605:  DATA 72,10
0606:  DATA 31,00
0607:  DATA 0D,10
0608:  DATA 3E,10
0609:  DATA C1,39
060A:  DATA E9,33
060B:  DATA EE,30
060C:  DATA 72,10
060D:  DATA E6,30
060E:  DATA 6C,3A
060F:  DATA E1,39
0610:  DATA 00,01
0611:  DATA 0D,10
0612:  DATA 3E,10
0613:  DATA 49,37
0614:  DATA E9,31
0615:  DATA E9,30
0616:  DATA EC,34
0617:  DATA FA,30
0618:  DATA 72,00
0619:  DATA 0D,10
061A:  DATA 3E,10
061B:  DATA C1,39
061C:  DATA E9,33
061D:  DATA EE,30
061E:  DATA 72,10
061F:  DATA F0,37
0620:  DATA F3,34
0621:  DATA E3,34
0622:  DATA 6F,37
0623:  DATA 00,01
0624:  DATA 0D,10
0625:  DATA 3E,10
0626:  DATA D2,32
0627:  DATA F3,32
0628:  DATA F4,32
0629:  DATA 6F,10
062A:  DATA E7,32
062B:  DATA EE,32
062C:  DATA F2,30
062D:  DATA 6C,17
062E:  DATA 2E,17
062F:  DATA A0,10
0630:  DATA 20,00
0631:  MOVF   0B,W
0632:  MOVWF  6C
0633:  BCF    0B.7
0634:  BSF    03.5
0635:  BSF    03.6
0636:  BSF    0C.7
0637:  BSF    0C.0
0638:  NOP
0639:  NOP
063A:  BCF    03.5
063B:  BCF    03.6
063C:  BTFSC  6C.7
063D:  BSF    0B.7
063E:  BSF    03.6
063F:  MOVF   0C,W
0640:  ANDLW  7F
0641:  BTFSC  03.2
0642:  GOTO   687
0643:  BCF    03.6
0644:  MOVWF  6C
0645:  BSF    03.6
0646:  MOVF   0D,W
0647:  BCF    03.6
0648:  MOVWF  6D
0649:  BSF    03.6
064A:  MOVF   0F,W
064B:  BCF    03.6
064C:  MOVWF  6E
064D:  MOVF   6C,W
064E:  BTFSS  0C.4
064F:  GOTO   64E
0650:  MOVWF  19
0651:  MOVF   6D,W
0652:  BSF    03.6
0653:  MOVWF  0D
0654:  BCF    03.6
0655:  MOVF   6E,W
0656:  BSF    03.6
0657:  MOVWF  0F
0658:  BCF    03.6
0659:  MOVF   0B,W
065A:  MOVWF  6F
065B:  BCF    0B.7
065C:  BSF    03.5
065D:  BSF    03.6
065E:  BSF    0C.7
065F:  BSF    0C.0
0660:  NOP
0661:  NOP
0662:  BCF    03.5
0663:  BCF    03.6
0664:  BTFSC  6F.7
0665:  BSF    0B.7
0666:  BSF    03.6
0667:  RLF    0C,W
0668:  RLF    0E,W
0669:  ANDLW  7F
066A:  BTFSC  03.2
066B:  GOTO   687
066C:  BCF    03.6
066D:  MOVWF  6C
066E:  BSF    03.6
066F:  MOVF   0D,W
0670:  BCF    03.6
0671:  MOVWF  6D
0672:  BSF    03.6
0673:  MOVF   0F,W
0674:  BCF    03.6
0675:  MOVWF  6E
0676:  MOVF   6C,W
0677:  BTFSS  0C.4
0678:  GOTO   677
0679:  MOVWF  19
067A:  MOVF   6D,W
067B:  BSF    03.6
067C:  MOVWF  0D
067D:  BCF    03.6
067E:  MOVF   6E,W
067F:  BSF    03.6
0680:  MOVWF  0F
0681:  INCF   0D,F
0682:  BTFSC  03.2
0683:  INCF   0F,F
0684:  BCF    03.6
0685:  GOTO   631
0686:  BSF    03.6
0687:  BCF    03.6
0688:  RETURN
0689:  MOVF   0B,W
068A:  MOVWF  6D
068B:  BCF    0B.7
068C:  BSF    03.5
068D:  BSF    03.6
068E:  BSF    0C.7
068F:  BSF    0C.0
0690:  NOP
0691:  NOP
0692:  BCF    03.5
0693:  BCF    03.6
0694:  BTFSC  6D.7
0695:  BSF    0B.7
0696:  BTFSC  03.0
0697:  GOTO   6C6
0698:  BSF    03.6
0699:  MOVF   0C,W
069A:  ANDLW  7F
069B:  BCF    03.6
069C:  MOVWF  6D
069D:  BSF    03.6
069E:  MOVF   0D,W
069F:  BCF    03.6
06A0:  MOVWF  6E
06A1:  BSF    03.6
06A2:  MOVF   0F,W
06A3:  BCF    03.6
06A4:  MOVWF  6F
06A5:  MOVF   6D,W
06A6:  BTFSS  0C.4
06A7:  GOTO   6A6
06A8:  MOVWF  19
06A9:  MOVF   6E,W
06AA:  BSF    03.6
06AB:  MOVWF  0D
06AC:  BCF    03.6
06AD:  MOVF   6F,W
06AE:  BSF    03.6
06AF:  MOVWF  0F
06B0:  BCF    03.6
06B1:  MOVF   0B,W
06B2:  MOVWF  70
06B3:  BCF    0B.7
06B4:  BSF    03.5
06B5:  BSF    03.6
06B6:  BSF    0C.7
06B7:  BSF    0C.0
06B8:  NOP
06B9:  NOP
06BA:  BTFSS  70.7
06BB:  GOTO   6C1
06BC:  BCF    03.5
06BD:  BCF    03.6
06BE:  BSF    0B.7
06BF:  BSF    03.5
06C0:  BSF    03.6
06C1:  BCF    03.5
06C2:  BCF    03.6
06C3:  DECFSZ 6C,F
06C4:  GOTO   6C6
06C5:  GOTO   6E6
06C6:  BSF    03.6
06C7:  RLF    0C,W
06C8:  RLF    0E,W
06C9:  ANDLW  7F
06CA:  BCF    03.6
06CB:  MOVWF  6D
06CC:  BSF    03.6
06CD:  MOVF   0D,W
06CE:  BCF    03.6
06CF:  MOVWF  6E
06D0:  BSF    03.6
06D1:  MOVF   0F,W
06D2:  BCF    03.6
06D3:  MOVWF  6F
06D4:  MOVF   6D,W
06D5:  BTFSS  0C.4
06D6:  GOTO   6D5
06D7:  MOVWF  19
06D8:  MOVF   6E,W
06D9:  BSF    03.6
06DA:  MOVWF  0D
06DB:  BCF    03.6
06DC:  MOVF   6F,W
06DD:  BSF    03.6
06DE:  MOVWF  0F
06DF:  INCF   0D,F
06E0:  BTFSC  03.2
06E1:  INCF   0F,F
06E2:  BCF    03.0
06E3:  BCF    03.6
06E4:  DECFSZ 6C,F
06E5:  GOTO   689
06E6:  RETURN
*
0FC7:  BSF    0A.0
0FC8:  BSF    0A.1
0FC9:  BSF    0A.2
0FCA:  ADDWF  02,F
0FCB:  GOTO   061
0FCC:  GOTO   082
0FCD:  GOTO   0A3
0FCE:  GOTO   0C4
0FCF:  BSF    0A.0
0FD0:  BSF    0A.1
0FD1:  BSF    0A.2
0FD2:  ADDWF  02,F
0FD3:  GOTO   3A9
0FD4:  GOTO   3C7
0FD5:  GOTO   3E5
0FD6:  GOTO   403
0FD7:  GOTO   421
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... // ::[CONFIGURACION DE PIC]:: 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
0309:  MOVLW  B2
030A:  MOVWF  04
030B:  BCF    03.7
030C:  MOVF   00,W
030D:  BTFSC  03.2
030E:  GOTO   31C
030F:  MOVLW  02
0310:  MOVWF  78
0311:  CLRF   77
0312:  DECFSZ 77,F
0313:  GOTO   312
0314:  DECFSZ 78,F
0315:  GOTO   311
0316:  MOVLW  97
0317:  MOVWF  77
0318:  DECFSZ 77,F
0319:  GOTO   318
031A:  DECFSZ 00,F
031B:  GOTO   30F
031C:  RETURN
....................  
.................... // ::[CONFIGURACION DE IO]:: 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0 ) 
....................  
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
....................  
.................... // ::[CONFIGURACION PUERTOS]:: 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Master,Fast,sda=I2C_SDA,scl=I2C_SCL) 
*
0297:  BCF    03.5
0298:  BCF    14.7
0299:  BCF    0C.3
029A:  BSF    03.5
029B:  MOVF   38,W
029C:  BCF    03.5
029D:  MOVWF  13
029E:  MOVLW  02
029F:  BTFSC  14.7
02A0:  GOTO   2A8
02A1:  BTFSS  0C.3
02A2:  GOTO   2A1
02A3:  MOVLW  00
02A4:  BSF    03.5
02A5:  BTFSC  11.6
02A6:  MOVLW  01
02A7:  BCF    03.5
02A8:  MOVWF  78
*
02AF:  BCF    03.5
02B0:  BCF    14.7
02B1:  BCF    0C.3
02B2:  BSF    03.5
02B3:  MOVF   38,W
02B4:  BCF    03.5
02B5:  MOVWF  13
02B6:  MOVLW  02
02B7:  BTFSC  14.7
02B8:  GOTO   2C0
02B9:  BTFSS  0C.3
02BA:  GOTO   2B9
02BB:  MOVLW  00
02BC:  BSF    03.5
02BD:  BTFSC  11.6
02BE:  MOVLW  01
02BF:  BCF    03.5
02C0:  MOVWF  78
*
02CD:  BCF    03.5
02CE:  BCF    14.7
02CF:  BCF    0C.3
02D0:  BSF    03.5
02D1:  MOVF   38,W
02D2:  BCF    03.5
02D3:  MOVWF  13
02D4:  MOVLW  02
02D5:  BTFSC  14.7
02D6:  GOTO   2DE
02D7:  BTFSS  0C.3
02D8:  GOTO   2D7
02D9:  MOVLW  00
02DA:  BSF    03.5
02DB:  BTFSC  11.6
02DC:  MOVLW  01
02DD:  BCF    03.5
02DE:  MOVWF  78
*
02E2:  BCF    03.5
02E3:  BCF    14.7
02E4:  BCF    0C.3
02E5:  BSF    03.5
02E6:  MOVF   38,W
02E7:  BCF    03.5
02E8:  MOVWF  13
02E9:  MOVLW  02
02EA:  BTFSC  14.7
02EB:  GOTO   2F3
02EC:  BTFSS  0C.3
02ED:  GOTO   2EC
02EE:  MOVLW  00
02EF:  BSF    03.5
02F0:  BTFSC  11.6
02F1:  MOVLW  01
02F2:  BCF    03.5
02F3:  MOVWF  78
.................... #use timer  (timer=0,tick=100us,bits=32,NOISR) 
*
06E7:  MOVF   01,W
06E8:  BTFSS  0B.2
06E9:  GOTO   6F4
06EA:  MOVLW  01
06EB:  ADDWF  2C,F
06EC:  BTFSC  03.0
06ED:  INCF   2D,F
06EE:  BTFSC  03.2
06EF:  INCF   2E,F
06F0:  BTFSC  03.2
06F1:  INCF   2F,F
06F2:  BCF    0B.2
06F3:  MOVF   01,W
06F4:  MOVWF  77
06F5:  MOVF   2C,W
06F6:  MOVWF  78
06F7:  MOVF   2D,W
06F8:  MOVWF  79
06F9:  MOVF   2E,W
06FA:  MOVWF  7A
06FB:  MOVF   2F,W
06FC:  MOVWF  6C
06FD:  RRF    6C,F
06FE:  RRF    7A,F
06FF:  RRF    79,F
0700:  RRF    78,F
0701:  RRF    77,F
0702:  RETURN
....................  
.................... // ::[DEFINICIONES]:: 
.................... #define TICK_TYPE       unsigned int32 
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       100 
.................... #define I2CWAIT         50 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... // ::[DECLARACIONES]:: 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
076A:  BCF    03.6
076B:  CLRF   30
076C:  CLRF   31
076D:  CLRF   32
076E:  CLRF   33
076F:  CLRF   34
0770:  CLRF   35
0771:  CLRF   36
0772:  CLRF   37
0773:  CLRF   38
0774:  CLRF   39
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
0775:  CLRF   3A
0776:  CLRF   3B
0777:  CLRF   3C
0778:  CLRF   3D
0779:  CLRF   3E
077A:  CLRF   3F
077B:  CLRF   40
077C:  CLRF   41
077D:  CLRF   42
077E:  CLRF   43
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... //Puertos de Displays 
.................... tPort pNJugadorU; 
.................... tPort pNJugadorD; 
.................... tPort pFJugadorU; 
.................... tPort pFJugadorD; 
....................  
.................... //Tiempo 
.................... int8 m_d=0; 
.................... int8 m_u=0; 
.................... int8 s_d=0; 
.................... int8 s_u=0; 
.................... int1 enableTime = false; 
....................  
.................... //Tiro 
.................... int8 sh_d=0; 
.................... int8 sh_u=0; 
.................... int1 enableShot = false; 
....................  
.................... int1 pauseTime = false; 
....................  
.................... int8 scoreLU =0; 
.................... int8 scoreLD =0; 
.................... int1 scoreLC =0; 
.................... int8 scoreVU =0; 
.................... int8 scoreVD =0; 
.................... int1 scoreVC =0; 
....................  
.................... // ::[PROTOTIPOS]:: 
....................  
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick); 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void timeTick(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8 char2int(char);  
.................... void doReset(void); 
.................... void sendN2Port(int8, int8, int8); 
.................... void timeSet(int8, int8, int8, int8); 
.................... void shotSet(int8, int8); 
.................... void timePass(); 
.................... void shotPass(); 
.................... void doBuzz(int); 
.................... void setScoreL (int8, int8, int8); 
.................... void setScoreV (int8, int8, int8); 
.................... void i2c_send(int8, int8); 
.................... void addScoreL (int8); 
.................... void addScoreV (int8); 
.................... void resScoreL (void); 
.................... void resScoreV (void); 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
077F:  CLRF   60
0780:  CLRF   61
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // *FUNCION:      setup() 
.................... // *PARAMETROS:   ninguno 
.................... // *REGRESA:      VOID 
.................... // *RESUMEN:      Configuracion inicial del dispositivo 
.................... void setup() 
.................... { 
....................    output_a (0x00) ; 
*
1000:  MOVLW  0F
1001:  BSF    03.5
1002:  MOVWF  05
1003:  BCF    03.5
1004:  CLRF   05
....................    output_b (0x00) ; 
1005:  BSF    03.5
1006:  CLRF   06
1007:  BCF    03.5
1008:  CLRF   06
....................    output_c (0x00) ; 
1009:  MOVLW  DF
100A:  BSF    03.5
100B:  MOVWF  07
100C:  BCF    03.5
100D:  CLRF   07
....................    output_d (0x00) ; 
100E:  BSF    03.5
100F:  CLRF   08
1010:  BCF    03.5
1011:  CLRF   08
....................    output_e (0x00) ; 
1012:  BSF    03.5
1013:  BCF    09.0
1014:  BCF    09.1
1015:  BCF    09.2
1016:  BCF    09.3
1017:  BCF    03.5
1018:  CLRF   09
1019:  CLRF   2B
101A:  BTFSC  0B.7
101B:  BSF    2B.7
101C:  BCF    0B.7
....................     
....................    delay_ms (DEFAULT_D) ; 
101D:  MOVLW  64
101E:  BSF    03.5
101F:  MOVWF  32
1020:  BCF    0A.4
1021:  BCF    03.5
1022:  CALL   309
1023:  BSF    0A.4
1024:  BTFSC  2B.7
1025:  BSF    0B.7
....................     
....................    IF (DEBUG) 
1026:  BTFSS  07.2
1027:  GOTO   099
....................    { 
....................       fprintf (RS232, "********************************\r") ; 
1028:  MOVLW  5F
1029:  BSF    03.6
102A:  MOVWF  0D
102B:  MOVLW  00
102C:  MOVWF  0F
102D:  BCF    0A.4
102E:  BCF    03.6
102F:  CALL   631
1030:  BSF    0A.4
....................       fprintf (RS232, " Grupo APM (c) 2020 \r") ; 
1031:  MOVLW  70
1032:  BSF    03.6
1033:  MOVWF  0D
1034:  MOVLW  00
1035:  MOVWF  0F
1036:  BCF    0A.4
1037:  BCF    03.6
1038:  CALL   631
1039:  BSF    0A.4
....................       fprintf (RS232, "================================\r"); 
103A:  MOVLW  7B
103B:  BSF    03.6
103C:  MOVWF  0D
103D:  MOVLW  00
103E:  MOVWF  0F
103F:  BCF    0A.4
1040:  BCF    03.6
1041:  CALL   631
1042:  BSF    0A.4
....................       fprintf (RS232, "Bluetooth Basketball Score Board\r") ; 
1043:  MOVLW  8C
1044:  BSF    03.6
1045:  MOVWF  0D
1046:  MOVLW  00
1047:  MOVWF  0F
1048:  BCF    0A.4
1049:  BCF    03.6
104A:  CALL   631
104B:  BSF    0A.4
....................       fprintf (RS232, "================================\r"); 
104C:  MOVLW  9D
104D:  BSF    03.6
104E:  MOVWF  0D
104F:  MOVLW  00
1050:  MOVWF  0F
1051:  BCF    0A.4
1052:  BCF    03.6
1053:  CALL   631
1054:  BSF    0A.4
....................       fprintf (RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
1055:  MOVLW  AE
1056:  BSF    03.6
1057:  MOVWF  0D
1058:  MOVLW  00
1059:  MOVWF  0F
105A:  BCF    03.0
105B:  MOVLW  08
105C:  BCF    03.6
105D:  MOVWF  6C
105E:  BCF    0A.4
105F:  CALL   689
1060:  BSF    0A.4
1061:  MOVLW  B9
1062:  BSF    03.6
1063:  MOVWF  0D
1064:  MOVLW  00
1065:  MOVWF  0F
1066:  BCF    0A.4
1067:  BCF    03.6
1068:  CALL   631
1069:  BSF    0A.4
106A:  MOVLW  B3
106B:  BSF    03.6
106C:  MOVWF  0D
106D:  MOVLW  00
106E:  MOVWF  0F
106F:  BCF    03.0
1070:  MOVLW  07
1071:  BCF    03.6
1072:  MOVWF  6C
1073:  BCF    0A.4
1074:  CALL   689
1075:  BSF    0A.4
1076:  MOVLW  BB
1077:  BSF    03.6
1078:  MOVWF  0D
1079:  MOVLW  00
107A:  MOVWF  0F
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   631
107E:  BSF    0A.4
107F:  MOVLW  20
1080:  BTFSS  0C.4
1081:  GOTO   080
1082:  MOVWF  19
1083:  MOVLW  0D
1084:  BTFSS  0C.4
1085:  GOTO   084
1086:  MOVWF  19
....................       fprintf (RS232, "********************************\r") ; 
1087:  MOVLW  BC
1088:  BSF    03.6
1089:  MOVWF  0D
108A:  MOVLW  00
108B:  MOVWF  0F
108C:  BCF    0A.4
108D:  BCF    03.6
108E:  CALL   631
108F:  BSF    0A.4
....................       fprintf (RS232, " DEPURACION :: COMUNICACIONES \r"); 
1090:  MOVLW  CD
1091:  BSF    03.6
1092:  MOVWF  0D
1093:  MOVLW  00
1094:  MOVWF  0F
1095:  BCF    0A.4
1096:  BCF    03.6
1097:  CALL   631
1098:  BSF    0A.4
1099:  CLRF   2B
109A:  BTFSC  0B.7
109B:  BSF    2B.7
109C:  BCF    0B.7
....................    } 
....................  
....................    delay_ms (DEFAULT_D) ; 
109D:  MOVLW  64
109E:  BSF    03.5
109F:  MOVWF  32
10A0:  BCF    0A.4
10A1:  BCF    03.5
10A2:  CALL   309
10A3:  BSF    0A.4
10A4:  BTFSC  2B.7
10A5:  BSF    0B.7
....................     
....................    IF (DEBUG){fputs (" > Configuracion de Puertos", RS232); } 
10A6:  BTFSS  07.2
10A7:  GOTO   0BF
10A8:  MOVLW  DD
10A9:  BSF    03.6
10AA:  MOVWF  0D
10AB:  MOVLW  00
10AC:  MOVWF  0F
10AD:  BCF    03.6
10AE:  CLRF   2B
10AF:  BTFSC  0B.7
10B0:  BSF    2B.7
10B1:  BCF    0B.7
10B2:  BCF    0A.4
10B3:  CALL   117
10B4:  BSF    0A.4
10B5:  BTFSC  2B.7
10B6:  BSF    0B.7
10B7:  MOVLW  0D
10B8:  BTFSS  0C.4
10B9:  GOTO   0B8
10BA:  MOVWF  19
10BB:  MOVLW  0A
10BC:  BTFSS  0C.4
10BD:  GOTO   0BC
10BE:  MOVWF  19
....................     
....................    pNJugadorU.a = PIN_B0; 
10BF:  MOVLW  30
10C0:  MOVWF  46
....................    pNJugadorU.b = PIN_B1; 
10C1:  MOVLW  31
10C2:  MOVWF  47
....................    pNJugadorU.c = PIN_B2; 
10C3:  MOVLW  32
10C4:  MOVWF  48
....................    pNJugadorU.d = PIN_B3; 
10C5:  MOVLW  33
10C6:  MOVWF  49
....................     
....................    pNJugadorD.a = PIN_B4; 
10C7:  MOVLW  34
10C8:  MOVWF  4A
....................    pNJugadorD.b = PIN_B5; 
10C9:  MOVLW  35
10CA:  MOVWF  4B
....................    pNJugadorD.c = PIN_B6; 
10CB:  MOVLW  36
10CC:  MOVWF  4C
....................    pNJugadorD.d = PIN_B7; 
10CD:  MOVLW  37
10CE:  MOVWF  4D
....................     
....................    pFJugadorU.a = PIN_D0; 
10CF:  MOVLW  40
10D0:  MOVWF  4E
....................    pFJugadorU.b = PIN_D1; 
10D1:  MOVLW  41
10D2:  MOVWF  4F
....................    pFJugadorU.c = PIN_D2; 
10D3:  MOVLW  42
10D4:  MOVWF  50
....................    pFJugadorU.d = PIN_D3; 
10D5:  MOVLW  43
10D6:  MOVWF  51
....................     
....................    pFJugadorD.a = PIN_D4; 
10D7:  MOVLW  44
10D8:  MOVWF  52
....................    pFJugadorD.b = PIN_D5; 
10D9:  MOVLW  45
10DA:  MOVWF  53
....................    pFJugadorD.c = PIN_D6; 
10DB:  MOVLW  46
10DC:  MOVWF  54
....................    pFJugadorD.d = PIN_D7; 
10DD:  MOVLW  47
10DE:  MOVWF  55
10DF:  CLRF   2B
10E0:  BTFSC  0B.7
10E1:  BSF    2B.7
10E2:  BCF    0B.7
....................    delay_ms (DEFAULT_D) ; 
10E3:  MOVLW  64
10E4:  BSF    03.5
10E5:  MOVWF  32
10E6:  BCF    0A.4
10E7:  BCF    03.5
10E8:  CALL   309
10E9:  BSF    0A.4
10EA:  BTFSC  2B.7
10EB:  BSF    0B.7
....................     
....................    IF (DEBUG){fputs (" > Inicializacion de I2C", RS232); } 
10EC:  BTFSS  07.2
10ED:  GOTO   105
10EE:  MOVLW  EB
10EF:  BSF    03.6
10F0:  MOVWF  0D
10F1:  MOVLW  00
10F2:  MOVWF  0F
10F3:  BCF    03.6
10F4:  CLRF   2B
10F5:  BTFSC  0B.7
10F6:  BSF    2B.7
10F7:  BCF    0B.7
10F8:  BCF    0A.4
10F9:  CALL   117
10FA:  BSF    0A.4
10FB:  BTFSC  2B.7
10FC:  BSF    0B.7
10FD:  MOVLW  0D
10FE:  BTFSS  0C.4
10FF:  GOTO   0FE
1100:  MOVWF  19
1101:  MOVLW  0A
1102:  BTFSS  0C.4
1103:  GOTO   102
1104:  MOVWF  19
....................    i2c_speed (100000) ; 
1105:  MOVLW  13
1106:  BSF    03.5
1107:  MOVWF  13
1108:  MOVLW  28
1109:  BCF    03.5
110A:  MOVWF  14
110B:  BSF    03.5
110C:  BSF    14.7
....................     
....................    IF (DEBUG){fputs (" > Habilitacion de displays", RS232); } 
110D:  BCF    03.5
110E:  BTFSS  07.2
110F:  GOTO   127
1110:  MOVLW  F8
1111:  BSF    03.6
1112:  MOVWF  0D
1113:  MOVLW  00
1114:  MOVWF  0F
1115:  BCF    03.6
1116:  CLRF   2B
1117:  BTFSC  0B.7
1118:  BSF    2B.7
1119:  BCF    0B.7
111A:  BCF    0A.4
111B:  CALL   117
111C:  BSF    0A.4
111D:  BTFSC  2B.7
111E:  BSF    0B.7
111F:  MOVLW  0D
1120:  BTFSS  0C.4
1121:  GOTO   120
1122:  MOVWF  19
1123:  MOVLW  0A
1124:  BTFSS  0C.4
1125:  GOTO   124
1126:  MOVWF  19
....................    output_bit (DISPLAY, ON); 
1127:  BSF    09.0
1128:  MOVLW  EE
1129:  BSF    03.5
112A:  MOVWF  09
112B:  BCF    03.5
112C:  CLRF   2B
112D:  BTFSC  0B.7
112E:  BSF    2B.7
112F:  BCF    0B.7
....................    delay_ms (DEFAULT_D) ; 
1130:  MOVLW  64
1131:  BSF    03.5
1132:  MOVWF  32
1133:  BCF    0A.4
1134:  BCF    03.5
1135:  CALL   309
1136:  BSF    0A.4
1137:  BTFSC  2B.7
1138:  BSF    0B.7
....................    output_bit (DISPLAY, OFF); 
1139:  BCF    09.0
113A:  MOVLW  EE
113B:  BSF    03.5
113C:  MOVWF  09
113D:  BCF    03.5
113E:  CLRF   2B
113F:  BTFSC  0B.7
1140:  BSF    2B.7
1141:  BCF    0B.7
....................    delay_ms (DEFAULT_D) ; 
1142:  MOVLW  64
1143:  BSF    03.5
1144:  MOVWF  32
1145:  BCF    0A.4
1146:  BCF    03.5
1147:  CALL   309
1148:  BSF    0A.4
1149:  BTFSC  2B.7
114A:  BSF    0B.7
....................    output_bit (DISPLAY, ON); 
114B:  BSF    09.0
114C:  MOVLW  EE
114D:  BSF    03.5
114E:  MOVWF  09
114F:  BCF    03.5
1150:  CLRF   2B
1151:  BTFSC  0B.7
1152:  BSF    2B.7
1153:  BCF    0B.7
....................    delay_ms (DEFAULT_D) ; 
1154:  MOVLW  64
1155:  BSF    03.5
1156:  MOVWF  32
1157:  BCF    0A.4
1158:  BCF    03.5
1159:  CALL   309
115A:  BSF    0A.4
115B:  BTFSC  2B.7
115C:  BSF    0B.7
....................     
....................    IF (DEBUG){fputs (" > Habilitacion de interrupciones", RS232); } 
115D:  BTFSS  07.2
115E:  GOTO   176
115F:  MOVLW  06
1160:  BSF    03.6
1161:  MOVWF  0D
1162:  MOVLW  01
1163:  MOVWF  0F
1164:  BCF    03.6
1165:  CLRF   2B
1166:  BTFSC  0B.7
1167:  BSF    2B.7
1168:  BCF    0B.7
1169:  BCF    0A.4
116A:  CALL   117
116B:  BSF    0A.4
116C:  BTFSC  2B.7
116D:  BSF    0B.7
116E:  MOVLW  0D
116F:  BTFSS  0C.4
1170:  GOTO   16F
1171:  MOVWF  19
1172:  MOVLW  0A
1173:  BTFSS  0C.4
1174:  GOTO   173
1175:  MOVWF  19
....................    enable_interrupts (INT_RDA) ; 
1176:  BSF    03.5
1177:  BSF    0C.5
....................    enable_interrupts (GLOBAL) ; 
1178:  MOVLW  C0
1179:  BCF    03.5
117A:  IORWF  0B,F
117B:  BCF    0A.3
117C:  BCF    0A.4
117D:  GOTO   783 (RETURN)
.................... } 
....................  
.................... void main() 
*
071B:  MOVF   03,W
071C:  ANDLW  1F
071D:  MOVWF  03
071E:  MOVLW  71
071F:  BSF    03.5
0720:  MOVWF  0F
0721:  CLRF   10
0722:  MOVF   0F,W
0723:  BSF    03.6
0724:  BCF    07.3
0725:  MOVLW  0C
0726:  BCF    03.6
0727:  MOVWF  19
0728:  MOVLW  A2
0729:  MOVWF  18
072A:  MOVLW  90
072B:  BCF    03.5
072C:  MOVWF  18
072D:  MOVLW  DF
072E:  BSF    03.5
072F:  MOVWF  07
0730:  MOVLW  DF
0731:  MOVWF  07
0732:  MOVLW  04
0733:  MOVWF  13
0734:  MOVLW  28
0735:  BCF    03.5
0736:  MOVWF  14
0737:  BSF    03.5
0738:  BCF    14.7
0739:  BCF    14.6
073A:  BCF    03.5
073B:  CLRF   2F
073C:  CLRF   2E
073D:  CLRF   2D
073E:  CLRF   2C
073F:  BSF    03.5
0740:  MOVF   01,W
0741:  ANDLW  C0
0742:  IORLW  06
0743:  MOVWF  01
0744:  BCF    03.5
0745:  CLRF   01
0746:  BCF    0B.2
0747:  CLRF   44
0748:  BCF    45.0
0749:  CLRF   56
074A:  CLRF   57
074B:  CLRF   58
074C:  CLRF   59
074D:  BCF    45.1
074E:  CLRF   5A
074F:  CLRF   5B
0750:  BCF    45.2
0751:  BCF    45.3
0752:  CLRF   5C
0753:  CLRF   5D
0754:  BCF    45.4
0755:  CLRF   5E
0756:  CLRF   5F
0757:  BCF    45.5
0758:  CLRF   63
0759:  CLRF   62
075A:  BSF    03.5
075B:  BSF    03.6
075C:  MOVF   09,W
075D:  ANDLW  C0
075E:  MOVWF  09
075F:  BCF    03.6
0760:  BCF    1F.4
0761:  BCF    1F.5
0762:  MOVLW  00
0763:  BSF    03.6
0764:  MOVWF  08
0765:  BCF    03.5
0766:  CLRF   07
0767:  CLRF   08
0768:  CLRF   09
0769:  BCF    03.7
.................... { 
....................    setup () ; 
*
0781:  BSF    0A.4
0782:  GOTO   000
0783:  BCF    0A.4
....................     
....................    TICK_TYPE CurrentTick, PreviousTick; 
....................    CurrentTick = PreviousTick = get_ticks (); 
0784:  CALL   6E7
0785:  MOVF   7A,W
0786:  MOVWF  6B
0787:  MOVF   79,W
0788:  MOVWF  6A
0789:  MOVF   78,W
078A:  MOVWF  69
078B:  MOVF   77,W
078C:  MOVWF  68
078D:  MOVF   6B,W
078E:  MOVWF  67
078F:  MOVF   6A,W
0790:  MOVWF  66
0791:  MOVF   69,W
0792:  MOVWF  65
0793:  MOVF   68,W
0794:  MOVWF  64
....................  
....................    WHILE (TRUE) 
....................    { 
....................       IF ( ! pauseTime) 
0795:  BTFSC  45.3
0796:  GOTO   7D5
....................       { 
....................          CurrentTick = get_ticks (); 
0797:  CALL   6E7
0798:  MOVF   7A,W
0799:  MOVWF  67
079A:  MOVF   79,W
079B:  MOVWF  66
079C:  MOVF   78,W
079D:  MOVWF  65
079E:  MOVF   77,W
079F:  MOVWF  64
....................  
....................          IF (GetTickDifference (CurrentTick, PreviousTick) >= (TICK_TYPE) TICKS_PER_SECOND) 
07A0:  MOVF   67,W
07A1:  MOVWF  6F
07A2:  MOVF   66,W
07A3:  MOVWF  6E
07A4:  MOVF   65,W
07A5:  MOVWF  6D
07A6:  MOVF   64,W
07A7:  MOVWF  6C
07A8:  MOVF   6B,W
07A9:  MOVWF  73
07AA:  MOVF   6A,W
07AB:  MOVWF  72
07AC:  MOVF   69,W
07AD:  MOVWF  71
07AE:  MOVF   68,W
07AF:  MOVWF  70
07B0:  GOTO   703
07B1:  MOVF   7A,W
07B2:  MOVWF  6F
07B3:  MOVF   79,W
07B4:  MOVWF  6E
07B5:  MOVF   78,W
07B6:  MOVWF  6D
07B7:  MOVF   77,W
07B8:  MOVWF  6C
07B9:  MOVF   6F,F
07BA:  BTFSS  03.2
07BB:  GOTO   7CA
07BC:  MOVF   6E,F
07BD:  BTFSS  03.2
07BE:  GOTO   7CA
07BF:  MOVF   6D,W
07C0:  SUBLW  1D
07C1:  BTFSC  03.0
07C2:  GOTO   7D5
07C3:  XORLW  FF
07C4:  BTFSS  03.2
07C5:  GOTO   7CA
07C6:  MOVF   6C,W
07C7:  SUBLW  83
07C8:  BTFSC  03.0
07C9:  GOTO   7D5
....................          { 
....................             timeTick () ; 
07CA:  BSF    0A.4
07CB:  GOTO   17E
07CC:  BCF    0A.4
....................             PreviousTick = CurrentTick; 
07CD:  MOVF   67,W
07CE:  MOVWF  6B
07CF:  MOVF   66,W
07D0:  MOVWF  6A
07D1:  MOVF   65,W
07D2:  MOVWF  69
07D3:  MOVF   64,W
07D4:  MOVWF  68
....................          } 
....................       } 
07D5:  GOTO   795
....................    } 
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(VOID)  
07D6:  SLEEP
.................... { 
....................    CHAR c; 
....................    c = fgetc (RS232); 
*
0465:  BTFSS  0C.5
0466:  GOTO   465
0467:  MOVF   1A,W
0468:  MOVWF  7B
....................  
....................    IF(cmdGet) 
0469:  BTFSS  45.0
046A:  GOTO   49F
....................    { 
....................       IF (c == '#'||c == '\r') 
046B:  MOVF   7B,W
046C:  SUBLW  23
046D:  BTFSC  03.2
046E:  GOTO   473
046F:  MOVF   7B,W
0470:  SUBLW  0D
0471:  BTFSS  03.2
0472:  GOTO   494
....................       { 
....................          cmdGet = false; 
0473:  BCF    45.0
....................          strcpy (cmd, rcmd); 
0474:  BSF    03.5
0475:  CLRF   23
0476:  MOVLW  3A
0477:  MOVWF  22
0478:  CLRF   21
0479:  MOVLW  30
047A:  MOVWF  20
047B:  MOVF   22,W
047C:  MOVWF  04
047D:  BCF    03.7
047E:  BTFSC  23.0
047F:  BSF    03.7
0480:  MOVF   00,W
0481:  MOVWF  24
0482:  MOVF   20,W
0483:  MOVWF  04
0484:  BCF    03.7
0485:  BTFSC  21.0
0486:  BSF    03.7
0487:  MOVF   24,W
0488:  MOVWF  00
0489:  MOVF   00,F
048A:  BTFSC  03.2
048B:  GOTO   48F
048C:  INCF   20,F
048D:  INCF   22,F
048E:  GOTO   47B
....................          parseCommand () ; 
048F:  BSF    0A.3
0490:  BCF    03.5
0491:  GOTO   000
0492:  BCF    0A.3
....................       } 
0493:  GOTO   49F
....................  
....................       ELSE 
....................       { 
....................          IF (cmdIndex < 9) 
0494:  MOVF   44,W
0495:  SUBLW  08
0496:  BTFSS  03.0
0497:  GOTO   49F
....................          { 
....................             rcmd[cmdIndex] = c; 
0498:  MOVLW  3A
0499:  ADDWF  44,W
049A:  MOVWF  04
049B:  BCF    03.7
049C:  MOVF   7B,W
049D:  MOVWF  00
....................             cmdIndex++; 
049E:  INCF   44,F
....................          } 
....................       } 
....................    } 
....................  
....................    IF (c == '-') 
049F:  MOVF   7B,W
04A0:  SUBLW  2D
04A1:  BTFSS  03.2
04A2:  GOTO   4B9
....................    { 
....................       cmdGet = true; 
04A3:  BSF    45.0
....................       rcmd = "\0\0\0\0\0\0\0\0\0"; 
04A4:  BSF    03.5
04A5:  CLRF   20
04A6:  CLRF   21
04A7:  MOVLW  3A
04A8:  MOVWF  04
04A9:  BCF    03.7
04AA:  MOVF   20,W
04AB:  ADDWF  04,F
04AC:  MOVF   21,W
04AD:  BCF    03.5
04AE:  CALL   051
04AF:  MOVWF  00
04B0:  IORLW  00
04B1:  BTFSC  03.2
04B2:  GOTO   4B8
04B3:  BSF    03.5
04B4:  INCF   21,F
04B5:  INCF   20,F
04B6:  GOTO   4A7
04B7:  BCF    03.5
....................       cmdIndex = 0; 
04B8:  CLRF   44
....................    } 
04B9:  BCF    0C.5
04BA:  BCF    0A.3
04BB:  BCF    0A.4
04BC:  GOTO   02D
.................... } 
....................  
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick) 
.................... { 
....................    RETURN (currTick - prevTick) ; 
*
0703:  MOVF   70,W
0704:  SUBWF  6C,W
0705:  MOVWF  77
0706:  MOVF   6D,W
0707:  MOVWF  78
0708:  MOVF   71,W
0709:  BTFSS  03.0
070A:  INCFSZ 71,W
070B:  SUBWF  78,F
070C:  MOVF   6E,W
070D:  MOVWF  79
070E:  MOVF   72,W
070F:  BTFSS  03.0
0710:  INCFSZ 72,W
0711:  SUBWF  79,F
0712:  MOVF   6F,W
0713:  MOVWF  7A
0714:  MOVF   73,W
0715:  BTFSS  03.0
0716:  INCFSZ 73,W
0717:  SUBWF  7A,F
0718:  BCF    0A.3
0719:  BCF    0A.4
071A:  GOTO   7B1 (RETURN)
.................... } 
....................  
.................... void timeTick(VOID) 
.................... { 
....................    IF (enableTime) 
*
117E:  BTFSS  45.1
117F:  GOTO   248
....................       timePass () ; 
....................  
....................    IF (enableShot) 
*
1248:  BTFSS  45.2
1249:  GOTO   2A3
....................       shotPass () ; 
*
12A3:  BCF    0A.3
12A4:  BCF    0A.4
12A5:  GOTO   7CC (RETURN)
.................... } 
....................  
.................... void doTest(VOID) 
.................... { 
....................    IF (DEBUG){fputs (" > Rutina de prueba", RS232); } 
*
0EBF:  BTFSS  07.2
0EC0:  GOTO   6D2
0EC1:  MOVLW  BD
0EC2:  BSF    03.6
0EC3:  MOVWF  0D
0EC4:  MOVLW  04
0EC5:  MOVWF  0F
0EC6:  BCF    0A.3
0EC7:  BCF    03.6
0EC8:  CALL   117
0EC9:  BSF    0A.3
0ECA:  MOVLW  0D
0ECB:  BTFSS  0C.4
0ECC:  GOTO   6CB
0ECD:  MOVWF  19
0ECE:  MOVLW  0A
0ECF:  BTFSS  0C.4
0ED0:  GOTO   6CF
0ED1:  MOVWF  19
....................    IF (DEBUG){fputs (" > Probando modulo tiempo", RS232); } 
0ED2:  BTFSS  07.2
0ED3:  GOTO   6E5
0ED4:  MOVLW  C7
0ED5:  BSF    03.6
0ED6:  MOVWF  0D
0ED7:  MOVLW  04
0ED8:  MOVWF  0F
0ED9:  BCF    0A.3
0EDA:  BCF    03.6
0EDB:  CALL   117
0EDC:  BSF    0A.3
0EDD:  MOVLW  0D
0EDE:  BTFSS  0C.4
0EDF:  GOTO   6DE
0EE0:  MOVWF  19
0EE1:  MOVLW  0A
0EE2:  BTFSS  0C.4
0EE3:  GOTO   6E2
0EE4:  MOVWF  19
....................       i2c_send (I2C_TIMER, I2C_CMD_TEST); 
0EE5:  MOVLW  0A
0EE6:  BSF    03.5
0EE7:  MOVWF  36
0EE8:  MOVLW  FF
0EE9:  MOVWF  37
0EEA:  BCF    0A.3
0EEB:  BCF    03.5
0EEC:  CALL   2C7
0EED:  BSF    0A.3
....................    IF (DEBUG){fputs (" > Probando modulo puntos", RS232); } 
0EEE:  BTFSS  07.2
0EEF:  GOTO   701
0EF0:  MOVLW  D4
0EF1:  BSF    03.6
0EF2:  MOVWF  0D
0EF3:  MOVLW  04
0EF4:  MOVWF  0F
0EF5:  BCF    0A.3
0EF6:  BCF    03.6
0EF7:  CALL   117
0EF8:  BSF    0A.3
0EF9:  MOVLW  0D
0EFA:  BTFSS  0C.4
0EFB:  GOTO   6FA
0EFC:  MOVWF  19
0EFD:  MOVLW  0A
0EFE:  BTFSS  0C.4
0EFF:  GOTO   6FE
0F00:  MOVWF  19
....................       i2c_send (I2C_SCORE, I2C_CMD_TEST); 
0F01:  MOVLW  0C
0F02:  BSF    03.5
0F03:  MOVWF  36
0F04:  MOVLW  FF
0F05:  MOVWF  37
0F06:  BCF    0A.3
0F07:  BCF    03.5
0F08:  CALL   2C7
0F09:  BSF    0A.3
....................    IF (DEBUG){fputs (" > Probando modulo comunicaciones", RS232); } 
0F0A:  BTFSS  07.2
0F0B:  GOTO   71D
0F0C:  MOVLW  E1
0F0D:  BSF    03.6
0F0E:  MOVWF  0D
0F0F:  MOVLW  04
0F10:  MOVWF  0F
0F11:  BCF    0A.3
0F12:  BCF    03.6
0F13:  CALL   117
0F14:  BSF    0A.3
0F15:  MOVLW  0D
0F16:  BTFSS  0C.4
0F17:  GOTO   716
0F18:  MOVWF  19
0F19:  MOVLW  0A
0F1A:  BTFSS  0C.4
0F1B:  GOTO   71A
0F1C:  MOVWF  19
....................    for (INT i = 0; i<10; i++) 
0F1D:  BSF    03.5
0F1E:  CLRF   2A
0F1F:  MOVF   2A,W
0F20:  SUBLW  09
0F21:  BTFSS  03.0
0F22:  GOTO   788
....................    { 
....................       showNumber (i, pNJugadorD); 
0F23:  MOVF   2A,W
0F24:  MOVWF  2B
0F25:  BCF    03.5
0F26:  MOVF   4D,W
0F27:  BSF    03.5
0F28:  MOVWF  2F
0F29:  BCF    03.5
0F2A:  MOVF   4C,W
0F2B:  BSF    03.5
0F2C:  MOVWF  2E
0F2D:  BCF    03.5
0F2E:  MOVF   4B,W
0F2F:  BSF    03.5
0F30:  MOVWF  2D
0F31:  BCF    03.5
0F32:  MOVF   4A,W
0F33:  BSF    03.5
0F34:  MOVWF  2C
0F35:  BCF    0A.3
0F36:  BCF    03.5
0F37:  CALL   1FD
0F38:  BSF    0A.3
....................       showNumber (i, pNJugadorU); 
0F39:  BSF    03.5
0F3A:  MOVF   2A,W
0F3B:  MOVWF  2B
0F3C:  BCF    03.5
0F3D:  MOVF   49,W
0F3E:  BSF    03.5
0F3F:  MOVWF  2F
0F40:  BCF    03.5
0F41:  MOVF   48,W
0F42:  BSF    03.5
0F43:  MOVWF  2E
0F44:  BCF    03.5
0F45:  MOVF   47,W
0F46:  BSF    03.5
0F47:  MOVWF  2D
0F48:  BCF    03.5
0F49:  MOVF   46,W
0F4A:  BSF    03.5
0F4B:  MOVWF  2C
0F4C:  BCF    0A.3
0F4D:  BCF    03.5
0F4E:  CALL   1FD
0F4F:  BSF    0A.3
....................       showNumber (i, pFJugadorD); 
0F50:  BSF    03.5
0F51:  MOVF   2A,W
0F52:  MOVWF  2B
0F53:  BCF    03.5
0F54:  MOVF   55,W
0F55:  BSF    03.5
0F56:  MOVWF  2F
0F57:  BCF    03.5
0F58:  MOVF   54,W
0F59:  BSF    03.5
0F5A:  MOVWF  2E
0F5B:  BCF    03.5
0F5C:  MOVF   53,W
0F5D:  BSF    03.5
0F5E:  MOVWF  2D
0F5F:  BCF    03.5
0F60:  MOVF   52,W
0F61:  BSF    03.5
0F62:  MOVWF  2C
0F63:  BCF    0A.3
0F64:  BCF    03.5
0F65:  CALL   1FD
0F66:  BSF    0A.3
....................       showNumber (i, pFJugadorU); 
0F67:  BSF    03.5
0F68:  MOVF   2A,W
0F69:  MOVWF  2B
0F6A:  BCF    03.5
0F6B:  MOVF   51,W
0F6C:  BSF    03.5
0F6D:  MOVWF  2F
0F6E:  BCF    03.5
0F6F:  MOVF   50,W
0F70:  BSF    03.5
0F71:  MOVWF  2E
0F72:  BCF    03.5
0F73:  MOVF   4F,W
0F74:  BSF    03.5
0F75:  MOVWF  2D
0F76:  BCF    03.5
0F77:  MOVF   4E,W
0F78:  BSF    03.5
0F79:  MOVWF  2C
0F7A:  BCF    0A.3
0F7B:  BCF    03.5
0F7C:  CALL   1FD
0F7D:  BSF    0A.3
....................       delay_ms (I2CWAIT); 
0F7E:  MOVLW  32
0F7F:  BSF    03.5
0F80:  MOVWF  32
0F81:  BCF    0A.3
0F82:  BCF    03.5
0F83:  CALL   309
0F84:  BSF    0A.3
0F85:  BSF    03.5
0F86:  INCF   2A,F
0F87:  GOTO   71F
....................    } 
.................... } 
....................  
....................  
.................... void doBuzz(INT t) 
.................... { 
....................    i2c_start () ; 
*
0291:  BSF    03.5
0292:  BSF    11.0
0293:  BTFSC  11.0
0294:  GOTO   293
....................    i2c_write (I2C_TIMER) ; 
0295:  MOVLW  0A
0296:  MOVWF  38
....................    i2c_write (0x80 + t); 
*
02A9:  MOVLW  80
02AA:  BSF    03.5
02AB:  ADDWF  2A,W
02AC:  MOVWF  2B
02AD:  MOVF   2B,W
02AE:  MOVWF  38
....................    i2c_stop () ; 
*
02C1:  BSF    03.5
02C2:  BSF    11.2
02C3:  BTFSC  11.2
02C4:  GOTO   2C3
02C5:  BCF    03.5
02C6:  RETURN
.................... } 
....................  
.................... void parseCommand(VOID) 
.................... { 
....................    CHAR c[10]; 
....................    strcpy (c, cmd); 
*
0800:  BSF    03.5
0801:  CLRF   2D
0802:  MOVLW  30
0803:  MOVWF  2C
0804:  CLRF   2B
0805:  MOVLW  A0
0806:  MOVWF  2A
0807:  MOVF   2C,W
0808:  MOVWF  04
0809:  BCF    03.7
080A:  BTFSC  2D.0
080B:  BSF    03.7
080C:  MOVF   00,W
080D:  MOVWF  2E
080E:  MOVF   2A,W
080F:  MOVWF  04
0810:  BCF    03.7
0811:  BTFSC  2B.0
0812:  BSF    03.7
0813:  MOVF   2E,W
0814:  MOVWF  00
0815:  MOVF   00,F
0816:  BTFSC  03.2
0817:  GOTO   01B
0818:  INCF   2A,F
0819:  INCF   2C,F
081A:  GOTO   007
....................  
....................    SWITCH (c[0]) 
081B:  MOVF   20,W
081C:  XORLW  30
081D:  BCF    03.5
081E:  BTFSC  03.2
081F:  GOTO   045
0820:  XORLW  72
0821:  BTFSC  03.2
0822:  GOTO   0E8
0823:  XORLW  04
0824:  BTFSC  03.2
0825:  GOTO   147
0826:  XORLW  0C
0827:  BTFSC  03.2
0828:  GOTO   199
0829:  XORLW  06
082A:  BTFSC  03.2
082B:  GOTO   1EB
082C:  XORLW  1C
082D:  BTFSC  03.2
082E:  GOTO   376
082F:  XORLW  01
0830:  BTFSC  03.2
0831:  GOTO   38B
0832:  XORLW  03
0833:  BTFSC  03.2
0834:  GOTO   3A0
0835:  XORLW  01
0836:  BTFSC  03.2
0837:  GOTO   447
0838:  XORLW  07
0839:  BTFSC  03.2
083A:  GOTO   497
083B:  XORLW  02
083C:  BTFSC  03.2
083D:  GOTO   534
083E:  XORLW  0E
083F:  BTFSC  03.2
0840:  GOTO   6BF
0841:  XORLW  02
0842:  BTFSC  03.2
0843:  GOTO   78A
0844:  GOTO   7C4
....................    { 
....................       case '0':   IF (DEBUG){fputs ("\r > Activacion manual de puerto", RS232); } 
0845:  BTFSS  07.2
0846:  GOTO   058
0847:  MOVLW  F2
0848:  BSF    03.6
0849:  MOVWF  0D
084A:  MOVLW  04
084B:  MOVWF  0F
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   117
084F:  BSF    0A.3
0850:  MOVLW  0D
0851:  BTFSS  0C.4
0852:  GOTO   051
0853:  MOVWF  19
0854:  MOVLW  0A
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
....................                   SWITCH (c[2]) 
0858:  MOVLW  31
0859:  BSF    03.5
085A:  SUBWF  22,W
085B:  ADDLW  FC
085C:  BTFSC  03.0
085D:  GOTO   0E6
085E:  ADDLW  04
085F:  BCF    03.5
0860:  GOTO   7C7
....................                   { 
....................                      CASE '1': showNumber (char2int (c[3]), pNJugadorD); 
0861:  BSF    03.5
0862:  MOVF   23,W
0863:  MOVWF  2D
0864:  BCF    0A.3
0865:  BCF    03.5
0866:  CALL   18D
0867:  BSF    0A.3
0868:  MOVF   78,W
0869:  BSF    03.5
086A:  MOVWF  2A
086B:  MOVWF  2B
086C:  BCF    03.5
086D:  MOVF   4D,W
086E:  BSF    03.5
086F:  MOVWF  2F
0870:  BCF    03.5
0871:  MOVF   4C,W
0872:  BSF    03.5
0873:  MOVWF  2E
0874:  BCF    03.5
0875:  MOVF   4B,W
0876:  BSF    03.5
0877:  MOVWF  2D
0878:  BCF    03.5
0879:  MOVF   4A,W
087A:  BSF    03.5
087B:  MOVWF  2C
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   1FD
087F:  BSF    0A.3
....................                      BREAK; 
0880:  BSF    03.5
0881:  GOTO   0E6
....................                      CASE '2': showNumber (char2int (c[3]), pNJugadorU); 
0882:  BSF    03.5
0883:  MOVF   23,W
0884:  MOVWF  2D
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   18D
0888:  BSF    0A.3
0889:  MOVF   78,W
088A:  BSF    03.5
088B:  MOVWF  2A
088C:  MOVWF  2B
088D:  BCF    03.5
088E:  MOVF   49,W
088F:  BSF    03.5
0890:  MOVWF  2F
0891:  BCF    03.5
0892:  MOVF   48,W
0893:  BSF    03.5
0894:  MOVWF  2E
0895:  BCF    03.5
0896:  MOVF   47,W
0897:  BSF    03.5
0898:  MOVWF  2D
0899:  BCF    03.5
089A:  MOVF   46,W
089B:  BSF    03.5
089C:  MOVWF  2C
089D:  BCF    0A.3
089E:  BCF    03.5
089F:  CALL   1FD
08A0:  BSF    0A.3
....................                      BREAK; 
08A1:  BSF    03.5
08A2:  GOTO   0E6
....................                      CASE '3': showNumber (char2int (c[3]), pFJugadorD); 
08A3:  BSF    03.5
08A4:  MOVF   23,W
08A5:  MOVWF  2D
08A6:  BCF    0A.3
08A7:  BCF    03.5
08A8:  CALL   18D
08A9:  BSF    0A.3
08AA:  MOVF   78,W
08AB:  BSF    03.5
08AC:  MOVWF  2A
08AD:  MOVWF  2B
08AE:  BCF    03.5
08AF:  MOVF   55,W
08B0:  BSF    03.5
08B1:  MOVWF  2F
08B2:  BCF    03.5
08B3:  MOVF   54,W
08B4:  BSF    03.5
08B5:  MOVWF  2E
08B6:  BCF    03.5
08B7:  MOVF   53,W
08B8:  BSF    03.5
08B9:  MOVWF  2D
08BA:  BCF    03.5
08BB:  MOVF   52,W
08BC:  BSF    03.5
08BD:  MOVWF  2C
08BE:  BCF    0A.3
08BF:  BCF    03.5
08C0:  CALL   1FD
08C1:  BSF    0A.3
....................                      BREAK; 
08C2:  BSF    03.5
08C3:  GOTO   0E6
....................                      CASE '4': showNumber (char2int (c[3]), pFJugadorU); 
08C4:  BSF    03.5
08C5:  MOVF   23,W
08C6:  MOVWF  2D
08C7:  BCF    0A.3
08C8:  BCF    03.5
08C9:  CALL   18D
08CA:  BSF    0A.3
08CB:  MOVF   78,W
08CC:  BSF    03.5
08CD:  MOVWF  2A
08CE:  MOVWF  2B
08CF:  BCF    03.5
08D0:  MOVF   51,W
08D1:  BSF    03.5
08D2:  MOVWF  2F
08D3:  BCF    03.5
08D4:  MOVF   50,W
08D5:  BSF    03.5
08D6:  MOVWF  2E
08D7:  BCF    03.5
08D8:  MOVF   4F,W
08D9:  BSF    03.5
08DA:  MOVWF  2D
08DB:  BCF    03.5
08DC:  MOVF   4E,W
08DD:  BSF    03.5
08DE:  MOVWF  2C
08DF:  BCF    0A.3
08E0:  BCF    03.5
08E1:  CALL   1FD
08E2:  BSF    0A.3
....................                      BREAK; 
08E3:  BSF    03.5
08E4:  GOTO   0E6
08E5:  BSF    03.5
....................                   } 
....................     
....................                   BREAK; 
08E6:  BCF    03.5
08E7:  GOTO   7C4
....................  
....................       case 'B': SWITCH (c[1]) 
08E8:  BSF    03.5
08E9:  MOVF   21,W
08EA:  XORLW  31
08EB:  BCF    03.5
08EC:  BTFSC  03.2
08ED:  GOTO   0F5
08EE:  XORLW  03
08EF:  BTFSC  03.2
08F0:  GOTO   110
08F1:  XORLW  01
08F2:  BTFSC  03.2
08F3:  GOTO   12B
08F4:  GOTO   146
....................       { 
....................          case '1': IF (DEBUG){fputs ("\r > Toque corto", RS232); } 
08F5:  BTFSS  07.2
08F6:  GOTO   108
08F7:  MOVLW  02
08F8:  BSF    03.6
08F9:  MOVWF  0D
08FA:  MOVLW  05
08FB:  MOVWF  0F
08FC:  BCF    0A.3
08FD:  BCF    03.6
08FE:  CALL   117
08FF:  BSF    0A.3
0900:  MOVLW  0D
0901:  BTFSS  0C.4
0902:  GOTO   101
0903:  MOVWF  19
0904:  MOVLW  0A
0905:  BTFSS  0C.4
0906:  GOTO   105
0907:  MOVWF  19
....................          doBuzz (1) ; 
0908:  MOVLW  01
0909:  BSF    03.5
090A:  MOVWF  2A
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   291
090E:  BSF    0A.3
....................          BREAK; 
090F:  GOTO   146
....................          case '2': IF (DEBUG){fputs ("\r > Toque largo", RS232); } 
0910:  BTFSS  07.2
0911:  GOTO   123
0912:  MOVLW  0A
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  05
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   117
091A:  BSF    0A.3
091B:  MOVLW  0D
091C:  BTFSS  0C.4
091D:  GOTO   11C
091E:  MOVWF  19
091F:  MOVLW  0A
0920:  BTFSS  0C.4
0921:  GOTO   120
0922:  MOVWF  19
....................          doBuzz (2) ; 
0923:  MOVLW  02
0924:  BSF    03.5
0925:  MOVWF  2A
0926:  BCF    0A.3
0927:  BCF    03.5
0928:  CALL   291
0929:  BSF    0A.3
....................          BREAK; 
092A:  GOTO   146
....................          case '3': IF (DEBUG){fputs ("\r > Toque doble", RS232); } 
092B:  BTFSS  07.2
092C:  GOTO   13E
092D:  MOVLW  12
092E:  BSF    03.6
092F:  MOVWF  0D
0930:  MOVLW  05
0931:  MOVWF  0F
0932:  BCF    0A.3
0933:  BCF    03.6
0934:  CALL   117
0935:  BSF    0A.3
0936:  MOVLW  0D
0937:  BTFSS  0C.4
0938:  GOTO   137
0939:  MOVWF  19
093A:  MOVLW  0A
093B:  BTFSS  0C.4
093C:  GOTO   13B
093D:  MOVWF  19
....................          doBuzz (3) ; 
093E:  MOVLW  03
093F:  BSF    03.5
0940:  MOVWF  2A
0941:  BCF    0A.3
0942:  BCF    03.5
0943:  CALL   291
0944:  BSF    0A.3
....................          BREAK; 
0945:  GOTO   146
....................       } 
....................  
....................       BREAK; 
0946:  GOTO   7C4
....................       case 'F': IF (DEBUG){fputs ("\r > Asignar faltas", RS232); } 
0947:  BTFSS  07.2
0948:  GOTO   15A
0949:  MOVLW  1A
094A:  BSF    03.6
094B:  MOVWF  0D
094C:  MOVLW  05
094D:  MOVWF  0F
094E:  BCF    0A.3
094F:  BCF    03.6
0950:  CALL   117
0951:  BSF    0A.3
0952:  MOVLW  0D
0953:  BTFSS  0C.4
0954:  GOTO   153
0955:  MOVWF  19
0956:  MOVLW  0A
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
....................       showNumber (char2int (c[1]), pFJugadorD); 
095A:  BSF    03.5
095B:  MOVF   21,W
095C:  MOVWF  2D
095D:  BCF    0A.3
095E:  BCF    03.5
095F:  CALL   18D
0960:  BSF    0A.3
0961:  MOVF   78,W
0962:  BSF    03.5
0963:  MOVWF  2A
0964:  MOVWF  2B
0965:  BCF    03.5
0966:  MOVF   55,W
0967:  BSF    03.5
0968:  MOVWF  2F
0969:  BCF    03.5
096A:  MOVF   54,W
096B:  BSF    03.5
096C:  MOVWF  2E
096D:  BCF    03.5
096E:  MOVF   53,W
096F:  BSF    03.5
0970:  MOVWF  2D
0971:  BCF    03.5
0972:  MOVF   52,W
0973:  BSF    03.5
0974:  MOVWF  2C
0975:  BCF    0A.3
0976:  BCF    03.5
0977:  CALL   1FD
0978:  BSF    0A.3
....................       showNumber (char2int (c[2]), pFJugadorU); 
0979:  BSF    03.5
097A:  MOVF   22,W
097B:  MOVWF  2D
097C:  BCF    0A.3
097D:  BCF    03.5
097E:  CALL   18D
097F:  BSF    0A.3
0980:  MOVF   78,W
0981:  BSF    03.5
0982:  MOVWF  2A
0983:  MOVWF  2B
0984:  BCF    03.5
0985:  MOVF   51,W
0986:  BSF    03.5
0987:  MOVWF  2F
0988:  BCF    03.5
0989:  MOVF   50,W
098A:  BSF    03.5
098B:  MOVWF  2E
098C:  BCF    03.5
098D:  MOVF   4F,W
098E:  BSF    03.5
098F:  MOVWF  2D
0990:  BCF    03.5
0991:  MOVF   4E,W
0992:  BSF    03.5
0993:  MOVWF  2C
0994:  BCF    0A.3
0995:  BCF    03.5
0996:  CALL   1FD
0997:  BSF    0A.3
....................       BREAK; 
0998:  GOTO   7C4
....................       case 'J': IF (DEBUG){fputs ("\r > Asignar jugador", RS232); } 
0999:  BTFSS  07.2
099A:  GOTO   1AC
099B:  MOVLW  24
099C:  BSF    03.6
099D:  MOVWF  0D
099E:  MOVLW  05
099F:  MOVWF  0F
09A0:  BCF    0A.3
09A1:  BCF    03.6
09A2:  CALL   117
09A3:  BSF    0A.3
09A4:  MOVLW  0D
09A5:  BTFSS  0C.4
09A6:  GOTO   1A5
09A7:  MOVWF  19
09A8:  MOVLW  0A
09A9:  BTFSS  0C.4
09AA:  GOTO   1A9
09AB:  MOVWF  19
....................       showNumber (char2int (c[1]), pNJugadorD); 
09AC:  BSF    03.5
09AD:  MOVF   21,W
09AE:  MOVWF  2D
09AF:  BCF    0A.3
09B0:  BCF    03.5
09B1:  CALL   18D
09B2:  BSF    0A.3
09B3:  MOVF   78,W
09B4:  BSF    03.5
09B5:  MOVWF  2A
09B6:  MOVWF  2B
09B7:  BCF    03.5
09B8:  MOVF   4D,W
09B9:  BSF    03.5
09BA:  MOVWF  2F
09BB:  BCF    03.5
09BC:  MOVF   4C,W
09BD:  BSF    03.5
09BE:  MOVWF  2E
09BF:  BCF    03.5
09C0:  MOVF   4B,W
09C1:  BSF    03.5
09C2:  MOVWF  2D
09C3:  BCF    03.5
09C4:  MOVF   4A,W
09C5:  BSF    03.5
09C6:  MOVWF  2C
09C7:  BCF    0A.3
09C8:  BCF    03.5
09C9:  CALL   1FD
09CA:  BSF    0A.3
....................       showNumber (char2int (c[2]), pNJugadorU); 
09CB:  BSF    03.5
09CC:  MOVF   22,W
09CD:  MOVWF  2D
09CE:  BCF    0A.3
09CF:  BCF    03.5
09D0:  CALL   18D
09D1:  BSF    0A.3
09D2:  MOVF   78,W
09D3:  BSF    03.5
09D4:  MOVWF  2A
09D5:  MOVWF  2B
09D6:  BCF    03.5
09D7:  MOVF   49,W
09D8:  BSF    03.5
09D9:  MOVWF  2F
09DA:  BCF    03.5
09DB:  MOVF   48,W
09DC:  BSF    03.5
09DD:  MOVWF  2E
09DE:  BCF    03.5
09DF:  MOVF   47,W
09E0:  BSF    03.5
09E1:  MOVWF  2D
09E2:  BCF    03.5
09E3:  MOVF   46,W
09E4:  BSF    03.5
09E5:  MOVWF  2C
09E6:  BCF    0A.3
09E7:  BCF    03.5
09E8:  CALL   1FD
09E9:  BSF    0A.3
....................       BREAK; 
09EA:  GOTO   7C4
....................       case 'L': 
....................       SWITCH (c[1]) 
09EB:  BSF    03.5
09EC:  MOVF   21,W
09ED:  XORLW  30
09EE:  BCF    03.5
09EF:  BTFSC  03.2
09F0:  GOTO   207
09F1:  XORLW  01
09F2:  BTFSC  03.2
09F3:  GOTO   223
09F4:  XORLW  03
09F5:  BTFSC  03.2
09F6:  GOTO   23E
09F7:  XORLW  01
09F8:  BTFSC  03.2
09F9:  GOTO   259
09FA:  XORLW  77
09FB:  BTFSC  03.2
09FC:  GOTO   274
09FD:  XORLW  02
09FE:  BTFSC  03.2
09FF:  GOTO   2F7
0A00:  XORLW  0F
0A01:  BTFSC  03.2
0A02:  GOTO   31E
0A03:  XORLW  19
0A04:  BTFSC  03.2
0A05:  GOTO   358
0A06:  GOTO   375
....................       { 
....................          case '0': IF (DEBUG){fputs ("\r > Resetea a 0", RS232); } 
0A07:  BTFSS  07.2
0A08:  GOTO   21A
0A09:  MOVLW  2E
0A0A:  BSF    03.6
0A0B:  MOVWF  0D
0A0C:  MOVLW  05
0A0D:  MOVWF  0F
0A0E:  BCF    0A.3
0A0F:  BCF    03.6
0A10:  CALL   117
0A11:  BSF    0A.3
0A12:  MOVLW  0D
0A13:  BTFSS  0C.4
0A14:  GOTO   213
0A15:  MOVWF  19
0A16:  MOVLW  0A
0A17:  BTFSS  0C.4
0A18:  GOTO   217
0A19:  MOVWF  19
....................          setScoreL(0,0,0); 
0A1A:  BSF    03.5
0A1B:  CLRF   2D
0A1C:  CLRF   2E
0A1D:  CLRF   2F
0A1E:  BCF    0A.3
0A1F:  BCF    03.5
0A20:  CALL   31D
0A21:  BSF    0A.3
....................          BREAK; 
0A22:  GOTO   375
....................          case '1': IF (DEBUG){fputs ("\r > Incrementar por 1", RS232); } 
0A23:  BTFSS  07.2
0A24:  GOTO   236
0A25:  MOVLW  36
0A26:  BSF    03.6
0A27:  MOVWF  0D
0A28:  MOVLW  05
0A29:  MOVWF  0F
0A2A:  BCF    0A.3
0A2B:  BCF    03.6
0A2C:  CALL   117
0A2D:  BSF    0A.3
0A2E:  MOVLW  0D
0A2F:  BTFSS  0C.4
0A30:  GOTO   22F
0A31:  MOVWF  19
0A32:  MOVLW  0A
0A33:  BTFSS  0C.4
0A34:  GOTO   233
0A35:  MOVWF  19
....................          addScoreL(1); 
0A36:  MOVLW  01
0A37:  BSF    03.5
0A38:  MOVWF  2A
0A39:  BCF    0A.3
0A3A:  BCF    03.5
0A3B:  CALL   35D
0A3C:  BSF    0A.3
....................          BREAK; 
0A3D:  GOTO   375
....................          case '2': IF (DEBUG){fputs ("\r > Incrementar por 2", RS232); } 
0A3E:  BTFSS  07.2
0A3F:  GOTO   251
0A40:  MOVLW  41
0A41:  BSF    03.6
0A42:  MOVWF  0D
0A43:  MOVLW  05
0A44:  MOVWF  0F
0A45:  BCF    0A.3
0A46:  BCF    03.6
0A47:  CALL   117
0A48:  BSF    0A.3
0A49:  MOVLW  0D
0A4A:  BTFSS  0C.4
0A4B:  GOTO   24A
0A4C:  MOVWF  19
0A4D:  MOVLW  0A
0A4E:  BTFSS  0C.4
0A4F:  GOTO   24E
0A50:  MOVWF  19
....................          addScoreL(2);          
0A51:  MOVLW  02
0A52:  BSF    03.5
0A53:  MOVWF  2A
0A54:  BCF    0A.3
0A55:  BCF    03.5
0A56:  CALL   35D
0A57:  BSF    0A.3
....................          BREAK; 
0A58:  GOTO   375
....................          case '3': IF (DEBUG){fputs ("\r > Incrementar por 3", RS232); } 
0A59:  BTFSS  07.2
0A5A:  GOTO   26C
0A5B:  MOVLW  4C
0A5C:  BSF    03.6
0A5D:  MOVWF  0D
0A5E:  MOVLW  05
0A5F:  MOVWF  0F
0A60:  BCF    0A.3
0A61:  BCF    03.6
0A62:  CALL   117
0A63:  BSF    0A.3
0A64:  MOVLW  0D
0A65:  BTFSS  0C.4
0A66:  GOTO   265
0A67:  MOVWF  19
0A68:  MOVLW  0A
0A69:  BTFSS  0C.4
0A6A:  GOTO   269
0A6B:  MOVWF  19
....................          addScoreL(3);          
0A6C:  MOVLW  03
0A6D:  BSF    03.5
0A6E:  MOVWF  2A
0A6F:  BCF    0A.3
0A70:  BCF    03.5
0A71:  CALL   35D
0A72:  BSF    0A.3
....................          BREAK; 
0A73:  GOTO   375
....................          case 'D': IF (DEBUG){fputs ("\r > Decrementar por 1", RS232); } 
0A74:  BTFSS  07.2
0A75:  GOTO   287
0A76:  MOVLW  57
0A77:  BSF    03.6
0A78:  MOVWF  0D
0A79:  MOVLW  05
0A7A:  MOVWF  0F
0A7B:  BCF    0A.3
0A7C:  BCF    03.6
0A7D:  CALL   117
0A7E:  BSF    0A.3
0A7F:  MOVLW  0D
0A80:  BTFSS  0C.4
0A81:  GOTO   280
0A82:  MOVWF  19
0A83:  MOVLW  0A
0A84:  BTFSS  0C.4
0A85:  GOTO   284
0A86:  MOVWF  19
....................          resScoreL();          
....................          BREAK; 
*
0AF6:  GOTO   375
....................          case 'F': IF (DEBUG){fputs ("\r > Asignar faltas", RS232); } 
0AF7:  BTFSS  07.2
0AF8:  GOTO   30A
0AF9:  MOVLW  62
0AFA:  BSF    03.6
0AFB:  MOVWF  0D
0AFC:  MOVLW  05
0AFD:  MOVWF  0F
0AFE:  BCF    0A.3
0AFF:  BCF    03.6
0B00:  CALL   117
0B01:  BSF    0A.3
0B02:  MOVLW  0D
0B03:  BTFSS  0C.4
0B04:  GOTO   303
0B05:  MOVWF  19
0B06:  MOVLW  0A
0B07:  BTFSS  0C.4
0B08:  GOTO   307
0B09:  MOVWF  19
....................          sendN2Port (char2int(c[2]), I2C_SCORE, PuertoE); 
0B0A:  BSF    03.5
0B0B:  MOVF   22,W
0B0C:  MOVWF  2D
0B0D:  BCF    0A.3
0B0E:  BCF    03.5
0B0F:  CALL   18D
0B10:  BSF    0A.3
0B11:  MOVF   78,W
0B12:  BSF    03.5
0B13:  MOVWF  2A
0B14:  MOVWF  32
0B15:  MOVLW  0C
0B16:  MOVWF  33
0B17:  MOVLW  05
0B18:  MOVWF  34
0B19:  BCF    0A.3
0B1A:  BCF    03.5
0B1B:  CALL   2FA
0B1C:  BSF    0A.3
....................          BREAK; 
0B1D:  GOTO   375
....................          case 'I': IF (DEBUG){fputs ("\r > Inicializar", RS232); } 
0B1E:  BTFSS  07.2
0B1F:  GOTO   331
0B20:  MOVLW  6C
0B21:  BSF    03.6
0B22:  MOVWF  0D
0B23:  MOVLW  05
0B24:  MOVWF  0F
0B25:  BCF    0A.3
0B26:  BCF    03.6
0B27:  CALL   117
0B28:  BSF    0A.3
0B29:  MOVLW  0D
0B2A:  BTFSS  0C.4
0B2B:  GOTO   32A
0B2C:  MOVWF  19
0B2D:  MOVLW  0A
0B2E:  BTFSS  0C.4
0B2F:  GOTO   32E
0B30:  MOVWF  19
....................          setScoreL(char2int(c[2]),char2int(c[3]),char2int(c[4])); 
0B31:  BSF    03.5
0B32:  MOVF   22,W
0B33:  MOVWF  2D
0B34:  BCF    0A.3
0B35:  BCF    03.5
0B36:  CALL   18D
0B37:  BSF    0A.3
0B38:  MOVF   78,W
0B39:  BSF    03.5
0B3A:  MOVWF  2A
0B3B:  MOVF   23,W
0B3C:  MOVWF  2D
0B3D:  BCF    0A.3
0B3E:  BCF    03.5
0B3F:  CALL   18D
0B40:  BSF    0A.3
0B41:  MOVF   78,W
0B42:  BSF    03.5
0B43:  MOVWF  2B
0B44:  MOVF   24,W
0B45:  MOVWF  2D
0B46:  BCF    0A.3
0B47:  BCF    03.5
0B48:  CALL   18D
0B49:  BSF    0A.3
0B4A:  MOVF   78,W
0B4B:  BSF    03.5
0B4C:  MOVWF  2C
0B4D:  MOVF   2A,W
0B4E:  MOVWF  2D
0B4F:  MOVF   2B,W
0B50:  MOVWF  2E
0B51:  MOVF   2C,W
0B52:  MOVWF  2F
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   31D
0B56:  BSF    0A.3
....................          BREAK; 
0B57:  GOTO   375
....................          case 'P': IF (DEBUG){fputs ("\r > Asignar posicion", RS232); } 
0B58:  BTFSS  07.2
0B59:  GOTO   36B
0B5A:  MOVLW  74
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  05
0B5E:  MOVWF  0F
0B5F:  BCF    0A.3
0B60:  BCF    03.6
0B61:  CALL   117
0B62:  BSF    0A.3
0B63:  MOVLW  0D
0B64:  BTFSS  0C.4
0B65:  GOTO   364
0B66:  MOVWF  19
0B67:  MOVLW  0A
0B68:  BTFSS  0C.4
0B69:  GOTO   368
0B6A:  MOVWF  19
....................          i2c_send (I2C_SCORE, I2C_CMD_POSL); 
0B6B:  MOVLW  0C
0B6C:  BSF    03.5
0B6D:  MOVWF  36
0B6E:  MOVLW  71
0B6F:  MOVWF  37
0B70:  BCF    0A.3
0B71:  BCF    03.5
0B72:  CALL   2C7
0B73:  BSF    0A.3
....................          BREAK; 
0B74:  GOTO   375
....................       } 
....................  
....................       BREAK; 
0B75:  GOTO   7C4
....................       case 'P': IF (DEBUG){fputs ("\r > Pausar tiempo", RS232); } 
0B76:  BTFSS  07.2
0B77:  GOTO   389
0B78:  MOVLW  7F
0B79:  BSF    03.6
0B7A:  MOVWF  0D
0B7B:  MOVLW  05
0B7C:  MOVWF  0F
0B7D:  BCF    0A.3
0B7E:  BCF    03.6
0B7F:  CALL   117
0B80:  BSF    0A.3
0B81:  MOVLW  0D
0B82:  BTFSS  0C.4
0B83:  GOTO   382
0B84:  MOVWF  19
0B85:  MOVLW  0A
0B86:  BTFSS  0C.4
0B87:  GOTO   386
0B88:  MOVWF  19
....................       pauseTime = true; 
0B89:  BSF    45.3
....................       BREAK; 
0B8A:  GOTO   7C4
....................       case 'Q': IF (DEBUG){fputs ("\r > Renudar tiempo", RS232); } 
0B8B:  BTFSS  07.2
0B8C:  GOTO   39E
0B8D:  MOVLW  88
0B8E:  BSF    03.6
0B8F:  MOVWF  0D
0B90:  MOVLW  05
0B91:  MOVWF  0F
0B92:  BCF    0A.3
0B93:  BCF    03.6
0B94:  CALL   117
0B95:  BSF    0A.3
0B96:  MOVLW  0D
0B97:  BTFSS  0C.4
0B98:  GOTO   397
0B99:  MOVWF  19
0B9A:  MOVLW  0A
0B9B:  BTFSS  0C.4
0B9C:  GOTO   39B
0B9D:  MOVWF  19
....................       pauseTime = false; 
0B9E:  BCF    45.3
....................       BREAK; 
0B9F:  GOTO   7C4
....................  
....................       CASE 'R': 
....................       SWITCH (c[1]) 
0BA0:  MOVLW  30
0BA1:  BSF    03.5
0BA2:  SUBWF  21,W
0BA3:  ADDLW  FB
0BA4:  BTFSC  03.0
0BA5:  GOTO   440
0BA6:  ADDLW  05
0BA7:  BCF    03.5
0BA8:  GOTO   7CF
....................       { 
....................          case '0': IF (DEBUG){fputs ("\r > Apagar Periodos", RS232); } 
0BA9:  BTFSS  07.2
0BAA:  GOTO   3BC
0BAB:  MOVLW  92
0BAC:  BSF    03.6
0BAD:  MOVWF  0D
0BAE:  MOVLW  05
0BAF:  MOVWF  0F
0BB0:  BCF    0A.3
0BB1:  BCF    03.6
0BB2:  CALL   117
0BB3:  BSF    0A.3
0BB4:  MOVLW  0D
0BB5:  BTFSS  0C.4
0BB6:  GOTO   3B5
0BB7:  MOVWF  19
0BB8:  MOVLW  0A
0BB9:  BTFSS  0C.4
0BBA:  GOTO   3B9
0BBB:  MOVWF  19
....................          i2c_send (I2C_TIMER, I2C_CMD_PER0); 
0BBC:  MOVLW  0A
0BBD:  BSF    03.5
0BBE:  MOVWF  36
0BBF:  MOVLW  70
0BC0:  MOVWF  37
0BC1:  BCF    0A.3
0BC2:  BCF    03.5
0BC3:  CALL   2C7
0BC4:  BSF    0A.3
....................          BREAK; 
0BC5:  BSF    03.5
0BC6:  GOTO   440
....................          case '1': IF (DEBUG){fputs ("\r > Periodo 1", RS232); } 
0BC7:  BTFSS  07.2
0BC8:  GOTO   3DA
0BC9:  MOVLW  9C
0BCA:  BSF    03.6
0BCB:  MOVWF  0D
0BCC:  MOVLW  05
0BCD:  MOVWF  0F
0BCE:  BCF    0A.3
0BCF:  BCF    03.6
0BD0:  CALL   117
0BD1:  BSF    0A.3
0BD2:  MOVLW  0D
0BD3:  BTFSS  0C.4
0BD4:  GOTO   3D3
0BD5:  MOVWF  19
0BD6:  MOVLW  0A
0BD7:  BTFSS  0C.4
0BD8:  GOTO   3D7
0BD9:  MOVWF  19
....................          i2c_send (I2C_TIMER, I2C_CMD_PER1); 
0BDA:  MOVLW  0A
0BDB:  BSF    03.5
0BDC:  MOVWF  36
0BDD:  MOVLW  71
0BDE:  MOVWF  37
0BDF:  BCF    0A.3
0BE0:  BCF    03.5
0BE1:  CALL   2C7
0BE2:  BSF    0A.3
....................          BREAK; 
0BE3:  BSF    03.5
0BE4:  GOTO   440
....................          case '2': IF (DEBUG){fputs ("\r > Periodo 2", RS232); } 
0BE5:  BTFSS  07.2
0BE6:  GOTO   3F8
0BE7:  MOVLW  A3
0BE8:  BSF    03.6
0BE9:  MOVWF  0D
0BEA:  MOVLW  05
0BEB:  MOVWF  0F
0BEC:  BCF    0A.3
0BED:  BCF    03.6
0BEE:  CALL   117
0BEF:  BSF    0A.3
0BF0:  MOVLW  0D
0BF1:  BTFSS  0C.4
0BF2:  GOTO   3F1
0BF3:  MOVWF  19
0BF4:  MOVLW  0A
0BF5:  BTFSS  0C.4
0BF6:  GOTO   3F5
0BF7:  MOVWF  19
....................          i2c_send (I2C_TIMER, I2C_CMD_PER2); 
0BF8:  MOVLW  0A
0BF9:  BSF    03.5
0BFA:  MOVWF  36
0BFB:  MOVLW  72
0BFC:  MOVWF  37
0BFD:  BCF    0A.3
0BFE:  BCF    03.5
0BFF:  CALL   2C7
0C00:  BSF    0A.3
....................          BREAK; 
0C01:  BSF    03.5
0C02:  GOTO   440
....................          case '3': IF (DEBUG){fputs ("\r > Periodo 3", RS232); } 
0C03:  BTFSS  07.2
0C04:  GOTO   416
0C05:  MOVLW  AA
0C06:  BSF    03.6
0C07:  MOVWF  0D
0C08:  MOVLW  05
0C09:  MOVWF  0F
0C0A:  BCF    0A.3
0C0B:  BCF    03.6
0C0C:  CALL   117
0C0D:  BSF    0A.3
0C0E:  MOVLW  0D
0C0F:  BTFSS  0C.4
0C10:  GOTO   40F
0C11:  MOVWF  19
0C12:  MOVLW  0A
0C13:  BTFSS  0C.4
0C14:  GOTO   413
0C15:  MOVWF  19
....................          i2c_send (I2C_TIMER, I2C_CMD_PER3); 
0C16:  MOVLW  0A
0C17:  BSF    03.5
0C18:  MOVWF  36
0C19:  MOVLW  73
0C1A:  MOVWF  37
0C1B:  BCF    0A.3
0C1C:  BCF    03.5
0C1D:  CALL   2C7
0C1E:  BSF    0A.3
....................          BREAK; 
0C1F:  BSF    03.5
0C20:  GOTO   440
....................          case '4': IF (DEBUG){fputs ("\r > Periodo 4", RS232); } 
0C21:  BTFSS  07.2
0C22:  GOTO   434
0C23:  MOVLW  B1
0C24:  BSF    03.6
0C25:  MOVWF  0D
0C26:  MOVLW  05
0C27:  MOVWF  0F
0C28:  BCF    0A.3
0C29:  BCF    03.6
0C2A:  CALL   117
0C2B:  BSF    0A.3
0C2C:  MOVLW  0D
0C2D:  BTFSS  0C.4
0C2E:  GOTO   42D
0C2F:  MOVWF  19
0C30:  MOVLW  0A
0C31:  BTFSS  0C.4
0C32:  GOTO   431
0C33:  MOVWF  19
....................          i2c_send (I2C_TIMER, I2C_CMD_PER4); 
0C34:  MOVLW  0A
0C35:  BSF    03.5
0C36:  MOVWF  36
0C37:  MOVLW  74
0C38:  MOVWF  37
0C39:  BCF    0A.3
0C3A:  BCF    03.5
0C3B:  CALL   2C7
0C3C:  BSF    0A.3
....................          BREAK; 
0C3D:  BSF    03.5
0C3E:  GOTO   440
0C3F:  BSF    03.5
....................       } 
....................       delay_ms (I2CWAIT); 
0C40:  MOVLW  32
0C41:  MOVWF  32
0C42:  BCF    0A.3
0C43:  BCF    03.5
0C44:  CALL   309
0C45:  BSF    0A.3
....................       BREAK; 
0C46:  GOTO   7C4
....................       case 'S': IF (DEBUG){fputs ("\r > Configuracion de tiro", RS232); } 
0C47:  BTFSS  07.2
0C48:  GOTO   45A
0C49:  MOVLW  B8
0C4A:  BSF    03.6
0C4B:  MOVWF  0D
0C4C:  MOVLW  05
0C4D:  MOVWF  0F
0C4E:  BCF    0A.3
0C4F:  BCF    03.6
0C50:  CALL   117
0C51:  BSF    0A.3
0C52:  MOVLW  0D
0C53:  BTFSS  0C.4
0C54:  GOTO   453
0C55:  MOVWF  19
0C56:  MOVLW  0A
0C57:  BTFSS  0C.4
0C58:  GOTO   457
0C59:  MOVWF  19
....................       shotSet (char2int (c[1]), char2int (c[2])) ; 
0C5A:  BSF    03.5
0C5B:  MOVF   21,W
0C5C:  MOVWF  2D
0C5D:  BCF    0A.3
0C5E:  BCF    03.5
0C5F:  CALL   18D
0C60:  BSF    0A.3
0C61:  MOVF   78,W
0C62:  BSF    03.5
0C63:  MOVWF  2A
0C64:  MOVF   22,W
0C65:  MOVWF  2D
0C66:  BCF    0A.3
0C67:  BCF    03.5
0C68:  CALL   18D
0C69:  BSF    0A.3
0C6A:  MOVF   78,W
0C6B:  BSF    03.5
0C6C:  MOVWF  2B
0C6D:  MOVF   2A,W
0C6E:  MOVWF  2C
0C6F:  MOVF   2B,W
0C70:  MOVWF  2D
....................       BREAK; 
*
0C96:  GOTO   7C4
....................       case 'T': IF (DEBUG){fputs ("\r > Configuracion de tiempo", RS232); } 
0C97:  BTFSS  07.2
0C98:  GOTO   4AA
0C99:  MOVLW  C5
0C9A:  BSF    03.6
0C9B:  MOVWF  0D
0C9C:  MOVLW  05
0C9D:  MOVWF  0F
0C9E:  BCF    0A.3
0C9F:  BCF    03.6
0CA0:  CALL   117
0CA1:  BSF    0A.3
0CA2:  MOVLW  0D
0CA3:  BTFSS  0C.4
0CA4:  GOTO   4A3
0CA5:  MOVWF  19
0CA6:  MOVLW  0A
0CA7:  BTFSS  0C.4
0CA8:  GOTO   4A7
0CA9:  MOVWF  19
....................       timeSet (char2int (c[1]), char2int (c[2]), char2int (c[3]), char2int (c[4])) ; 
0CAA:  BSF    03.5
0CAB:  MOVF   21,W
0CAC:  MOVWF  2D
0CAD:  BCF    0A.3
0CAE:  BCF    03.5
0CAF:  CALL   18D
0CB0:  BSF    0A.3
0CB1:  MOVF   78,W
0CB2:  BSF    03.5
0CB3:  MOVWF  2A
0CB4:  MOVF   22,W
0CB5:  MOVWF  2D
0CB6:  BCF    0A.3
0CB7:  BCF    03.5
0CB8:  CALL   18D
0CB9:  BSF    0A.3
0CBA:  MOVF   78,W
0CBB:  BSF    03.5
0CBC:  MOVWF  2B
0CBD:  MOVF   23,W
0CBE:  MOVWF  2D
0CBF:  BCF    0A.3
0CC0:  BCF    03.5
0CC1:  CALL   18D
0CC2:  BSF    0A.3
0CC3:  MOVF   78,W
0CC4:  BSF    03.5
0CC5:  MOVWF  2C
0CC6:  MOVF   24,W
0CC7:  MOVWF  2D
0CC8:  BCF    0A.3
0CC9:  BCF    03.5
0CCA:  CALL   18D
0CCB:  BSF    0A.3
0CCC:  MOVF   78,W
0CCD:  BSF    03.5
0CCE:  MOVWF  2D
0CCF:  MOVF   2A,W
0CD0:  MOVWF  2E
0CD1:  MOVF   2B,W
0CD2:  MOVWF  2F
0CD3:  MOVF   2C,W
0CD4:  MOVWF  30
0CD5:  MOVF   2D,W
0CD6:  MOVWF  31
....................       BREAK; 
*
0D33:  GOTO   7C4
....................       case 'V': 
....................       SWITCH (c[1]) 
0D34:  BSF    03.5
0D35:  MOVF   21,W
0D36:  XORLW  30
0D37:  BCF    03.5
0D38:  BTFSC  03.2
0D39:  GOTO   550
0D3A:  XORLW  01
0D3B:  BTFSC  03.2
0D3C:  GOTO   56C
0D3D:  XORLW  03
0D3E:  BTFSC  03.2
0D3F:  GOTO   587
0D40:  XORLW  01
0D41:  BTFSC  03.2
0D42:  GOTO   5A2
0D43:  XORLW  77
0D44:  BTFSC  03.2
0D45:  GOTO   5BD
0D46:  XORLW  02
0D47:  BTFSC  03.2
0D48:  GOTO   640
0D49:  XORLW  0F
0D4A:  BTFSC  03.2
0D4B:  GOTO   667
0D4C:  XORLW  19
0D4D:  BTFSC  03.2
0D4E:  GOTO   6A1
0D4F:  GOTO   6BE
....................       { 
....................          case '0': IF (DEBUG){fputs ("\r > Resetea a 0", RS232); } 
0D50:  BTFSS  07.2
0D51:  GOTO   563
0D52:  MOVLW  D3
0D53:  BSF    03.6
0D54:  MOVWF  0D
0D55:  MOVLW  05
0D56:  MOVWF  0F
0D57:  BCF    0A.3
0D58:  BCF    03.6
0D59:  CALL   117
0D5A:  BSF    0A.3
0D5B:  MOVLW  0D
0D5C:  BTFSS  0C.4
0D5D:  GOTO   55C
0D5E:  MOVWF  19
0D5F:  MOVLW  0A
0D60:  BTFSS  0C.4
0D61:  GOTO   560
0D62:  MOVWF  19
....................          setScoreV(0,0,0); 
0D63:  BSF    03.5
0D64:  CLRF   2D
0D65:  CLRF   2E
0D66:  CLRF   2F
0D67:  BCF    0A.3
0D68:  BCF    03.5
0D69:  CALL   3C1
0D6A:  BSF    0A.3
....................          BREAK; 
0D6B:  GOTO   6BE
....................          case '1': IF (DEBUG){fputs ("\r > Incrementar por 1", RS232); } 
0D6C:  BTFSS  07.2
0D6D:  GOTO   57F
0D6E:  MOVLW  DB
0D6F:  BSF    03.6
0D70:  MOVWF  0D
0D71:  MOVLW  05
0D72:  MOVWF  0F
0D73:  BCF    0A.3
0D74:  BCF    03.6
0D75:  CALL   117
0D76:  BSF    0A.3
0D77:  MOVLW  0D
0D78:  BTFSS  0C.4
0D79:  GOTO   578
0D7A:  MOVWF  19
0D7B:  MOVLW  0A
0D7C:  BTFSS  0C.4
0D7D:  GOTO   57C
0D7E:  MOVWF  19
....................          addScoreV(1);          
0D7F:  MOVLW  01
0D80:  BSF    03.5
0D81:  MOVWF  2A
0D82:  BCF    0A.3
0D83:  BCF    03.5
0D84:  CALL   401
0D85:  BSF    0A.3
....................          BREAK; 
0D86:  GOTO   6BE
....................          case '2': IF (DEBUG){fputs ("\r > Incrementar por 2", RS232); } 
0D87:  BTFSS  07.2
0D88:  GOTO   59A
0D89:  MOVLW  E6
0D8A:  BSF    03.6
0D8B:  MOVWF  0D
0D8C:  MOVLW  05
0D8D:  MOVWF  0F
0D8E:  BCF    0A.3
0D8F:  BCF    03.6
0D90:  CALL   117
0D91:  BSF    0A.3
0D92:  MOVLW  0D
0D93:  BTFSS  0C.4
0D94:  GOTO   593
0D95:  MOVWF  19
0D96:  MOVLW  0A
0D97:  BTFSS  0C.4
0D98:  GOTO   597
0D99:  MOVWF  19
....................          addScoreV(2); 
0D9A:  MOVLW  02
0D9B:  BSF    03.5
0D9C:  MOVWF  2A
0D9D:  BCF    0A.3
0D9E:  BCF    03.5
0D9F:  CALL   401
0DA0:  BSF    0A.3
....................          BREAK; 
0DA1:  GOTO   6BE
....................          case '3': IF (DEBUG){fputs ("\r > Incrementar por 3", RS232); } 
0DA2:  BTFSS  07.2
0DA3:  GOTO   5B5
0DA4:  MOVLW  F1
0DA5:  BSF    03.6
0DA6:  MOVWF  0D
0DA7:  MOVLW  05
0DA8:  MOVWF  0F
0DA9:  BCF    0A.3
0DAA:  BCF    03.6
0DAB:  CALL   117
0DAC:  BSF    0A.3
0DAD:  MOVLW  0D
0DAE:  BTFSS  0C.4
0DAF:  GOTO   5AE
0DB0:  MOVWF  19
0DB1:  MOVLW  0A
0DB2:  BTFSS  0C.4
0DB3:  GOTO   5B2
0DB4:  MOVWF  19
....................          addScoreV(3); 
0DB5:  MOVLW  03
0DB6:  BSF    03.5
0DB7:  MOVWF  2A
0DB8:  BCF    0A.3
0DB9:  BCF    03.5
0DBA:  CALL   401
0DBB:  BSF    0A.3
....................          BREAK; 
0DBC:  GOTO   6BE
....................          case 'D': IF (DEBUG){fputs ("\r > Decrementar por 1", RS232); } 
0DBD:  BTFSS  07.2
0DBE:  GOTO   5D0
0DBF:  MOVLW  FC
0DC0:  BSF    03.6
0DC1:  MOVWF  0D
0DC2:  MOVLW  05
0DC3:  MOVWF  0F
0DC4:  BCF    0A.3
0DC5:  BCF    03.6
0DC6:  CALL   117
0DC7:  BSF    0A.3
0DC8:  MOVLW  0D
0DC9:  BTFSS  0C.4
0DCA:  GOTO   5C9
0DCB:  MOVWF  19
0DCC:  MOVLW  0A
0DCD:  BTFSS  0C.4
0DCE:  GOTO   5CD
0DCF:  MOVWF  19
....................          resScoreV(); 
....................          BREAK; 
*
0E3F:  GOTO   6BE
....................          case 'F': IF (DEBUG){fputs ("\r > Asignar faltas", RS232); } 
0E40:  BTFSS  07.2
0E41:  GOTO   653
0E42:  MOVLW  07
0E43:  BSF    03.6
0E44:  MOVWF  0D
0E45:  MOVLW  06
0E46:  MOVWF  0F
0E47:  BCF    0A.3
0E48:  BCF    03.6
0E49:  CALL   117
0E4A:  BSF    0A.3
0E4B:  MOVLW  0D
0E4C:  BTFSS  0C.4
0E4D:  GOTO   64C
0E4E:  MOVWF  19
0E4F:  MOVLW  0A
0E50:  BTFSS  0C.4
0E51:  GOTO   650
0E52:  MOVWF  19
....................          sendN2Port (char2int(c[2]), I2C_SCORE, PuertoF); 
0E53:  BSF    03.5
0E54:  MOVF   22,W
0E55:  MOVWF  2D
0E56:  BCF    0A.3
0E57:  BCF    03.5
0E58:  CALL   18D
0E59:  BSF    0A.3
0E5A:  MOVF   78,W
0E5B:  BSF    03.5
0E5C:  MOVWF  2A
0E5D:  MOVWF  32
0E5E:  MOVLW  0C
0E5F:  MOVWF  33
0E60:  MOVLW  06
0E61:  MOVWF  34
0E62:  BCF    0A.3
0E63:  BCF    03.5
0E64:  CALL   2FA
0E65:  BSF    0A.3
....................          BREAK; 
0E66:  GOTO   6BE
....................          case 'I': IF (DEBUG){fputs ("\r > Inicializar", RS232); } 
0E67:  BTFSS  07.2
0E68:  GOTO   67A
0E69:  MOVLW  11
0E6A:  BSF    03.6
0E6B:  MOVWF  0D
0E6C:  MOVLW  06
0E6D:  MOVWF  0F
0E6E:  BCF    0A.3
0E6F:  BCF    03.6
0E70:  CALL   117
0E71:  BSF    0A.3
0E72:  MOVLW  0D
0E73:  BTFSS  0C.4
0E74:  GOTO   673
0E75:  MOVWF  19
0E76:  MOVLW  0A
0E77:  BTFSS  0C.4
0E78:  GOTO   677
0E79:  MOVWF  19
....................                    setScoreV(char2int(c[2]),char2int(c[3]),char2int(c[4])); 
0E7A:  BSF    03.5
0E7B:  MOVF   22,W
0E7C:  MOVWF  2D
0E7D:  BCF    0A.3
0E7E:  BCF    03.5
0E7F:  CALL   18D
0E80:  BSF    0A.3
0E81:  MOVF   78,W
0E82:  BSF    03.5
0E83:  MOVWF  2A
0E84:  MOVF   23,W
0E85:  MOVWF  2D
0E86:  BCF    0A.3
0E87:  BCF    03.5
0E88:  CALL   18D
0E89:  BSF    0A.3
0E8A:  MOVF   78,W
0E8B:  BSF    03.5
0E8C:  MOVWF  2B
0E8D:  MOVF   24,W
0E8E:  MOVWF  2D
0E8F:  BCF    0A.3
0E90:  BCF    03.5
0E91:  CALL   18D
0E92:  BSF    0A.3
0E93:  MOVF   78,W
0E94:  BSF    03.5
0E95:  MOVWF  2C
0E96:  MOVF   2A,W
0E97:  MOVWF  2D
0E98:  MOVF   2B,W
0E99:  MOVWF  2E
0E9A:  MOVF   2C,W
0E9B:  MOVWF  2F
0E9C:  BCF    0A.3
0E9D:  BCF    03.5
0E9E:  CALL   3C1
0E9F:  BSF    0A.3
....................          BREAK; 
0EA0:  GOTO   6BE
....................          case 'P': IF (DEBUG){fputs ("\r > Asignar posicion", RS232); } 
0EA1:  BTFSS  07.2
0EA2:  GOTO   6B4
0EA3:  MOVLW  19
0EA4:  BSF    03.6
0EA5:  MOVWF  0D
0EA6:  MOVLW  06
0EA7:  MOVWF  0F
0EA8:  BCF    0A.3
0EA9:  BCF    03.6
0EAA:  CALL   117
0EAB:  BSF    0A.3
0EAC:  MOVLW  0D
0EAD:  BTFSS  0C.4
0EAE:  GOTO   6AD
0EAF:  MOVWF  19
0EB0:  MOVLW  0A
0EB1:  BTFSS  0C.4
0EB2:  GOTO   6B1
0EB3:  MOVWF  19
....................          i2c_send (I2C_SCORE, I2C_CMD_POSV); 
0EB4:  MOVLW  0C
0EB5:  BSF    03.5
0EB6:  MOVWF  36
0EB7:  MOVLW  72
0EB8:  MOVWF  37
0EB9:  BCF    0A.3
0EBA:  BCF    03.5
0EBB:  CALL   2C7
0EBC:  BSF    0A.3
....................          BREAK; 
0EBD:  GOTO   6BE
....................       } 
....................  
....................       BREAK; 
0EBE:  GOTO   7C4
....................       CASE 'X': doTest (); //Rutina de prueba 
....................       BREAK; 
*
0F88:  BCF    03.5
0F89:  GOTO   7C4
....................       case 'Z': IF (DEBUG){fputs ("\r > Reseteo general... ! ", RS232); } 
0F8A:  BTFSS  07.2
0F8B:  GOTO   79D
0F8C:  MOVLW  24
0F8D:  BSF    03.6
0F8E:  MOVWF  0D
0F8F:  MOVLW  06
0F90:  MOVWF  0F
0F91:  BCF    0A.3
0F92:  BCF    03.6
0F93:  CALL   117
0F94:  BSF    0A.3
0F95:  MOVLW  0D
0F96:  BTFSS  0C.4
0F97:  GOTO   796
0F98:  MOVWF  19
0F99:  MOVLW  0A
0F9A:  BTFSS  0C.4
0F9B:  GOTO   79A
0F9C:  MOVWF  19
....................       delay_ms (500) ; 
0F9D:  MOVLW  02
0F9E:  BSF    03.5
0F9F:  MOVWF  2A
0FA0:  MOVLW  FA
0FA1:  MOVWF  32
0FA2:  BCF    0A.3
0FA3:  BCF    03.5
0FA4:  CALL   309
0FA5:  BSF    0A.3
0FA6:  BSF    03.5
0FA7:  DECFSZ 2A,F
0FA8:  GOTO   7A0
....................       doReset () ; 
....................       break; 
*
0FC3:  GOTO   7C4
....................    } 
0FC4:  BCF    0A.3
0FC5:  BCF    0A.4
0FC6:  GOTO   492 (RETURN)
.................... } 
....................  
.................... void setScoreL(int8 c, int8 d, int8 u) 
.................... { 
....................    //TODO: Codigo para mostrar puntos 
....................    scoreLU = u; 
*
031D:  BSF    03.5
031E:  MOVF   2F,W
031F:  BCF    03.5
0320:  MOVWF  5C
....................    scoreLD = d; 
0321:  BSF    03.5
0322:  MOVF   2E,W
0323:  BCF    03.5
0324:  MOVWF  5D
....................    if(c > 0) 
0325:  BSF    03.5
0326:  MOVF   2D,F
0327:  BTFSC  03.2
0328:  GOTO   32D
....................       scoreLC = true; 
0329:  BCF    03.5
032A:  BSF    45.4
032B:  GOTO   32F
032C:  BSF    03.5
....................    else 
....................       scoreLC = false; 
032D:  BCF    03.5
032E:  BCF    45.4
....................     
....................    sendN2Port (scoreLU, I2C_SCORE, PuertoA); 
032F:  MOVF   5C,W
0330:  BSF    03.5
0331:  MOVWF  32
0332:  MOVLW  0C
0333:  MOVWF  33
0334:  MOVLW  01
0335:  MOVWF  34
0336:  BCF    03.5
0337:  CALL   2FA
....................    delay_ms(I2CWAIT); 
0338:  MOVLW  32
0339:  BSF    03.5
033A:  MOVWF  32
033B:  BCF    03.5
033C:  CALL   309
....................    sendN2Port (scoreLD, I2C_SCORE, PuertoB); 
033D:  MOVF   5D,W
033E:  BSF    03.5
033F:  MOVWF  32
0340:  MOVLW  0C
0341:  MOVWF  33
0342:  MOVLW  02
0343:  MOVWF  34
0344:  BCF    03.5
0345:  CALL   2FA
....................    delay_ms(I2CWAIT);    
0346:  MOVLW  32
0347:  BSF    03.5
0348:  MOVWF  32
0349:  BCF    03.5
034A:  CALL   309
....................    if(scoreLC) 
034B:  BTFSS  45.4
034C:  GOTO   355
....................       i2c_send(I2C_SCORE, I2C_CMD_CLON); 
034D:  MOVLW  0C
034E:  BSF    03.5
034F:  MOVWF  36
0350:  MOVLW  73
0351:  MOVWF  37
0352:  BCF    03.5
0353:  CALL   2C7
0354:  GOTO   35C
....................    else 
....................       i2c_send(I2C_SCORE, I2C_CMD_CLOF);    
0355:  MOVLW  0C
0356:  BSF    03.5
0357:  MOVWF  36
0358:  MOVLW  74
0359:  MOVWF  37
035A:  BCF    03.5
035B:  CALL   2C7
035C:  RETURN
.................... } 
....................  
.................... void setScoreV(int8 c, int8 d, int8 u) 
.................... { 
....................    //TODO: Codigo para mostrar puntos 
....................    scoreVU = u; 
*
03C1:  BSF    03.5
03C2:  MOVF   2F,W
03C3:  BCF    03.5
03C4:  MOVWF  5E
....................    scoreVD = d; 
03C5:  BSF    03.5
03C6:  MOVF   2E,W
03C7:  BCF    03.5
03C8:  MOVWF  5F
....................    if(c > 0) 
03C9:  BSF    03.5
03CA:  MOVF   2D,F
03CB:  BTFSC  03.2
03CC:  GOTO   3D1
....................       scoreVC = true; 
03CD:  BCF    03.5
03CE:  BSF    45.5
03CF:  GOTO   3D3
03D0:  BSF    03.5
....................    else 
....................       scoreVC = false; 
03D1:  BCF    03.5
03D2:  BCF    45.5
....................     
....................    sendN2Port (scoreVU, I2C_SCORE, PuertoD); 
03D3:  MOVF   5E,W
03D4:  BSF    03.5
03D5:  MOVWF  32
03D6:  MOVLW  0C
03D7:  MOVWF  33
03D8:  MOVLW  04
03D9:  MOVWF  34
03DA:  BCF    03.5
03DB:  CALL   2FA
....................    delay_ms(I2CWAIT); 
03DC:  MOVLW  32
03DD:  BSF    03.5
03DE:  MOVWF  32
03DF:  BCF    03.5
03E0:  CALL   309
....................    sendN2Port (scoreVD, I2C_SCORE, PuertoC); 
03E1:  MOVF   5F,W
03E2:  BSF    03.5
03E3:  MOVWF  32
03E4:  MOVLW  0C
03E5:  MOVWF  33
03E6:  MOVLW  03
03E7:  MOVWF  34
03E8:  BCF    03.5
03E9:  CALL   2FA
....................    delay_ms(I2CWAIT); 
03EA:  MOVLW  32
03EB:  BSF    03.5
03EC:  MOVWF  32
03ED:  BCF    03.5
03EE:  CALL   309
....................     
....................    if(scoreVC) 
03EF:  BTFSS  45.5
03F0:  GOTO   3F9
....................       i2c_send(I2C_SCORE, I2C_CMD_CVON); 
03F1:  MOVLW  0C
03F2:  BSF    03.5
03F3:  MOVWF  36
03F4:  MOVLW  75
03F5:  MOVWF  37
03F6:  BCF    03.5
03F7:  CALL   2C7
03F8:  GOTO   400
....................    else 
....................       i2c_send(I2C_SCORE, I2C_CMD_CVOF);    
03F9:  MOVLW  0C
03FA:  BSF    03.5
03FB:  MOVWF  36
03FC:  MOVLW  76
03FD:  MOVWF  37
03FE:  BCF    03.5
03FF:  CALL   2C7
0400:  RETURN
....................  
.................... } 
....................  
.................... void addScoreV(int8 a) 
0401:  BSF    03.5
0402:  BCF    2B.0
0403:  BCF    03.5
0404:  BTFSS  45.5
0405:  GOTO   409
0406:  BSF    03.5
0407:  BSF    2B.0
0408:  BCF    03.5
0409:  MOVF   5F,W
040A:  BSF    03.5
040B:  MOVWF  2C
040C:  BCF    03.5
040D:  MOVF   5E,W
040E:  BSF    03.5
040F:  MOVWF  2D
.................... { 
....................    int1 tc = scoreVC; 
....................    int8 td = scoreVD; 
....................    int8 tu = scoreVU; 
....................     
....................    scoreVU += a; 
0410:  MOVF   2A,W
0411:  BCF    03.5
0412:  ADDWF  5E,F
....................     
....................    if(scoreVU > 10) 
0413:  MOVF   5E,W
0414:  SUBLW  0A
0415:  BTFSC  03.0
0416:  GOTO   41A
....................    { 
....................       scoreVD++; 
0417:  INCF   5F,F
....................       scoreVU -=10; 
0418:  MOVLW  0A
0419:  SUBWF  5E,F
....................    } 
....................    if(scoreVD > 10) 
041A:  MOVF   5F,W
041B:  SUBLW  0A
041C:  BTFSC  03.0
041D:  GOTO   421
....................    { 
....................       scoreVC = true; 
041E:  BSF    45.5
....................       scoreVD -=10; 
041F:  MOVLW  0A
0420:  SUBWF  5F,F
....................    } 
....................     
....................    if(scoreVC != tc) 
0421:  CLRF   77
0422:  BSF    03.5
0423:  BTFSC  2B.0
0424:  BSF    77.5
0425:  BCF    03.5
0426:  MOVF   45,W
0427:  XORWF  77,W
0428:  ANDLW  20
0429:  BTFSC  03.2
042A:  GOTO   43C
....................    { 
....................       if(scoreVC) 
042B:  BTFSS  45.5
042C:  GOTO   435
....................          i2c_send(I2C_SCORE, I2C_CMD_CLON); 
042D:  MOVLW  0C
042E:  BSF    03.5
042F:  MOVWF  36
0430:  MOVLW  73
0431:  MOVWF  37
0432:  BCF    03.5
0433:  CALL   2C7
0434:  GOTO   43C
....................       else 
....................          i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0435:  MOVLW  0C
0436:  BSF    03.5
0437:  MOVWF  36
0438:  MOVLW  74
0439:  MOVWF  37
043A:  BCF    03.5
043B:  CALL   2C7
....................    } 
....................     
....................    delay_ms(I2CWAIT); 
043C:  MOVLW  32
043D:  BSF    03.5
043E:  MOVWF  32
043F:  BCF    03.5
0440:  CALL   309
....................    if(scoreVD != td) 
0441:  BSF    03.5
0442:  MOVF   2C,W
0443:  BCF    03.5
0444:  SUBWF  5F,W
0445:  BTFSC  03.2
0446:  GOTO   450
....................       sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0447:  MOVF   5F,W
0448:  BSF    03.5
0449:  MOVWF  32
044A:  MOVLW  0C
044B:  MOVWF  33
044C:  MOVLW  03
044D:  MOVWF  34
044E:  BCF    03.5
044F:  CALL   2FA
....................    delay_ms(I2CWAIT); 
0450:  MOVLW  32
0451:  BSF    03.5
0452:  MOVWF  32
0453:  BCF    03.5
0454:  CALL   309
....................    if(scoreVU != tu) 
0455:  BSF    03.5
0456:  MOVF   2D,W
0457:  BCF    03.5
0458:  SUBWF  5E,W
0459:  BTFSC  03.2
045A:  GOTO   464
....................       sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
045B:  MOVF   5E,W
045C:  BSF    03.5
045D:  MOVWF  32
045E:  MOVLW  0C
045F:  MOVWF  33
0460:  MOVLW  04
0461:  MOVWF  34
0462:  BCF    03.5
0463:  CALL   2FA
0464:  RETURN
.................... } 
....................  
.................... void resScoreV() 
*
0DD0:  BSF    03.5
0DD1:  BCF    2A.0
0DD2:  BCF    03.5
0DD3:  BTFSS  45.5
0DD4:  GOTO   5D8
0DD5:  BSF    03.5
0DD6:  BSF    2A.0
0DD7:  BCF    03.5
0DD8:  MOVF   5F,W
0DD9:  BSF    03.5
0DDA:  MOVWF  2B
0DDB:  BCF    03.5
0DDC:  MOVF   5E,W
0DDD:  BSF    03.5
0DDE:  MOVWF  2C
.................... { 
....................    int1 tc = scoreVC; 
....................    int8 td = scoreVD; 
....................    int8 tu = scoreVU; 
....................  
....................    if(scoreVU > 0) 
0DDF:  BCF    03.5
0DE0:  MOVF   5E,F
0DE1:  BTFSC  03.2
0DE2:  GOTO   5E5
....................       scoreVU--; 
0DE3:  DECF   5E,F
0DE4:  GOTO   5F0
....................    else 
....................    { 
....................       if(scoreVD > 0) 
0DE5:  MOVF   5F,F
0DE6:  BTFSC  03.2
0DE7:  GOTO   5EC
....................       { 
....................          scoreVD--; 
0DE8:  DECF   5F,F
....................          scoreVU = 9; 
0DE9:  MOVLW  09
0DEA:  MOVWF  5E
....................       } 
0DEB:  GOTO   5F0
....................       else 
....................       {   
....................          scoreVC = false; 
0DEC:  BCF    45.5
....................          scoreVD = 9; 
0DED:  MOVLW  09
0DEE:  MOVWF  5F
....................          scoreVU = 9; 
0DEF:  MOVWF  5E
....................       } 
....................    } 
....................     
....................    if(scoreVC != tc) 
0DF0:  CLRF   77
0DF1:  BSF    03.5
0DF2:  BTFSC  2A.0
0DF3:  BSF    77.5
0DF4:  BCF    03.5
0DF5:  MOVF   45,W
0DF6:  XORWF  77,W
0DF7:  ANDLW  20
0DF8:  BTFSC  03.2
0DF9:  GOTO   60F
....................    { 
....................       if(scoreVC) 
0DFA:  BTFSS  45.5
0DFB:  GOTO   606
....................          i2c_send(I2C_SCORE, I2C_CMD_CVON); 
0DFC:  MOVLW  0C
0DFD:  BSF    03.5
0DFE:  MOVWF  36
0DFF:  MOVLW  75
0E00:  MOVWF  37
0E01:  BCF    0A.3
0E02:  BCF    03.5
0E03:  CALL   2C7
0E04:  BSF    0A.3
0E05:  GOTO   60F
....................       else 
....................          i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
0E06:  MOVLW  0C
0E07:  BSF    03.5
0E08:  MOVWF  36
0E09:  MOVLW  76
0E0A:  MOVWF  37
0E0B:  BCF    0A.3
0E0C:  BCF    03.5
0E0D:  CALL   2C7
0E0E:  BSF    0A.3
....................    } 
....................    delay_ms(I2CWAIT); 
0E0F:  MOVLW  32
0E10:  BSF    03.5
0E11:  MOVWF  32
0E12:  BCF    0A.3
0E13:  BCF    03.5
0E14:  CALL   309
0E15:  BSF    0A.3
....................    if(scoreVD != td) 
0E16:  BSF    03.5
0E17:  MOVF   2B,W
0E18:  BCF    03.5
0E19:  SUBWF  5F,W
0E1A:  BTFSC  03.2
0E1B:  GOTO   627
....................       sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0E1C:  MOVF   5F,W
0E1D:  BSF    03.5
0E1E:  MOVWF  32
0E1F:  MOVLW  0C
0E20:  MOVWF  33
0E21:  MOVLW  03
0E22:  MOVWF  34
0E23:  BCF    0A.3
0E24:  BCF    03.5
0E25:  CALL   2FA
0E26:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0E27:  MOVLW  32
0E28:  BSF    03.5
0E29:  MOVWF  32
0E2A:  BCF    0A.3
0E2B:  BCF    03.5
0E2C:  CALL   309
0E2D:  BSF    0A.3
....................    if(scoreVU != tu) 
0E2E:  BSF    03.5
0E2F:  MOVF   2C,W
0E30:  BCF    03.5
0E31:  SUBWF  5E,W
0E32:  BTFSC  03.2
0E33:  GOTO   63F
....................       sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0E34:  MOVF   5E,W
0E35:  BSF    03.5
0E36:  MOVWF  32
0E37:  MOVLW  0C
0E38:  MOVWF  33
0E39:  MOVLW  04
0E3A:  MOVWF  34
0E3B:  BCF    0A.3
0E3C:  BCF    03.5
0E3D:  CALL   2FA
0E3E:  BSF    0A.3
.................... } 
....................  
.................... void addScoreL(int8 a) 
*
035D:  BSF    03.5
035E:  BCF    2B.0
035F:  BCF    03.5
0360:  BTFSS  45.4
0361:  GOTO   365
0362:  BSF    03.5
0363:  BSF    2B.0
0364:  BCF    03.5
0365:  MOVF   5D,W
0366:  BSF    03.5
0367:  MOVWF  2C
0368:  BCF    03.5
0369:  MOVF   5C,W
036A:  BSF    03.5
036B:  MOVWF  2D
.................... { 
....................    int1 tc = scoreLC; 
....................    int8 td = scoreLD; 
....................    int8 tu = scoreLU; 
....................     
....................    scoreLU += a; 
036C:  MOVF   2A,W
036D:  BCF    03.5
036E:  ADDWF  5C,F
....................     
....................    if(scoreLU > 10) 
036F:  MOVF   5C,W
0370:  SUBLW  0A
0371:  BTFSC  03.0
0372:  GOTO   376
....................    { 
....................       scoreLD++; 
0373:  INCF   5D,F
....................       scoreLU -=10; 
0374:  MOVLW  0A
0375:  SUBWF  5C,F
....................    } 
....................    if(scoreLD > 10) 
0376:  MOVF   5D,W
0377:  SUBLW  0A
0378:  BTFSC  03.0
0379:  GOTO   37D
....................    { 
....................       scoreLC = true; 
037A:  BSF    45.4
....................       scoreLD -=10; 
037B:  MOVLW  0A
037C:  SUBWF  5D,F
....................    } 
....................     
....................    if(scoreLC != tc) 
037D:  CLRF   77
037E:  BSF    03.5
037F:  BTFSC  2B.0
0380:  BSF    77.4
0381:  BCF    03.5
0382:  MOVF   45,W
0383:  XORWF  77,W
0384:  ANDLW  10
0385:  BTFSC  03.2
0386:  GOTO   398
....................    { 
....................       if(scoreLC) 
0387:  BTFSS  45.4
0388:  GOTO   391
....................          i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0389:  MOVLW  0C
038A:  BSF    03.5
038B:  MOVWF  36
038C:  MOVLW  73
038D:  MOVWF  37
038E:  BCF    03.5
038F:  CALL   2C7
0390:  GOTO   398
....................       else 
....................          i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0391:  MOVLW  0C
0392:  BSF    03.5
0393:  MOVWF  36
0394:  MOVLW  74
0395:  MOVWF  37
0396:  BCF    03.5
0397:  CALL   2C7
....................    } 
....................    delay_ms(I2CWAIT);    
0398:  MOVLW  32
0399:  BSF    03.5
039A:  MOVWF  32
039B:  BCF    03.5
039C:  CALL   309
....................    if(scoreLD != td) 
039D:  BSF    03.5
039E:  MOVF   2C,W
039F:  BCF    03.5
03A0:  SUBWF  5D,W
03A1:  BTFSC  03.2
03A2:  GOTO   3AC
....................       sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
03A3:  MOVF   5D,W
03A4:  BSF    03.5
03A5:  MOVWF  32
03A6:  MOVLW  0C
03A7:  MOVWF  33
03A8:  MOVLW  02
03A9:  MOVWF  34
03AA:  BCF    03.5
03AB:  CALL   2FA
....................    delay_ms(I2CWAIT); 
03AC:  MOVLW  32
03AD:  BSF    03.5
03AE:  MOVWF  32
03AF:  BCF    03.5
03B0:  CALL   309
....................    if(scoreLU != tu) 
03B1:  BSF    03.5
03B2:  MOVF   2D,W
03B3:  BCF    03.5
03B4:  SUBWF  5C,W
03B5:  BTFSC  03.2
03B6:  GOTO   3C0
....................       sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
03B7:  MOVF   5C,W
03B8:  BSF    03.5
03B9:  MOVWF  32
03BA:  MOVLW  0C
03BB:  MOVWF  33
03BC:  MOVLW  01
03BD:  MOVWF  34
03BE:  BCF    03.5
03BF:  CALL   2FA
03C0:  RETURN
.................... } 
....................  
.................... void resScoreL() 
*
0A87:  BSF    03.5
0A88:  BCF    2A.0
0A89:  BCF    03.5
0A8A:  BTFSS  45.4
0A8B:  GOTO   28F
0A8C:  BSF    03.5
0A8D:  BSF    2A.0
0A8E:  BCF    03.5
0A8F:  MOVF   5D,W
0A90:  BSF    03.5
0A91:  MOVWF  2B
0A92:  BCF    03.5
0A93:  MOVF   5C,W
0A94:  BSF    03.5
0A95:  MOVWF  2C
.................... { 
....................    int1 tc = scoreLC; 
....................    int8 td = scoreLD; 
....................    int8 tu = scoreLU; 
....................  
....................    if(scoreLU > 0) 
0A96:  BCF    03.5
0A97:  MOVF   5C,F
0A98:  BTFSC  03.2
0A99:  GOTO   29C
....................       scoreLU--; 
0A9A:  DECF   5C,F
0A9B:  GOTO   2A7
....................    else 
....................    { 
....................       if(scoreLD > 0) 
0A9C:  MOVF   5D,F
0A9D:  BTFSC  03.2
0A9E:  GOTO   2A3
....................       { 
....................          scoreLD--; 
0A9F:  DECF   5D,F
....................          scoreLU = 9; 
0AA0:  MOVLW  09
0AA1:  MOVWF  5C
....................       } 
0AA2:  GOTO   2A7
....................       else 
....................       {   
....................          scoreLC = false; 
0AA3:  BCF    45.4
....................          scoreLD = 9; 
0AA4:  MOVLW  09
0AA5:  MOVWF  5D
....................          scoreLU = 9; 
0AA6:  MOVWF  5C
....................       } 
....................    } 
....................     
....................    if(scoreLC != tc) 
0AA7:  CLRF   77
0AA8:  BSF    03.5
0AA9:  BTFSC  2A.0
0AAA:  BSF    77.4
0AAB:  BCF    03.5
0AAC:  MOVF   45,W
0AAD:  XORWF  77,W
0AAE:  ANDLW  10
0AAF:  BTFSC  03.2
0AB0:  GOTO   2C6
....................    { 
....................       if(scoreLC) 
0AB1:  BTFSS  45.4
0AB2:  GOTO   2BD
....................          i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0AB3:  MOVLW  0C
0AB4:  BSF    03.5
0AB5:  MOVWF  36
0AB6:  MOVLW  73
0AB7:  MOVWF  37
0AB8:  BCF    0A.3
0AB9:  BCF    03.5
0ABA:  CALL   2C7
0ABB:  BSF    0A.3
0ABC:  GOTO   2C6
....................       else 
....................          i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0ABD:  MOVLW  0C
0ABE:  BSF    03.5
0ABF:  MOVWF  36
0AC0:  MOVLW  74
0AC1:  MOVWF  37
0AC2:  BCF    0A.3
0AC3:  BCF    03.5
0AC4:  CALL   2C7
0AC5:  BSF    0A.3
....................    } 
....................    delay_ms(I2CWAIT); 
0AC6:  MOVLW  32
0AC7:  BSF    03.5
0AC8:  MOVWF  32
0AC9:  BCF    0A.3
0ACA:  BCF    03.5
0ACB:  CALL   309
0ACC:  BSF    0A.3
....................    if(scoreLD != td) 
0ACD:  BSF    03.5
0ACE:  MOVF   2B,W
0ACF:  BCF    03.5
0AD0:  SUBWF  5D,W
0AD1:  BTFSC  03.2
0AD2:  GOTO   2DE
....................       sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0AD3:  MOVF   5D,W
0AD4:  BSF    03.5
0AD5:  MOVWF  32
0AD6:  MOVLW  0C
0AD7:  MOVWF  33
0AD8:  MOVLW  02
0AD9:  MOVWF  34
0ADA:  BCF    0A.3
0ADB:  BCF    03.5
0ADC:  CALL   2FA
0ADD:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0ADE:  MOVLW  32
0ADF:  BSF    03.5
0AE0:  MOVWF  32
0AE1:  BCF    0A.3
0AE2:  BCF    03.5
0AE3:  CALL   309
0AE4:  BSF    0A.3
....................    if(scoreLU != tu) 
0AE5:  BSF    03.5
0AE6:  MOVF   2C,W
0AE7:  BCF    03.5
0AE8:  SUBWF  5C,W
0AE9:  BTFSC  03.2
0AEA:  GOTO   2F6
....................       sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0AEB:  MOVF   5C,W
0AEC:  BSF    03.5
0AED:  MOVWF  32
0AEE:  MOVLW  0C
0AEF:  MOVWF  33
0AF0:  MOVLW  01
0AF1:  MOVWF  34
0AF2:  BCF    0A.3
0AF3:  BCF    03.5
0AF4:  CALL   2FA
0AF5:  BSF    0A.3
.................... } 
....................  
.................... void shotSet(int8 shd, int8 shu) 
.................... { 
....................    sh_u = shu; 
*
0C71:  MOVF   2D,W
0C72:  BCF    03.5
0C73:  MOVWF  5B
....................    sh_d = shd; 
0C74:  BSF    03.5
0C75:  MOVF   2C,W
0C76:  BCF    03.5
0C77:  MOVWF  5A
....................    sendN2Port (shd, I2C_TIMER, PuertoA); 
0C78:  BSF    03.5
0C79:  MOVF   2C,W
0C7A:  MOVWF  32
0C7B:  MOVLW  0A
0C7C:  MOVWF  33
0C7D:  MOVLW  01
0C7E:  MOVWF  34
0C7F:  BCF    0A.3
0C80:  BCF    03.5
0C81:  CALL   2FA
0C82:  BSF    0A.3
....................    delay_ms (I2CWAIT) ; 
0C83:  MOVLW  32
0C84:  BSF    03.5
0C85:  MOVWF  32
0C86:  BCF    0A.3
0C87:  BCF    03.5
0C88:  CALL   309
0C89:  BSF    0A.3
....................    sendN2Port (shu, I2C_TIMER, PuertoB); 
0C8A:  BSF    03.5
0C8B:  MOVF   2D,W
0C8C:  MOVWF  32
0C8D:  MOVLW  0A
0C8E:  MOVWF  33
0C8F:  MOVLW  02
0C90:  MOVWF  34
0C91:  BCF    0A.3
0C92:  BCF    03.5
0C93:  CALL   2FA
0C94:  BSF    0A.3
....................     
....................    enableShot = true; 
0C95:  BSF    45.2
.................... } 
....................  
.................... void timeSet(INT8 md, int8 mu, int8 sd, int8 su) 
.................... { 
....................    m_u = mu; 
*
0CD7:  MOVF   2F,W
0CD8:  BCF    03.5
0CD9:  MOVWF  57
....................    m_d = md; 
0CDA:  BSF    03.5
0CDB:  MOVF   2E,W
0CDC:  BCF    03.5
0CDD:  MOVWF  56
....................    s_d = sd; 
0CDE:  BSF    03.5
0CDF:  MOVF   30,W
0CE0:  BCF    03.5
0CE1:  MOVWF  58
....................    s_u = su; 
0CE2:  BSF    03.5
0CE3:  MOVF   31,W
0CE4:  BCF    03.5
0CE5:  MOVWF  59
....................     
....................    sendN2Port (su, I2C_TIMER, PuertoD); 
0CE6:  BSF    03.5
0CE7:  MOVF   31,W
0CE8:  MOVWF  32
0CE9:  MOVLW  0A
0CEA:  MOVWF  33
0CEB:  MOVLW  04
0CEC:  MOVWF  34
0CED:  BCF    0A.3
0CEE:  BCF    03.5
0CEF:  CALL   2FA
0CF0:  BSF    0A.3
....................    delay_ms (I2CWAIT) ; 
0CF1:  MOVLW  32
0CF2:  BSF    03.5
0CF3:  MOVWF  32
0CF4:  BCF    0A.3
0CF5:  BCF    03.5
0CF6:  CALL   309
0CF7:  BSF    0A.3
....................    sendN2Port (sd, I2C_TIMER, PuertoC); 
0CF8:  BSF    03.5
0CF9:  MOVF   30,W
0CFA:  MOVWF  32
0CFB:  MOVLW  0A
0CFC:  MOVWF  33
0CFD:  MOVLW  03
0CFE:  MOVWF  34
0CFF:  BCF    0A.3
0D00:  BCF    03.5
0D01:  CALL   2FA
0D02:  BSF    0A.3
....................    delay_ms (I2CWAIT) ; 
0D03:  MOVLW  32
0D04:  BSF    03.5
0D05:  MOVWF  32
0D06:  BCF    0A.3
0D07:  BCF    03.5
0D08:  CALL   309
0D09:  BSF    0A.3
....................    sendN2Port (mu, I2C_TIMER, PuertoE); 
0D0A:  BSF    03.5
0D0B:  MOVF   2F,W
0D0C:  MOVWF  32
0D0D:  MOVLW  0A
0D0E:  MOVWF  33
0D0F:  MOVLW  05
0D10:  MOVWF  34
0D11:  BCF    0A.3
0D12:  BCF    03.5
0D13:  CALL   2FA
0D14:  BSF    0A.3
....................    delay_ms (I2CWAIT) ; 
0D15:  MOVLW  32
0D16:  BSF    03.5
0D17:  MOVWF  32
0D18:  BCF    0A.3
0D19:  BCF    03.5
0D1A:  CALL   309
0D1B:  BSF    0A.3
....................     
....................    IF (md != 0) 
0D1C:  BSF    03.5
0D1D:  MOVF   2E,F
0D1E:  BTFSC  03.2
0D1F:  GOTO   52A
....................    { 
....................       i2c_send (I2C_TIMER, I2C_CMD_MDON); 
0D20:  MOVLW  0A
0D21:  MOVWF  36
0D22:  MOVLW  75
0D23:  MOVWF  37
0D24:  BCF    0A.3
0D25:  BCF    03.5
0D26:  CALL   2C7
0D27:  BSF    0A.3
....................    } 
0D28:  GOTO   532
0D29:  BSF    03.5
....................  
....................    ELSE 
....................    { 
....................       i2c_send (I2C_TIMER, I2C_CMD_MDOF); 
0D2A:  MOVLW  0A
0D2B:  MOVWF  36
0D2C:  MOVLW  76
0D2D:  MOVWF  37
0D2E:  BCF    0A.3
0D2F:  BCF    03.5
0D30:  CALL   2C7
0D31:  BSF    0A.3
....................    } 
....................  
....................    enableTime = true; 
0D32:  BSF    45.1
.................... } 
....................  
.................... void shotPass() 
*
124A:  MOVF   5A,W
124B:  MOVWF  6C
124C:  MOVF   5B,W
124D:  MOVWF  6D
.................... { 
....................    INT8 shd = sh_d; 
....................    INT8 shu = sh_u; 
....................    
....................    IF (sh_u > 0) 
124E:  MOVF   5B,F
124F:  BTFSC  03.2
1250:  GOTO   253
....................       sh_u--; 
1251:  DECF   5B,F
1252:  GOTO   26C
....................  
....................    ELSE 
....................    { 
....................       IF (sh_d > 0) 
1253:  MOVF   5A,F
1254:  BTFSC  03.2
1255:  GOTO   25A
....................       { 
....................          sh_u = 9; 
1256:  MOVLW  09
1257:  MOVWF  5B
....................          sh_d--; 
1258:  DECF   5A,F
....................       } 
1259:  GOTO   26C
....................  
....................       ELSE 
....................       { 
....................          sh_d = 0; 
125A:  CLRF   5A
....................          sh_u = 0; 
125B:  CLRF   5B
....................          enableShot = false; 
125C:  BCF    45.2
125D:  CLRF   2B
125E:  BTFSC  0B.7
125F:  BSF    2B.7
1260:  BCF    0B.7
....................          i2c_send(I2C_TIMER,I2C_CMD_BUZ1); 
1261:  MOVLW  0A
1262:  BSF    03.5
1263:  MOVWF  36
1264:  MOVLW  81
1265:  MOVWF  37
1266:  BCF    0A.4
1267:  BCF    03.5
1268:  CALL   2C7
1269:  BSF    0A.4
126A:  BTFSC  2B.7
126B:  BSF    0B.7
....................       } 
....................    } 
....................  
....................    IF (shu != sh_u) 
126C:  MOVF   5B,W
126D:  SUBWF  6D,W
126E:  BTFSC  03.2
126F:  GOTO   281
1270:  CLRF   2B
1271:  BTFSC  0B.7
1272:  BSF    2B.7
1273:  BCF    0B.7
....................       sendN2Port (sh_u, I2C_TIMER, PuertoB); 
1274:  MOVF   5B,W
1275:  BSF    03.5
1276:  MOVWF  32
1277:  MOVLW  0A
1278:  MOVWF  33
1279:  MOVLW  02
127A:  MOVWF  34
127B:  BCF    0A.4
127C:  BCF    03.5
127D:  CALL   2FA
127E:  BSF    0A.4
127F:  BTFSC  2B.7
1280:  BSF    0B.7
1281:  CLRF   2B
1282:  BTFSC  0B.7
1283:  BSF    2B.7
1284:  BCF    0B.7
....................  
....................    delay_ms (I2CWAIT) ; 
1285:  MOVLW  32
1286:  BSF    03.5
1287:  MOVWF  32
1288:  BCF    0A.4
1289:  BCF    03.5
128A:  CALL   309
128B:  BSF    0A.4
128C:  BTFSC  2B.7
128D:  BSF    0B.7
....................  
....................    IF (shd != sh_d) 
128E:  MOVF   5A,W
128F:  SUBWF  6C,W
1290:  BTFSC  03.2
1291:  GOTO   2A3
1292:  CLRF   2B
1293:  BTFSC  0B.7
1294:  BSF    2B.7
1295:  BCF    0B.7
....................       sendN2Port (sh_d, I2C_TIMER, PuertoA); 
1296:  MOVF   5A,W
1297:  BSF    03.5
1298:  MOVWF  32
1299:  MOVLW  0A
129A:  MOVWF  33
129B:  MOVLW  01
129C:  MOVWF  34
129D:  BCF    0A.4
129E:  BCF    03.5
129F:  CALL   2FA
12A0:  BSF    0A.4
12A1:  BTFSC  2B.7
12A2:  BSF    0B.7
....................  
....................     
.................... } 
....................  
.................... void timePass() 
*
1180:  MOVF   56,W
1181:  MOVWF  6C
1182:  MOVF   57,W
1183:  MOVWF  6D
1184:  MOVF   58,W
1185:  MOVWF  6E
1186:  MOVF   59,W
1187:  MOVWF  6F
.................... { 
....................    INT8 md = m_d; 
....................    INT8 mu = m_u; 
....................    INT8 sd = s_d; 
....................    INT8 su = s_u; 
....................     
....................    IF (s_u > 0) 
1188:  MOVF   59,F
1189:  BTFSC  03.2
118A:  GOTO   18D
....................       s_u--; 
118B:  DECF   59,F
118C:  GOTO   1BC
....................  
....................    ELSE 
....................    { 
....................       IF (s_d > 0) 
118D:  MOVF   58,F
118E:  BTFSC  03.2
118F:  GOTO   194
....................       { 
....................          s_u = 9; 
1190:  MOVLW  09
1191:  MOVWF  59
....................          s_d--; 
1192:  DECF   58,F
....................       } 
1193:  GOTO   1BC
....................  
....................       ELSE 
....................       { 
....................          IF (m_u > 0) 
1194:  MOVF   57,F
1195:  BTFSC  03.2
1196:  GOTO   19D
....................          { 
....................             s_d = 5; 
1197:  MOVLW  05
1198:  MOVWF  58
....................             s_u = 9; 
1199:  MOVLW  09
119A:  MOVWF  59
....................             m_u--; 
119B:  DECF   57,F
....................          } 
119C:  GOTO   1BC
....................  
....................          ELSE 
....................          { 
....................             IF (m_d > 0) 
119D:  MOVF   56,F
119E:  BTFSC  03.2
119F:  GOTO   1A8
....................             { 
....................                m_d = 0; 
11A0:  CLRF   56
....................                m_u = 9; 
11A1:  MOVLW  09
11A2:  MOVWF  57
....................                s_d = 5; 
11A3:  MOVLW  05
11A4:  MOVWF  58
....................                s_u = 9; 
11A5:  MOVLW  09
11A6:  MOVWF  59
....................             } 
11A7:  GOTO   1BC
....................  
....................             ELSE 
....................             { 
....................                //TODO: End count 
....................                m_d = 0; 
11A8:  CLRF   56
....................                m_u = 0; 
11A9:  CLRF   57
....................                s_d = 0; 
11AA:  CLRF   58
....................                s_u = 0; 
11AB:  CLRF   59
....................                enableTime = false; 
11AC:  BCF    45.1
11AD:  CLRF   2B
11AE:  BTFSC  0B.7
11AF:  BSF    2B.7
11B0:  BCF    0B.7
....................                i2c_send(I2C_TIMER,I2C_CMD_BUZ2); 
11B1:  MOVLW  0A
11B2:  BSF    03.5
11B3:  MOVWF  36
11B4:  MOVLW  82
11B5:  MOVWF  37
11B6:  BCF    0A.4
11B7:  BCF    03.5
11B8:  CALL   2C7
11B9:  BSF    0A.4
11BA:  BTFSC  2B.7
11BB:  BSF    0B.7
....................             } 
....................          } 
....................       } 
....................    } 
....................  
....................     
....................    IF (su != s_u) 
11BC:  MOVF   59,W
11BD:  SUBWF  6F,W
11BE:  BTFSC  03.2
11BF:  GOTO   1D1
11C0:  CLRF   2B
11C1:  BTFSC  0B.7
11C2:  BSF    2B.7
11C3:  BCF    0B.7
....................       sendN2Port (s_u, I2C_TIMER, PuertoD); 
11C4:  MOVF   59,W
11C5:  BSF    03.5
11C6:  MOVWF  32
11C7:  MOVLW  0A
11C8:  MOVWF  33
11C9:  MOVLW  04
11CA:  MOVWF  34
11CB:  BCF    0A.4
11CC:  BCF    03.5
11CD:  CALL   2FA
11CE:  BSF    0A.4
11CF:  BTFSC  2B.7
11D0:  BSF    0B.7
11D1:  CLRF   2B
11D2:  BTFSC  0B.7
11D3:  BSF    2B.7
11D4:  BCF    0B.7
....................  
....................    delay_ms (I2CWAIT) ; 
11D5:  MOVLW  32
11D6:  BSF    03.5
11D7:  MOVWF  32
11D8:  BCF    0A.4
11D9:  BCF    03.5
11DA:  CALL   309
11DB:  BSF    0A.4
11DC:  BTFSC  2B.7
11DD:  BSF    0B.7
....................  
....................    IF (sd != s_d) 
11DE:  MOVF   58,W
11DF:  SUBWF  6E,W
11E0:  BTFSC  03.2
11E1:  GOTO   1F3
11E2:  CLRF   2B
11E3:  BTFSC  0B.7
11E4:  BSF    2B.7
11E5:  BCF    0B.7
....................       sendN2Port (s_d, I2C_TIMER, PuertoC); 
11E6:  MOVF   58,W
11E7:  BSF    03.5
11E8:  MOVWF  32
11E9:  MOVLW  0A
11EA:  MOVWF  33
11EB:  MOVLW  03
11EC:  MOVWF  34
11ED:  BCF    0A.4
11EE:  BCF    03.5
11EF:  CALL   2FA
11F0:  BSF    0A.4
11F1:  BTFSC  2B.7
11F2:  BSF    0B.7
11F3:  CLRF   2B
11F4:  BTFSC  0B.7
11F5:  BSF    2B.7
11F6:  BCF    0B.7
....................  
....................    delay_ms (I2CWAIT) ; 
11F7:  MOVLW  32
11F8:  BSF    03.5
11F9:  MOVWF  32
11FA:  BCF    0A.4
11FB:  BCF    03.5
11FC:  CALL   309
11FD:  BSF    0A.4
11FE:  BTFSC  2B.7
11FF:  BSF    0B.7
....................  
....................    IF (mu != m_u) 
1200:  MOVF   57,W
1201:  SUBWF  6D,W
1202:  BTFSC  03.2
1203:  GOTO   215
1204:  CLRF   2B
1205:  BTFSC  0B.7
1206:  BSF    2B.7
1207:  BCF    0B.7
....................       sendN2Port (m_u, I2C_TIMER, PuertoE); 
1208:  MOVF   57,W
1209:  BSF    03.5
120A:  MOVWF  32
120B:  MOVLW  0A
120C:  MOVWF  33
120D:  MOVLW  05
120E:  MOVWF  34
120F:  BCF    0A.4
1210:  BCF    03.5
1211:  CALL   2FA
1212:  BSF    0A.4
1213:  BTFSC  2B.7
1214:  BSF    0B.7
1215:  CLRF   2B
1216:  BTFSC  0B.7
1217:  BSF    2B.7
1218:  BCF    0B.7
....................  
....................    delay_ms (I2CWAIT) ; 
1219:  MOVLW  32
121A:  BSF    03.5
121B:  MOVWF  32
121C:  BCF    0A.4
121D:  BCF    03.5
121E:  CALL   309
121F:  BSF    0A.4
1220:  BTFSC  2B.7
1221:  BSF    0B.7
....................  
....................    IF (md != m_d) 
1222:  MOVF   56,W
1223:  SUBWF  6C,W
1224:  BTFSC  03.2
1225:  GOTO   248
....................       IF (m_d == 0) 
1226:  MOVF   56,F
1227:  BTFSS  03.2
1228:  GOTO   239
1229:  CLRF   2B
122A:  BTFSC  0B.7
122B:  BSF    2B.7
122C:  BCF    0B.7
....................       { 
....................          i2c_send (I2C_TIMER, I2C_CMD_MDOF); 
122D:  MOVLW  0A
122E:  BSF    03.5
122F:  MOVWF  36
1230:  MOVLW  76
1231:  MOVWF  37
1232:  BCF    0A.4
1233:  BCF    03.5
1234:  CALL   2C7
1235:  BSF    0A.4
1236:  BTFSC  2B.7
1237:  BSF    0B.7
....................       } 
1238:  GOTO   248
1239:  CLRF   2B
123A:  BTFSC  0B.7
123B:  BSF    2B.7
123C:  BCF    0B.7
....................  
....................    ELSE 
....................    { 
....................       i2c_send (I2C_TIMER, I2C_CMD_MDON); 
123D:  MOVLW  0A
123E:  BSF    03.5
123F:  MOVWF  36
1240:  MOVLW  75
1241:  MOVWF  37
1242:  BCF    0A.4
1243:  BCF    03.5
1244:  CALL   2C7
1245:  BSF    0A.4
1246:  BTFSC  2B.7
1247:  BSF    0B.7
....................    } 
....................     
.................... } 
....................  
.................... void showNumber(INT8 n, tPort p) 
*
01FD:  BSF    03.5
01FE:  BCF    30.0
01FF:  BCF    30.1
0200:  BCF    30.2
0201:  BCF    30.3
.................... { 
....................    INT1 a = 0, b = 0, c = 0, d = 0; 
....................  
....................    SWITCH (n) 
0202:  MOVLW  01
0203:  SUBWF  2B,W
0204:  ADDLW  F7
0205:  BTFSC  03.0
0206:  GOTO   22C
0207:  ADDLW  09
0208:  BCF    03.5
0209:  GOTO   284
....................    { 
....................       CASE 1: a = 1; 
020A:  BSF    03.5
020B:  BSF    30.0
....................       BREAK; 
020C:  GOTO   22C
....................       CASE 2: b = 1; 
020D:  BSF    03.5
020E:  BSF    30.1
....................       BREAK; 
020F:  GOTO   22C
....................       CASE 3: a = 1; b = 1; 
0210:  BSF    03.5
0211:  BSF    30.0
0212:  BSF    30.1
....................       BREAK; 
0213:  GOTO   22C
....................       CASE 4: c = 1; 
0214:  BSF    03.5
0215:  BSF    30.2
....................       BREAK; 
0216:  GOTO   22C
....................       CASE 5: c = 1; a = 1; 
0217:  BSF    03.5
0218:  BSF    30.2
0219:  BSF    30.0
....................       BREAK; 
021A:  GOTO   22C
....................       CASE 6: c = 1; b = 1; 
021B:  BSF    03.5
021C:  BSF    30.2
021D:  BSF    30.1
....................       BREAK; 
021E:  GOTO   22C
....................       CASE 7: c = 1; b = 1; a = 1; 
021F:  BSF    03.5
0220:  BSF    30.2
0221:  BSF    30.1
0222:  BSF    30.0
....................       BREAK; 
0223:  GOTO   22C
....................       CASE 8: d = 1; 
0224:  BSF    03.5
0225:  BSF    30.3
....................       BREAK; 
0226:  GOTO   22C
....................       CASE 9: d = 1; a = 1; 
0227:  BSF    03.5
0228:  BSF    30.3
0229:  BSF    30.0
....................       BREAK; 
022A:  GOTO   22C
022B:  BSF    03.5
....................    } 
....................  
....................    output_bit (p.a, a); 
022C:  MOVLW  00
022D:  BTFSC  30.0
022E:  MOVLW  01
022F:  MOVWF  77
0230:  MOVF   2C,W
0231:  MOVWF  31
0232:  MOVF   77,W
0233:  MOVWF  32
0234:  CLRF   34
0235:  CLRF   33
0236:  BCF    03.5
0237:  CALL   1DB
0238:  BSF    03.5
0239:  MOVF   2C,W
023A:  MOVWF  31
023B:  CLRF   32
023C:  CLRF   34
023D:  MOVLW  80
023E:  MOVWF  33
023F:  BCF    03.5
0240:  CALL   1DB
....................    output_bit (p.b, b); 
0241:  MOVLW  00
0242:  BSF    03.5
0243:  BTFSC  30.1
0244:  MOVLW  01
0245:  MOVWF  77
0246:  MOVF   2D,W
0247:  MOVWF  31
0248:  MOVF   77,W
0249:  MOVWF  32
024A:  CLRF   34
024B:  CLRF   33
024C:  BCF    03.5
024D:  CALL   1DB
024E:  BSF    03.5
024F:  MOVF   2D,W
0250:  MOVWF  31
0251:  CLRF   32
0252:  CLRF   34
0253:  MOVLW  80
0254:  MOVWF  33
0255:  BCF    03.5
0256:  CALL   1DB
....................    output_bit (p.c, c); 
0257:  MOVLW  00
0258:  BSF    03.5
0259:  BTFSC  30.2
025A:  MOVLW  01
025B:  MOVWF  77
025C:  MOVF   2E,W
025D:  MOVWF  31
025E:  MOVF   77,W
025F:  MOVWF  32
0260:  CLRF   34
0261:  CLRF   33
0262:  BCF    03.5
0263:  CALL   1DB
0264:  BSF    03.5
0265:  MOVF   2E,W
0266:  MOVWF  31
0267:  CLRF   32
0268:  CLRF   34
0269:  MOVLW  80
026A:  MOVWF  33
026B:  BCF    03.5
026C:  CALL   1DB
....................    output_bit (p.d, d); 
026D:  MOVLW  00
026E:  BSF    03.5
026F:  BTFSC  30.3
0270:  MOVLW  01
0271:  MOVWF  77
0272:  MOVF   2F,W
0273:  MOVWF  31
0274:  MOVF   77,W
0275:  MOVWF  32
0276:  CLRF   34
0277:  CLRF   33
0278:  BCF    03.5
0279:  CALL   1DB
027A:  BSF    03.5
027B:  MOVF   2F,W
027C:  MOVWF  31
027D:  CLRF   32
027E:  CLRF   34
027F:  MOVLW  80
0280:  MOVWF  33
0281:  BCF    03.5
0282:  CALL   1DB
0283:  RETURN
.................... } 
....................  
.................... int8 char2int(CHAR c) 
.................... { 
....................    SWITCH (c) 
*
018D:  MOVLW  30
018E:  BSF    03.5
018F:  SUBWF  2D,W
0190:  ADDLW  F6
0191:  BTFSC  03.0
0192:  GOTO   1C9
0193:  ADDLW  0A
0194:  BCF    03.5
0195:  GOTO   1CD
....................    { 
....................       case '0': RETURN 0; 
0196:  MOVLW  00
0197:  MOVWF  78
0198:  GOTO   1CC
....................       BREAK; 
0199:  BSF    03.5
019A:  GOTO   1C9
....................       case '1': RETURN 1; 
019B:  MOVLW  01
019C:  MOVWF  78
019D:  GOTO   1CC
....................       BREAK; 
019E:  BSF    03.5
019F:  GOTO   1C9
....................       case '2': RETURN 2; 
01A0:  MOVLW  02
01A1:  MOVWF  78
01A2:  GOTO   1CC
....................       BREAK; 
01A3:  BSF    03.5
01A4:  GOTO   1C9
....................       case '3': RETURN 3; 
01A5:  MOVLW  03
01A6:  MOVWF  78
01A7:  GOTO   1CC
....................       BREAK; 
01A8:  BSF    03.5
01A9:  GOTO   1C9
....................       case '4': RETURN 4; 
01AA:  MOVLW  04
01AB:  MOVWF  78
01AC:  GOTO   1CC
....................       BREAK; 
01AD:  BSF    03.5
01AE:  GOTO   1C9
....................       case '5': RETURN 5; 
01AF:  MOVLW  05
01B0:  MOVWF  78
01B1:  GOTO   1CC
....................       BREAK; 
01B2:  BSF    03.5
01B3:  GOTO   1C9
....................       case '6': RETURN 6; 
01B4:  MOVLW  06
01B5:  MOVWF  78
01B6:  GOTO   1CC
....................       BREAK; 
01B7:  BSF    03.5
01B8:  GOTO   1C9
....................       case '7': RETURN 7; 
01B9:  MOVLW  07
01BA:  MOVWF  78
01BB:  GOTO   1CC
....................       BREAK; 
01BC:  BSF    03.5
01BD:  GOTO   1C9
....................       case '8': RETURN 8; 
01BE:  MOVLW  08
01BF:  MOVWF  78
01C0:  GOTO   1CC
....................       BREAK; 
01C1:  BSF    03.5
01C2:  GOTO   1C9
....................       case '9': RETURN 9; 
01C3:  MOVLW  09
01C4:  MOVWF  78
01C5:  GOTO   1CC
....................       BREAK; 
01C6:  BSF    03.5
01C7:  GOTO   1C9
01C8:  BSF    03.5
....................    } 
....................  
....................    RETURN 0; 
01C9:  MOVLW  00
01CA:  MOVWF  78
01CB:  BCF    03.5
01CC:  RETURN
.................... } 
....................  
.................... void doReset(VOID) 
.................... { 
....................    i2c_send (I2C_TIMER, I2C_CMD_RESET); 
*
0FA9:  MOVLW  0A
0FAA:  MOVWF  36
0FAB:  MOVLW  FD
0FAC:  MOVWF  37
0FAD:  BCF    0A.3
0FAE:  BCF    03.5
0FAF:  CALL   2C7
0FB0:  BSF    0A.3
....................    delay_ms (I2CWAIT) ; 
0FB1:  MOVLW  32
0FB2:  BSF    03.5
0FB3:  MOVWF  32
0FB4:  BCF    0A.3
0FB5:  BCF    03.5
0FB6:  CALL   309
0FB7:  BSF    0A.3
....................    i2c_send (I2C_SCORE, I2C_CMD_RESET); 
0FB8:  MOVLW  0C
0FB9:  BSF    03.5
0FBA:  MOVWF  36
0FBB:  MOVLW  FD
0FBC:  MOVWF  37
0FBD:  BCF    0A.3
0FBE:  BCF    03.5
0FBF:  CALL   2C7
0FC0:  BSF    0A.3
....................    reset_cpu () ; 
0FC1:  CLRF   0A
0FC2:  GOTO   000
.................... } 
....................  
.................... void sendN2Port(INT8 n, int8 a, int8 p) 
*
02FA:  BSF    03.5
02FB:  SWAPF  34,W
02FC:  MOVWF  77
02FD:  MOVLW  F0
02FE:  ANDWF  77,F
02FF:  MOVF   77,W
0300:  ADDWF  32,W
0301:  MOVWF  35
.................... { 
....................    INT c = (p * 16) + n; 
....................    i2c_send (a, c); 
0302:  MOVF   33,W
0303:  MOVWF  36
0304:  MOVF   35,W
0305:  MOVWF  37
0306:  BCF    03.5
0307:  CALL   2C7
0308:  RETURN
.................... } 
....................  
.................... void i2c_send(INT8 a, int8 c) 
.................... { 
....................    i2c_start () ; 
*
02C7:  BSF    03.5
02C8:  BSF    11.0
02C9:  BTFSC  11.0
02CA:  GOTO   2C9
....................    i2c_write (a) ; 
02CB:  MOVF   36,W
02CC:  MOVWF  38
....................    i2c_write (c) ; 
*
02DF:  BSF    03.5
02E0:  MOVF   37,W
02E1:  MOVWF  38
....................    i2c_stop () ; 
*
02F4:  BSF    03.5
02F5:  BSF    11.2
02F6:  BTFSC  11.2
02F7:  GOTO   2F6
02F8:  BCF    03.5
02F9:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

CCS PCM C Compiler, Version 5.076, 56587               18-feb.-23 14:31

               Filename:   C:\Users\nogue\Proyectos\bbsb\mcoms\mcoms.lst

               ROM used:   4179 words (51%)
                           Largest free fragment is 2048
               RAM used:   90 (24%) at main() level
                           134 (36%) worst case
               Stack used: 6 locations (1 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   6B4
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   42A
....................  
....................  
.................... /**:COPYRIGHT 
....................             _ /      _ /  
....................         _ /_ /_ /  _/_/ 
....................          _ /       _ /  
....................         _ /       _ /  
....................        _ / _ / _/_ / _ / 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo APM 
....................      
....................  */ 
.................... // * AUTOR: Victor Noguedad 
.................... // * ARCHIVO: mscoms.c 
.................... // * RESUMEN: Programa principal del modulo de comunicaciones 
.................... // ::[CABECERAS]:: 
.................... #include <mcoms.h> 
.................... /**:COPYRIGHT 
....................  
....................            _/       _/ 
....................         _/_/_/   _/_/ 
....................          _/       _/ 
....................         _/       _/ 
....................        _/_/   _/_/_/ 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo  APM 
....................      
....................  */ 
....................  
.................... // *AUTOR:    Victor Noguedad 
.................... // *ARCHIVO:  mscoms.c 
.................... // *RESUMEN:  Programa principal del modulo de comunicaciones 
....................  
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  00
0056:  RETLW  00
0057:  DATA 2A,15
0058:  DATA 2A,15
0059:  DATA 2A,15
005A:  DATA 2A,15
005B:  DATA 2A,15
005C:  DATA 2A,15
005D:  DATA 2A,15
005E:  DATA 2A,15
005F:  DATA 2A,15
0060:  DATA 2A,15
0061:  DATA 2A,15
0062:  DATA 2A,15
0063:  DATA 2A,15
0064:  DATA 2A,15
0065:  DATA 2A,15
0066:  DATA 2A,15
0067:  DATA 0D,00
0068:  DATA A0,23
0069:  DATA F2,3A
006A:  DATA F0,37
006B:  DATA A0,20
006C:  DATA D0,26
006D:  DATA 20,14
006E:  DATA E3,14
006F:  DATA 20,19
0070:  DATA 30,19
0071:  DATA 30,10
0072:  DATA 0D,00
0073:  DATA BD,1E
0074:  DATA BD,1E
0075:  DATA BD,1E
0076:  DATA BD,1E
0077:  DATA BD,1E
0078:  DATA BD,1E
0079:  DATA BD,1E
007A:  DATA BD,1E
007B:  DATA BD,1E
007C:  DATA BD,1E
007D:  DATA BD,1E
007E:  DATA BD,1E
007F:  DATA BD,1E
0080:  DATA BD,1E
0081:  DATA BD,1E
0082:  DATA BD,1E
0083:  DATA 0D,00
0084:  DATA 42,36
0085:  DATA F5,32
0086:  DATA F4,37
0087:  DATA 6F,3A
0088:  DATA 68,10
0089:  DATA C2,30
008A:  DATA F3,35
008B:  DATA 65,3A
008C:  DATA E2,30
008D:  DATA 6C,36
008E:  DATA A0,29
008F:  DATA E3,37
0090:  DATA F2,32
0091:  DATA 20,21
0092:  DATA EF,30
0093:  DATA 72,32
0094:  DATA 0D,00
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA BD,1E
009B:  DATA BD,1E
009C:  DATA BD,1E
009D:  DATA BD,1E
009E:  DATA BD,1E
009F:  DATA BD,1E
00A0:  DATA BD,1E
00A1:  DATA BD,1E
00A2:  DATA BD,1E
00A3:  DATA BD,1E
00A4:  DATA BD,1E
00A5:  DATA 0D,00
00A6:  DATA D6,32
00A7:  DATA F2,39
00A8:  DATA E9,37
00A9:  DATA 6E,10
00AA:  DATA A5,39
00AB:  DATA A0,16
00AC:  DATA 20,39
00AD:  DATA 65,3B
00AE:  DATA A0,12
00AF:  DATA 73,10
00B0:  DATA 0D,00
00B1:  DATA 32,17
00B2:  DATA 30,00
00B3:  DATA 46,00
00B4:  DATA 2A,15
00B5:  DATA 2A,15
00B6:  DATA 2A,15
00B7:  DATA 2A,15
00B8:  DATA 2A,15
00B9:  DATA 2A,15
00BA:  DATA 2A,15
00BB:  DATA 2A,15
00BC:  DATA 2A,15
00BD:  DATA 2A,15
00BE:  DATA 2A,15
00BF:  DATA 2A,15
00C0:  DATA 2A,15
00C1:  DATA 2A,15
00C2:  DATA 2A,15
00C3:  DATA 2A,15
00C4:  DATA 0D,00
00C5:  DATA 20,22
00C6:  DATA 45,28
00C7:  DATA 55,29
00C8:  DATA C1,21
00C9:  DATA C9,27
00CA:  DATA 4E,10
00CB:  DATA 3A,1D
00CC:  DATA A0,21
00CD:  DATA CF,26
00CE:  DATA 55,27
00CF:  DATA C9,21
00D0:  DATA C1,21
00D1:  DATA C9,27
00D2:  DATA CE,22
00D3:  DATA 53,10
00D4:  DATA 0D,00
00D5:  DATA 20,1F
00D6:  DATA A0,21
00D7:  DATA 6F,37
00D8:  DATA E6,34
00D9:  DATA E7,3A
00DA:  DATA F2,30
00DB:  DATA E3,34
00DC:  DATA 6F,37
00DD:  DATA 20,32
00DE:  DATA 65,10
00DF:  DATA D0,3A
00E0:  DATA 65,39
00E1:  DATA F4,37
00E2:  DATA 73,00
00E3:  DATA 20,1F
00E4:  DATA A0,24
00E5:  DATA EE,34
00E6:  DATA E3,34
00E7:  DATA 61,36
00E8:  DATA 69,3D
00E9:  DATA E1,31
00EA:  DATA E9,37
00EB:  DATA 6E,10
00EC:  DATA E4,32
00ED:  DATA A0,24
00EE:  DATA B2,21
00EF:  DATA 00,01
00F0:  DATA 20,1F
00F1:  DATA 20,24
00F2:  DATA 61,31
00F3:  DATA 69,36
00F4:  DATA 69,3A
00F5:  DATA E1,31
00F6:  DATA E9,37
00F7:  DATA 6E,10
00F8:  DATA E4,32
00F9:  DATA 20,32
00FA:  DATA E9,39
00FB:  DATA 70,36
00FC:  DATA E1,3C
00FD:  DATA 73,00
00FE:  DATA 20,1F
00FF:  DATA 20,24
0100:  DATA 61,31
0101:  DATA 69,36
0102:  DATA 69,3A
0103:  DATA E1,31
0104:  DATA E9,37
0105:  DATA 6E,10
0106:  DATA E4,32
0107:  DATA A0,34
0108:  DATA 6E,3A
0109:  DATA 65,39
010A:  DATA F2,3A
010B:  DATA F0,31
010C:  DATA E9,37
010D:  DATA EE,32
010E:  DATA 73,00
010F:  MOVF   0B,W
0110:  BSF    03.5
0111:  MOVWF  38
0112:  BCF    03.5
0113:  BCF    0B.7
0114:  BSF    03.5
0115:  BSF    03.6
0116:  BSF    0C.7
0117:  BSF    0C.0
0118:  NOP
0119:  NOP
011A:  BCF    03.6
011B:  BTFSS  38.7
011C:  GOTO   120
011D:  BCF    03.5
011E:  BSF    0B.7
011F:  BSF    03.5
0120:  BCF    03.5
0121:  BSF    03.6
0122:  MOVF   0C,W
0123:  ANDLW  7F
0124:  BTFSC  03.2
0125:  GOTO   183
0126:  BSF    03.5
0127:  BCF    03.6
0128:  MOVWF  38
0129:  BCF    03.5
012A:  BSF    03.6
012B:  MOVF   0D,W
012C:  BSF    03.5
012D:  BCF    03.6
012E:  MOVWF  39
012F:  BCF    03.5
0130:  BSF    03.6
0131:  MOVF   0F,W
0132:  BSF    03.5
0133:  BCF    03.6
0134:  MOVWF  3A
0135:  MOVF   38,W
0136:  BCF    03.5
0137:  BTFSS  0C.4
0138:  GOTO   137
0139:  MOVWF  19
013A:  BSF    03.5
013B:  MOVF   39,W
013C:  BCF    03.5
013D:  BSF    03.6
013E:  MOVWF  0D
013F:  BSF    03.5
0140:  BCF    03.6
0141:  MOVF   3A,W
0142:  BCF    03.5
0143:  BSF    03.6
0144:  MOVWF  0F
0145:  BCF    03.6
0146:  MOVF   0B,W
0147:  BSF    03.5
0148:  MOVWF  3B
0149:  BCF    03.5
014A:  BCF    0B.7
014B:  BSF    03.5
014C:  BSF    03.6
014D:  BSF    0C.7
014E:  BSF    0C.0
014F:  NOP
0150:  NOP
0151:  BCF    03.6
0152:  BTFSS  3B.7
0153:  GOTO   157
0154:  BCF    03.5
0155:  BSF    0B.7
0156:  BSF    03.5
0157:  BCF    03.5
0158:  BSF    03.6
0159:  RLF    0C,W
015A:  RLF    0E,W
015B:  ANDLW  7F
015C:  BTFSC  03.2
015D:  GOTO   183
015E:  BSF    03.5
015F:  BCF    03.6
0160:  MOVWF  38
0161:  BCF    03.5
0162:  BSF    03.6
0163:  MOVF   0D,W
0164:  BSF    03.5
0165:  BCF    03.6
0166:  MOVWF  39
0167:  BCF    03.5
0168:  BSF    03.6
0169:  MOVF   0F,W
016A:  BSF    03.5
016B:  BCF    03.6
016C:  MOVWF  3A
016D:  MOVF   38,W
016E:  BCF    03.5
016F:  BTFSS  0C.4
0170:  GOTO   16F
0171:  MOVWF  19
0172:  BSF    03.5
0173:  MOVF   39,W
0174:  BCF    03.5
0175:  BSF    03.6
0176:  MOVWF  0D
0177:  BSF    03.5
0178:  BCF    03.6
0179:  MOVF   3A,W
017A:  BCF    03.5
017B:  BSF    03.6
017C:  MOVWF  0F
017D:  INCF   0D,F
017E:  BTFSC  03.2
017F:  INCF   0F,F
0180:  BCF    03.6
0181:  GOTO   10F
0182:  BSF    03.6
0183:  BCF    03.6
0184:  RETURN
*
01C5:  BSF    0A.0
01C6:  BCF    0A.1
01C7:  BCF    0A.2
01C8:  ADDWF  02,F
01C9:  GOTO   18E
01CA:  GOTO   193
01CB:  GOTO   198
01CC:  GOTO   19D
01CD:  GOTO   1A2
01CE:  GOTO   1A7
01CF:  GOTO   1AC
01D0:  GOTO   1B1
01D1:  GOTO   1B6
01D2:  GOTO   1BB
01D3:  BSF    03.5
01D4:  MOVF   3E,W
01D5:  ANDLW  07
01D6:  MOVWF  77
01D7:  RRF    3E,W
01D8:  MOVWF  78
01D9:  RRF    78,F
01DA:  RRF    78,F
01DB:  MOVLW  1F
01DC:  ANDWF  78,F
01DD:  MOVF   78,W
01DE:  ADDWF  40,W
01DF:  MOVWF  04
01E0:  BCF    03.7
01E1:  BTFSC  41.0
01E2:  BSF    03.7
01E3:  CLRF   78
01E4:  INCF   78,F
01E5:  INCF   77,F
01E6:  GOTO   1E8
01E7:  RLF    78,F
01E8:  DECFSZ 77,F
01E9:  GOTO   1E7
01EA:  MOVF   3F,F
01EB:  BTFSC  03.2
01EC:  GOTO   1F0
01ED:  MOVF   78,W
01EE:  IORWF  00,F
01EF:  GOTO   1F3
01F0:  COMF   78,F
01F1:  MOVF   78,W
01F2:  ANDWF  00,F
01F3:  BCF    03.5
01F4:  RETURN
*
027C:  BCF    0A.0
027D:  BSF    0A.1
027E:  BCF    0A.2
027F:  ADDWF  02,F
0280:  GOTO   202
0281:  GOTO   205
0282:  GOTO   208
0283:  GOTO   20C
0284:  GOTO   20F
0285:  GOTO   213
0286:  GOTO   217
0287:  GOTO   21C
0288:  GOTO   21F
*
0496:  DATA 20,1F
0497:  DATA 20,29
0498:  DATA 75,3A
0499:  DATA 69,37
049A:  DATA 61,10
049B:  DATA E4,32
049C:  DATA 20,38
049D:  DATA F2,3A
049E:  DATA 65,31
049F:  DATA 61,00
04A0:  DATA 20,1F
04A1:  DATA 20,28
04A2:  DATA F2,37
04A3:  DATA E2,30
04A4:  DATA 6E,32
04A5:  DATA 6F,10
04A6:  DATA ED,37
04A7:  DATA E4,3A
04A8:  DATA EC,37
04A9:  DATA 20,3A
04AA:  DATA E9,32
04AB:  DATA 6D,38
04AC:  DATA 6F,00
04AD:  DATA 20,1F
04AE:  DATA 20,28
04AF:  DATA F2,37
04B0:  DATA E2,30
04B1:  DATA 6E,32
04B2:  DATA 6F,10
04B3:  DATA ED,37
04B4:  DATA E4,3A
04B5:  DATA EC,37
04B6:  DATA 20,38
04B7:  DATA 75,37
04B8:  DATA F4,37
04B9:  DATA 73,00
04BA:  DATA 20,1F
04BB:  DATA 20,28
04BC:  DATA F2,37
04BD:  DATA E2,30
04BE:  DATA 6E,32
04BF:  DATA 6F,10
04C0:  DATA ED,37
04C1:  DATA E4,3A
04C2:  DATA EC,37
04C3:  DATA A0,31
04C4:  DATA EF,36
04C5:  DATA 75,37
04C6:  DATA E9,31
04C7:  DATA E1,31
04C8:  DATA E9,37
04C9:  DATA EE,32
04CA:  DATA 73,00
04CB:  DATA 0D,10
04CC:  DATA 3E,10
04CD:  DATA C1,31
04CE:  DATA F4,34
04CF:  DATA F6,30
04D0:  DATA E3,34
04D1:  DATA 6F,37
04D2:  DATA A0,36
04D3:  DATA 61,37
04D4:  DATA F5,30
04D5:  DATA 6C,10
04D6:  DATA E4,32
04D7:  DATA 20,38
04D8:  DATA F5,32
04D9:  DATA 72,3A
04DA:  DATA 6F,00
04DB:  DATA 0D,10
04DC:  DATA 3E,10
04DD:  DATA D4,37
04DE:  DATA F1,3A
04DF:  DATA 65,10
04E0:  DATA E3,37
04E1:  DATA 72,3A
04E2:  DATA 6F,00
04E3:  DATA 0D,10
04E4:  DATA 3E,10
04E5:  DATA D4,37
04E6:  DATA F1,3A
04E7:  DATA 65,10
04E8:  DATA EC,30
04E9:  DATA F2,33
04EA:  DATA 6F,00
04EB:  DATA 0D,10
04EC:  DATA 3E,10
04ED:  DATA D4,37
04EE:  DATA F1,3A
04EF:  DATA 65,10
04F0:  DATA E4,37
04F1:  DATA 62,36
04F2:  DATA 65,00
04F3:  DATA 0D,10
04F4:  DATA 3E,10
04F5:  DATA C1,39
04F6:  DATA E9,33
04F7:  DATA EE,30
04F8:  DATA 72,10
04F9:  DATA E6,30
04FA:  DATA 6C,3A
04FB:  DATA E1,39
04FC:  DATA 00,01
04FD:  DATA 0D,10
04FE:  DATA 3E,10
04FF:  DATA C1,39
0500:  DATA E9,33
0501:  DATA EE,30
0502:  DATA 72,10
0503:  DATA EA,3A
0504:  DATA E7,30
0505:  DATA E4,37
0506:  DATA 72,00
0507:  DATA 0D,10
0508:  DATA 3E,10
0509:  DATA D2,32
050A:  DATA F3,32
050B:  DATA F4,32
050C:  DATA 61,10
050D:  DATA 61,10
050E:  DATA 30,00
050F:  DATA 0D,10
0510:  DATA 3E,10
0511:  DATA 49,37
0512:  DATA 63,39
0513:  DATA E5,36
0514:  DATA 65,37
0515:  DATA F4,30
0516:  DATA 72,10
0517:  DATA F0,37
0518:  DATA 72,10
0519:  DATA 31,00
051A:  DATA 0D,10
051B:  DATA 3E,10
051C:  DATA 49,37
051D:  DATA 63,39
051E:  DATA E5,36
051F:  DATA 65,37
0520:  DATA F4,30
0521:  DATA 72,10
0522:  DATA F0,37
0523:  DATA 72,10
0524:  DATA 32,00
0525:  DATA 0D,10
0526:  DATA 3E,10
0527:  DATA 49,37
0528:  DATA 63,39
0529:  DATA E5,36
052A:  DATA 65,37
052B:  DATA F4,30
052C:  DATA 72,10
052D:  DATA F0,37
052E:  DATA 72,10
052F:  DATA 33,00
0530:  DATA 0D,10
0531:  DATA 3E,10
0532:  DATA C4,32
0533:  DATA 63,39
0534:  DATA E5,36
0535:  DATA 65,37
0536:  DATA F4,30
0537:  DATA 72,10
0538:  DATA F0,37
0539:  DATA 72,10
053A:  DATA 31,00
053B:  DATA 0D,10
053C:  DATA 3E,10
053D:  DATA C1,39
053E:  DATA E9,33
053F:  DATA EE,30
0540:  DATA 72,10
0541:  DATA E6,30
0542:  DATA 6C,3A
0543:  DATA E1,39
0544:  DATA 00,01
0545:  DATA 0D,10
0546:  DATA 3E,10
0547:  DATA 49,37
0548:  DATA E9,31
0549:  DATA E9,30
054A:  DATA EC,34
054B:  DATA FA,30
054C:  DATA 72,00
054D:  DATA 0D,10
054E:  DATA 3E,10
054F:  DATA C1,39
0550:  DATA E9,33
0551:  DATA EE,30
0552:  DATA 72,10
0553:  DATA F0,37
0554:  DATA F3,34
0555:  DATA E3,34
0556:  DATA 6F,37
0557:  DATA 00,01
0558:  DATA 0D,10
0559:  DATA 3E,10
055A:  DATA D0,30
055B:  DATA F5,39
055C:  DATA 61,39
055D:  DATA 20,3A
055E:  DATA E9,32
055F:  DATA 6D,38
0560:  DATA 6F,00
0561:  DATA 0D,10
0562:  DATA 3E,10
0563:  DATA D2,32
0564:  DATA EE,3A
0565:  DATA E4,30
0566:  DATA 72,10
0567:  DATA F4,34
0568:  DATA E5,36
0569:  DATA F0,37
056A:  DATA 00,01
056B:  DATA 0D,10
056C:  DATA 3E,10
056D:  DATA 41,38
056E:  DATA E1,33
056F:  DATA 61,39
0570:  DATA 20,28
0571:  DATA 65,39
0572:  DATA E9,37
0573:  DATA E4,37
0574:  DATA 73,00
0575:  DATA 0D,10
0576:  DATA 3E,10
0577:  DATA D0,32
0578:  DATA F2,34
0579:  DATA 6F,32
057A:  DATA 6F,10
057B:  DATA 31,00
057C:  DATA 0D,10
057D:  DATA 3E,10
057E:  DATA D0,32
057F:  DATA F2,34
0580:  DATA 6F,32
0581:  DATA 6F,10
0582:  DATA 32,00
0583:  DATA 0D,10
0584:  DATA 3E,10
0585:  DATA D0,32
0586:  DATA F2,34
0587:  DATA 6F,32
0588:  DATA 6F,10
0589:  DATA 33,00
058A:  DATA 0D,10
058B:  DATA 3E,10
058C:  DATA D0,32
058D:  DATA F2,34
058E:  DATA 6F,32
058F:  DATA 6F,10
0590:  DATA 34,00
0591:  DATA 0D,10
0592:  DATA 3E,10
0593:  DATA D2,32
0594:  DATA F3,32
0595:  DATA F4,32
0596:  DATA 61,10
0597:  DATA 61,10
0598:  DATA 30,00
0599:  DATA 0D,10
059A:  DATA 3E,10
059B:  DATA 49,37
059C:  DATA 63,39
059D:  DATA E5,36
059E:  DATA 65,37
059F:  DATA F4,30
05A0:  DATA 72,10
05A1:  DATA F0,37
05A2:  DATA 72,10
05A3:  DATA 31,00
05A4:  DATA 0D,10
05A5:  DATA 3E,10
05A6:  DATA 49,37
05A7:  DATA 63,39
05A8:  DATA E5,36
05A9:  DATA 65,37
05AA:  DATA F4,30
05AB:  DATA 72,10
05AC:  DATA F0,37
05AD:  DATA 72,10
05AE:  DATA 32,00
05AF:  DATA 0D,10
05B0:  DATA 3E,10
05B1:  DATA 49,37
05B2:  DATA 63,39
05B3:  DATA E5,36
05B4:  DATA 65,37
05B5:  DATA F4,30
05B6:  DATA 72,10
05B7:  DATA F0,37
05B8:  DATA 72,10
05B9:  DATA 33,00
05BA:  DATA 0D,10
05BB:  DATA 3E,10
05BC:  DATA C4,32
05BD:  DATA 63,39
05BE:  DATA E5,36
05BF:  DATA 65,37
05C0:  DATA F4,30
05C1:  DATA 72,10
05C2:  DATA F0,37
05C3:  DATA 72,10
05C4:  DATA 31,00
05C5:  DATA 0D,10
05C6:  DATA 3E,10
05C7:  DATA C1,39
05C8:  DATA E9,33
05C9:  DATA EE,30
05CA:  DATA 72,10
05CB:  DATA E6,30
05CC:  DATA 6C,3A
05CD:  DATA E1,39
05CE:  DATA 00,01
05CF:  DATA 0D,10
05D0:  DATA 3E,10
05D1:  DATA 49,37
05D2:  DATA E9,31
05D3:  DATA E9,30
05D4:  DATA EC,34
05D5:  DATA FA,30
05D6:  DATA 72,00
05D7:  DATA 0D,10
05D8:  DATA 3E,10
05D9:  DATA C1,39
05DA:  DATA E9,33
05DB:  DATA EE,30
05DC:  DATA 72,10
05DD:  DATA F0,37
05DE:  DATA F3,34
05DF:  DATA E3,34
05E0:  DATA 6F,37
05E1:  DATA 00,01
05E2:  DATA 0D,10
05E3:  DATA 3E,10
05E4:  DATA D2,32
05E5:  DATA F3,32
05E6:  DATA F4,32
05E7:  DATA 6F,10
05E8:  DATA E7,32
05E9:  DATA EE,32
05EA:  DATA F2,30
05EB:  DATA 6C,17
05EC:  DATA 2E,17
05ED:  DATA A0,10
05EE:  DATA 20,00
05EF:  DATA 0D,10
05F0:  DATA 3E,10
05F1:  DATA C3,37
05F2:  DATA 6E,33
05F3:  DATA E9,33
05F4:  DATA 75,39
05F5:  DATA E1,31
05F6:  DATA E9,37
05F7:  DATA 6E,10
05F8:  DATA E4,32
05F9:  DATA 20,3A
05FA:  DATA 69,39
05FB:  DATA 6F,00
05FC:  DATA 0D,10
05FD:  DATA 3E,10
05FE:  DATA C3,37
05FF:  DATA 6E,33
0600:  DATA E9,33
0601:  DATA 75,39
0602:  DATA E1,31
0603:  DATA E9,37
0604:  DATA 6E,10
0605:  DATA E4,32
0606:  DATA 20,3A
0607:  DATA E9,32
0608:  DATA 6D,38
0609:  DATA 6F,00
060A:  MOVF   0B,W
060B:  MOVWF  7B
060C:  BCF    0B.7
060D:  BSF    03.5
060E:  BSF    03.6
060F:  BSF    0C.7
0610:  BSF    0C.0
0611:  NOP
0612:  NOP
0613:  BTFSS  7B.7
0614:  GOTO   61A
0615:  BCF    03.5
0616:  BCF    03.6
0617:  BSF    0B.7
0618:  BSF    03.5
0619:  BSF    03.6
061A:  BCF    03.5
061B:  MOVF   0C,W
061C:  ANDLW  7F
061D:  BTFSC  03.2
061E:  GOTO   65A
061F:  MOVWF  7B
0620:  MOVF   0D,W
0621:  MOVWF  7C
0622:  MOVF   0F,W
0623:  MOVWF  7D
0624:  MOVF   7B,W
0625:  BCF    03.6
0626:  BTFSS  0C.4
0627:  GOTO   626
0628:  MOVWF  19
0629:  MOVF   7C,W
062A:  BSF    03.6
062B:  MOVWF  0D
062C:  MOVF   7D,W
062D:  MOVWF  0F
062E:  BCF    03.6
062F:  MOVF   0B,W
0630:  MOVWF  7E
0631:  BCF    0B.7
0632:  BSF    03.5
0633:  BSF    03.6
0634:  BSF    0C.7
0635:  BSF    0C.0
0636:  NOP
0637:  NOP
0638:  BTFSS  7E.7
0639:  GOTO   63F
063A:  BCF    03.5
063B:  BCF    03.6
063C:  BSF    0B.7
063D:  BSF    03.5
063E:  BSF    03.6
063F:  BCF    03.5
0640:  RLF    0C,W
0641:  RLF    0E,W
0642:  ANDLW  7F
0643:  BTFSC  03.2
0644:  GOTO   65A
0645:  MOVWF  7B
0646:  MOVF   0D,W
0647:  MOVWF  7C
0648:  MOVF   0F,W
0649:  MOVWF  7D
064A:  MOVF   7B,W
064B:  BCF    03.6
064C:  BTFSS  0C.4
064D:  GOTO   64C
064E:  MOVWF  19
064F:  MOVF   7C,W
0650:  BSF    03.6
0651:  MOVWF  0D
0652:  MOVF   7D,W
0653:  MOVWF  0F
0654:  INCF   0D,F
0655:  BTFSC  03.2
0656:  INCF   0F,F
0657:  BCF    03.6
0658:  GOTO   60A
0659:  BSF    03.6
065A:  BCF    03.6
065B:  RETURN
065C:  MOVF   0B,W
065D:  MOVWF  7B
065E:  BCF    0B.7
065F:  BSF    03.5
0660:  BSF    03.6
0661:  BSF    0C.7
0662:  BSF    0C.0
0663:  NOP
0664:  NOP
0665:  BTFSS  7B.7
0666:  GOTO   66C
0667:  BCF    03.5
0668:  BCF    03.6
0669:  BSF    0B.7
066A:  BSF    03.5
066B:  BSF    03.6
066C:  BTFSC  03.0
066D:  GOTO   694
066E:  BCF    03.5
066F:  MOVF   0C,W
0670:  ANDLW  7F
0671:  MOVWF  7B
0672:  MOVF   0D,W
0673:  MOVWF  7C
0674:  MOVF   0F,W
0675:  MOVWF  7D
0676:  MOVF   7B,W
0677:  BCF    03.6
0678:  BTFSS  0C.4
0679:  GOTO   678
067A:  MOVWF  19
067B:  MOVF   7C,W
067C:  BSF    03.6
067D:  MOVWF  0D
067E:  MOVF   7D,W
067F:  MOVWF  0F
0680:  BCF    03.6
0681:  MOVF   0B,W
0682:  MOVWF  7E
0683:  BCF    0B.7
0684:  BSF    03.5
0685:  BSF    03.6
0686:  BSF    0C.7
0687:  BSF    0C.0
0688:  NOP
0689:  NOP
068A:  BTFSS  7E.7
068B:  GOTO   691
068C:  BCF    03.5
068D:  BCF    03.6
068E:  BSF    0B.7
068F:  BSF    03.5
0690:  BSF    03.6
0691:  DECFSZ 75,F
0692:  GOTO   694
0693:  GOTO   6B1
0694:  BCF    03.5
0695:  RLF    0C,W
0696:  RLF    0E,W
0697:  ANDLW  7F
0698:  MOVWF  7B
0699:  MOVF   0D,W
069A:  MOVWF  7C
069B:  MOVF   0F,W
069C:  MOVWF  7D
069D:  MOVF   7B,W
069E:  BCF    03.6
069F:  BTFSS  0C.4
06A0:  GOTO   69F
06A1:  MOVWF  19
06A2:  MOVF   7C,W
06A3:  BSF    03.6
06A4:  MOVWF  0D
06A5:  MOVF   7D,W
06A6:  MOVWF  0F
06A7:  INCF   0D,F
06A8:  BTFSC  03.2
06A9:  INCF   0F,F
06AA:  BCF    03.0
06AB:  DECFSZ 75,F
06AC:  GOTO   6AE
06AD:  GOTO   6B0
06AE:  BCF    03.6
06AF:  GOTO   65C
06B0:  BSF    03.5
06B1:  BCF    03.5
06B2:  BCF    03.6
06B3:  RETURN
*
0FC1:  BSF    0A.0
0FC2:  BSF    0A.1
0FC3:  BSF    0A.2
0FC4:  ADDWF  02,F
0FC5:  GOTO   061
0FC6:  GOTO   082
0FC7:  GOTO   0A3
0FC8:  GOTO   0C4
0FC9:  BSF    0A.0
0FCA:  BSF    0A.1
0FCB:  BSF    0A.2
0FCC:  ADDWF  02,F
0FCD:  GOTO   3A7
0FCE:  GOTO   3C5
0FCF:  GOTO   3E3
0FD0:  GOTO   401
0FD1:  GOTO   41F
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... // ::[CONFIGURACION DE PIC]:: 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
02D2:  MOVLW  BF
02D3:  MOVWF  04
02D4:  BCF    03.7
02D5:  MOVF   00,W
02D6:  BTFSC  03.2
02D7:  GOTO   2E5
02D8:  MOVLW  02
02D9:  MOVWF  78
02DA:  CLRF   77
02DB:  DECFSZ 77,F
02DC:  GOTO   2DB
02DD:  DECFSZ 78,F
02DE:  GOTO   2DA
02DF:  MOVLW  97
02E0:  MOVWF  77
02E1:  DECFSZ 77,F
02E2:  GOTO   2E1
02E3:  DECFSZ 00,F
02E4:  GOTO   2D8
02E5:  RETURN
....................  
.................... // ::[CONFIGURACION DE IO]:: 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0 ) 
....................  
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
....................  
.................... // ::[CONFIGURACION PUERTOS]:: 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232, ERRORS) 
*
042A:  BTFSS  0C.5
042B:  GOTO   42A
042C:  MOVF   18,W
042D:  MOVWF  2C
042E:  MOVF   1A,W
042F:  MOVWF  78
0430:  BTFSS  2C.1
0431:  GOTO   434
0432:  BCF    18.4
0433:  BSF    18.4
.................... //#use i2c    (Master,Fast,sda=I2C_SDA,scl=I2C_SCL) 
.................... #use i2c    (master, scl=I2C_SCL, sda=I2C_SDA, fast) 
*
0289:  BCF    14.7
028A:  BCF    0C.3
028B:  BSF    03.5
028C:  MOVF   45,W
028D:  BCF    03.5
028E:  MOVWF  13
028F:  MOVLW  02
0290:  BTFSC  14.7
0291:  GOTO   299
0292:  BTFSS  0C.3
0293:  GOTO   292
0294:  MOVLW  00
0295:  BSF    03.5
0296:  BTFSC  11.6
0297:  MOVLW  01
0298:  BCF    03.5
0299:  MOVWF  78
029A:  RETURN
....................  
.................... // ::[DEFINICIONES]:: 
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       10 
.................... #define I2CWAIT         50 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... // ::[DECLARACIONES]:: 
.................... //Estructura para el puerto 
....................  
.................... typedef struct sPort { 
....................     int a; 
....................     int b; 
....................     int c; 
....................     int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char cmd[20] = "\0"; 
*
06F7:  BCF    03.6
06F8:  CLRF   2D
06F9:  CLRF   2E
.................... char rcmd[20] = "\0"; 
06FA:  CLRF   41
06FB:  CLRF   42
.................... int8 cmdIndex = 0; 
.................... int1 cmdGet = false; 
....................  
.................... //Puertos de Displays 
.................... tPort pNJugadorU; 
.................... tPort pNJugadorD; 
.................... tPort pFJugadorU; 
.................... tPort pFJugadorD; 
....................  
.................... //Tiempo 
.................... int8 m_d = 0; 
.................... int8 m_u = 0; 
.................... int8 s_d = 0; 
.................... int8 s_u = 0; 
....................  
.................... //Tiro 
.................... int8 sh_d = 0; 
.................... int8 sh_u = 0; 
....................  
.................... int8 scoreLU = 0; 
.................... int8 scoreLD = 0; 
.................... int1 scoreLC = 0; 
.................... int8 scoreVU = 0; 
.................... int8 scoreVD = 0; 
.................... int1 scoreVC = 0; 
....................  
.................... // ::[PROTOTIPOS]:: 
....................  
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8 char2int(char); 
.................... void doReset(void); 
.................... void sendN2Port(int8, int8, int8); 
.................... void timeSet(int8, int8, int8, int8); 
.................... void shotSet(int8, int8); 
.................... void doBuzz(int); 
.................... void setScoreL(int8, int8, int8); 
.................... void setScoreV(int8, int8, int8); 
.................... void i2c_send(int8, int8); 
.................... void addScoreL(int8); 
.................... void addScoreV(int8); 
.................... void resScoreL(void); 
.................... void resScoreV(void); 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
06FC:  CLRF   71
06FD:  CLRF   72
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // *FUNCION:      setup() 
.................... // *PARAMETROS:   ninguno 
.................... // *REGRESA:      VOID 
.................... // *RESUMEN:      Configuracion inicial del dispositivo 
....................  
.................... void setup() { 
....................     output_a(0x00); 
*
1000:  MOVLW  0F
1001:  BSF    03.5
1002:  MOVWF  05
1003:  BCF    03.5
1004:  CLRF   05
....................     output_b(0x00); 
1005:  BSF    03.5
1006:  CLRF   06
1007:  BCF    03.5
1008:  CLRF   06
....................     output_c(0x00); 
1009:  MOVLW  DF
100A:  BSF    03.5
100B:  MOVWF  07
100C:  BCF    03.5
100D:  CLRF   07
....................     output_d(0x00); 
100E:  BSF    03.5
100F:  CLRF   08
1010:  BCF    03.5
1011:  CLRF   08
....................     output_e(0x00); 
1012:  BSF    03.5
1013:  BCF    09.0
1014:  BCF    09.1
1015:  BCF    09.2
1016:  BCF    09.3
1017:  BCF    03.5
1018:  CLRF   09
1019:  CLRF   2B
101A:  BTFSC  0B.7
101B:  BSF    2B.7
101C:  BCF    0B.7
....................  
....................     delay_ms(DEFAULT_D); 
101D:  MOVLW  0A
101E:  BSF    03.5
101F:  MOVWF  3F
1020:  BCF    0A.4
1021:  BCF    03.5
1022:  CALL   2D2
1023:  BSF    0A.4
1024:  BTFSC  2B.7
1025:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
1026:  BTFSS  07.2
1027:  GOTO   099
....................         fprintf(RS232, "********************************\r"); 
1028:  MOVLW  57
1029:  BSF    03.6
102A:  MOVWF  0D
102B:  MOVLW  00
102C:  MOVWF  0F
102D:  BCF    0A.4
102E:  BCF    03.6
102F:  CALL   60A
1030:  BSF    0A.4
....................         fprintf(RS232, " Grupo APM (c) 2020 \r"); 
1031:  MOVLW  68
1032:  BSF    03.6
1033:  MOVWF  0D
1034:  MOVLW  00
1035:  MOVWF  0F
1036:  BCF    0A.4
1037:  BCF    03.6
1038:  CALL   60A
1039:  BSF    0A.4
....................         fprintf(RS232, "================================\r"); 
103A:  MOVLW  73
103B:  BSF    03.6
103C:  MOVWF  0D
103D:  MOVLW  00
103E:  MOVWF  0F
103F:  BCF    0A.4
1040:  BCF    03.6
1041:  CALL   60A
1042:  BSF    0A.4
....................         fprintf(RS232, "Bluetooth Basketball Score Board\r"); 
1043:  MOVLW  84
1044:  BSF    03.6
1045:  MOVWF  0D
1046:  MOVLW  00
1047:  MOVWF  0F
1048:  BCF    0A.4
1049:  BCF    03.6
104A:  CALL   60A
104B:  BSF    0A.4
....................         fprintf(RS232, "================================\r"); 
104C:  MOVLW  95
104D:  BSF    03.6
104E:  MOVWF  0D
104F:  MOVLW  00
1050:  MOVWF  0F
1051:  BCF    0A.4
1052:  BCF    03.6
1053:  CALL   60A
1054:  BSF    0A.4
....................         fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
1055:  MOVLW  A6
1056:  BSF    03.6
1057:  MOVWF  0D
1058:  MOVLW  00
1059:  MOVWF  0F
105A:  BCF    03.0
105B:  MOVLW  08
105C:  MOVWF  75
105D:  BCF    0A.4
105E:  BCF    03.6
105F:  CALL   65C
1060:  BSF    0A.4
1061:  MOVLW  B1
1062:  BSF    03.6
1063:  MOVWF  0D
1064:  MOVLW  00
1065:  MOVWF  0F
1066:  BCF    0A.4
1067:  BCF    03.6
1068:  CALL   60A
1069:  BSF    0A.4
106A:  MOVLW  AB
106B:  BSF    03.6
106C:  MOVWF  0D
106D:  MOVLW  00
106E:  MOVWF  0F
106F:  BCF    03.0
1070:  MOVLW  07
1071:  MOVWF  75
1072:  BCF    0A.4
1073:  BCF    03.6
1074:  CALL   65C
1075:  BSF    0A.4
1076:  MOVLW  B3
1077:  BSF    03.6
1078:  MOVWF  0D
1079:  MOVLW  00
107A:  MOVWF  0F
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   60A
107E:  BSF    0A.4
107F:  MOVLW  20
1080:  BTFSS  0C.4
1081:  GOTO   080
1082:  MOVWF  19
1083:  MOVLW  0D
1084:  BTFSS  0C.4
1085:  GOTO   084
1086:  MOVWF  19
....................         fprintf(RS232, "********************************\r"); 
1087:  MOVLW  B4
1088:  BSF    03.6
1089:  MOVWF  0D
108A:  MOVLW  00
108B:  MOVWF  0F
108C:  BCF    0A.4
108D:  BCF    03.6
108E:  CALL   60A
108F:  BSF    0A.4
....................         fprintf(RS232, " DEPURACION :: COMUNICACIONES \r"); 
1090:  MOVLW  C5
1091:  BSF    03.6
1092:  MOVWF  0D
1093:  MOVLW  00
1094:  MOVWF  0F
1095:  BCF    0A.4
1096:  BCF    03.6
1097:  CALL   60A
1098:  BSF    0A.4
1099:  CLRF   2B
109A:  BTFSC  0B.7
109B:  BSF    2B.7
109C:  BCF    0B.7
....................     } 
....................  
....................     delay_ms(DEFAULT_D); 
109D:  MOVLW  0A
109E:  BSF    03.5
109F:  MOVWF  3F
10A0:  BCF    0A.4
10A1:  BCF    03.5
10A2:  CALL   2D2
10A3:  BSF    0A.4
10A4:  BTFSC  2B.7
10A5:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
10A6:  BTFSS  07.2
10A7:  GOTO   0BF
....................         fputs(" > Configuracion de Puertos", RS232); 
10A8:  MOVLW  D5
10A9:  BSF    03.6
10AA:  MOVWF  0D
10AB:  MOVLW  00
10AC:  MOVWF  0F
10AD:  BCF    03.6
10AE:  CLRF   2B
10AF:  BTFSC  0B.7
10B0:  BSF    2B.7
10B1:  BCF    0B.7
10B2:  BCF    0A.4
10B3:  CALL   10F
10B4:  BSF    0A.4
10B5:  BTFSC  2B.7
10B6:  BSF    0B.7
10B7:  MOVLW  0D
10B8:  BTFSS  0C.4
10B9:  GOTO   0B8
10BA:  MOVWF  19
10BB:  MOVLW  0A
10BC:  BTFSS  0C.4
10BD:  GOTO   0BC
10BE:  MOVWF  19
....................     } 
....................  
....................     pNJugadorU.a = PIN_B0; 
10BF:  MOVLW  30
10C0:  MOVWF  57
....................     pNJugadorU.b = PIN_B1; 
10C1:  MOVLW  31
10C2:  MOVWF  58
....................     pNJugadorU.c = PIN_B2; 
10C3:  MOVLW  32
10C4:  MOVWF  59
....................     pNJugadorU.d = PIN_B3; 
10C5:  MOVLW  33
10C6:  MOVWF  5A
....................  
....................     pNJugadorD.a = PIN_B4; 
10C7:  MOVLW  34
10C8:  MOVWF  5B
....................     pNJugadorD.b = PIN_B5; 
10C9:  MOVLW  35
10CA:  MOVWF  5C
....................     pNJugadorD.c = PIN_B6; 
10CB:  MOVLW  36
10CC:  MOVWF  5D
....................     pNJugadorD.d = PIN_B7; 
10CD:  MOVLW  37
10CE:  MOVWF  5E
....................  
....................     pFJugadorU.a = PIN_D0; 
10CF:  MOVLW  40
10D0:  MOVWF  5F
....................     pFJugadorU.b = PIN_D1; 
10D1:  MOVLW  41
10D2:  MOVWF  60
....................     pFJugadorU.c = PIN_D2; 
10D3:  MOVLW  42
10D4:  MOVWF  61
....................     pFJugadorU.d = PIN_D3; 
10D5:  MOVLW  43
10D6:  MOVWF  62
....................  
....................     pFJugadorD.a = PIN_D4; 
10D7:  MOVLW  44
10D8:  MOVWF  63
....................     pFJugadorD.b = PIN_D5; 
10D9:  MOVLW  45
10DA:  MOVWF  64
....................     pFJugadorD.c = PIN_D6; 
10DB:  MOVLW  46
10DC:  MOVWF  65
....................     pFJugadorD.d = PIN_D7; 
10DD:  MOVLW  47
10DE:  MOVWF  66
10DF:  CLRF   2B
10E0:  BTFSC  0B.7
10E1:  BSF    2B.7
10E2:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
10E3:  MOVLW  0A
10E4:  BSF    03.5
10E5:  MOVWF  3F
10E6:  BCF    0A.4
10E7:  BCF    03.5
10E8:  CALL   2D2
10E9:  BSF    0A.4
10EA:  BTFSC  2B.7
10EB:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
10EC:  BTFSS  07.2
10ED:  GOTO   105
....................         fputs(" > Inicializacion de I2C", RS232); 
10EE:  MOVLW  E3
10EF:  BSF    03.6
10F0:  MOVWF  0D
10F1:  MOVLW  00
10F2:  MOVWF  0F
10F3:  BCF    03.6
10F4:  CLRF   2B
10F5:  BTFSC  0B.7
10F6:  BSF    2B.7
10F7:  BCF    0B.7
10F8:  BCF    0A.4
10F9:  CALL   10F
10FA:  BSF    0A.4
10FB:  BTFSC  2B.7
10FC:  BSF    0B.7
10FD:  MOVLW  0D
10FE:  BTFSS  0C.4
10FF:  GOTO   0FE
1100:  MOVWF  19
1101:  MOVLW  0A
1102:  BTFSS  0C.4
1103:  GOTO   102
1104:  MOVWF  19
....................     } 
....................     i2c_speed (100000) ; 
1105:  MOVLW  13
1106:  BSF    03.5
1107:  MOVWF  13
1108:  MOVLW  28
1109:  BCF    03.5
110A:  MOVWF  14
110B:  BSF    03.5
110C:  BSF    14.7
....................  
....................     IF(DEBUG) { 
110D:  BCF    03.5
110E:  BTFSS  07.2
110F:  GOTO   127
....................         fputs(" > Habilitacion de displays", RS232); 
1110:  MOVLW  F0
1111:  BSF    03.6
1112:  MOVWF  0D
1113:  MOVLW  00
1114:  MOVWF  0F
1115:  BCF    03.6
1116:  CLRF   2B
1117:  BTFSC  0B.7
1118:  BSF    2B.7
1119:  BCF    0B.7
111A:  BCF    0A.4
111B:  CALL   10F
111C:  BSF    0A.4
111D:  BTFSC  2B.7
111E:  BSF    0B.7
111F:  MOVLW  0D
1120:  BTFSS  0C.4
1121:  GOTO   120
1122:  MOVWF  19
1123:  MOVLW  0A
1124:  BTFSS  0C.4
1125:  GOTO   124
1126:  MOVWF  19
....................     } 
....................     output_bit(DISPLAY, ON); 
1127:  BSF    09.0
1128:  MOVLW  EE
1129:  BSF    03.5
112A:  MOVWF  09
112B:  BCF    03.5
112C:  CLRF   2B
112D:  BTFSC  0B.7
112E:  BSF    2B.7
112F:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
1130:  MOVLW  0A
1131:  BSF    03.5
1132:  MOVWF  3F
1133:  BCF    0A.4
1134:  BCF    03.5
1135:  CALL   2D2
1136:  BSF    0A.4
1137:  BTFSC  2B.7
1138:  BSF    0B.7
....................     output_bit(DISPLAY, OFF); 
1139:  BCF    09.0
113A:  MOVLW  EE
113B:  BSF    03.5
113C:  MOVWF  09
113D:  BCF    03.5
113E:  CLRF   2B
113F:  BTFSC  0B.7
1140:  BSF    2B.7
1141:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
1142:  MOVLW  0A
1143:  BSF    03.5
1144:  MOVWF  3F
1145:  BCF    0A.4
1146:  BCF    03.5
1147:  CALL   2D2
1148:  BSF    0A.4
1149:  BTFSC  2B.7
114A:  BSF    0B.7
....................     output_bit(DISPLAY, ON); 
114B:  BSF    09.0
114C:  MOVLW  EE
114D:  BSF    03.5
114E:  MOVWF  09
114F:  BCF    03.5
1150:  CLRF   2B
1151:  BTFSC  0B.7
1152:  BSF    2B.7
1153:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
1154:  MOVLW  0A
1155:  BSF    03.5
1156:  MOVWF  3F
1157:  BCF    0A.4
1158:  BCF    03.5
1159:  CALL   2D2
115A:  BSF    0A.4
115B:  BTFSC  2B.7
115C:  BSF    0B.7
....................  
....................     if (DEBUG) { 
115D:  BTFSS  07.2
115E:  GOTO   176
....................         fputs(" > Habilitacion de interrupciones", RS232); 
115F:  MOVLW  FE
1160:  BSF    03.6
1161:  MOVWF  0D
1162:  MOVLW  00
1163:  MOVWF  0F
1164:  BCF    03.6
1165:  CLRF   2B
1166:  BTFSC  0B.7
1167:  BSF    2B.7
1168:  BCF    0B.7
1169:  BCF    0A.4
116A:  CALL   10F
116B:  BSF    0A.4
116C:  BTFSC  2B.7
116D:  BSF    0B.7
116E:  MOVLW  0D
116F:  BTFSS  0C.4
1170:  GOTO   16F
1171:  MOVWF  19
1172:  MOVLW  0A
1173:  BTFSS  0C.4
1174:  GOTO   173
1175:  MOVWF  19
....................     } 
....................     enable_interrupts(INT_RDA); 
1176:  BSF    03.5
1177:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
1178:  MOVLW  C0
1179:  BCF    03.5
117A:  IORWF  0B,F
117B:  BCF    0A.3
117C:  BCF    0A.4
117D:  GOTO   700 (RETURN)
.................... } 
....................  
.................... void main() { 
*
06B4:  MOVF   03,W
06B5:  ANDLW  1F
06B6:  MOVWF  03
06B7:  MOVLW  71
06B8:  BSF    03.5
06B9:  MOVWF  0F
06BA:  CLRF   10
06BB:  MOVF   0F,W
06BC:  BCF    03.5
06BD:  CLRF   2C
06BE:  BSF    03.5
06BF:  BSF    03.6
06C0:  BCF    07.3
06C1:  MOVLW  0C
06C2:  BCF    03.6
06C3:  MOVWF  19
06C4:  MOVLW  A2
06C5:  MOVWF  18
06C6:  MOVLW  90
06C7:  BCF    03.5
06C8:  MOVWF  18
06C9:  MOVLW  DF
06CA:  BSF    03.5
06CB:  MOVWF  07
06CC:  MOVLW  DF
06CD:  MOVWF  07
06CE:  MOVLW  04
06CF:  MOVWF  13
06D0:  MOVLW  28
06D1:  BCF    03.5
06D2:  MOVWF  14
06D3:  BSF    03.5
06D4:  BCF    14.7
06D5:  BCF    14.6
06D6:  BCF    03.5
06D7:  CLRF   55
06D8:  BCF    56.0
06D9:  CLRF   67
06DA:  CLRF   68
06DB:  CLRF   69
06DC:  CLRF   6A
06DD:  CLRF   6B
06DE:  CLRF   6C
06DF:  CLRF   6D
06E0:  CLRF   6E
06E1:  BCF    56.1
06E2:  CLRF   6F
06E3:  CLRF   70
06E4:  BCF    56.2
06E5:  CLRF   74
06E6:  CLRF   73
06E7:  BSF    03.5
06E8:  BSF    03.6
06E9:  MOVF   09,W
06EA:  ANDLW  C0
06EB:  MOVWF  09
06EC:  BCF    03.6
06ED:  BCF    1F.4
06EE:  BCF    1F.5
06EF:  MOVLW  00
06F0:  BSF    03.6
06F1:  MOVWF  08
06F2:  BCF    03.5
06F3:  CLRF   07
06F4:  CLRF   08
06F5:  CLRF   09
06F6:  BCF    03.7
....................     setup(); 
*
06FE:  BSF    0A.4
06FF:  GOTO   000
0700:  BCF    0A.4
....................  
....................     WHILE(TRUE) { 
0701:  GOTO   701
....................     } 
.................... } 
....................  
.................... #INT_RDA 
.................... void RDA_isr(VOID) { 
0702:  SLEEP
....................     CHAR c; 
....................     c = fgetc(RS232); 
*
0434:  MOVF   78,W
0435:  BSF    03.5
0436:  MOVWF  22
....................  
....................     IF(cmdGet) { 
0437:  BCF    03.5
0438:  BTFSS  56.0
0439:  GOTO   474
....................  
....................         IF(c == '#' || c == '\r') { 
043A:  BSF    03.5
043B:  MOVF   22,W
043C:  SUBLW  23
043D:  BTFSC  03.2
043E:  GOTO   443
043F:  MOVF   22,W
0440:  SUBLW  0D
0441:  BTFSS  03.2
0442:  GOTO   466
....................             cmdGet = false; 
0443:  BCF    03.5
0444:  BCF    56.0
....................             strcpy(cmd, rcmd); 
0445:  BSF    03.5
0446:  CLRF   26
0447:  MOVLW  41
0448:  MOVWF  25
0449:  CLRF   24
044A:  MOVLW  2D
044B:  MOVWF  23
044C:  MOVF   25,W
044D:  MOVWF  04
044E:  BCF    03.7
044F:  BTFSC  26.0
0450:  BSF    03.7
0451:  MOVF   00,W
0452:  MOVWF  27
0453:  MOVF   23,W
0454:  MOVWF  04
0455:  BCF    03.7
0456:  BTFSC  24.0
0457:  BSF    03.7
0458:  MOVF   27,W
0459:  MOVWF  00
045A:  MOVF   00,F
045B:  BTFSC  03.2
045C:  GOTO   460
045D:  INCF   23,F
045E:  INCF   25,F
045F:  GOTO   44C
....................             parseCommand(); 
0460:  BSF    0A.3
0461:  BCF    03.5
0462:  GOTO   000
0463:  BCF    0A.3
....................         } 
0464:  GOTO   474
0465:  BSF    03.5
....................  
....................         ELSE{ 
....................             IF(cmdIndex < 20) { 
0466:  BCF    03.5
0467:  MOVF   55,W
0468:  SUBLW  13
0469:  BTFSS  03.0
046A:  GOTO   474
....................                 rcmd[cmdIndex] = c; 
046B:  MOVLW  41
046C:  ADDWF  55,W
046D:  MOVWF  04
046E:  BCF    03.7
046F:  BSF    03.5
0470:  MOVF   22,W
0471:  MOVWF  00
....................                 cmdIndex++; 
0472:  BCF    03.5
0473:  INCF   55,F
....................             } 
....................         } 
....................     } 
....................  
....................     IF(c == '-') { 
0474:  BSF    03.5
0475:  MOVF   22,W
0476:  SUBLW  2D
0477:  BTFSS  03.2
0478:  GOTO   491
....................         cmdGet = true; 
0479:  BCF    03.5
047A:  BSF    56.0
....................         rcmd = "\0"; 
047B:  BSF    03.5
047C:  CLRF   23
047D:  CLRF   24
047E:  MOVLW  41
047F:  MOVWF  04
0480:  BCF    03.7
0481:  MOVF   23,W
0482:  ADDWF  04,F
0483:  MOVF   24,W
0484:  BCF    03.5
0485:  CALL   051
0486:  MOVWF  00
0487:  IORLW  00
0488:  BTFSC  03.2
0489:  GOTO   48F
048A:  BSF    03.5
048B:  INCF   24,F
048C:  INCF   23,F
048D:  GOTO   47E
048E:  BCF    03.5
....................         cmdIndex = 0; 
048F:  CLRF   55
0490:  BSF    03.5
....................     } 
0491:  BCF    03.5
0492:  BCF    0C.5
0493:  BCF    0A.3
0494:  BCF    0A.4
0495:  GOTO   02D
.................... } 
....................  
.................... void doTest(VOID) { 
....................  
....................     IF(DEBUG) { 
*
0DCE:  BTFSS  07.2
0DCF:  GOTO   5E1
....................         fputs(" > Rutina de prueba", RS232); 
0DD0:  MOVLW  96
0DD1:  BSF    03.6
0DD2:  MOVWF  0D
0DD3:  MOVLW  04
0DD4:  MOVWF  0F
0DD5:  BCF    0A.3
0DD6:  BCF    03.6
0DD7:  CALL   10F
0DD8:  BSF    0A.3
0DD9:  MOVLW  0D
0DDA:  BTFSS  0C.4
0DDB:  GOTO   5DA
0DDC:  MOVWF  19
0DDD:  MOVLW  0A
0DDE:  BTFSS  0C.4
0DDF:  GOTO   5DE
0DE0:  MOVWF  19
....................     } 
....................  
....................     IF(DEBUG) { 
0DE1:  BTFSS  07.2
0DE2:  GOTO   5F4
....................         fputs(" > Probando modulo tiempo", RS232); 
0DE3:  MOVLW  A0
0DE4:  BSF    03.6
0DE5:  MOVWF  0D
0DE6:  MOVLW  04
0DE7:  MOVWF  0F
0DE8:  BCF    0A.3
0DE9:  BCF    03.6
0DEA:  CALL   10F
0DEB:  BSF    0A.3
0DEC:  MOVLW  0D
0DED:  BTFSS  0C.4
0DEE:  GOTO   5ED
0DEF:  MOVWF  19
0DF0:  MOVLW  0A
0DF1:  BTFSS  0C.4
0DF2:  GOTO   5F1
0DF3:  MOVWF  19
....................     } 
....................     i2c_send(I2C_TIMER, I2C_CMD_TEST); 
0DF4:  MOVLW  0A
0DF5:  BSF    03.5
0DF6:  MOVWF  43
0DF7:  MOVLW  FF
0DF8:  MOVWF  44
0DF9:  BCF    0A.3
0DFA:  BCF    03.5
0DFB:  CALL   2B0
0DFC:  BSF    0A.3
....................  
....................     IF(DEBUG) { 
0DFD:  BTFSS  07.2
0DFE:  GOTO   610
....................         fputs(" > Probando modulo puntos", RS232); 
0DFF:  MOVLW  AD
0E00:  BSF    03.6
0E01:  MOVWF  0D
0E02:  MOVLW  04
0E03:  MOVWF  0F
0E04:  BCF    0A.3
0E05:  BCF    03.6
0E06:  CALL   10F
0E07:  BSF    0A.3
0E08:  MOVLW  0D
0E09:  BTFSS  0C.4
0E0A:  GOTO   609
0E0B:  MOVWF  19
0E0C:  MOVLW  0A
0E0D:  BTFSS  0C.4
0E0E:  GOTO   60D
0E0F:  MOVWF  19
....................     } 
....................     i2c_send(I2C_SCORE, I2C_CMD_TEST); 
0E10:  MOVLW  0C
0E11:  BSF    03.5
0E12:  MOVWF  43
0E13:  MOVLW  FF
0E14:  MOVWF  44
0E15:  BCF    0A.3
0E16:  BCF    03.5
0E17:  CALL   2B0
0E18:  BSF    0A.3
....................  
....................     IF(DEBUG) { 
0E19:  BTFSS  07.2
0E1A:  GOTO   62C
....................         fputs(" > Probando modulo comunicaciones", RS232); 
0E1B:  MOVLW  BA
0E1C:  BSF    03.6
0E1D:  MOVWF  0D
0E1E:  MOVLW  04
0E1F:  MOVWF  0F
0E20:  BCF    0A.3
0E21:  BCF    03.6
0E22:  CALL   10F
0E23:  BSF    0A.3
0E24:  MOVLW  0D
0E25:  BTFSS  0C.4
0E26:  GOTO   625
0E27:  MOVWF  19
0E28:  MOVLW  0A
0E29:  BTFSS  0C.4
0E2A:  GOTO   629
0E2B:  MOVWF  19
....................     } 
....................     for (INT i = 0; i < 10; i++) { 
0E2C:  BSF    03.5
0E2D:  CLRF   37
0E2E:  MOVF   37,W
0E2F:  SUBLW  09
0E30:  BTFSS  03.0
0E31:  GOTO   697
....................         showNumber(i, pNJugadorD); 
0E32:  MOVF   37,W
0E33:  MOVWF  38
0E34:  BCF    03.5
0E35:  MOVF   5E,W
0E36:  BSF    03.5
0E37:  MOVWF  3C
0E38:  BCF    03.5
0E39:  MOVF   5D,W
0E3A:  BSF    03.5
0E3B:  MOVWF  3B
0E3C:  BCF    03.5
0E3D:  MOVF   5C,W
0E3E:  BSF    03.5
0E3F:  MOVWF  3A
0E40:  BCF    03.5
0E41:  MOVF   5B,W
0E42:  BSF    03.5
0E43:  MOVWF  39
0E44:  BCF    0A.3
0E45:  BCF    03.5
0E46:  CALL   1F5
0E47:  BSF    0A.3
....................         showNumber(i, pNJugadorU); 
0E48:  BSF    03.5
0E49:  MOVF   37,W
0E4A:  MOVWF  38
0E4B:  BCF    03.5
0E4C:  MOVF   5A,W
0E4D:  BSF    03.5
0E4E:  MOVWF  3C
0E4F:  BCF    03.5
0E50:  MOVF   59,W
0E51:  BSF    03.5
0E52:  MOVWF  3B
0E53:  BCF    03.5
0E54:  MOVF   58,W
0E55:  BSF    03.5
0E56:  MOVWF  3A
0E57:  BCF    03.5
0E58:  MOVF   57,W
0E59:  BSF    03.5
0E5A:  MOVWF  39
0E5B:  BCF    0A.3
0E5C:  BCF    03.5
0E5D:  CALL   1F5
0E5E:  BSF    0A.3
....................         showNumber(i, pFJugadorD); 
0E5F:  BSF    03.5
0E60:  MOVF   37,W
0E61:  MOVWF  38
0E62:  BCF    03.5
0E63:  MOVF   66,W
0E64:  BSF    03.5
0E65:  MOVWF  3C
0E66:  BCF    03.5
0E67:  MOVF   65,W
0E68:  BSF    03.5
0E69:  MOVWF  3B
0E6A:  BCF    03.5
0E6B:  MOVF   64,W
0E6C:  BSF    03.5
0E6D:  MOVWF  3A
0E6E:  BCF    03.5
0E6F:  MOVF   63,W
0E70:  BSF    03.5
0E71:  MOVWF  39
0E72:  BCF    0A.3
0E73:  BCF    03.5
0E74:  CALL   1F5
0E75:  BSF    0A.3
....................         showNumber(i, pFJugadorU); 
0E76:  BSF    03.5
0E77:  MOVF   37,W
0E78:  MOVWF  38
0E79:  BCF    03.5
0E7A:  MOVF   62,W
0E7B:  BSF    03.5
0E7C:  MOVWF  3C
0E7D:  BCF    03.5
0E7E:  MOVF   61,W
0E7F:  BSF    03.5
0E80:  MOVWF  3B
0E81:  BCF    03.5
0E82:  MOVF   60,W
0E83:  BSF    03.5
0E84:  MOVWF  3A
0E85:  BCF    03.5
0E86:  MOVF   5F,W
0E87:  BSF    03.5
0E88:  MOVWF  39
0E89:  BCF    0A.3
0E8A:  BCF    03.5
0E8B:  CALL   1F5
0E8C:  BSF    0A.3
....................         delay_ms(I2CWAIT); 
0E8D:  MOVLW  32
0E8E:  BSF    03.5
0E8F:  MOVWF  3F
0E90:  BCF    0A.3
0E91:  BCF    03.5
0E92:  CALL   2D2
0E93:  BSF    0A.3
0E94:  BSF    03.5
0E95:  INCF   37,F
0E96:  GOTO   62E
....................     } 
.................... } 
....................  
.................... void doBuzz(INT t) { 
....................     i2c_start(); 
*
029B:  BSF    03.5
029C:  BSF    11.0
029D:  BTFSC  11.0
029E:  GOTO   29D
....................     i2c_write(I2C_TIMER); 
029F:  MOVLW  0A
02A0:  MOVWF  45
02A1:  BCF    03.5
02A2:  CALL   289
....................     i2c_write(0x80 + t); 
02A3:  MOVLW  80
02A4:  BSF    03.5
02A5:  ADDWF  37,W
02A6:  MOVWF  38
02A7:  MOVWF  45
02A8:  BCF    03.5
02A9:  CALL   289
....................     i2c_stop(); 
02AA:  BSF    03.5
02AB:  BSF    11.2
02AC:  BTFSC  11.2
02AD:  GOTO   2AC
02AE:  BCF    03.5
02AF:  RETURN
.................... } 
....................  
.................... void parseCommand(VOID) { 
....................     CHAR c[20]; 
....................     strcpy(c, cmd); 
*
0800:  BSF    03.5
0801:  CLRF   3A
0802:  MOVLW  2D
0803:  MOVWF  39
0804:  CLRF   38
0805:  MOVLW  A3
0806:  MOVWF  37
0807:  MOVF   39,W
0808:  MOVWF  04
0809:  BCF    03.7
080A:  BTFSC  3A.0
080B:  BSF    03.7
080C:  MOVF   00,W
080D:  MOVWF  3B
080E:  MOVF   37,W
080F:  MOVWF  04
0810:  BCF    03.7
0811:  BTFSC  38.0
0812:  BSF    03.7
0813:  MOVF   3B,W
0814:  MOVWF  00
0815:  MOVF   00,F
0816:  BTFSC  03.2
0817:  GOTO   01B
0818:  INCF   37,F
0819:  INCF   39,F
081A:  GOTO   007
....................  
....................     SWITCH(c[0]) { 
081B:  MOVF   23,W
081C:  XORLW  30
081D:  BCF    03.5
081E:  BTFSC  03.2
081F:  GOTO   045
0820:  XORLW  72
0821:  BTFSC  03.2
0822:  GOTO   0E8
0823:  XORLW  04
0824:  BTFSC  03.2
0825:  GOTO   147
0826:  XORLW  0C
0827:  BTFSC  03.2
0828:  GOTO   199
0829:  XORLW  06
082A:  BTFSC  03.2
082B:  GOTO   1EB
082C:  XORLW  1C
082D:  BTFSC  03.2
082E:  GOTO   376
082F:  XORLW  01
0830:  BTFSC  03.2
0831:  GOTO   38A
0832:  XORLW  03
0833:  BTFSC  03.2
0834:  GOTO   39E
0835:  XORLW  04
0836:  BTFSC  03.2
0837:  GOTO   445
0838:  XORLW  0E
0839:  BTFSC  03.2
083A:  GOTO   5CE
083B:  XORLW  02
083C:  BTFSC  03.2
083D:  GOTO   699
083E:  XORLW  09
083F:  BTFSC  03.2
0840:  GOTO   6D3
0841:  XORLW  07
0842:  BTFSC  03.2
0843:  GOTO   722
0844:  GOTO   7BE
....................         case '0': IF(DEBUG) 
0845:  BTFSS  07.2
0846:  GOTO   058
....................         { 
....................             fputs("\r > Activacion manual de puerto", RS232); 
0847:  MOVLW  CB
0848:  BSF    03.6
0849:  MOVWF  0D
084A:  MOVLW  04
084B:  MOVWF  0F
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   10F
084F:  BSF    0A.3
0850:  MOVLW  0D
0851:  BTFSS  0C.4
0852:  GOTO   051
0853:  MOVWF  19
0854:  MOVLW  0A
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
....................         } 
....................  
....................         SWITCH(c[2]) { 
0858:  MOVLW  31
0859:  BSF    03.5
085A:  SUBWF  25,W
085B:  ADDLW  FC
085C:  BTFSC  03.0
085D:  GOTO   0E6
085E:  ADDLW  04
085F:  BCF    03.5
0860:  GOTO   7C1
....................             CASE '1' : showNumber(char2int(c[3]), pNJugadorD); 
0861:  BSF    03.5
0862:  MOVF   26,W
0863:  MOVWF  3A
0864:  BCF    0A.3
0865:  BCF    03.5
0866:  CALL   185
0867:  BSF    0A.3
0868:  MOVF   78,W
0869:  BSF    03.5
086A:  MOVWF  37
086B:  MOVWF  38
086C:  BCF    03.5
086D:  MOVF   5E,W
086E:  BSF    03.5
086F:  MOVWF  3C
0870:  BCF    03.5
0871:  MOVF   5D,W
0872:  BSF    03.5
0873:  MOVWF  3B
0874:  BCF    03.5
0875:  MOVF   5C,W
0876:  BSF    03.5
0877:  MOVWF  3A
0878:  BCF    03.5
0879:  MOVF   5B,W
087A:  BSF    03.5
087B:  MOVWF  39
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   1F5
087F:  BSF    0A.3
....................             BREAK; 
0880:  BSF    03.5
0881:  GOTO   0E6
....................             CASE '2' : showNumber(char2int(c[3]), pNJugadorU); 
0882:  BSF    03.5
0883:  MOVF   26,W
0884:  MOVWF  3A
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   185
0888:  BSF    0A.3
0889:  MOVF   78,W
088A:  BSF    03.5
088B:  MOVWF  37
088C:  MOVWF  38
088D:  BCF    03.5
088E:  MOVF   5A,W
088F:  BSF    03.5
0890:  MOVWF  3C
0891:  BCF    03.5
0892:  MOVF   59,W
0893:  BSF    03.5
0894:  MOVWF  3B
0895:  BCF    03.5
0896:  MOVF   58,W
0897:  BSF    03.5
0898:  MOVWF  3A
0899:  BCF    03.5
089A:  MOVF   57,W
089B:  BSF    03.5
089C:  MOVWF  39
089D:  BCF    0A.3
089E:  BCF    03.5
089F:  CALL   1F5
08A0:  BSF    0A.3
....................             BREAK; 
08A1:  BSF    03.5
08A2:  GOTO   0E6
....................             CASE '3' : showNumber(char2int(c[3]), pFJugadorD); 
08A3:  BSF    03.5
08A4:  MOVF   26,W
08A5:  MOVWF  3A
08A6:  BCF    0A.3
08A7:  BCF    03.5
08A8:  CALL   185
08A9:  BSF    0A.3
08AA:  MOVF   78,W
08AB:  BSF    03.5
08AC:  MOVWF  37
08AD:  MOVWF  38
08AE:  BCF    03.5
08AF:  MOVF   66,W
08B0:  BSF    03.5
08B1:  MOVWF  3C
08B2:  BCF    03.5
08B3:  MOVF   65,W
08B4:  BSF    03.5
08B5:  MOVWF  3B
08B6:  BCF    03.5
08B7:  MOVF   64,W
08B8:  BSF    03.5
08B9:  MOVWF  3A
08BA:  BCF    03.5
08BB:  MOVF   63,W
08BC:  BSF    03.5
08BD:  MOVWF  39
08BE:  BCF    0A.3
08BF:  BCF    03.5
08C0:  CALL   1F5
08C1:  BSF    0A.3
....................             BREAK; 
08C2:  BSF    03.5
08C3:  GOTO   0E6
....................             CASE '4' : showNumber(char2int(c[3]), pFJugadorU); 
08C4:  BSF    03.5
08C5:  MOVF   26,W
08C6:  MOVWF  3A
08C7:  BCF    0A.3
08C8:  BCF    03.5
08C9:  CALL   185
08CA:  BSF    0A.3
08CB:  MOVF   78,W
08CC:  BSF    03.5
08CD:  MOVWF  37
08CE:  MOVWF  38
08CF:  BCF    03.5
08D0:  MOVF   62,W
08D1:  BSF    03.5
08D2:  MOVWF  3C
08D3:  BCF    03.5
08D4:  MOVF   61,W
08D5:  BSF    03.5
08D6:  MOVWF  3B
08D7:  BCF    03.5
08D8:  MOVF   60,W
08D9:  BSF    03.5
08DA:  MOVWF  3A
08DB:  BCF    03.5
08DC:  MOVF   5F,W
08DD:  BSF    03.5
08DE:  MOVWF  39
08DF:  BCF    0A.3
08E0:  BCF    03.5
08E1:  CALL   1F5
08E2:  BSF    0A.3
....................             BREAK; 
08E3:  BSF    03.5
08E4:  GOTO   0E6
08E5:  BSF    03.5
....................         } 
....................  
....................         BREAK; 
08E6:  BCF    03.5
08E7:  GOTO   7BE
....................  
....................         case 'B': SWITCH(c[1]) 
08E8:  BSF    03.5
08E9:  MOVF   24,W
08EA:  XORLW  31
08EB:  BCF    03.5
08EC:  BTFSC  03.2
08ED:  GOTO   0F5
08EE:  XORLW  03
08EF:  BTFSC  03.2
08F0:  GOTO   110
08F1:  XORLW  01
08F2:  BTFSC  03.2
08F3:  GOTO   12B
08F4:  GOTO   146
....................         { 
....................             case '1': IF(DEBUG) 
08F5:  BTFSS  07.2
08F6:  GOTO   108
....................             { 
....................                 fputs("\r > Toque corto", RS232); 
08F7:  MOVLW  DB
08F8:  BSF    03.6
08F9:  MOVWF  0D
08FA:  MOVLW  04
08FB:  MOVWF  0F
08FC:  BCF    0A.3
08FD:  BCF    03.6
08FE:  CALL   10F
08FF:  BSF    0A.3
0900:  MOVLW  0D
0901:  BTFSS  0C.4
0902:  GOTO   101
0903:  MOVWF  19
0904:  MOVLW  0A
0905:  BTFSS  0C.4
0906:  GOTO   105
0907:  MOVWF  19
....................             } 
....................             doBuzz(1); 
0908:  MOVLW  01
0909:  BSF    03.5
090A:  MOVWF  37
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   29B
090E:  BSF    0A.3
....................             BREAK; 
090F:  GOTO   146
....................             case '2': IF(DEBUG) 
0910:  BTFSS  07.2
0911:  GOTO   123
....................             { 
....................                 fputs("\r > Toque largo", RS232); 
0912:  MOVLW  E3
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  04
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   10F
091A:  BSF    0A.3
091B:  MOVLW  0D
091C:  BTFSS  0C.4
091D:  GOTO   11C
091E:  MOVWF  19
091F:  MOVLW  0A
0920:  BTFSS  0C.4
0921:  GOTO   120
0922:  MOVWF  19
....................             } 
....................             doBuzz(2); 
0923:  MOVLW  02
0924:  BSF    03.5
0925:  MOVWF  37
0926:  BCF    0A.3
0927:  BCF    03.5
0928:  CALL   29B
0929:  BSF    0A.3
....................             BREAK; 
092A:  GOTO   146
....................             case '3': IF(DEBUG) 
092B:  BTFSS  07.2
092C:  GOTO   13E
....................             { 
....................                 fputs("\r > Toque doble", RS232); 
092D:  MOVLW  EB
092E:  BSF    03.6
092F:  MOVWF  0D
0930:  MOVLW  04
0931:  MOVWF  0F
0932:  BCF    0A.3
0933:  BCF    03.6
0934:  CALL   10F
0935:  BSF    0A.3
0936:  MOVLW  0D
0937:  BTFSS  0C.4
0938:  GOTO   137
0939:  MOVWF  19
093A:  MOVLW  0A
093B:  BTFSS  0C.4
093C:  GOTO   13B
093D:  MOVWF  19
....................             } 
....................             doBuzz(3); 
093E:  MOVLW  03
093F:  BSF    03.5
0940:  MOVWF  37
0941:  BCF    0A.3
0942:  BCF    03.5
0943:  CALL   29B
0944:  BSF    0A.3
....................             BREAK; 
0945:  GOTO   146
....................         } 
....................  
....................         BREAK; 
0946:  GOTO   7BE
....................         case 'F': IF(DEBUG) 
0947:  BTFSS  07.2
0948:  GOTO   15A
....................         { 
....................             fputs("\r > Asignar faltas", RS232); 
0949:  MOVLW  F3
094A:  BSF    03.6
094B:  MOVWF  0D
094C:  MOVLW  04
094D:  MOVWF  0F
094E:  BCF    0A.3
094F:  BCF    03.6
0950:  CALL   10F
0951:  BSF    0A.3
0952:  MOVLW  0D
0953:  BTFSS  0C.4
0954:  GOTO   153
0955:  MOVWF  19
0956:  MOVLW  0A
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
....................         } 
....................         showNumber(char2int(c[1]), pFJugadorD); 
095A:  BSF    03.5
095B:  MOVF   24,W
095C:  MOVWF  3A
095D:  BCF    0A.3
095E:  BCF    03.5
095F:  CALL   185
0960:  BSF    0A.3
0961:  MOVF   78,W
0962:  BSF    03.5
0963:  MOVWF  37
0964:  MOVWF  38
0965:  BCF    03.5
0966:  MOVF   66,W
0967:  BSF    03.5
0968:  MOVWF  3C
0969:  BCF    03.5
096A:  MOVF   65,W
096B:  BSF    03.5
096C:  MOVWF  3B
096D:  BCF    03.5
096E:  MOVF   64,W
096F:  BSF    03.5
0970:  MOVWF  3A
0971:  BCF    03.5
0972:  MOVF   63,W
0973:  BSF    03.5
0974:  MOVWF  39
0975:  BCF    0A.3
0976:  BCF    03.5
0977:  CALL   1F5
0978:  BSF    0A.3
....................         showNumber(char2int(c[2]), pFJugadorU); 
0979:  BSF    03.5
097A:  MOVF   25,W
097B:  MOVWF  3A
097C:  BCF    0A.3
097D:  BCF    03.5
097E:  CALL   185
097F:  BSF    0A.3
0980:  MOVF   78,W
0981:  BSF    03.5
0982:  MOVWF  37
0983:  MOVWF  38
0984:  BCF    03.5
0985:  MOVF   62,W
0986:  BSF    03.5
0987:  MOVWF  3C
0988:  BCF    03.5
0989:  MOVF   61,W
098A:  BSF    03.5
098B:  MOVWF  3B
098C:  BCF    03.5
098D:  MOVF   60,W
098E:  BSF    03.5
098F:  MOVWF  3A
0990:  BCF    03.5
0991:  MOVF   5F,W
0992:  BSF    03.5
0993:  MOVWF  39
0994:  BCF    0A.3
0995:  BCF    03.5
0996:  CALL   1F5
0997:  BSF    0A.3
....................         BREAK; 
0998:  GOTO   7BE
....................         case 'J': IF(DEBUG) 
0999:  BTFSS  07.2
099A:  GOTO   1AC
....................         { 
....................             fputs("\r > Asignar jugador", RS232); 
099B:  MOVLW  FD
099C:  BSF    03.6
099D:  MOVWF  0D
099E:  MOVLW  04
099F:  MOVWF  0F
09A0:  BCF    0A.3
09A1:  BCF    03.6
09A2:  CALL   10F
09A3:  BSF    0A.3
09A4:  MOVLW  0D
09A5:  BTFSS  0C.4
09A6:  GOTO   1A5
09A7:  MOVWF  19
09A8:  MOVLW  0A
09A9:  BTFSS  0C.4
09AA:  GOTO   1A9
09AB:  MOVWF  19
....................         } 
....................         showNumber(char2int(c[1]), pNJugadorD); 
09AC:  BSF    03.5
09AD:  MOVF   24,W
09AE:  MOVWF  3A
09AF:  BCF    0A.3
09B0:  BCF    03.5
09B1:  CALL   185
09B2:  BSF    0A.3
09B3:  MOVF   78,W
09B4:  BSF    03.5
09B5:  MOVWF  37
09B6:  MOVWF  38
09B7:  BCF    03.5
09B8:  MOVF   5E,W
09B9:  BSF    03.5
09BA:  MOVWF  3C
09BB:  BCF    03.5
09BC:  MOVF   5D,W
09BD:  BSF    03.5
09BE:  MOVWF  3B
09BF:  BCF    03.5
09C0:  MOVF   5C,W
09C1:  BSF    03.5
09C2:  MOVWF  3A
09C3:  BCF    03.5
09C4:  MOVF   5B,W
09C5:  BSF    03.5
09C6:  MOVWF  39
09C7:  BCF    0A.3
09C8:  BCF    03.5
09C9:  CALL   1F5
09CA:  BSF    0A.3
....................         showNumber(char2int(c[2]), pNJugadorU); 
09CB:  BSF    03.5
09CC:  MOVF   25,W
09CD:  MOVWF  3A
09CE:  BCF    0A.3
09CF:  BCF    03.5
09D0:  CALL   185
09D1:  BSF    0A.3
09D2:  MOVF   78,W
09D3:  BSF    03.5
09D4:  MOVWF  37
09D5:  MOVWF  38
09D6:  BCF    03.5
09D7:  MOVF   5A,W
09D8:  BSF    03.5
09D9:  MOVWF  3C
09DA:  BCF    03.5
09DB:  MOVF   59,W
09DC:  BSF    03.5
09DD:  MOVWF  3B
09DE:  BCF    03.5
09DF:  MOVF   58,W
09E0:  BSF    03.5
09E1:  MOVWF  3A
09E2:  BCF    03.5
09E3:  MOVF   57,W
09E4:  BSF    03.5
09E5:  MOVWF  39
09E6:  BCF    0A.3
09E7:  BCF    03.5
09E8:  CALL   1F5
09E9:  BSF    0A.3
....................         BREAK; 
09EA:  GOTO   7BE
....................         case 'L': 
....................         SWITCH(c[1]) 
09EB:  BSF    03.5
09EC:  MOVF   24,W
09ED:  XORLW  30
09EE:  BCF    03.5
09EF:  BTFSC  03.2
09F0:  GOTO   207
09F1:  XORLW  01
09F2:  BTFSC  03.2
09F3:  GOTO   223
09F4:  XORLW  03
09F5:  BTFSC  03.2
09F6:  GOTO   23E
09F7:  XORLW  01
09F8:  BTFSC  03.2
09F9:  GOTO   259
09FA:  XORLW  77
09FB:  BTFSC  03.2
09FC:  GOTO   274
09FD:  XORLW  02
09FE:  BTFSC  03.2
09FF:  GOTO   2F7
0A00:  XORLW  0F
0A01:  BTFSC  03.2
0A02:  GOTO   31E
0A03:  XORLW  19
0A04:  BTFSC  03.2
0A05:  GOTO   358
0A06:  GOTO   375
....................         { 
....................             case '0': IF(DEBUG) 
0A07:  BTFSS  07.2
0A08:  GOTO   21A
....................             { 
....................                 fputs("\r > Resetea a 0", RS232); 
0A09:  MOVLW  07
0A0A:  BSF    03.6
0A0B:  MOVWF  0D
0A0C:  MOVLW  05
0A0D:  MOVWF  0F
0A0E:  BCF    0A.3
0A0F:  BCF    03.6
0A10:  CALL   10F
0A11:  BSF    0A.3
0A12:  MOVLW  0D
0A13:  BTFSS  0C.4
0A14:  GOTO   213
0A15:  MOVWF  19
0A16:  MOVLW  0A
0A17:  BTFSS  0C.4
0A18:  GOTO   217
0A19:  MOVWF  19
....................             } 
....................             setScoreL(0, 0, 0); 
0A1A:  BSF    03.5
0A1B:  CLRF   3A
0A1C:  CLRF   3B
0A1D:  CLRF   3C
0A1E:  BCF    0A.3
0A1F:  BCF    03.5
0A20:  CALL   2E6
0A21:  BSF    0A.3
....................             BREAK; 
0A22:  GOTO   375
....................             case '1': IF(DEBUG) 
0A23:  BTFSS  07.2
0A24:  GOTO   236
....................             { 
....................                 fputs("\r > Incrementar por 1", RS232); 
0A25:  MOVLW  0F
0A26:  BSF    03.6
0A27:  MOVWF  0D
0A28:  MOVLW  05
0A29:  MOVWF  0F
0A2A:  BCF    0A.3
0A2B:  BCF    03.6
0A2C:  CALL   10F
0A2D:  BSF    0A.3
0A2E:  MOVLW  0D
0A2F:  BTFSS  0C.4
0A30:  GOTO   22F
0A31:  MOVWF  19
0A32:  MOVLW  0A
0A33:  BTFSS  0C.4
0A34:  GOTO   233
0A35:  MOVWF  19
....................             } 
....................             addScoreL(1); 
0A36:  MOVLW  01
0A37:  BSF    03.5
0A38:  MOVWF  37
0A39:  BCF    0A.3
0A3A:  BCF    03.5
0A3B:  CALL   326
0A3C:  BSF    0A.3
....................             BREAK; 
0A3D:  GOTO   375
....................             case '2': IF(DEBUG) 
0A3E:  BTFSS  07.2
0A3F:  GOTO   251
....................             { 
....................                 fputs("\r > Incrementar por 2", RS232); 
0A40:  MOVLW  1A
0A41:  BSF    03.6
0A42:  MOVWF  0D
0A43:  MOVLW  05
0A44:  MOVWF  0F
0A45:  BCF    0A.3
0A46:  BCF    03.6
0A47:  CALL   10F
0A48:  BSF    0A.3
0A49:  MOVLW  0D
0A4A:  BTFSS  0C.4
0A4B:  GOTO   24A
0A4C:  MOVWF  19
0A4D:  MOVLW  0A
0A4E:  BTFSS  0C.4
0A4F:  GOTO   24E
0A50:  MOVWF  19
....................             } 
....................             addScoreL(2); 
0A51:  MOVLW  02
0A52:  BSF    03.5
0A53:  MOVWF  37
0A54:  BCF    0A.3
0A55:  BCF    03.5
0A56:  CALL   326
0A57:  BSF    0A.3
....................             BREAK; 
0A58:  GOTO   375
....................             case '3': IF(DEBUG) 
0A59:  BTFSS  07.2
0A5A:  GOTO   26C
....................             { 
....................                 fputs("\r > Incrementar por 3", RS232); 
0A5B:  MOVLW  25
0A5C:  BSF    03.6
0A5D:  MOVWF  0D
0A5E:  MOVLW  05
0A5F:  MOVWF  0F
0A60:  BCF    0A.3
0A61:  BCF    03.6
0A62:  CALL   10F
0A63:  BSF    0A.3
0A64:  MOVLW  0D
0A65:  BTFSS  0C.4
0A66:  GOTO   265
0A67:  MOVWF  19
0A68:  MOVLW  0A
0A69:  BTFSS  0C.4
0A6A:  GOTO   269
0A6B:  MOVWF  19
....................             } 
....................             addScoreL(3); 
0A6C:  MOVLW  03
0A6D:  BSF    03.5
0A6E:  MOVWF  37
0A6F:  BCF    0A.3
0A70:  BCF    03.5
0A71:  CALL   326
0A72:  BSF    0A.3
....................             BREAK; 
0A73:  GOTO   375
....................             case 'D': IF(DEBUG) 
0A74:  BTFSS  07.2
0A75:  GOTO   287
....................             { 
....................                 fputs("\r > Decrementar por 1", RS232); 
0A76:  MOVLW  30
0A77:  BSF    03.6
0A78:  MOVWF  0D
0A79:  MOVLW  05
0A7A:  MOVWF  0F
0A7B:  BCF    0A.3
0A7C:  BCF    03.6
0A7D:  CALL   10F
0A7E:  BSF    0A.3
0A7F:  MOVLW  0D
0A80:  BTFSS  0C.4
0A81:  GOTO   280
0A82:  MOVWF  19
0A83:  MOVLW  0A
0A84:  BTFSS  0C.4
0A85:  GOTO   284
0A86:  MOVWF  19
....................             } 
....................             resScoreL(); 
....................             BREAK; 
*
0AF6:  GOTO   375
....................             case 'F': IF(DEBUG) 
0AF7:  BTFSS  07.2
0AF8:  GOTO   30A
....................             { 
....................                 fputs("\r > Asignar faltas", RS232); 
0AF9:  MOVLW  3B
0AFA:  BSF    03.6
0AFB:  MOVWF  0D
0AFC:  MOVLW  05
0AFD:  MOVWF  0F
0AFE:  BCF    0A.3
0AFF:  BCF    03.6
0B00:  CALL   10F
0B01:  BSF    0A.3
0B02:  MOVLW  0D
0B03:  BTFSS  0C.4
0B04:  GOTO   303
0B05:  MOVWF  19
0B06:  MOVLW  0A
0B07:  BTFSS  0C.4
0B08:  GOTO   307
0B09:  MOVWF  19
....................             } 
....................             sendN2Port(char2int(c[2]), I2C_SCORE, PuertoE); 
0B0A:  BSF    03.5
0B0B:  MOVF   25,W
0B0C:  MOVWF  3A
0B0D:  BCF    0A.3
0B0E:  BCF    03.5
0B0F:  CALL   185
0B10:  BSF    0A.3
0B11:  MOVF   78,W
0B12:  BSF    03.5
0B13:  MOVWF  37
0B14:  MOVWF  3F
0B15:  MOVLW  0C
0B16:  MOVWF  40
0B17:  MOVLW  05
0B18:  MOVWF  41
0B19:  BCF    0A.3
0B1A:  BCF    03.5
0B1B:  CALL   2C3
0B1C:  BSF    0A.3
....................             BREAK; 
0B1D:  GOTO   375
....................             case 'I': IF(DEBUG) 
0B1E:  BTFSS  07.2
0B1F:  GOTO   331
....................             { 
....................                 fputs("\r > Inicializar", RS232); 
0B20:  MOVLW  45
0B21:  BSF    03.6
0B22:  MOVWF  0D
0B23:  MOVLW  05
0B24:  MOVWF  0F
0B25:  BCF    0A.3
0B26:  BCF    03.6
0B27:  CALL   10F
0B28:  BSF    0A.3
0B29:  MOVLW  0D
0B2A:  BTFSS  0C.4
0B2B:  GOTO   32A
0B2C:  MOVWF  19
0B2D:  MOVLW  0A
0B2E:  BTFSS  0C.4
0B2F:  GOTO   32E
0B30:  MOVWF  19
....................             } 
....................             setScoreL(char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0B31:  BSF    03.5
0B32:  MOVF   25,W
0B33:  MOVWF  3A
0B34:  BCF    0A.3
0B35:  BCF    03.5
0B36:  CALL   185
0B37:  BSF    0A.3
0B38:  MOVF   78,W
0B39:  BSF    03.5
0B3A:  MOVWF  37
0B3B:  MOVF   26,W
0B3C:  MOVWF  3A
0B3D:  BCF    0A.3
0B3E:  BCF    03.5
0B3F:  CALL   185
0B40:  BSF    0A.3
0B41:  MOVF   78,W
0B42:  BSF    03.5
0B43:  MOVWF  38
0B44:  MOVF   27,W
0B45:  MOVWF  3A
0B46:  BCF    0A.3
0B47:  BCF    03.5
0B48:  CALL   185
0B49:  BSF    0A.3
0B4A:  MOVF   78,W
0B4B:  BSF    03.5
0B4C:  MOVWF  39
0B4D:  MOVF   37,W
0B4E:  MOVWF  3A
0B4F:  MOVF   38,W
0B50:  MOVWF  3B
0B51:  MOVF   39,W
0B52:  MOVWF  3C
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   2E6
0B56:  BSF    0A.3
....................             BREAK; 
0B57:  GOTO   375
....................             case 'P': IF(DEBUG) 
0B58:  BTFSS  07.2
0B59:  GOTO   36B
....................             { 
....................                 fputs("\r > Asignar posicion", RS232); 
0B5A:  MOVLW  4D
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  05
0B5E:  MOVWF  0F
0B5F:  BCF    0A.3
0B60:  BCF    03.6
0B61:  CALL   10F
0B62:  BSF    0A.3
0B63:  MOVLW  0D
0B64:  BTFSS  0C.4
0B65:  GOTO   364
0B66:  MOVWF  19
0B67:  MOVLW  0A
0B68:  BTFSS  0C.4
0B69:  GOTO   368
0B6A:  MOVWF  19
....................             } 
....................             i2c_send(I2C_SCORE, I2C_CMD_POSL); 
0B6B:  MOVLW  0C
0B6C:  BSF    03.5
0B6D:  MOVWF  43
0B6E:  MOVLW  71
0B6F:  MOVWF  44
0B70:  BCF    0A.3
0B71:  BCF    03.5
0B72:  CALL   2B0
0B73:  BSF    0A.3
....................             BREAK; 
0B74:  GOTO   375
....................         } 
....................         BREAK; 
0B75:  GOTO   7BE
....................         case 'P': IF(DEBUG) 
0B76:  BTFSS  07.2
0B77:  GOTO   389
....................         { 
....................             fputs("\r > Pausar tiempo", RS232); 
0B78:  MOVLW  58
0B79:  BSF    03.6
0B7A:  MOVWF  0D
0B7B:  MOVLW  05
0B7C:  MOVWF  0F
0B7D:  BCF    0A.3
0B7E:  BCF    03.6
0B7F:  CALL   10F
0B80:  BSF    0A.3
0B81:  MOVLW  0D
0B82:  BTFSS  0C.4
0B83:  GOTO   382
0B84:  MOVWF  19
0B85:  MOVLW  0A
0B86:  BTFSS  0C.4
0B87:  GOTO   386
0B88:  MOVWF  19
....................         } 
....................         BREAK; 
0B89:  GOTO   7BE
....................         case 'Q': IF(DEBUG) 
0B8A:  BTFSS  07.2
0B8B:  GOTO   39D
....................         { 
....................             fputs("\r > Renudar tiempo", RS232); 
0B8C:  MOVLW  61
0B8D:  BSF    03.6
0B8E:  MOVWF  0D
0B8F:  MOVLW  05
0B90:  MOVWF  0F
0B91:  BCF    0A.3
0B92:  BCF    03.6
0B93:  CALL   10F
0B94:  BSF    0A.3
0B95:  MOVLW  0D
0B96:  BTFSS  0C.4
0B97:  GOTO   396
0B98:  MOVWF  19
0B99:  MOVLW  0A
0B9A:  BTFSS  0C.4
0B9B:  GOTO   39A
0B9C:  MOVWF  19
....................         } 
....................         BREAK; 
0B9D:  GOTO   7BE
....................  
....................         CASE 'R' : 
....................                 SWITCH(c[1]) { 
0B9E:  MOVLW  30
0B9F:  BSF    03.5
0BA0:  SUBWF  24,W
0BA1:  ADDLW  FB
0BA2:  BTFSC  03.0
0BA3:  GOTO   43E
0BA4:  ADDLW  05
0BA5:  BCF    03.5
0BA6:  GOTO   7C9
....................             case '0': IF(DEBUG) 
0BA7:  BTFSS  07.2
0BA8:  GOTO   3BA
....................             { 
....................                 fputs("\r > Apagar Periodos", RS232); 
0BA9:  MOVLW  6B
0BAA:  BSF    03.6
0BAB:  MOVWF  0D
0BAC:  MOVLW  05
0BAD:  MOVWF  0F
0BAE:  BCF    0A.3
0BAF:  BCF    03.6
0BB0:  CALL   10F
0BB1:  BSF    0A.3
0BB2:  MOVLW  0D
0BB3:  BTFSS  0C.4
0BB4:  GOTO   3B3
0BB5:  MOVWF  19
0BB6:  MOVLW  0A
0BB7:  BTFSS  0C.4
0BB8:  GOTO   3B7
0BB9:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER0); 
0BBA:  MOVLW  0A
0BBB:  BSF    03.5
0BBC:  MOVWF  43
0BBD:  MOVLW  70
0BBE:  MOVWF  44
0BBF:  BCF    0A.3
0BC0:  BCF    03.5
0BC1:  CALL   2B0
0BC2:  BSF    0A.3
....................             BREAK; 
0BC3:  BSF    03.5
0BC4:  GOTO   43E
....................             case '1': IF(DEBUG) 
0BC5:  BTFSS  07.2
0BC6:  GOTO   3D8
....................             { 
....................                 fputs("\r > Periodo 1", RS232); 
0BC7:  MOVLW  75
0BC8:  BSF    03.6
0BC9:  MOVWF  0D
0BCA:  MOVLW  05
0BCB:  MOVWF  0F
0BCC:  BCF    0A.3
0BCD:  BCF    03.6
0BCE:  CALL   10F
0BCF:  BSF    0A.3
0BD0:  MOVLW  0D
0BD1:  BTFSS  0C.4
0BD2:  GOTO   3D1
0BD3:  MOVWF  19
0BD4:  MOVLW  0A
0BD5:  BTFSS  0C.4
0BD6:  GOTO   3D5
0BD7:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER1); 
0BD8:  MOVLW  0A
0BD9:  BSF    03.5
0BDA:  MOVWF  43
0BDB:  MOVLW  71
0BDC:  MOVWF  44
0BDD:  BCF    0A.3
0BDE:  BCF    03.5
0BDF:  CALL   2B0
0BE0:  BSF    0A.3
....................             BREAK; 
0BE1:  BSF    03.5
0BE2:  GOTO   43E
....................             case '2': IF(DEBUG) 
0BE3:  BTFSS  07.2
0BE4:  GOTO   3F6
....................             { 
....................                 fputs("\r > Periodo 2", RS232); 
0BE5:  MOVLW  7C
0BE6:  BSF    03.6
0BE7:  MOVWF  0D
0BE8:  MOVLW  05
0BE9:  MOVWF  0F
0BEA:  BCF    0A.3
0BEB:  BCF    03.6
0BEC:  CALL   10F
0BED:  BSF    0A.3
0BEE:  MOVLW  0D
0BEF:  BTFSS  0C.4
0BF0:  GOTO   3EF
0BF1:  MOVWF  19
0BF2:  MOVLW  0A
0BF3:  BTFSS  0C.4
0BF4:  GOTO   3F3
0BF5:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER2); 
0BF6:  MOVLW  0A
0BF7:  BSF    03.5
0BF8:  MOVWF  43
0BF9:  MOVLW  72
0BFA:  MOVWF  44
0BFB:  BCF    0A.3
0BFC:  BCF    03.5
0BFD:  CALL   2B0
0BFE:  BSF    0A.3
....................             BREAK; 
0BFF:  BSF    03.5
0C00:  GOTO   43E
....................             case '3': IF(DEBUG) 
0C01:  BTFSS  07.2
0C02:  GOTO   414
....................             { 
....................                 fputs("\r > Periodo 3", RS232); 
0C03:  MOVLW  83
0C04:  BSF    03.6
0C05:  MOVWF  0D
0C06:  MOVLW  05
0C07:  MOVWF  0F
0C08:  BCF    0A.3
0C09:  BCF    03.6
0C0A:  CALL   10F
0C0B:  BSF    0A.3
0C0C:  MOVLW  0D
0C0D:  BTFSS  0C.4
0C0E:  GOTO   40D
0C0F:  MOVWF  19
0C10:  MOVLW  0A
0C11:  BTFSS  0C.4
0C12:  GOTO   411
0C13:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER3); 
0C14:  MOVLW  0A
0C15:  BSF    03.5
0C16:  MOVWF  43
0C17:  MOVLW  73
0C18:  MOVWF  44
0C19:  BCF    0A.3
0C1A:  BCF    03.5
0C1B:  CALL   2B0
0C1C:  BSF    0A.3
....................             BREAK; 
0C1D:  BSF    03.5
0C1E:  GOTO   43E
....................             case '4': IF(DEBUG) 
0C1F:  BTFSS  07.2
0C20:  GOTO   432
....................             { 
....................                 fputs("\r > Periodo 4", RS232); 
0C21:  MOVLW  8A
0C22:  BSF    03.6
0C23:  MOVWF  0D
0C24:  MOVLW  05
0C25:  MOVWF  0F
0C26:  BCF    0A.3
0C27:  BCF    03.6
0C28:  CALL   10F
0C29:  BSF    0A.3
0C2A:  MOVLW  0D
0C2B:  BTFSS  0C.4
0C2C:  GOTO   42B
0C2D:  MOVWF  19
0C2E:  MOVLW  0A
0C2F:  BTFSS  0C.4
0C30:  GOTO   42F
0C31:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER4); 
0C32:  MOVLW  0A
0C33:  BSF    03.5
0C34:  MOVWF  43
0C35:  MOVLW  74
0C36:  MOVWF  44
0C37:  BCF    0A.3
0C38:  BCF    03.5
0C39:  CALL   2B0
0C3A:  BSF    0A.3
....................             BREAK; 
0C3B:  BSF    03.5
0C3C:  GOTO   43E
0C3D:  BSF    03.5
....................         } 
....................         delay_ms(I2CWAIT); 
0C3E:  MOVLW  32
0C3F:  MOVWF  3F
0C40:  BCF    0A.3
0C41:  BCF    03.5
0C42:  CALL   2D2
0C43:  BSF    0A.3
....................         BREAK; 
0C44:  GOTO   7BE
....................         case 'V': 
....................         SWITCH(c[1]) 
0C45:  BSF    03.5
0C46:  MOVF   24,W
0C47:  XORLW  30
0C48:  BCF    03.5
0C49:  BTFSC  03.2
0C4A:  GOTO   461
0C4B:  XORLW  01
0C4C:  BTFSC  03.2
0C4D:  GOTO   47D
0C4E:  XORLW  03
0C4F:  BTFSC  03.2
0C50:  GOTO   498
0C51:  XORLW  01
0C52:  BTFSC  03.2
0C53:  GOTO   4B3
0C54:  XORLW  77
0C55:  BTFSC  03.2
0C56:  GOTO   4CE
0C57:  XORLW  02
0C58:  BTFSC  03.2
0C59:  GOTO   54F
0C5A:  XORLW  0F
0C5B:  BTFSC  03.2
0C5C:  GOTO   576
0C5D:  XORLW  19
0C5E:  BTFSC  03.2
0C5F:  GOTO   5B0
0C60:  GOTO   5CD
....................         { 
....................             case '0': IF(DEBUG) 
0C61:  BTFSS  07.2
0C62:  GOTO   474
....................             { 
....................                 fputs("\r > Resetea a 0", RS232); 
0C63:  MOVLW  91
0C64:  BSF    03.6
0C65:  MOVWF  0D
0C66:  MOVLW  05
0C67:  MOVWF  0F
0C68:  BCF    0A.3
0C69:  BCF    03.6
0C6A:  CALL   10F
0C6B:  BSF    0A.3
0C6C:  MOVLW  0D
0C6D:  BTFSS  0C.4
0C6E:  GOTO   46D
0C6F:  MOVWF  19
0C70:  MOVLW  0A
0C71:  BTFSS  0C.4
0C72:  GOTO   471
0C73:  MOVWF  19
....................             } 
....................             setScoreV(0, 0, 0); 
0C74:  BSF    03.5
0C75:  CLRF   3A
0C76:  CLRF   3B
0C77:  CLRF   3C
0C78:  BCF    0A.3
0C79:  BCF    03.5
0C7A:  CALL   38A
0C7B:  BSF    0A.3
....................             BREAK; 
0C7C:  GOTO   5CD
....................             case '1': IF(DEBUG) 
0C7D:  BTFSS  07.2
0C7E:  GOTO   490
....................             { 
....................                 fputs("\r > Incrementar por 1", RS232); 
0C7F:  MOVLW  99
0C80:  BSF    03.6
0C81:  MOVWF  0D
0C82:  MOVLW  05
0C83:  MOVWF  0F
0C84:  BCF    0A.3
0C85:  BCF    03.6
0C86:  CALL   10F
0C87:  BSF    0A.3
0C88:  MOVLW  0D
0C89:  BTFSS  0C.4
0C8A:  GOTO   489
0C8B:  MOVWF  19
0C8C:  MOVLW  0A
0C8D:  BTFSS  0C.4
0C8E:  GOTO   48D
0C8F:  MOVWF  19
....................             } 
....................             addScoreV(1); 
0C90:  MOVLW  01
0C91:  BSF    03.5
0C92:  MOVWF  37
0C93:  BCF    0A.3
0C94:  BCF    03.5
0C95:  CALL   3C8
0C96:  BSF    0A.3
....................             BREAK; 
0C97:  GOTO   5CD
....................             case '2': IF(DEBUG) 
0C98:  BTFSS  07.2
0C99:  GOTO   4AB
....................             { 
....................                 fputs("\r > Incrementar por 2", RS232); 
0C9A:  MOVLW  A4
0C9B:  BSF    03.6
0C9C:  MOVWF  0D
0C9D:  MOVLW  05
0C9E:  MOVWF  0F
0C9F:  BCF    0A.3
0CA0:  BCF    03.6
0CA1:  CALL   10F
0CA2:  BSF    0A.3
0CA3:  MOVLW  0D
0CA4:  BTFSS  0C.4
0CA5:  GOTO   4A4
0CA6:  MOVWF  19
0CA7:  MOVLW  0A
0CA8:  BTFSS  0C.4
0CA9:  GOTO   4A8
0CAA:  MOVWF  19
....................             } 
....................             addScoreV(2); 
0CAB:  MOVLW  02
0CAC:  BSF    03.5
0CAD:  MOVWF  37
0CAE:  BCF    0A.3
0CAF:  BCF    03.5
0CB0:  CALL   3C8
0CB1:  BSF    0A.3
....................             BREAK; 
0CB2:  GOTO   5CD
....................             case '3': IF(DEBUG) 
0CB3:  BTFSS  07.2
0CB4:  GOTO   4C6
....................             { 
....................                 fputs("\r > Incrementar por 3", RS232); 
0CB5:  MOVLW  AF
0CB6:  BSF    03.6
0CB7:  MOVWF  0D
0CB8:  MOVLW  05
0CB9:  MOVWF  0F
0CBA:  BCF    0A.3
0CBB:  BCF    03.6
0CBC:  CALL   10F
0CBD:  BSF    0A.3
0CBE:  MOVLW  0D
0CBF:  BTFSS  0C.4
0CC0:  GOTO   4BF
0CC1:  MOVWF  19
0CC2:  MOVLW  0A
0CC3:  BTFSS  0C.4
0CC4:  GOTO   4C3
0CC5:  MOVWF  19
....................             } 
....................             addScoreV(3); 
0CC6:  MOVLW  03
0CC7:  BSF    03.5
0CC8:  MOVWF  37
0CC9:  BCF    0A.3
0CCA:  BCF    03.5
0CCB:  CALL   3C8
0CCC:  BSF    0A.3
....................             BREAK; 
0CCD:  GOTO   5CD
....................             case 'D': IF(DEBUG) 
0CCE:  BTFSS  07.2
0CCF:  GOTO   4E1
....................             { 
....................                 fputs("\r > Decrementar por 1", RS232); 
0CD0:  MOVLW  BA
0CD1:  BSF    03.6
0CD2:  MOVWF  0D
0CD3:  MOVLW  05
0CD4:  MOVWF  0F
0CD5:  BCF    0A.3
0CD6:  BCF    03.6
0CD7:  CALL   10F
0CD8:  BSF    0A.3
0CD9:  MOVLW  0D
0CDA:  BTFSS  0C.4
0CDB:  GOTO   4DA
0CDC:  MOVWF  19
0CDD:  MOVLW  0A
0CDE:  BTFSS  0C.4
0CDF:  GOTO   4DE
0CE0:  MOVWF  19
....................             } 
....................             resScoreV(); 
....................             BREAK; 
*
0D4E:  GOTO   5CD
....................             case 'F': IF(DEBUG) 
0D4F:  BTFSS  07.2
0D50:  GOTO   562
....................             { 
....................                 fputs("\r > Asignar faltas", RS232); 
0D51:  MOVLW  C5
0D52:  BSF    03.6
0D53:  MOVWF  0D
0D54:  MOVLW  05
0D55:  MOVWF  0F
0D56:  BCF    0A.3
0D57:  BCF    03.6
0D58:  CALL   10F
0D59:  BSF    0A.3
0D5A:  MOVLW  0D
0D5B:  BTFSS  0C.4
0D5C:  GOTO   55B
0D5D:  MOVWF  19
0D5E:  MOVLW  0A
0D5F:  BTFSS  0C.4
0D60:  GOTO   55F
0D61:  MOVWF  19
....................             } 
....................             sendN2Port(char2int(c[2]), I2C_SCORE, PuertoF); 
0D62:  BSF    03.5
0D63:  MOVF   25,W
0D64:  MOVWF  3A
0D65:  BCF    0A.3
0D66:  BCF    03.5
0D67:  CALL   185
0D68:  BSF    0A.3
0D69:  MOVF   78,W
0D6A:  BSF    03.5
0D6B:  MOVWF  37
0D6C:  MOVWF  3F
0D6D:  MOVLW  0C
0D6E:  MOVWF  40
0D6F:  MOVLW  06
0D70:  MOVWF  41
0D71:  BCF    0A.3
0D72:  BCF    03.5
0D73:  CALL   2C3
0D74:  BSF    0A.3
....................             BREAK; 
0D75:  GOTO   5CD
....................             case 'I': IF(DEBUG) 
0D76:  BTFSS  07.2
0D77:  GOTO   589
....................             { 
....................                 fputs("\r > Inicializar", RS232); 
0D78:  MOVLW  CF
0D79:  BSF    03.6
0D7A:  MOVWF  0D
0D7B:  MOVLW  05
0D7C:  MOVWF  0F
0D7D:  BCF    0A.3
0D7E:  BCF    03.6
0D7F:  CALL   10F
0D80:  BSF    0A.3
0D81:  MOVLW  0D
0D82:  BTFSS  0C.4
0D83:  GOTO   582
0D84:  MOVWF  19
0D85:  MOVLW  0A
0D86:  BTFSS  0C.4
0D87:  GOTO   586
0D88:  MOVWF  19
....................             } 
....................             setScoreV(char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0D89:  BSF    03.5
0D8A:  MOVF   25,W
0D8B:  MOVWF  3A
0D8C:  BCF    0A.3
0D8D:  BCF    03.5
0D8E:  CALL   185
0D8F:  BSF    0A.3
0D90:  MOVF   78,W
0D91:  BSF    03.5
0D92:  MOVWF  37
0D93:  MOVF   26,W
0D94:  MOVWF  3A
0D95:  BCF    0A.3
0D96:  BCF    03.5
0D97:  CALL   185
0D98:  BSF    0A.3
0D99:  MOVF   78,W
0D9A:  BSF    03.5
0D9B:  MOVWF  38
0D9C:  MOVF   27,W
0D9D:  MOVWF  3A
0D9E:  BCF    0A.3
0D9F:  BCF    03.5
0DA0:  CALL   185
0DA1:  BSF    0A.3
0DA2:  MOVF   78,W
0DA3:  BSF    03.5
0DA4:  MOVWF  39
0DA5:  MOVF   37,W
0DA6:  MOVWF  3A
0DA7:  MOVF   38,W
0DA8:  MOVWF  3B
0DA9:  MOVF   39,W
0DAA:  MOVWF  3C
0DAB:  BCF    0A.3
0DAC:  BCF    03.5
0DAD:  CALL   38A
0DAE:  BSF    0A.3
....................             BREAK; 
0DAF:  GOTO   5CD
....................             case 'P': IF(DEBUG) 
0DB0:  BTFSS  07.2
0DB1:  GOTO   5C3
....................             { 
....................                 fputs("\r > Asignar posicion", RS232); 
0DB2:  MOVLW  D7
0DB3:  BSF    03.6
0DB4:  MOVWF  0D
0DB5:  MOVLW  05
0DB6:  MOVWF  0F
0DB7:  BCF    0A.3
0DB8:  BCF    03.6
0DB9:  CALL   10F
0DBA:  BSF    0A.3
0DBB:  MOVLW  0D
0DBC:  BTFSS  0C.4
0DBD:  GOTO   5BC
0DBE:  MOVWF  19
0DBF:  MOVLW  0A
0DC0:  BTFSS  0C.4
0DC1:  GOTO   5C0
0DC2:  MOVWF  19
....................             } 
....................             i2c_send(I2C_SCORE, I2C_CMD_POSV); 
0DC3:  MOVLW  0C
0DC4:  BSF    03.5
0DC5:  MOVWF  43
0DC6:  MOVLW  72
0DC7:  MOVWF  44
0DC8:  BCF    0A.3
0DC9:  BCF    03.5
0DCA:  CALL   2B0
0DCB:  BSF    0A.3
....................             BREAK; 
0DCC:  GOTO   5CD
....................         } 
....................         BREAK; 
0DCD:  GOTO   7BE
....................         CASE 'X' : doTest(); //Rutina de prueba 
....................         BREAK; 
*
0E97:  BCF    03.5
0E98:  GOTO   7BE
....................         case 'Z': IF(DEBUG) 
0E99:  BTFSS  07.2
0E9A:  GOTO   6AC
....................         { 
....................             fputs("\r > Reseteo general... ! ", RS232); 
0E9B:  MOVLW  E2
0E9C:  BSF    03.6
0E9D:  MOVWF  0D
0E9E:  MOVLW  05
0E9F:  MOVWF  0F
0EA0:  BCF    0A.3
0EA1:  BCF    03.6
0EA2:  CALL   10F
0EA3:  BSF    0A.3
0EA4:  MOVLW  0D
0EA5:  BTFSS  0C.4
0EA6:  GOTO   6A5
0EA7:  MOVWF  19
0EA8:  MOVLW  0A
0EA9:  BTFSS  0C.4
0EAA:  GOTO   6A9
0EAB:  MOVWF  19
....................         } 
....................         delay_ms(500); 
0EAC:  MOVLW  02
0EAD:  BSF    03.5
0EAE:  MOVWF  37
0EAF:  MOVLW  FA
0EB0:  MOVWF  3F
0EB1:  BCF    0A.3
0EB2:  BCF    03.5
0EB3:  CALL   2D2
0EB4:  BSF    0A.3
0EB5:  BSF    03.5
0EB6:  DECFSZ 37,F
0EB7:  GOTO   6AF
....................         doReset(); 
....................         BREAK; 
*
0ED2:  GOTO   7BE
....................         case 'S': IF(DEBUG) 
0ED3:  BTFSS  07.2
0ED4:  GOTO   6E6
....................         { 
....................             fputs("\r > Configuracion de tiro", RS232); 
0ED5:  MOVLW  EF
0ED6:  BSF    03.6
0ED7:  MOVWF  0D
0ED8:  MOVLW  05
0ED9:  MOVWF  0F
0EDA:  BCF    0A.3
0EDB:  BCF    03.6
0EDC:  CALL   10F
0EDD:  BSF    0A.3
0EDE:  MOVLW  0D
0EDF:  BTFSS  0C.4
0EE0:  GOTO   6DF
0EE1:  MOVWF  19
0EE2:  MOVLW  0A
0EE3:  BTFSS  0C.4
0EE4:  GOTO   6E3
0EE5:  MOVWF  19
....................         } 
....................         shotSet(char2int(c[1]), char2int(c[2])); 
0EE6:  BSF    03.5
0EE7:  MOVF   24,W
0EE8:  MOVWF  3A
0EE9:  BCF    0A.3
0EEA:  BCF    03.5
0EEB:  CALL   185
0EEC:  BSF    0A.3
0EED:  MOVF   78,W
0EEE:  BSF    03.5
0EEF:  MOVWF  37
0EF0:  MOVF   25,W
0EF1:  MOVWF  3A
0EF2:  BCF    0A.3
0EF3:  BCF    03.5
0EF4:  CALL   185
0EF5:  BSF    0A.3
0EF6:  MOVF   78,W
0EF7:  BSF    03.5
0EF8:  MOVWF  38
0EF9:  MOVF   37,W
0EFA:  MOVWF  39
0EFB:  MOVF   38,W
0EFC:  MOVWF  3A
....................         BREAK; 
*
0F21:  GOTO   7BE
....................         case 'T': IF(DEBUG) 
0F22:  BTFSS  07.2
0F23:  GOTO   735
....................         { 
....................             fputs("\r > Configuracion de tiempo", RS232); 
0F24:  MOVLW  FC
0F25:  BSF    03.6
0F26:  MOVWF  0D
0F27:  MOVLW  05
0F28:  MOVWF  0F
0F29:  BCF    0A.3
0F2A:  BCF    03.6
0F2B:  CALL   10F
0F2C:  BSF    0A.3
0F2D:  MOVLW  0D
0F2E:  BTFSS  0C.4
0F2F:  GOTO   72E
0F30:  MOVWF  19
0F31:  MOVLW  0A
0F32:  BTFSS  0C.4
0F33:  GOTO   732
0F34:  MOVWF  19
....................         } 
....................         timeSet(char2int(c[1]), char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0F35:  BSF    03.5
0F36:  MOVF   24,W
0F37:  MOVWF  3A
0F38:  BCF    0A.3
0F39:  BCF    03.5
0F3A:  CALL   185
0F3B:  BSF    0A.3
0F3C:  MOVF   78,W
0F3D:  BSF    03.5
0F3E:  MOVWF  37
0F3F:  MOVF   25,W
0F40:  MOVWF  3A
0F41:  BCF    0A.3
0F42:  BCF    03.5
0F43:  CALL   185
0F44:  BSF    0A.3
0F45:  MOVF   78,W
0F46:  BSF    03.5
0F47:  MOVWF  38
0F48:  MOVF   26,W
0F49:  MOVWF  3A
0F4A:  BCF    0A.3
0F4B:  BCF    03.5
0F4C:  CALL   185
0F4D:  BSF    0A.3
0F4E:  MOVF   78,W
0F4F:  BSF    03.5
0F50:  MOVWF  39
0F51:  MOVF   27,W
0F52:  MOVWF  3A
0F53:  BCF    0A.3
0F54:  BCF    03.5
0F55:  CALL   185
0F56:  BSF    0A.3
0F57:  MOVF   78,W
0F58:  BSF    03.5
0F59:  MOVWF  3A
0F5A:  MOVF   37,W
0F5B:  MOVWF  3B
0F5C:  MOVF   38,W
0F5D:  MOVWF  3C
0F5E:  MOVF   39,W
0F5F:  MOVWF  3D
0F60:  MOVF   3A,W
0F61:  MOVWF  3E
....................         BREAK; 
*
0FBD:  GOTO   7BE
....................     } 
0FBE:  BCF    0A.3
0FBF:  BCF    0A.4
0FC0:  GOTO   463 (RETURN)
.................... } 
....................  
.................... void setScoreL(int8 c, int8 d, int8 u) { 
....................     //TODO: Codigo para mostrar puntos 
....................     scoreLU = u; 
*
02E6:  BSF    03.5
02E7:  MOVF   3C,W
02E8:  BCF    03.5
02E9:  MOVWF  6D
....................     scoreLD = d; 
02EA:  BSF    03.5
02EB:  MOVF   3B,W
02EC:  BCF    03.5
02ED:  MOVWF  6E
....................     if (c > 0) 
02EE:  BSF    03.5
02EF:  MOVF   3A,F
02F0:  BTFSC  03.2
02F1:  GOTO   2F6
....................         scoreLC = true; 
02F2:  BCF    03.5
02F3:  BSF    56.1
02F4:  GOTO   2F8
02F5:  BSF    03.5
....................     else 
....................         scoreLC = false; 
02F6:  BCF    03.5
02F7:  BCF    56.1
....................  
....................     sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
02F8:  MOVF   6D,W
02F9:  BSF    03.5
02FA:  MOVWF  3F
02FB:  MOVLW  0C
02FC:  MOVWF  40
02FD:  MOVLW  01
02FE:  MOVWF  41
02FF:  BCF    03.5
0300:  CALL   2C3
....................     delay_ms(I2CWAIT); 
0301:  MOVLW  32
0302:  BSF    03.5
0303:  MOVWF  3F
0304:  BCF    03.5
0305:  CALL   2D2
....................     sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0306:  MOVF   6E,W
0307:  BSF    03.5
0308:  MOVWF  3F
0309:  MOVLW  0C
030A:  MOVWF  40
030B:  MOVLW  02
030C:  MOVWF  41
030D:  BCF    03.5
030E:  CALL   2C3
....................     delay_ms(I2CWAIT); 
030F:  MOVLW  32
0310:  BSF    03.5
0311:  MOVWF  3F
0312:  BCF    03.5
0313:  CALL   2D2
....................     if (scoreLC) 
0314:  BTFSS  56.1
0315:  GOTO   31E
....................         i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0316:  MOVLW  0C
0317:  BSF    03.5
0318:  MOVWF  43
0319:  MOVLW  73
031A:  MOVWF  44
031B:  BCF    03.5
031C:  CALL   2B0
031D:  GOTO   325
....................     else 
....................         i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
031E:  MOVLW  0C
031F:  BSF    03.5
0320:  MOVWF  43
0321:  MOVLW  74
0322:  MOVWF  44
0323:  BCF    03.5
0324:  CALL   2B0
0325:  RETURN
.................... } 
....................  
.................... void setScoreV(int8 c, int8 d, int8 u) { 
....................     //TODO: Codigo para mostrar puntos 
....................     scoreVU = u; 
*
038A:  BSF    03.5
038B:  MOVF   3C,W
038C:  BCF    03.5
038D:  MOVWF  6F
....................     scoreVD = d; 
038E:  BSF    03.5
038F:  MOVF   3B,W
0390:  MOVWF  70
....................     if (c > 0) 
0391:  MOVF   3A,F
0392:  BTFSC  03.2
0393:  GOTO   398
....................         scoreVC = true; 
0394:  BCF    03.5
0395:  BSF    56.2
0396:  GOTO   39A
0397:  BSF    03.5
....................     else 
....................         scoreVC = false; 
0398:  BCF    03.5
0399:  BCF    56.2
....................  
....................     sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
039A:  MOVF   6F,W
039B:  BSF    03.5
039C:  MOVWF  3F
039D:  MOVLW  0C
039E:  MOVWF  40
039F:  MOVLW  04
03A0:  MOVWF  41
03A1:  BCF    03.5
03A2:  CALL   2C3
....................     delay_ms(I2CWAIT); 
03A3:  MOVLW  32
03A4:  BSF    03.5
03A5:  MOVWF  3F
03A6:  BCF    03.5
03A7:  CALL   2D2
....................     sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
03A8:  MOVF   70,W
03A9:  BSF    03.5
03AA:  MOVWF  3F
03AB:  MOVLW  0C
03AC:  MOVWF  40
03AD:  MOVLW  03
03AE:  MOVWF  41
03AF:  BCF    03.5
03B0:  CALL   2C3
....................     delay_ms(I2CWAIT); 
03B1:  MOVLW  32
03B2:  BSF    03.5
03B3:  MOVWF  3F
03B4:  BCF    03.5
03B5:  CALL   2D2
....................  
....................     if (scoreVC) 
03B6:  BTFSS  56.2
03B7:  GOTO   3C0
....................         i2c_send(I2C_SCORE, I2C_CMD_CVON); 
03B8:  MOVLW  0C
03B9:  BSF    03.5
03BA:  MOVWF  43
03BB:  MOVLW  75
03BC:  MOVWF  44
03BD:  BCF    03.5
03BE:  CALL   2B0
03BF:  GOTO   3C7
....................     else 
....................         i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
03C0:  MOVLW  0C
03C1:  BSF    03.5
03C2:  MOVWF  43
03C3:  MOVLW  76
03C4:  MOVWF  44
03C5:  BCF    03.5
03C6:  CALL   2B0
03C7:  RETURN
....................  
.................... } 
....................  
.................... void addScoreV(int8 a) { 
03C8:  BSF    03.5
03C9:  BCF    38.0
03CA:  BCF    03.5
03CB:  BTFSS  56.2
03CC:  GOTO   3D0
03CD:  BSF    03.5
03CE:  BSF    38.0
03CF:  BCF    03.5
03D0:  MOVF   70,W
03D1:  BSF    03.5
03D2:  MOVWF  39
03D3:  BCF    03.5
03D4:  MOVF   6F,W
03D5:  BSF    03.5
03D6:  MOVWF  3A
....................     int1 tc = scoreVC; 
....................     int8 td = scoreVD; 
....................     int8 tu = scoreVU; 
....................  
....................     scoreVU += a; 
03D7:  MOVF   37,W
03D8:  BCF    03.5
03D9:  ADDWF  6F,F
....................  
....................     if (scoreVU > 10) { 
03DA:  MOVF   6F,W
03DB:  SUBLW  0A
03DC:  BTFSC  03.0
03DD:  GOTO   3E1
....................         scoreVD++; 
03DE:  INCF   70,F
....................         scoreVU-=10; 
03DF:  MOVLW  0A
03E0:  SUBWF  6F,F
....................     } 
....................     if (scoreVD > 10) { 
03E1:  MOVF   70,W
03E2:  SUBLW  0A
03E3:  BTFSC  03.0
03E4:  GOTO   3E8
....................         scoreVC = true; 
03E5:  BSF    56.2
....................         scoreVD-=10; 
03E6:  MOVLW  0A
03E7:  SUBWF  70,F
....................     } 
....................  
....................     if (scoreVC != tc) { 
03E8:  CLRF   77
03E9:  BSF    03.5
03EA:  BTFSC  38.0
03EB:  BSF    77.2
03EC:  BCF    03.5
03ED:  MOVF   56,W
03EE:  XORWF  77,W
03EF:  ANDLW  04
03F0:  BTFSC  03.2
03F1:  GOTO   403
....................         if (scoreVC) 
03F2:  BTFSS  56.2
03F3:  GOTO   3FC
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
03F4:  MOVLW  0C
03F5:  BSF    03.5
03F6:  MOVWF  43
03F7:  MOVLW  73
03F8:  MOVWF  44
03F9:  BCF    03.5
03FA:  CALL   2B0
03FB:  GOTO   403
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
03FC:  MOVLW  0C
03FD:  BSF    03.5
03FE:  MOVWF  43
03FF:  MOVLW  74
0400:  MOVWF  44
0401:  BCF    03.5
0402:  CALL   2B0
....................     } 
....................  
....................     delay_ms(I2CWAIT); 
0403:  MOVLW  32
0404:  BSF    03.5
0405:  MOVWF  3F
0406:  BCF    03.5
0407:  CALL   2D2
....................     if (scoreVD != td) 
0408:  BSF    03.5
0409:  MOVF   39,W
040A:  SUBWF  70,W
040B:  BTFSC  03.2
040C:  GOTO   416
....................         sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
040D:  MOVF   70,W
040E:  MOVWF  3F
040F:  MOVLW  0C
0410:  MOVWF  40
0411:  MOVLW  03
0412:  MOVWF  41
0413:  BCF    03.5
0414:  CALL   2C3
0415:  BSF    03.5
....................     delay_ms(I2CWAIT); 
0416:  MOVLW  32
0417:  MOVWF  3F
0418:  BCF    03.5
0419:  CALL   2D2
....................     if (scoreVU != tu) 
041A:  BSF    03.5
041B:  MOVF   3A,W
041C:  BCF    03.5
041D:  SUBWF  6F,W
041E:  BTFSC  03.2
041F:  GOTO   429
....................         sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0420:  MOVF   6F,W
0421:  BSF    03.5
0422:  MOVWF  3F
0423:  MOVLW  0C
0424:  MOVWF  40
0425:  MOVLW  04
0426:  MOVWF  41
0427:  BCF    03.5
0428:  CALL   2C3
0429:  RETURN
.................... } 
....................  
.................... void resScoreV() { 
*
0CE1:  BSF    03.5
0CE2:  BCF    37.0
0CE3:  BCF    03.5
0CE4:  BTFSS  56.2
0CE5:  GOTO   4E9
0CE6:  BSF    03.5
0CE7:  BSF    37.0
0CE8:  BCF    03.5
0CE9:  MOVF   70,W
0CEA:  BSF    03.5
0CEB:  MOVWF  38
0CEC:  BCF    03.5
0CED:  MOVF   6F,W
0CEE:  BSF    03.5
0CEF:  MOVWF  39
....................     int1 tc = scoreVC; 
....................     int8 td = scoreVD; 
....................     int8 tu = scoreVU; 
....................  
....................     if (scoreVU > 0) 
0CF0:  BCF    03.5
0CF1:  MOVF   6F,F
0CF2:  BTFSC  03.2
0CF3:  GOTO   4F6
....................         scoreVU--; 
0CF4:  DECF   6F,F
0CF5:  GOTO   501
....................     else { 
....................         if (scoreVD > 0) { 
0CF6:  MOVF   70,F
0CF7:  BTFSC  03.2
0CF8:  GOTO   4FD
....................             scoreVD--; 
0CF9:  DECF   70,F
....................             scoreVU = 9; 
0CFA:  MOVLW  09
0CFB:  MOVWF  6F
....................         } else { 
0CFC:  GOTO   501
....................             scoreVC = false; 
0CFD:  BCF    56.2
....................             scoreVD = 9; 
0CFE:  MOVLW  09
0CFF:  MOVWF  70
....................             scoreVU = 9; 
0D00:  MOVWF  6F
....................         } 
....................     } 
....................  
....................     if (scoreVC != tc) { 
0D01:  CLRF   77
0D02:  BSF    03.5
0D03:  BTFSC  37.0
0D04:  BSF    77.2
0D05:  BCF    03.5
0D06:  MOVF   56,W
0D07:  XORWF  77,W
0D08:  ANDLW  04
0D09:  BTFSC  03.2
0D0A:  GOTO   520
....................         if (scoreVC) 
0D0B:  BTFSS  56.2
0D0C:  GOTO   517
....................             i2c_send(I2C_SCORE, I2C_CMD_CVON); 
0D0D:  MOVLW  0C
0D0E:  BSF    03.5
0D0F:  MOVWF  43
0D10:  MOVLW  75
0D11:  MOVWF  44
0D12:  BCF    0A.3
0D13:  BCF    03.5
0D14:  CALL   2B0
0D15:  BSF    0A.3
0D16:  GOTO   520
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
0D17:  MOVLW  0C
0D18:  BSF    03.5
0D19:  MOVWF  43
0D1A:  MOVLW  76
0D1B:  MOVWF  44
0D1C:  BCF    0A.3
0D1D:  BCF    03.5
0D1E:  CALL   2B0
0D1F:  BSF    0A.3
....................     } 
....................     delay_ms(I2CWAIT); 
0D20:  MOVLW  32
0D21:  BSF    03.5
0D22:  MOVWF  3F
0D23:  BCF    0A.3
0D24:  BCF    03.5
0D25:  CALL   2D2
0D26:  BSF    0A.3
....................     if (scoreVD != td) 
0D27:  BSF    03.5
0D28:  MOVF   38,W
0D29:  SUBWF  70,W
0D2A:  BTFSC  03.2
0D2B:  GOTO   537
....................         sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0D2C:  MOVF   70,W
0D2D:  MOVWF  3F
0D2E:  MOVLW  0C
0D2F:  MOVWF  40
0D30:  MOVLW  03
0D31:  MOVWF  41
0D32:  BCF    0A.3
0D33:  BCF    03.5
0D34:  CALL   2C3
0D35:  BSF    0A.3
0D36:  BSF    03.5
....................     delay_ms(I2CWAIT); 
0D37:  MOVLW  32
0D38:  MOVWF  3F
0D39:  BCF    0A.3
0D3A:  BCF    03.5
0D3B:  CALL   2D2
0D3C:  BSF    0A.3
....................     if (scoreVU != tu) 
0D3D:  BSF    03.5
0D3E:  MOVF   39,W
0D3F:  BCF    03.5
0D40:  SUBWF  6F,W
0D41:  BTFSC  03.2
0D42:  GOTO   54E
....................         sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0D43:  MOVF   6F,W
0D44:  BSF    03.5
0D45:  MOVWF  3F
0D46:  MOVLW  0C
0D47:  MOVWF  40
0D48:  MOVLW  04
0D49:  MOVWF  41
0D4A:  BCF    0A.3
0D4B:  BCF    03.5
0D4C:  CALL   2C3
0D4D:  BSF    0A.3
.................... } 
....................  
.................... void addScoreL(int8 a) { 
*
0326:  BSF    03.5
0327:  BCF    38.0
0328:  BCF    03.5
0329:  BTFSS  56.1
032A:  GOTO   32E
032B:  BSF    03.5
032C:  BSF    38.0
032D:  BCF    03.5
032E:  MOVF   6E,W
032F:  BSF    03.5
0330:  MOVWF  39
0331:  BCF    03.5
0332:  MOVF   6D,W
0333:  BSF    03.5
0334:  MOVWF  3A
....................     int1 tc = scoreLC; 
....................     int8 td = scoreLD; 
....................     int8 tu = scoreLU; 
....................  
....................     scoreLU += a; 
0335:  MOVF   37,W
0336:  BCF    03.5
0337:  ADDWF  6D,F
....................  
....................     if (scoreLU > 10) { 
0338:  MOVF   6D,W
0339:  SUBLW  0A
033A:  BTFSC  03.0
033B:  GOTO   33F
....................         scoreLD++; 
033C:  INCF   6E,F
....................         scoreLU -=10; 
033D:  MOVLW  0A
033E:  SUBWF  6D,F
....................     } 
....................     if (scoreLD > 10) { 
033F:  MOVF   6E,W
0340:  SUBLW  0A
0341:  BTFSC  03.0
0342:  GOTO   346
....................         scoreLC = true; 
0343:  BSF    56.1
....................         scoreLD -= 10; 
0344:  MOVLW  0A
0345:  SUBWF  6E,F
....................     } 
....................  
....................     if (scoreLC != tc) { 
0346:  CLRF   77
0347:  BSF    03.5
0348:  BTFSC  38.0
0349:  BSF    77.1
034A:  BCF    03.5
034B:  MOVF   56,W
034C:  XORWF  77,W
034D:  ANDLW  02
034E:  BTFSC  03.2
034F:  GOTO   361
....................         if (scoreLC) 
0350:  BTFSS  56.1
0351:  GOTO   35A
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0352:  MOVLW  0C
0353:  BSF    03.5
0354:  MOVWF  43
0355:  MOVLW  73
0356:  MOVWF  44
0357:  BCF    03.5
0358:  CALL   2B0
0359:  GOTO   361
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
035A:  MOVLW  0C
035B:  BSF    03.5
035C:  MOVWF  43
035D:  MOVLW  74
035E:  MOVWF  44
035F:  BCF    03.5
0360:  CALL   2B0
....................     } 
....................     delay_ms(I2CWAIT); 
0361:  MOVLW  32
0362:  BSF    03.5
0363:  MOVWF  3F
0364:  BCF    03.5
0365:  CALL   2D2
....................     if (scoreLD != td) 
0366:  BSF    03.5
0367:  MOVF   39,W
0368:  BCF    03.5
0369:  SUBWF  6E,W
036A:  BTFSC  03.2
036B:  GOTO   375
....................         sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
036C:  MOVF   6E,W
036D:  BSF    03.5
036E:  MOVWF  3F
036F:  MOVLW  0C
0370:  MOVWF  40
0371:  MOVLW  02
0372:  MOVWF  41
0373:  BCF    03.5
0374:  CALL   2C3
....................     delay_ms(I2CWAIT); 
0375:  MOVLW  32
0376:  BSF    03.5
0377:  MOVWF  3F
0378:  BCF    03.5
0379:  CALL   2D2
....................     if (scoreLU != tu) 
037A:  BSF    03.5
037B:  MOVF   3A,W
037C:  BCF    03.5
037D:  SUBWF  6D,W
037E:  BTFSC  03.2
037F:  GOTO   389
....................         sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0380:  MOVF   6D,W
0381:  BSF    03.5
0382:  MOVWF  3F
0383:  MOVLW  0C
0384:  MOVWF  40
0385:  MOVLW  01
0386:  MOVWF  41
0387:  BCF    03.5
0388:  CALL   2C3
0389:  RETURN
.................... } 
....................  
.................... void resScoreL() { 
*
0A87:  BSF    03.5
0A88:  BCF    37.0
0A89:  BCF    03.5
0A8A:  BTFSS  56.1
0A8B:  GOTO   28F
0A8C:  BSF    03.5
0A8D:  BSF    37.0
0A8E:  BCF    03.5
0A8F:  MOVF   6E,W
0A90:  BSF    03.5
0A91:  MOVWF  38
0A92:  BCF    03.5
0A93:  MOVF   6D,W
0A94:  BSF    03.5
0A95:  MOVWF  39
....................     int1 tc = scoreLC; 
....................     int8 td = scoreLD; 
....................     int8 tu = scoreLU; 
....................  
....................     if (scoreLU > 0) 
0A96:  BCF    03.5
0A97:  MOVF   6D,F
0A98:  BTFSC  03.2
0A99:  GOTO   29C
....................         scoreLU--; 
0A9A:  DECF   6D,F
0A9B:  GOTO   2A7
....................     else { 
....................         if (scoreLD > 0) { 
0A9C:  MOVF   6E,F
0A9D:  BTFSC  03.2
0A9E:  GOTO   2A3
....................             scoreLD--; 
0A9F:  DECF   6E,F
....................             scoreLU = 9; 
0AA0:  MOVLW  09
0AA1:  MOVWF  6D
....................         } else { 
0AA2:  GOTO   2A7
....................             scoreLC = false; 
0AA3:  BCF    56.1
....................             scoreLD = 9; 
0AA4:  MOVLW  09
0AA5:  MOVWF  6E
....................             scoreLU = 9; 
0AA6:  MOVWF  6D
....................         } 
....................     } 
....................  
....................     if (scoreLC != tc) { 
0AA7:  CLRF   77
0AA8:  BSF    03.5
0AA9:  BTFSC  37.0
0AAA:  BSF    77.1
0AAB:  BCF    03.5
0AAC:  MOVF   56,W
0AAD:  XORWF  77,W
0AAE:  ANDLW  02
0AAF:  BTFSC  03.2
0AB0:  GOTO   2C6
....................         if (scoreLC) 
0AB1:  BTFSS  56.1
0AB2:  GOTO   2BD
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0AB3:  MOVLW  0C
0AB4:  BSF    03.5
0AB5:  MOVWF  43
0AB6:  MOVLW  73
0AB7:  MOVWF  44
0AB8:  BCF    0A.3
0AB9:  BCF    03.5
0ABA:  CALL   2B0
0ABB:  BSF    0A.3
0ABC:  GOTO   2C6
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0ABD:  MOVLW  0C
0ABE:  BSF    03.5
0ABF:  MOVWF  43
0AC0:  MOVLW  74
0AC1:  MOVWF  44
0AC2:  BCF    0A.3
0AC3:  BCF    03.5
0AC4:  CALL   2B0
0AC5:  BSF    0A.3
....................     } 
....................     delay_ms(I2CWAIT); 
0AC6:  MOVLW  32
0AC7:  BSF    03.5
0AC8:  MOVWF  3F
0AC9:  BCF    0A.3
0ACA:  BCF    03.5
0ACB:  CALL   2D2
0ACC:  BSF    0A.3
....................     if (scoreLD != td) 
0ACD:  BSF    03.5
0ACE:  MOVF   38,W
0ACF:  BCF    03.5
0AD0:  SUBWF  6E,W
0AD1:  BTFSC  03.2
0AD2:  GOTO   2DE
....................         sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0AD3:  MOVF   6E,W
0AD4:  BSF    03.5
0AD5:  MOVWF  3F
0AD6:  MOVLW  0C
0AD7:  MOVWF  40
0AD8:  MOVLW  02
0AD9:  MOVWF  41
0ADA:  BCF    0A.3
0ADB:  BCF    03.5
0ADC:  CALL   2C3
0ADD:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0ADE:  MOVLW  32
0ADF:  BSF    03.5
0AE0:  MOVWF  3F
0AE1:  BCF    0A.3
0AE2:  BCF    03.5
0AE3:  CALL   2D2
0AE4:  BSF    0A.3
....................     if (scoreLU != tu) 
0AE5:  BSF    03.5
0AE6:  MOVF   39,W
0AE7:  BCF    03.5
0AE8:  SUBWF  6D,W
0AE9:  BTFSC  03.2
0AEA:  GOTO   2F6
....................         sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0AEB:  MOVF   6D,W
0AEC:  BSF    03.5
0AED:  MOVWF  3F
0AEE:  MOVLW  0C
0AEF:  MOVWF  40
0AF0:  MOVLW  01
0AF1:  MOVWF  41
0AF2:  BCF    0A.3
0AF3:  BCF    03.5
0AF4:  CALL   2C3
0AF5:  BSF    0A.3
.................... } 
....................  
.................... void shotSet(int8 shd, int8 shu) { 
....................     sh_u = shu; 
*
0EFD:  MOVF   3A,W
0EFE:  BCF    03.5
0EFF:  MOVWF  6C
....................     sh_d = shd; 
0F00:  BSF    03.5
0F01:  MOVF   39,W
0F02:  BCF    03.5
0F03:  MOVWF  6B
....................     sendN2Port(shd, I2C_TIMER, PuertoA); 
0F04:  BSF    03.5
0F05:  MOVF   39,W
0F06:  MOVWF  3F
0F07:  MOVLW  0A
0F08:  MOVWF  40
0F09:  MOVLW  01
0F0A:  MOVWF  41
0F0B:  BCF    0A.3
0F0C:  BCF    03.5
0F0D:  CALL   2C3
0F0E:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0F0F:  MOVLW  32
0F10:  BSF    03.5
0F11:  MOVWF  3F
0F12:  BCF    0A.3
0F13:  BCF    03.5
0F14:  CALL   2D2
0F15:  BSF    0A.3
....................     sendN2Port(shu, I2C_TIMER, PuertoB); 
0F16:  BSF    03.5
0F17:  MOVF   3A,W
0F18:  MOVWF  3F
0F19:  MOVLW  0A
0F1A:  MOVWF  40
0F1B:  MOVLW  02
0F1C:  MOVWF  41
0F1D:  BCF    0A.3
0F1E:  BCF    03.5
0F1F:  CALL   2C3
0F20:  BSF    0A.3
.................... } 
....................  
.................... void timeSet(INT8 md, int8 mu, int8 sd, int8 su) { 
....................     m_u = mu; 
*
0F62:  MOVF   3C,W
0F63:  BCF    03.5
0F64:  MOVWF  68
....................     m_d = md; 
0F65:  BSF    03.5
0F66:  MOVF   3B,W
0F67:  BCF    03.5
0F68:  MOVWF  67
....................     s_d = sd; 
0F69:  BSF    03.5
0F6A:  MOVF   3D,W
0F6B:  BCF    03.5
0F6C:  MOVWF  69
....................     s_u = su; 
0F6D:  BSF    03.5
0F6E:  MOVF   3E,W
0F6F:  BCF    03.5
0F70:  MOVWF  6A
....................  
....................     sendN2Port(su, I2C_TIMER, PuertoD); 
0F71:  BSF    03.5
0F72:  MOVF   3E,W
0F73:  MOVWF  3F
0F74:  MOVLW  0A
0F75:  MOVWF  40
0F76:  MOVLW  04
0F77:  MOVWF  41
0F78:  BCF    0A.3
0F79:  BCF    03.5
0F7A:  CALL   2C3
0F7B:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0F7C:  MOVLW  32
0F7D:  BSF    03.5
0F7E:  MOVWF  3F
0F7F:  BCF    0A.3
0F80:  BCF    03.5
0F81:  CALL   2D2
0F82:  BSF    0A.3
....................     sendN2Port(sd, I2C_TIMER, PuertoC); 
0F83:  BSF    03.5
0F84:  MOVF   3D,W
0F85:  MOVWF  3F
0F86:  MOVLW  0A
0F87:  MOVWF  40
0F88:  MOVLW  03
0F89:  MOVWF  41
0F8A:  BCF    0A.3
0F8B:  BCF    03.5
0F8C:  CALL   2C3
0F8D:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0F8E:  MOVLW  32
0F8F:  BSF    03.5
0F90:  MOVWF  3F
0F91:  BCF    0A.3
0F92:  BCF    03.5
0F93:  CALL   2D2
0F94:  BSF    0A.3
....................     sendN2Port(mu, I2C_TIMER, PuertoE); 
0F95:  BSF    03.5
0F96:  MOVF   3C,W
0F97:  MOVWF  3F
0F98:  MOVLW  0A
0F99:  MOVWF  40
0F9A:  MOVLW  05
0F9B:  MOVWF  41
0F9C:  BCF    0A.3
0F9D:  BCF    03.5
0F9E:  CALL   2C3
0F9F:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0FA0:  MOVLW  32
0FA1:  BSF    03.5
0FA2:  MOVWF  3F
0FA3:  BCF    0A.3
0FA4:  BCF    03.5
0FA5:  CALL   2D2
0FA6:  BSF    0A.3
....................  
....................     IF(md != 0) { 
0FA7:  BSF    03.5
0FA8:  MOVF   3B,F
0FA9:  BTFSC  03.2
0FAA:  GOTO   7B5
....................         i2c_send(I2C_TIMER, I2C_CMD_MDON); 
0FAB:  MOVLW  0A
0FAC:  MOVWF  43
0FAD:  MOVLW  75
0FAE:  MOVWF  44
0FAF:  BCF    0A.3
0FB0:  BCF    03.5
0FB1:  CALL   2B0
0FB2:  BSF    0A.3
....................     } 
0FB3:  GOTO   7BD
0FB4:  BSF    03.5
....................  
....................     ELSE{ 
....................         i2c_send(I2C_TIMER, I2C_CMD_MDOF); 
0FB5:  MOVLW  0A
0FB6:  MOVWF  43
0FB7:  MOVLW  76
0FB8:  MOVWF  44
0FB9:  BCF    0A.3
0FBA:  BCF    03.5
0FBB:  CALL   2B0
0FBC:  BSF    0A.3
....................     } 
....................  
.................... } 
....................  
.................... void showNumber(INT8 n, tPort p) { 
*
01F5:  BSF    03.5
01F6:  BCF    3D.0
01F7:  BCF    3D.1
01F8:  BCF    3D.2
01F9:  BCF    3D.3
....................     INT1 a = 0, b = 0, c = 0, d = 0; 
....................  
....................     SWITCH(n) { 
01FA:  MOVLW  01
01FB:  SUBWF  38,W
01FC:  ADDLW  F7
01FD:  BTFSC  03.0
01FE:  GOTO   224
01FF:  ADDLW  09
0200:  BCF    03.5
0201:  GOTO   27C
....................         CASE 1 : a = 1; 
0202:  BSF    03.5
0203:  BSF    3D.0
....................         BREAK; 
0204:  GOTO   224
....................         CASE 2 : b = 1; 
0205:  BSF    03.5
0206:  BSF    3D.1
....................         BREAK; 
0207:  GOTO   224
....................         CASE 3 : a = 1; 
0208:  BSF    03.5
0209:  BSF    3D.0
....................         b = 1; 
020A:  BSF    3D.1
....................         BREAK; 
020B:  GOTO   224
....................         CASE 4 : c = 1; 
020C:  BSF    03.5
020D:  BSF    3D.2
....................         BREAK; 
020E:  GOTO   224
....................         CASE 5 : c = 1; 
020F:  BSF    03.5
0210:  BSF    3D.2
....................         a = 1; 
0211:  BSF    3D.0
....................         BREAK; 
0212:  GOTO   224
....................         CASE 6 : c = 1; 
0213:  BSF    03.5
0214:  BSF    3D.2
....................         b = 1; 
0215:  BSF    3D.1
....................         BREAK; 
0216:  GOTO   224
....................         CASE 7 : c = 1; 
0217:  BSF    03.5
0218:  BSF    3D.2
....................         b = 1; 
0219:  BSF    3D.1
....................         a = 1; 
021A:  BSF    3D.0
....................         BREAK; 
021B:  GOTO   224
....................         CASE 8 : d = 1; 
021C:  BSF    03.5
021D:  BSF    3D.3
....................         BREAK; 
021E:  GOTO   224
....................         CASE 9 : d = 1; 
021F:  BSF    03.5
0220:  BSF    3D.3
....................         a = 1; 
0221:  BSF    3D.0
....................         BREAK; 
0222:  GOTO   224
0223:  BSF    03.5
....................     } 
....................  
....................     output_bit(p.a, a); 
0224:  MOVLW  00
0225:  BTFSC  3D.0
0226:  MOVLW  01
0227:  MOVWF  77
0228:  MOVF   39,W
0229:  MOVWF  3E
022A:  MOVF   77,W
022B:  MOVWF  3F
022C:  CLRF   41
022D:  CLRF   40
022E:  BCF    03.5
022F:  CALL   1D3
0230:  BSF    03.5
0231:  MOVF   39,W
0232:  MOVWF  3E
0233:  CLRF   3F
0234:  CLRF   41
0235:  MOVLW  80
0236:  MOVWF  40
0237:  BCF    03.5
0238:  CALL   1D3
....................     output_bit(p.b, b); 
0239:  MOVLW  00
023A:  BSF    03.5
023B:  BTFSC  3D.1
023C:  MOVLW  01
023D:  MOVWF  77
023E:  MOVF   3A,W
023F:  MOVWF  3E
0240:  MOVF   77,W
0241:  MOVWF  3F
0242:  CLRF   41
0243:  CLRF   40
0244:  BCF    03.5
0245:  CALL   1D3
0246:  BSF    03.5
0247:  MOVF   3A,W
0248:  MOVWF  3E
0249:  CLRF   3F
024A:  CLRF   41
024B:  MOVLW  80
024C:  MOVWF  40
024D:  BCF    03.5
024E:  CALL   1D3
....................     output_bit(p.c, c); 
024F:  MOVLW  00
0250:  BSF    03.5
0251:  BTFSC  3D.2
0252:  MOVLW  01
0253:  MOVWF  77
0254:  MOVF   3B,W
0255:  MOVWF  3E
0256:  MOVF   77,W
0257:  MOVWF  3F
0258:  CLRF   41
0259:  CLRF   40
025A:  BCF    03.5
025B:  CALL   1D3
025C:  BSF    03.5
025D:  MOVF   3B,W
025E:  MOVWF  3E
025F:  CLRF   3F
0260:  CLRF   41
0261:  MOVLW  80
0262:  MOVWF  40
0263:  BCF    03.5
0264:  CALL   1D3
....................     output_bit(p.d, d); 
0265:  MOVLW  00
0266:  BSF    03.5
0267:  BTFSC  3D.3
0268:  MOVLW  01
0269:  MOVWF  77
026A:  MOVF   3C,W
026B:  MOVWF  3E
026C:  MOVF   77,W
026D:  MOVWF  3F
026E:  CLRF   41
026F:  CLRF   40
0270:  BCF    03.5
0271:  CALL   1D3
0272:  BSF    03.5
0273:  MOVF   3C,W
0274:  MOVWF  3E
0275:  CLRF   3F
0276:  CLRF   41
0277:  MOVLW  80
0278:  MOVWF  40
0279:  BCF    03.5
027A:  CALL   1D3
027B:  RETURN
.................... } 
....................  
.................... int8 char2int(CHAR c) { 
....................  
....................     SWITCH(c) { 
*
0185:  MOVLW  30
0186:  BSF    03.5
0187:  SUBWF  3A,W
0188:  ADDLW  F6
0189:  BTFSC  03.0
018A:  GOTO   1C1
018B:  ADDLW  0A
018C:  BCF    03.5
018D:  GOTO   1C5
....................         case '0': RETURN 0; 
018E:  MOVLW  00
018F:  MOVWF  78
0190:  GOTO   1C4
....................         BREAK; 
0191:  BSF    03.5
0192:  GOTO   1C1
....................         case '1': RETURN 1; 
0193:  MOVLW  01
0194:  MOVWF  78
0195:  GOTO   1C4
....................         BREAK; 
0196:  BSF    03.5
0197:  GOTO   1C1
....................         case '2': RETURN 2; 
0198:  MOVLW  02
0199:  MOVWF  78
019A:  GOTO   1C4
....................         BREAK; 
019B:  BSF    03.5
019C:  GOTO   1C1
....................         case '3': RETURN 3; 
019D:  MOVLW  03
019E:  MOVWF  78
019F:  GOTO   1C4
....................         BREAK; 
01A0:  BSF    03.5
01A1:  GOTO   1C1
....................         case '4': RETURN 4; 
01A2:  MOVLW  04
01A3:  MOVWF  78
01A4:  GOTO   1C4
....................         BREAK; 
01A5:  BSF    03.5
01A6:  GOTO   1C1
....................         case '5': RETURN 5; 
01A7:  MOVLW  05
01A8:  MOVWF  78
01A9:  GOTO   1C4
....................         BREAK; 
01AA:  BSF    03.5
01AB:  GOTO   1C1
....................         case '6': RETURN 6; 
01AC:  MOVLW  06
01AD:  MOVWF  78
01AE:  GOTO   1C4
....................         BREAK; 
01AF:  BSF    03.5
01B0:  GOTO   1C1
....................         case '7': RETURN 7; 
01B1:  MOVLW  07
01B2:  MOVWF  78
01B3:  GOTO   1C4
....................         BREAK; 
01B4:  BSF    03.5
01B5:  GOTO   1C1
....................         case '8': RETURN 8; 
01B6:  MOVLW  08
01B7:  MOVWF  78
01B8:  GOTO   1C4
....................         BREAK; 
01B9:  BSF    03.5
01BA:  GOTO   1C1
....................         case '9': RETURN 9; 
01BB:  MOVLW  09
01BC:  MOVWF  78
01BD:  GOTO   1C4
....................         BREAK; 
01BE:  BSF    03.5
01BF:  GOTO   1C1
01C0:  BSF    03.5
....................     } 
....................  
....................     RETURN 0; 
01C1:  MOVLW  00
01C2:  MOVWF  78
01C3:  BCF    03.5
01C4:  RETURN
.................... } 
....................  
.................... void doReset(VOID) { 
....................     i2c_send(I2C_TIMER, I2C_CMD_RESET); 
*
0EB8:  MOVLW  0A
0EB9:  MOVWF  43
0EBA:  MOVLW  FD
0EBB:  MOVWF  44
0EBC:  BCF    0A.3
0EBD:  BCF    03.5
0EBE:  CALL   2B0
0EBF:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0EC0:  MOVLW  32
0EC1:  BSF    03.5
0EC2:  MOVWF  3F
0EC3:  BCF    0A.3
0EC4:  BCF    03.5
0EC5:  CALL   2D2
0EC6:  BSF    0A.3
....................     i2c_send(I2C_SCORE, I2C_CMD_RESET); 
0EC7:  MOVLW  0C
0EC8:  BSF    03.5
0EC9:  MOVWF  43
0ECA:  MOVLW  FD
0ECB:  MOVWF  44
0ECC:  BCF    0A.3
0ECD:  BCF    03.5
0ECE:  CALL   2B0
0ECF:  BSF    0A.3
....................     reset_cpu(); 
0ED0:  CLRF   0A
0ED1:  GOTO   000
.................... } 
....................  
.................... void sendN2Port(INT8 n, int8 a, int8 p) { 
*
02C3:  BSF    03.5
02C4:  SWAPF  41,W
02C5:  MOVWF  77
02C6:  MOVLW  F0
02C7:  ANDWF  77,F
02C8:  MOVF   77,W
02C9:  ADDWF  3F,W
02CA:  MOVWF  42
....................     INT c = (p * 16) + n; 
....................     i2c_send(a, c); 
02CB:  MOVF   40,W
02CC:  MOVWF  43
02CD:  MOVF   42,W
02CE:  MOVWF  44
02CF:  BCF    03.5
02D0:  CALL   2B0
02D1:  RETURN
.................... } 
....................  
.................... void i2c_send(INT8 a, int8 c) { 
....................     i2c_start(); 
*
02B0:  BSF    03.5
02B1:  BSF    11.0
02B2:  BTFSC  11.0
02B3:  GOTO   2B2
....................     i2c_write(a); 
02B4:  MOVF   43,W
02B5:  MOVWF  45
02B6:  BCF    03.5
02B7:  CALL   289
....................     i2c_write(c); 
02B8:  BSF    03.5
02B9:  MOVF   44,W
02BA:  MOVWF  45
02BB:  BCF    03.5
02BC:  CALL   289
....................     i2c_stop(); 
02BD:  BSF    03.5
02BE:  BSF    11.2
02BF:  BTFSC  11.2
02C0:  GOTO   2BF
02C1:  BCF    03.5
02C2:  RETURN
.................... } 

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

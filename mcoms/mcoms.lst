CCS PCM C Compiler, Version 5.076, 56587               09-mar.-20 21:46

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mcoms\mcoms.lst

               ROM used:   4195 words (51%)
                           Largest free fragment is 2048
               RAM used:   85 (23%) at main() level
                           121 (33%) worst case
               Stack used: 7 locations (3 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   334
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   38C
....................  
.................... #include <mcoms.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 0D,00
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA A0,23
007D:  DATA F2,3A
007E:  DATA F0,37
007F:  DATA A0,20
0080:  DATA D0,26
0081:  DATA 20,14
0082:  DATA E3,14
0083:  DATA 20,19
0084:  DATA 30,19
0085:  DATA 30,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 0D,00
008A:  DATA BD,1E
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA 0D,00
009B:  DATA 42,36
009C:  DATA F5,32
009D:  DATA F4,37
009E:  DATA 6F,3A
009F:  DATA 68,10
00A0:  DATA C2,30
00A1:  DATA F3,35
00A2:  DATA 65,3A
00A3:  DATA E2,30
00A4:  DATA 6C,36
00A5:  DATA A0,29
00A6:  DATA E3,37
00A7:  DATA F2,32
00A8:  DATA 20,21
00A9:  DATA EF,30
00AA:  DATA 72,32
00AB:  DATA 0D,00
00AC:  DATA BD,1E
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA 0D,00
00BD:  DATA D6,32
00BE:  DATA F2,39
00BF:  DATA E9,37
00C0:  DATA 6E,10
00C1:  DATA A5,39
00C2:  DATA A0,16
00C3:  DATA 20,39
00C4:  DATA 65,3B
00C5:  DATA A0,12
00C6:  DATA 73,10
00C7:  DATA 0D,00
00C8:  DATA 31,17
00C9:  DATA 35,00
00CA:  DATA 44,00
00CB:  DATA 2A,15
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 0D,00
00DC:  DATA 20,10
00DD:  DATA C4,22
00DE:  DATA D0,2A
00DF:  DATA D2,20
00E0:  DATA C3,24
00E1:  DATA 4F,27
00E2:  DATA 20,1D
00E3:  DATA 3A,10
00E4:  DATA C3,27
00E5:  DATA CD,2A
00E6:  DATA CE,24
00E7:  DATA C3,20
00E8:  DATA C3,24
00E9:  DATA 4F,27
00EA:  DATA C5,29
00EB:  DATA 20,10
00EC:  DATA 0D,00
00ED:  DATA 47,39
00EE:  DATA 75,38
00EF:  DATA 6F,10
00F0:  DATA 41,28
00F1:  DATA 4D,10
00F2:  DATA A8,31
00F3:  DATA 29,10
00F4:  DATA 32,18
00F5:  DATA 32,18
00F6:  DATA 20,1D
00F7:  DATA 3A,10
00F8:  DATA 42,21
00F9:  DATA 53,21
00FA:  DATA A0,18
00FB:  DATA 2E,18
00FC:  DATA 20,39
00FD:  DATA 65,3B
00FE:  DATA A0,20
00FF:  DATA 00,00
0100:  DATA 3E,10
0101:  DATA C3,37
0102:  DATA 6E,33
0103:  DATA E9,33
0104:  DATA 75,39
0105:  DATA E1,31
0106:  DATA E9,37
0107:  DATA 6E,10
0108:  DATA E4,32
0109:  DATA 20,28
010A:  DATA F5,32
010B:  DATA 72,3A
010C:  DATA EF,39
010D:  DATA 00,01
010E:  DATA 3E,10
010F:  DATA 49,37
0110:  DATA E9,31
0111:  DATA E9,30
0112:  DATA EC,34
0113:  DATA FA,30
0114:  DATA E3,34
0115:  DATA 6F,37
0116:  DATA 20,32
0117:  DATA 65,10
0118:  DATA 49,19
0119:  DATA 43,00
011A:  DATA 3E,10
011B:  DATA 49,37
011C:  DATA E9,31
011D:  DATA E9,30
011E:  DATA EC,34
011F:  DATA FA,30
0120:  DATA E3,34
0121:  DATA 6F,37
0122:  DATA 20,32
0123:  DATA 65,10
0124:  DATA ED,37
0125:  DATA E4,3A
0126:  DATA EC,37
0127:  DATA 20,3A
0128:  DATA E9,32
0129:  DATA 6D,38
012A:  DATA 6F,00
012B:  DATA 3E,10
012C:  DATA 49,37
012D:  DATA E9,31
012E:  DATA E9,30
012F:  DATA EC,34
0130:  DATA FA,30
0131:  DATA E3,34
0132:  DATA 6F,37
0133:  DATA 20,32
0134:  DATA 65,10
0135:  DATA ED,37
0136:  DATA E4,3A
0137:  DATA EC,37
0138:  DATA 20,38
0139:  DATA 75,37
013A:  DATA F4,37
013B:  DATA 73,00
013C:  DATA 3E,10
013D:  DATA C8,30
013E:  DATA E2,34
013F:  DATA EC,34
0140:  DATA F4,30
0141:  DATA E3,34
0142:  DATA 6F,37
0143:  DATA 20,32
0144:  DATA 65,10
0145:  DATA E4,34
0146:  DATA 73,38
0147:  DATA EC,30
0148:  DATA F9,39
0149:  DATA 00,01
014A:  DATA 3E,10
014B:  DATA C8,30
014C:  DATA E2,34
014D:  DATA EC,34
014E:  DATA F4,30
014F:  DATA E3,34
0150:  DATA 6F,37
0151:  DATA 20,32
0152:  DATA 65,10
0153:  DATA 69,37
0154:  DATA F4,32
0155:  DATA 72,39
0156:  DATA 75,38
0157:  DATA E3,34
0158:  DATA 6F,37
0159:  DATA E5,39
015A:  DATA 00,00
015B:  MOVF   0B,W
015C:  BSF    03.5
015D:  MOVWF  2B
015E:  BCF    03.5
015F:  BCF    0B.7
0160:  BSF    03.5
0161:  BSF    03.6
0162:  BSF    0C.7
0163:  BSF    0C.0
0164:  NOP
0165:  NOP
0166:  BCF    03.6
0167:  BTFSS  2B.7
0168:  GOTO   16C
0169:  BCF    03.5
016A:  BSF    0B.7
016B:  BSF    03.5
016C:  BCF    03.5
016D:  BSF    03.6
016E:  MOVF   0C,W
016F:  ANDLW  7F
0170:  BTFSC  03.2
0171:  GOTO   1CF
0172:  BSF    03.5
0173:  BCF    03.6
0174:  MOVWF  2B
0175:  BCF    03.5
0176:  BSF    03.6
0177:  MOVF   0D,W
0178:  BSF    03.5
0179:  BCF    03.6
017A:  MOVWF  2C
017B:  BCF    03.5
017C:  BSF    03.6
017D:  MOVF   0F,W
017E:  BSF    03.5
017F:  BCF    03.6
0180:  MOVWF  2D
0181:  MOVF   2B,W
0182:  BCF    03.5
0183:  BTFSS  0C.4
0184:  GOTO   183
0185:  MOVWF  19
0186:  BSF    03.5
0187:  MOVF   2C,W
0188:  BCF    03.5
0189:  BSF    03.6
018A:  MOVWF  0D
018B:  BSF    03.5
018C:  BCF    03.6
018D:  MOVF   2D,W
018E:  BCF    03.5
018F:  BSF    03.6
0190:  MOVWF  0F
0191:  BCF    03.6
0192:  MOVF   0B,W
0193:  BSF    03.5
0194:  MOVWF  2E
0195:  BCF    03.5
0196:  BCF    0B.7
0197:  BSF    03.5
0198:  BSF    03.6
0199:  BSF    0C.7
019A:  BSF    0C.0
019B:  NOP
019C:  NOP
019D:  BCF    03.6
019E:  BTFSS  2E.7
019F:  GOTO   1A3
01A0:  BCF    03.5
01A1:  BSF    0B.7
01A2:  BSF    03.5
01A3:  BCF    03.5
01A4:  BSF    03.6
01A5:  RLF    0C,W
01A6:  RLF    0E,W
01A7:  ANDLW  7F
01A8:  BTFSC  03.2
01A9:  GOTO   1CF
01AA:  BSF    03.5
01AB:  BCF    03.6
01AC:  MOVWF  2B
01AD:  BCF    03.5
01AE:  BSF    03.6
01AF:  MOVF   0D,W
01B0:  BSF    03.5
01B1:  BCF    03.6
01B2:  MOVWF  2C
01B3:  BCF    03.5
01B4:  BSF    03.6
01B5:  MOVF   0F,W
01B6:  BSF    03.5
01B7:  BCF    03.6
01B8:  MOVWF  2D
01B9:  MOVF   2B,W
01BA:  BCF    03.5
01BB:  BTFSS  0C.4
01BC:  GOTO   1BB
01BD:  MOVWF  19
01BE:  BSF    03.5
01BF:  MOVF   2C,W
01C0:  BCF    03.5
01C1:  BSF    03.6
01C2:  MOVWF  0D
01C3:  BSF    03.5
01C4:  BCF    03.6
01C5:  MOVF   2D,W
01C6:  BCF    03.5
01C7:  BSF    03.6
01C8:  MOVWF  0F
01C9:  INCF   0D,F
01CA:  BTFSC  03.2
01CB:  INCF   0F,F
01CC:  BCF    03.6
01CD:  GOTO   15B
01CE:  BSF    03.6
01CF:  BCF    03.6
01D0:  RETURN
*
0211:  BCF    0A.0
0212:  BSF    0A.1
0213:  BCF    0A.2
0214:  ADDWF  02,F
0215:  GOTO   1DA
0216:  GOTO   1DF
0217:  GOTO   1E4
0218:  GOTO   1E9
0219:  GOTO   1EE
021A:  GOTO   1F3
021B:  GOTO   1F8
021C:  GOTO   1FD
021D:  GOTO   202
021E:  GOTO   207
021F:  BSF    03.5
0220:  MOVF   31,W
0221:  ANDLW  07
0222:  MOVWF  77
0223:  RRF    31,W
0224:  MOVWF  78
0225:  RRF    78,F
0226:  RRF    78,F
0227:  MOVLW  1F
0228:  ANDWF  78,F
0229:  MOVF   78,W
022A:  ADDWF  33,W
022B:  MOVWF  04
022C:  BCF    03.7
022D:  BTFSC  34.0
022E:  BSF    03.7
022F:  CLRF   78
0230:  INCF   78,F
0231:  INCF   77,F
0232:  GOTO   234
0233:  RLF    78,F
0234:  DECFSZ 77,F
0235:  GOTO   233
0236:  MOVF   32,F
0237:  BTFSC  03.2
0238:  GOTO   23C
0239:  MOVF   78,W
023A:  IORWF  00,F
023B:  GOTO   23F
023C:  COMF   78,F
023D:  MOVF   78,W
023E:  ANDWF  00,F
023F:  BCF    03.5
0240:  RETURN
*
02C8:  BCF    0A.0
02C9:  BSF    0A.1
02CA:  BCF    0A.2
02CB:  ADDWF  02,F
02CC:  GOTO   24E
02CD:  GOTO   251
02CE:  GOTO   254
02CF:  GOTO   258
02D0:  GOTO   25B
02D1:  GOTO   25F
02D2:  GOTO   263
02D3:  GOTO   268
02D4:  GOTO   26B
*
0390:  DATA 3E,10
0391:  DATA D2,3A
0392:  DATA F4,34
0393:  DATA EE,30
0394:  DATA 20,32
0395:  DATA 65,10
0396:  DATA 70,39
0397:  DATA F5,32
0398:  DATA E2,30
0399:  DATA 00,01
039A:  DATA 3E,10
039B:  DATA 50,39
039C:  DATA 6F,31
039D:  DATA 61,37
039E:  DATA E4,37
039F:  DATA A0,36
03A0:  DATA 6F,32
03A1:  DATA 75,36
03A2:  DATA 6F,10
03A3:  DATA F4,34
03A4:  DATA E5,36
03A5:  DATA F0,37
03A6:  DATA 00,01
03A7:  DATA 3E,10
03A8:  DATA 50,39
03A9:  DATA 6F,31
03AA:  DATA 61,37
03AB:  DATA E4,37
03AC:  DATA A0,36
03AD:  DATA 6F,32
03AE:  DATA 75,36
03AF:  DATA 6F,10
03B0:  DATA F0,3A
03B1:  DATA 6E,3A
03B2:  DATA EF,39
03B3:  DATA 00,01
03B4:  DATA 3E,10
03B5:  DATA 50,39
03B6:  DATA 6F,31
03B7:  DATA 61,37
03B8:  DATA E4,37
03B9:  DATA A0,36
03BA:  DATA 6F,32
03BB:  DATA 75,36
03BC:  DATA 6F,10
03BD:  DATA E3,37
03BE:  DATA ED,3A
03BF:  DATA EE,34
03C0:  DATA E3,30
03C1:  DATA E3,34
03C2:  DATA 6F,37
03C3:  DATA E5,39
03C4:  DATA 00,00
03C5:  DATA 0D,1F
03C6:  DATA A0,20
03C7:  DATA 63,3A
03C8:  DATA 69,3B
03C9:  DATA E1,31
03CA:  DATA E9,37
03CB:  DATA 6E,10
03CC:  DATA ED,30
03CD:  DATA EE,3A
03CE:  DATA 61,36
03CF:  DATA 20,32
03D0:  DATA 65,10
03D1:  DATA F0,3A
03D2:  DATA 65,39
03D3:  DATA F4,37
03D4:  DATA 00,01
03D5:  DATA 0D,1F
03D6:  DATA 20,2A
03D7:  DATA EF,38
03D8:  DATA F5,32
03D9:  DATA A0,31
03DA:  DATA 6F,39
03DB:  DATA F4,37
03DC:  DATA 00,01
03DD:  DATA 0D,1F
03DE:  DATA 20,2A
03DF:  DATA EF,38
03E0:  DATA F5,32
03E1:  DATA 20,36
03E2:  DATA 61,39
03E3:  DATA E7,37
03E4:  DATA 00,01
03E5:  DATA 0D,1F
03E6:  DATA 20,2A
03E7:  DATA EF,38
03E8:  DATA F5,32
03E9:  DATA 20,32
03EA:  DATA 6F,31
03EB:  DATA EC,32
03EC:  DATA 00,01
03ED:  DATA 0D,1F
03EE:  DATA A0,20
03EF:  DATA F3,34
03F0:  DATA 67,37
03F1:  DATA 61,39
03F2:  DATA 20,33
03F3:  DATA 61,36
03F4:  DATA F4,30
03F5:  DATA 73,00
03F6:  DATA 0D,1F
03F7:  DATA A0,20
03F8:  DATA F3,34
03F9:  DATA 67,37
03FA:  DATA 61,39
03FB:  DATA 20,35
03FC:  DATA F5,33
03FD:  DATA 61,32
03FE:  DATA 6F,39
03FF:  DATA 00,01
0400:  DATA 0D,1F
0401:  DATA A0,21
0402:  DATA EF,36
0403:  DATA 61,37
0404:  DATA E4,37
0405:  DATA 20,36
0406:  DATA EF,31
0407:  DATA 61,36
0408:  DATA 00,01
0409:  DATA 0D,1F
040A:  DATA 20,29
040B:  DATA E5,39
040C:  DATA 65,3A
040D:  DATA E5,30
040E:  DATA A0,30
040F:  DATA 20,18
0410:  DATA 00,01
0411:  DATA 0D,1F
0412:  DATA A0,24
0413:  DATA EE,31
0414:  DATA F2,32
0415:  DATA ED,32
0416:  DATA 6E,3A
0417:  DATA 61,39
0418:  DATA 20,38
0419:  DATA 6F,39
041A:  DATA A0,18
041B:  DATA 00,01
041C:  DATA 0D,1F
041D:  DATA A0,24
041E:  DATA EE,31
041F:  DATA F2,32
0420:  DATA ED,32
0421:  DATA 6E,3A
0422:  DATA 61,39
0423:  DATA 20,38
0424:  DATA 6F,39
0425:  DATA 20,19
0426:  DATA 00,01
0427:  DATA 0D,1F
0428:  DATA A0,24
0429:  DATA EE,31
042A:  DATA F2,32
042B:  DATA ED,32
042C:  DATA 6E,3A
042D:  DATA 61,39
042E:  DATA 20,38
042F:  DATA 6F,39
0430:  DATA A0,19
0431:  DATA 00,01
0432:  DATA 0D,1F
0433:  DATA 20,22
0434:  DATA E5,31
0435:  DATA F2,32
0436:  DATA ED,32
0437:  DATA 6E,3A
0438:  DATA 61,39
0439:  DATA 20,38
043A:  DATA 6F,39
043B:  DATA A0,18
043C:  DATA 00,01
043D:  DATA 0D,1F
043E:  DATA A0,24
043F:  DATA EE,34
0440:  DATA E3,34
0441:  DATA 61,36
0442:  DATA 69,3D
0443:  DATA 61,39
0444:  DATA 00,01
0445:  DATA 0D,1F
0446:  DATA A0,20
0447:  DATA F3,34
0448:  DATA 67,37
0449:  DATA 61,39
044A:  DATA 20,38
044B:  DATA EF,39
044C:  DATA E9,31
044D:  DATA E9,37
044E:  DATA 6E,00
044F:  DATA 0D,1F
0450:  DATA 20,28
0451:  DATA E1,3A
0452:  DATA F3,30
0453:  DATA 72,10
0454:  DATA F4,34
0455:  DATA E5,36
0456:  DATA F0,37
0457:  DATA 00,01
0458:  DATA 0D,1F
0459:  DATA 20,29
045A:  DATA 65,37
045B:  DATA 75,32
045C:  DATA 61,39
045D:  DATA 20,3A
045E:  DATA E9,32
045F:  DATA 6D,38
0460:  DATA 6F,00
0461:  DATA 0D,1F
0462:  DATA A0,20
0463:  DATA F0,30
0464:  DATA E7,30
0465:  DATA 72,10
0466:  DATA D0,32
0467:  DATA F2,34
0468:  DATA 6F,32
0469:  DATA EF,39
046A:  DATA 00,01
046B:  DATA 0D,1F
046C:  DATA 20,28
046D:  DATA 65,39
046E:  DATA E9,37
046F:  DATA E4,37
0470:  DATA A0,18
0471:  DATA 00,01
0472:  DATA 0D,1F
0473:  DATA 20,28
0474:  DATA 65,39
0475:  DATA E9,37
0476:  DATA E4,37
0477:  DATA 20,19
0478:  DATA 00,01
0479:  DATA 0D,1F
047A:  DATA 20,28
047B:  DATA 65,39
047C:  DATA E9,37
047D:  DATA E4,37
047E:  DATA A0,19
047F:  DATA 00,01
0480:  DATA 0D,1F
0481:  DATA 20,28
0482:  DATA 65,39
0483:  DATA E9,37
0484:  DATA E4,37
0485:  DATA 20,1A
0486:  DATA 00,01
0487:  DATA 0D,1F
0488:  DATA A0,21
0489:  DATA 6F,37
048A:  DATA E6,34
048B:  DATA E7,3A
048C:  DATA F2,30
048D:  DATA E3,34
048E:  DATA 6F,37
048F:  DATA 20,32
0490:  DATA 65,10
0491:  DATA F4,34
0492:  DATA F2,37
0493:  DATA 00,01
0494:  DATA 0D,1F
0495:  DATA A0,21
0496:  DATA 6F,37
0497:  DATA E6,34
0498:  DATA E7,3A
0499:  DATA F2,30
049A:  DATA E3,34
049B:  DATA 6F,37
049C:  DATA 20,32
049D:  DATA 65,10
049E:  DATA F4,34
049F:  DATA E5,36
04A0:  DATA F0,37
04A1:  DATA 00,01
04A2:  DATA 0D,1F
04A3:  DATA A0,21
04A4:  DATA EF,36
04A5:  DATA 61,37
04A6:  DATA E4,37
04A7:  DATA 20,3B
04A8:  DATA E9,39
04A9:  DATA 69,3A
04AA:  DATA 61,37
04AB:  DATA F4,32
04AC:  DATA 00,01
04AD:  DATA 0D,1F
04AE:  DATA 20,29
04AF:  DATA E5,39
04B0:  DATA 65,3A
04B1:  DATA E5,30
04B2:  DATA A0,30
04B3:  DATA 20,18
04B4:  DATA 00,01
04B5:  DATA 0D,1F
04B6:  DATA A0,24
04B7:  DATA EE,31
04B8:  DATA F2,32
04B9:  DATA ED,32
04BA:  DATA 6E,3A
04BB:  DATA 61,39
04BC:  DATA 20,38
04BD:  DATA 6F,39
04BE:  DATA A0,18
04BF:  DATA 00,01
04C0:  DATA 0D,1F
04C1:  DATA A0,24
04C2:  DATA EE,31
04C3:  DATA F2,32
04C4:  DATA ED,32
04C5:  DATA 6E,3A
04C6:  DATA 61,39
04C7:  DATA 20,38
04C8:  DATA 6F,39
04C9:  DATA 20,19
04CA:  DATA 00,01
04CB:  DATA 0D,1F
04CC:  DATA A0,24
04CD:  DATA EE,31
04CE:  DATA F2,32
04CF:  DATA ED,32
04D0:  DATA 6E,3A
04D1:  DATA 61,39
04D2:  DATA 20,38
04D3:  DATA 6F,39
04D4:  DATA A0,19
04D5:  DATA 00,01
04D6:  DATA 0D,1F
04D7:  DATA 20,22
04D8:  DATA E5,31
04D9:  DATA F2,32
04DA:  DATA ED,32
04DB:  DATA 6E,3A
04DC:  DATA 61,39
04DD:  DATA 20,38
04DE:  DATA 6F,39
04DF:  DATA A0,18
04E0:  DATA 00,01
04E1:  DATA 0D,1F
04E2:  DATA A0,24
04E3:  DATA EE,34
04E4:  DATA E3,34
04E5:  DATA 61,36
04E6:  DATA 69,3D
04E7:  DATA 61,39
04E8:  DATA 00,01
04E9:  DATA 0D,1F
04EA:  DATA A0,20
04EB:  DATA F3,34
04EC:  DATA 67,37
04ED:  DATA 61,39
04EE:  DATA 20,38
04EF:  DATA EF,39
04F0:  DATA E9,31
04F1:  DATA E9,37
04F2:  DATA 6E,00
04F3:  DATA 0D,1F
04F4:  DATA 20,29
04F5:  DATA E5,39
04F6:  DATA 65,3A
04F7:  DATA E5,37
04F8:  DATA A0,33
04F9:  DATA 65,37
04FA:  DATA 65,39
04FB:  DATA 61,36
04FC:  DATA 2E,17
04FD:  DATA AE,10
04FE:  DATA 00,00
04FF:  MOVF   0B,W
0500:  MOVWF  6C
0501:  BCF    0B.7
0502:  BSF    03.5
0503:  BSF    03.6
0504:  BSF    0C.7
0505:  BSF    0C.0
0506:  NOP
0507:  NOP
0508:  BCF    03.5
0509:  BCF    03.6
050A:  BTFSC  6C.7
050B:  BSF    0B.7
050C:  BSF    03.6
050D:  MOVF   0C,W
050E:  ANDLW  7F
050F:  BTFSC  03.2
0510:  GOTO   555
0511:  BCF    03.6
0512:  MOVWF  6C
0513:  BSF    03.6
0514:  MOVF   0D,W
0515:  BCF    03.6
0516:  MOVWF  6D
0517:  BSF    03.6
0518:  MOVF   0F,W
0519:  BCF    03.6
051A:  MOVWF  6E
051B:  MOVF   6C,W
051C:  BTFSS  0C.4
051D:  GOTO   51C
051E:  MOVWF  19
051F:  MOVF   6D,W
0520:  BSF    03.6
0521:  MOVWF  0D
0522:  BCF    03.6
0523:  MOVF   6E,W
0524:  BSF    03.6
0525:  MOVWF  0F
0526:  BCF    03.6
0527:  MOVF   0B,W
0528:  MOVWF  6F
0529:  BCF    0B.7
052A:  BSF    03.5
052B:  BSF    03.6
052C:  BSF    0C.7
052D:  BSF    0C.0
052E:  NOP
052F:  NOP
0530:  BCF    03.5
0531:  BCF    03.6
0532:  BTFSC  6F.7
0533:  BSF    0B.7
0534:  BSF    03.6
0535:  RLF    0C,W
0536:  RLF    0E,W
0537:  ANDLW  7F
0538:  BTFSC  03.2
0539:  GOTO   555
053A:  BCF    03.6
053B:  MOVWF  6C
053C:  BSF    03.6
053D:  MOVF   0D,W
053E:  BCF    03.6
053F:  MOVWF  6D
0540:  BSF    03.6
0541:  MOVF   0F,W
0542:  BCF    03.6
0543:  MOVWF  6E
0544:  MOVF   6C,W
0545:  BTFSS  0C.4
0546:  GOTO   545
0547:  MOVWF  19
0548:  MOVF   6D,W
0549:  BSF    03.6
054A:  MOVWF  0D
054B:  BCF    03.6
054C:  MOVF   6E,W
054D:  BSF    03.6
054E:  MOVWF  0F
054F:  INCF   0D,F
0550:  BTFSC  03.2
0551:  INCF   0F,F
0552:  BCF    03.6
0553:  GOTO   4FF
0554:  BSF    03.6
0555:  BCF    03.6
0556:  RETURN
0557:  MOVF   0B,W
0558:  MOVWF  6D
0559:  BCF    0B.7
055A:  BSF    03.5
055B:  BSF    03.6
055C:  BSF    0C.7
055D:  BSF    0C.0
055E:  NOP
055F:  NOP
0560:  BCF    03.5
0561:  BCF    03.6
0562:  BTFSC  6D.7
0563:  BSF    0B.7
0564:  BTFSC  03.0
0565:  GOTO   594
0566:  BSF    03.6
0567:  MOVF   0C,W
0568:  ANDLW  7F
0569:  BCF    03.6
056A:  MOVWF  6D
056B:  BSF    03.6
056C:  MOVF   0D,W
056D:  BCF    03.6
056E:  MOVWF  6E
056F:  BSF    03.6
0570:  MOVF   0F,W
0571:  BCF    03.6
0572:  MOVWF  6F
0573:  MOVF   6D,W
0574:  BTFSS  0C.4
0575:  GOTO   574
0576:  MOVWF  19
0577:  MOVF   6E,W
0578:  BSF    03.6
0579:  MOVWF  0D
057A:  BCF    03.6
057B:  MOVF   6F,W
057C:  BSF    03.6
057D:  MOVWF  0F
057E:  BCF    03.6
057F:  MOVF   0B,W
0580:  MOVWF  70
0581:  BCF    0B.7
0582:  BSF    03.5
0583:  BSF    03.6
0584:  BSF    0C.7
0585:  BSF    0C.0
0586:  NOP
0587:  NOP
0588:  BTFSS  70.7
0589:  GOTO   58F
058A:  BCF    03.5
058B:  BCF    03.6
058C:  BSF    0B.7
058D:  BSF    03.5
058E:  BSF    03.6
058F:  BCF    03.5
0590:  BCF    03.6
0591:  DECFSZ 6C,F
0592:  GOTO   594
0593:  GOTO   5B4
0594:  BSF    03.6
0595:  RLF    0C,W
0596:  RLF    0E,W
0597:  ANDLW  7F
0598:  BCF    03.6
0599:  MOVWF  6D
059A:  BSF    03.6
059B:  MOVF   0D,W
059C:  BCF    03.6
059D:  MOVWF  6E
059E:  BSF    03.6
059F:  MOVF   0F,W
05A0:  BCF    03.6
05A1:  MOVWF  6F
05A2:  MOVF   6D,W
05A3:  BTFSS  0C.4
05A4:  GOTO   5A3
05A5:  MOVWF  19
05A6:  MOVF   6E,W
05A7:  BSF    03.6
05A8:  MOVWF  0D
05A9:  BCF    03.6
05AA:  MOVF   6F,W
05AB:  BSF    03.6
05AC:  MOVWF  0F
05AD:  INCF   0D,F
05AE:  BTFSC  03.2
05AF:  INCF   0F,F
05B0:  BCF    03.0
05B1:  BCF    03.6
05B2:  DECFSZ 6C,F
05B3:  GOTO   557
05B4:  RETURN
*
0EB5:  BCF    0A.0
0EB6:  BSF    0A.1
0EB7:  BSF    0A.2
0EB8:  ADDWF  02,F
0EB9:  GOTO   061
0EBA:  GOTO   082
0EBB:  GOTO   0A3
0EBC:  GOTO   0C4
0EBD:  BCF    0A.0
0EBE:  BSF    0A.1
0EBF:  BSF    0A.2
0EC0:  ADDWF  02,F
0EC1:  GOTO   300
0EC2:  GOTO   325
0EC3:  GOTO   34A
0EC4:  GOTO   36F
0EC5:  GOTO   394
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "1.5" 
.................... #define FW_REVISION  "D" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
0310:  MOVLW  B2
0311:  MOVWF  04
0312:  BCF    03.7
0313:  MOVF   00,W
0314:  BTFSC  03.2
0315:  GOTO   323
0316:  MOVLW  02
0317:  MOVWF  78
0318:  CLRF   77
0319:  DECFSZ 77,F
031A:  GOTO   319
031B:  DECFSZ 78,F
031C:  GOTO   318
031D:  MOVLW  97
031E:  MOVWF  77
031F:  DECFSZ 77,F
0320:  GOTO   31F
0321:  DECFSZ 00,F
0322:  GOTO   316
0323:  RETURN
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Master,Fast,sda=I2C_SDA,scl=I2C_SCL) 
*
02D5:  BCF    14.7
02D6:  BCF    0C.3
02D7:  BSF    03.5
02D8:  MOVF   38,W
02D9:  BCF    03.5
02DA:  MOVWF  13
02DB:  MOVLW  02
02DC:  BTFSC  14.7
02DD:  GOTO   2E5
02DE:  BTFSS  0C.3
02DF:  GOTO   2DE
02E0:  MOVLW  00
02E1:  BSF    03.5
02E2:  BTFSC  11.6
02E3:  MOVLW  01
02E4:  BCF    03.5
02E5:  MOVWF  78
02E6:  RETURN
.................... #use timer  (timer=0,tick=100us,bits=32,NOISR) 
*
077E:  MOVF   01,W
077F:  BTFSS  0B.2
0780:  GOTO   78B
0781:  MOVLW  01
0782:  ADDWF  2C,F
0783:  BTFSC  03.0
0784:  INCF   2D,F
0785:  BTFSC  03.2
0786:  INCF   2E,F
0787:  BTFSC  03.2
0788:  INCF   2F,F
0789:  BCF    0B.2
078A:  MOVF   01,W
078B:  MOVWF  77
078C:  MOVF   2C,W
078D:  MOVWF  78
078E:  MOVF   2D,W
078F:  MOVWF  79
0790:  MOVF   2E,W
0791:  MOVWF  7A
0792:  MOVF   2F,W
0793:  MOVWF  6C
0794:  RRF    6C,F
0795:  RRF    7A,F
0796:  RRF    79,F
0797:  RRF    78,F
0798:  RRF    77,F
0799:  RETURN
....................  
.................... //-- DEFINICIONES -- 
.................... #define TICK_TYPE       unsigned int32 
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       200 
.................... #define I2CWAIT         50 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... //-- DECLARACIONES -- 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
104D:  BCF    03.6
104E:  CLRF   30
104F:  CLRF   31
1050:  CLRF   32
1051:  CLRF   33
1052:  CLRF   34
1053:  CLRF   35
1054:  CLRF   36
1055:  CLRF   37
1056:  CLRF   38
1057:  CLRF   39
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
1058:  CLRF   3A
1059:  CLRF   3B
105A:  CLRF   3C
105B:  CLRF   3D
105C:  CLRF   3E
105D:  CLRF   3F
105E:  CLRF   40
105F:  CLRF   41
1060:  CLRF   42
1061:  CLRF   43
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... //Puertos de Displays 
.................... tPort pNJugadorU; 
.................... tPort pNJugadorD; 
.................... tPort pFJugadorU; 
.................... tPort pFJugadorD; 
....................  
.................... //Tiempo 
.................... int8 m_d=0; 
.................... int8 m_u=0; 
.................... int8 s_d=0; 
.................... int8 s_u=0; 
.................... int1 enableTime = false; 
....................  
.................... //Tiro 
.................... int8 sh_d=0; 
.................... int8 sh_u=0; 
.................... int1 enableShot = false; 
....................  
.................... int1 pauseTime = false; 
....................  
.................... int16 scoreL =0; 
.................... int16 scoreV =0; 
....................  
.................... //-- PROTOTIPOS -- 
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick); 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void timeTick(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8  char2int(char);  
.................... void doReset(void); 
.................... void sendN2Port(int8, int8, int8); 
.................... void timeSet(int8, int8, int8, int8); 
.................... void shotSet(int8, int8); 
.................... void timePass(); 
.................... void shotPass(); 
.................... void doBuzz(int); 
.................... void showScoreL(void); 
.................... void showScoreV(void); 
.................... void i2c_send(int8, int8); 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
1062:  CLRF   60
1063:  CLRF   61
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
05B5:  MOVLW  0F
05B6:  BSF    03.5
05B7:  MOVWF  05
05B8:  BCF    03.5
05B9:  CLRF   05
....................    output_b(0x00); 
05BA:  BSF    03.5
05BB:  CLRF   06
05BC:  BCF    03.5
05BD:  CLRF   06
....................    output_c(0x00); 
05BE:  MOVLW  DF
05BF:  BSF    03.5
05C0:  MOVWF  07
05C1:  BCF    03.5
05C2:  CLRF   07
....................    output_d(0x00); 
05C3:  BSF    03.5
05C4:  CLRF   08
05C5:  BCF    03.5
05C6:  CLRF   08
....................    output_e(0x00); 
05C7:  BSF    03.5
05C8:  BCF    09.0
05C9:  BCF    09.1
05CA:  BCF    09.2
05CB:  BCF    09.3
05CC:  BCF    03.5
05CD:  CLRF   09
05CE:  CLRF   2B
05CF:  BTFSC  0B.7
05D0:  BSF    2B.7
05D1:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
05D2:  MOVLW  C8
05D3:  BSF    03.5
05D4:  MOVWF  32
05D5:  BCF    03.5
05D6:  CALL   310
05D7:  BTFSC  2B.7
05D8:  BSF    0B.7
....................     
....................    if(DEBUG) 
05D9:  BTFSS  07.2
05DA:  GOTO   637
....................    { 
....................       fprintf(RS232,"********************************\r"); 
05DB:  MOVLW  68
05DC:  BSF    03.6
05DD:  MOVWF  0D
05DE:  MOVLW  00
05DF:  MOVWF  0F
05E0:  BCF    03.6
05E1:  CALL   4FF
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
05E2:  MOVLW  79
05E3:  BSF    03.6
05E4:  MOVWF  0D
05E5:  MOVLW  00
05E6:  MOVWF  0F
05E7:  BCF    03.6
05E8:  CALL   4FF
....................       fprintf(RS232,"================================\r"); 
05E9:  MOVLW  8A
05EA:  BSF    03.6
05EB:  MOVWF  0D
05EC:  MOVLW  00
05ED:  MOVWF  0F
05EE:  BCF    03.6
05EF:  CALL   4FF
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
05F0:  MOVLW  9B
05F1:  BSF    03.6
05F2:  MOVWF  0D
05F3:  MOVLW  00
05F4:  MOVWF  0F
05F5:  BCF    03.6
05F6:  CALL   4FF
....................       fprintf(RS232,"================================\r"); 
05F7:  MOVLW  AC
05F8:  BSF    03.6
05F9:  MOVWF  0D
05FA:  MOVLW  00
05FB:  MOVWF  0F
05FC:  BCF    03.6
05FD:  CALL   4FF
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
05FE:  MOVLW  BD
05FF:  BSF    03.6
0600:  MOVWF  0D
0601:  MOVLW  00
0602:  MOVWF  0F
0603:  BCF    03.0
0604:  MOVLW  08
0605:  BCF    03.6
0606:  MOVWF  6C
0607:  CALL   557
0608:  MOVLW  C8
0609:  BSF    03.6
060A:  MOVWF  0D
060B:  MOVLW  00
060C:  MOVWF  0F
060D:  BCF    03.6
060E:  CALL   4FF
060F:  MOVLW  C2
0610:  BSF    03.6
0611:  MOVWF  0D
0612:  MOVLW  00
0613:  MOVWF  0F
0614:  BCF    03.0
0615:  MOVLW  07
0616:  BCF    03.6
0617:  MOVWF  6C
0618:  CALL   557
0619:  MOVLW  CA
061A:  BSF    03.6
061B:  MOVWF  0D
061C:  MOVLW  00
061D:  MOVWF  0F
061E:  BCF    03.6
061F:  CALL   4FF
0620:  MOVLW  20
0621:  BTFSS  0C.4
0622:  GOTO   621
0623:  MOVWF  19
0624:  MOVLW  0D
0625:  BTFSS  0C.4
0626:  GOTO   625
0627:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0628:  MOVLW  CB
0629:  BSF    03.6
062A:  MOVWF  0D
062B:  MOVLW  00
062C:  MOVWF  0F
062D:  BCF    03.6
062E:  CALL   4FF
....................       fprintf(RS232,"  DEPURACION :: COMUNICACIONES  \r"); 
062F:  MOVLW  DC
0630:  BSF    03.6
0631:  MOVWF  0D
0632:  MOVLW  00
0633:  MOVWF  0F
0634:  BCF    03.6
0635:  CALL   4FF
....................    } 
0636:  GOTO   64C
....................    else 
....................    { 
....................       fputs("Grupo APM (c) 2020 :: BBSB 1.0 rev A",RS232); 
0637:  MOVLW  ED
0638:  BSF    03.6
0639:  MOVWF  0D
063A:  MOVLW  00
063B:  MOVWF  0F
063C:  BCF    03.6
063D:  CLRF   2B
063E:  BTFSC  0B.7
063F:  BSF    2B.7
0640:  BCF    0B.7
0641:  CALL   15B
0642:  BTFSC  2B.7
0643:  BSF    0B.7
0644:  MOVLW  0D
0645:  BTFSS  0C.4
0646:  GOTO   645
0647:  MOVWF  19
0648:  MOVLW  0A
0649:  BTFSS  0C.4
064A:  GOTO   649
064B:  MOVWF  19
064C:  CLRF   2B
064D:  BTFSC  0B.7
064E:  BSF    2B.7
064F:  BCF    0B.7
....................    } 
....................     
....................    delay_ms(DEFAULT_D); 
0650:  MOVLW  C8
0651:  BSF    03.5
0652:  MOVWF  32
0653:  BCF    03.5
0654:  CALL   310
0655:  BTFSC  2B.7
0656:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
0657:  BTFSS  07.2
0658:  GOTO   66E
0659:  MOVLW  00
065A:  BSF    03.6
065B:  MOVWF  0D
065C:  MOVLW  01
065D:  MOVWF  0F
065E:  BCF    03.6
065F:  CLRF   2B
0660:  BTFSC  0B.7
0661:  BSF    2B.7
0662:  BCF    0B.7
0663:  CALL   15B
0664:  BTFSC  2B.7
0665:  BSF    0B.7
0666:  MOVLW  0D
0667:  BTFSS  0C.4
0668:  GOTO   667
0669:  MOVWF  19
066A:  MOVLW  0A
066B:  BTFSS  0C.4
066C:  GOTO   66B
066D:  MOVWF  19
....................    //TODO: Activar puertos 
....................    pNJugadorU.a = PIN_B0; 
066E:  MOVLW  30
066F:  MOVWF  46
....................    pNJugadorU.b = PIN_B1; 
0670:  MOVLW  31
0671:  MOVWF  47
....................    pNJugadorU.c = PIN_B2; 
0672:  MOVLW  32
0673:  MOVWF  48
....................    pNJugadorU.d = PIN_B3; 
0674:  MOVLW  33
0675:  MOVWF  49
....................     
....................    pNJugadorD.a = PIN_B4; 
0676:  MOVLW  34
0677:  MOVWF  4A
....................    pNJugadorD.b = PIN_B5; 
0678:  MOVLW  35
0679:  MOVWF  4B
....................    pNJugadorD.c = PIN_B6; 
067A:  MOVLW  36
067B:  MOVWF  4C
....................    pNJugadorD.d = PIN_B7; 
067C:  MOVLW  37
067D:  MOVWF  4D
....................     
....................    pFJugadorU.a = PIN_D0; 
067E:  MOVLW  40
067F:  MOVWF  4E
....................    pFJugadorU.b = PIN_D1; 
0680:  MOVLW  41
0681:  MOVWF  4F
....................    pFJugadorU.c = PIN_D2; 
0682:  MOVLW  42
0683:  MOVWF  50
....................    pFJugadorU.d = PIN_D3; 
0684:  MOVLW  43
0685:  MOVWF  51
....................     
....................    pFJugadorD.a = PIN_D4; 
0686:  MOVLW  44
0687:  MOVWF  52
....................    pFJugadorD.b = PIN_D5; 
0688:  MOVLW  45
0689:  MOVWF  53
....................    pFJugadorD.c = PIN_D6; 
068A:  MOVLW  46
068B:  MOVWF  54
....................    pFJugadorD.d = PIN_D7; 
068C:  MOVLW  47
068D:  MOVWF  55
068E:  CLRF   2B
068F:  BTFSC  0B.7
0690:  BSF    2B.7
0691:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0692:  MOVLW  C8
0693:  BSF    03.5
0694:  MOVWF  32
0695:  BCF    03.5
0696:  CALL   310
0697:  BTFSC  2B.7
0698:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Inicializacion de I2C",RS232);} 
0699:  BTFSS  07.2
069A:  GOTO   6B0
069B:  MOVLW  0E
069C:  BSF    03.6
069D:  MOVWF  0D
069E:  MOVLW  01
069F:  MOVWF  0F
06A0:  BCF    03.6
06A1:  CLRF   2B
06A2:  BTFSC  0B.7
06A3:  BSF    2B.7
06A4:  BCF    0B.7
06A5:  CALL   15B
06A6:  BTFSC  2B.7
06A7:  BSF    0B.7
06A8:  MOVLW  0D
06A9:  BTFSS  0C.4
06AA:  GOTO   6A9
06AB:  MOVWF  19
06AC:  MOVLW  0A
06AD:  BTFSS  0C.4
06AE:  GOTO   6AD
06AF:  MOVWF  19
....................    i2c_speed(100000); 
06B0:  MOVLW  13
06B1:  BSF    03.5
06B2:  MOVWF  13
06B3:  MOVLW  28
06B4:  BCF    03.5
06B5:  MOVWF  14
06B6:  BSF    03.5
06B7:  BSF    14.7
....................     
....................    if(DEBUG) {fputs("> Inicializacion de modulo tiempo",RS232);} 
06B8:  BCF    03.5
06B9:  BTFSS  07.2
06BA:  GOTO   6D0
06BB:  MOVLW  1A
06BC:  BSF    03.6
06BD:  MOVWF  0D
06BE:  MOVLW  01
06BF:  MOVWF  0F
06C0:  BCF    03.6
06C1:  CLRF   2B
06C2:  BTFSC  0B.7
06C3:  BSF    2B.7
06C4:  BCF    0B.7
06C5:  CALL   15B
06C6:  BTFSC  2B.7
06C7:  BSF    0B.7
06C8:  MOVLW  0D
06C9:  BTFSS  0C.4
06CA:  GOTO   6C9
06CB:  MOVWF  19
06CC:  MOVLW  0A
06CD:  BTFSS  0C.4
06CE:  GOTO   6CD
06CF:  MOVWF  19
06D0:  CLRF   2B
06D1:  BTFSC  0B.7
06D2:  BSF    2B.7
06D3:  BCF    0B.7
....................    i2c_send(I2C_TIMER, I2C_CMD_INIT); 
06D4:  MOVLW  0A
06D5:  BSF    03.5
06D6:  MOVWF  36
06D7:  MOVLW  F0
06D8:  MOVWF  37
06D9:  BCF    03.5
06DA:  CALL   2FD
06DB:  BTFSC  2B.7
06DC:  BSF    0B.7
06DD:  CLRF   2B
06DE:  BTFSC  0B.7
06DF:  BSF    2B.7
06E0:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
06E1:  MOVLW  C8
06E2:  BSF    03.5
06E3:  MOVWF  32
06E4:  BCF    03.5
06E5:  CALL   310
06E6:  BTFSC  2B.7
06E7:  BSF    0B.7
....................  
....................    if(DEBUG) {fputs("> Inicializacion de modulo puntos",RS232);} 
06E8:  BTFSS  07.2
06E9:  GOTO   6FF
06EA:  MOVLW  2B
06EB:  BSF    03.6
06EC:  MOVWF  0D
06ED:  MOVLW  01
06EE:  MOVWF  0F
06EF:  BCF    03.6
06F0:  CLRF   2B
06F1:  BTFSC  0B.7
06F2:  BSF    2B.7
06F3:  BCF    0B.7
06F4:  CALL   15B
06F5:  BTFSC  2B.7
06F6:  BSF    0B.7
06F7:  MOVLW  0D
06F8:  BTFSS  0C.4
06F9:  GOTO   6F8
06FA:  MOVWF  19
06FB:  MOVLW  0A
06FC:  BTFSS  0C.4
06FD:  GOTO   6FC
06FE:  MOVWF  19
06FF:  CLRF   2B
0700:  BTFSC  0B.7
0701:  BSF    2B.7
0702:  BCF    0B.7
....................    i2c_send(I2C_SCORE, I2C_CMD_INIT); 
0703:  MOVLW  0C
0704:  BSF    03.5
0705:  MOVWF  36
0706:  MOVLW  F0
0707:  MOVWF  37
0708:  BCF    03.5
0709:  CALL   2FD
070A:  BTFSC  2B.7
070B:  BSF    0B.7
070C:  CLRF   2B
070D:  BTFSC  0B.7
070E:  BSF    2B.7
070F:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0710:  MOVLW  C8
0711:  BSF    03.5
0712:  MOVWF  32
0713:  BCF    03.5
0714:  CALL   310
0715:  BTFSC  2B.7
0716:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de displays",RS232);} 
0717:  BTFSS  07.2
0718:  GOTO   72E
0719:  MOVLW  3C
071A:  BSF    03.6
071B:  MOVWF  0D
071C:  MOVLW  01
071D:  MOVWF  0F
071E:  BCF    03.6
071F:  CLRF   2B
0720:  BTFSC  0B.7
0721:  BSF    2B.7
0722:  BCF    0B.7
0723:  CALL   15B
0724:  BTFSC  2B.7
0725:  BSF    0B.7
0726:  MOVLW  0D
0727:  BTFSS  0C.4
0728:  GOTO   727
0729:  MOVWF  19
072A:  MOVLW  0A
072B:  BTFSS  0C.4
072C:  GOTO   72B
072D:  MOVWF  19
....................    output_bit(DISPLAY, ON); 
072E:  BSF    09.0
072F:  MOVLW  EE
0730:  BSF    03.5
0731:  MOVWF  09
0732:  BCF    03.5
0733:  CLRF   2B
0734:  BTFSC  0B.7
0735:  BSF    2B.7
0736:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0737:  MOVLW  C8
0738:  BSF    03.5
0739:  MOVWF  32
073A:  BCF    03.5
073B:  CALL   310
073C:  BTFSC  2B.7
073D:  BSF    0B.7
....................    output_bit(DISPLAY, OFF); 
073E:  BCF    09.0
073F:  MOVLW  EE
0740:  BSF    03.5
0741:  MOVWF  09
0742:  BCF    03.5
0743:  CLRF   2B
0744:  BTFSC  0B.7
0745:  BSF    2B.7
0746:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0747:  MOVLW  C8
0748:  BSF    03.5
0749:  MOVWF  32
074A:  BCF    03.5
074B:  CALL   310
074C:  BTFSC  2B.7
074D:  BSF    0B.7
....................    output_bit(DISPLAY, ON); 
074E:  BSF    09.0
074F:  MOVLW  EE
0750:  BSF    03.5
0751:  MOVWF  09
0752:  BCF    03.5
0753:  CLRF   2B
0754:  BTFSC  0B.7
0755:  BSF    2B.7
0756:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0757:  MOVLW  C8
0758:  BSF    03.5
0759:  MOVWF  32
075A:  BCF    03.5
075B:  CALL   310
075C:  BTFSC  2B.7
075D:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
075E:  BTFSS  07.2
075F:  GOTO   775
0760:  MOVLW  4A
0761:  BSF    03.6
0762:  MOVWF  0D
0763:  MOVLW  01
0764:  MOVWF  0F
0765:  BCF    03.6
0766:  CLRF   2B
0767:  BTFSC  0B.7
0768:  BSF    2B.7
0769:  BCF    0B.7
076A:  CALL   15B
076B:  BTFSC  2B.7
076C:  BSF    0B.7
076D:  MOVLW  0D
076E:  BTFSS  0C.4
076F:  GOTO   76E
0770:  MOVWF  19
0771:  MOVLW  0A
0772:  BTFSS  0C.4
0773:  GOTO   772
0774:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
0775:  BSF    03.5
0776:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0777:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0778:  MOVLW  C0
0779:  BCF    03.5
077A:  IORWF  0B,F
077B:  BCF    0A.3
077C:  BSF    0A.4
077D:  GOTO   066 (RETURN)
.................... } 
....................  
.................... void main() 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  71
1004:  BSF    03.5
1005:  MOVWF  0F
1006:  CLRF   10
1007:  MOVF   0F,W
1008:  BSF    03.6
1009:  BCF    07.3
100A:  MOVLW  0C
100B:  BCF    03.6
100C:  MOVWF  19
100D:  MOVLW  A2
100E:  MOVWF  18
100F:  MOVLW  90
1010:  BCF    03.5
1011:  MOVWF  18
1012:  MOVLW  DF
1013:  BSF    03.5
1014:  MOVWF  07
1015:  MOVLW  DF
1016:  MOVWF  07
1017:  MOVLW  04
1018:  MOVWF  13
1019:  MOVLW  28
101A:  BCF    03.5
101B:  MOVWF  14
101C:  BSF    03.5
101D:  BCF    14.7
101E:  BCF    14.6
101F:  BCF    03.5
1020:  CLRF   2F
1021:  CLRF   2E
1022:  CLRF   2D
1023:  CLRF   2C
1024:  BSF    03.5
1025:  MOVF   01,W
1026:  ANDLW  C0
1027:  IORLW  06
1028:  MOVWF  01
1029:  BCF    03.5
102A:  CLRF   01
102B:  BCF    0B.2
102C:  CLRF   44
102D:  BCF    45.0
102E:  CLRF   56
102F:  CLRF   57
1030:  CLRF   58
1031:  CLRF   59
1032:  BCF    45.1
1033:  CLRF   5A
1034:  CLRF   5B
1035:  BCF    45.2
1036:  BCF    45.3
1037:  CLRF   5D
1038:  CLRF   5C
1039:  CLRF   5F
103A:  CLRF   5E
103B:  CLRF   63
103C:  CLRF   62
103D:  BSF    03.5
103E:  BSF    03.6
103F:  MOVF   09,W
1040:  ANDLW  C0
1041:  MOVWF  09
1042:  BCF    03.6
1043:  BCF    1F.4
1044:  BCF    1F.5
1045:  MOVLW  00
1046:  BSF    03.6
1047:  MOVWF  08
1048:  BCF    03.5
1049:  CLRF   07
104A:  CLRF   08
104B:  CLRF   09
104C:  BCF    03.7
.................... { 
....................    setup(); 
*
1064:  BCF    0A.4
1065:  GOTO   5B5
1066:  BSF    0A.4
....................     
....................    TICK_TYPE CurrentTick,PreviousTick; 
....................  
....................    CurrentTick = PreviousTick = get_ticks(); 
1067:  BCF    0A.4
1068:  CALL   77E
1069:  BSF    0A.4
106A:  MOVF   7A,W
106B:  MOVWF  6B
106C:  MOVF   79,W
106D:  MOVWF  6A
106E:  MOVF   78,W
106F:  MOVWF  69
1070:  MOVF   77,W
1071:  MOVWF  68
1072:  MOVF   6B,W
1073:  MOVWF  67
1074:  MOVF   6A,W
1075:  MOVWF  66
1076:  MOVF   69,W
1077:  MOVWF  65
1078:  MOVF   68,W
1079:  MOVWF  64
....................  
....................    while(TRUE) 
....................    { 
....................       if(!pauseTime) 
107A:  BTFSC  45.3
107B:  GOTO   1E9
....................       { 
....................       CurrentTick = get_ticks(); 
107C:  BCF    0A.4
107D:  CALL   77E
107E:  BSF    0A.4
107F:  MOVF   7A,W
1080:  MOVWF  67
1081:  MOVF   79,W
1082:  MOVWF  66
1083:  MOVF   78,W
1084:  MOVWF  65
1085:  MOVF   77,W
1086:  MOVWF  64
....................  
....................          if(GetTickDifference(CurrentTick, PreviousTick) >= (TICK_TYPE)TICKS_PER_SECOND) 
1087:  MOVF   67,W
1088:  MOVWF  6F
1089:  MOVF   66,W
108A:  MOVWF  6E
108B:  MOVF   65,W
108C:  MOVWF  6D
108D:  MOVF   64,W
108E:  MOVWF  6C
108F:  MOVF   6B,W
1090:  MOVWF  73
1091:  MOVF   6A,W
1092:  MOVWF  72
1093:  MOVF   69,W
1094:  MOVWF  71
1095:  MOVF   68,W
1096:  MOVWF  70
1097:  BCF    0A.4
1098:  GOTO   79A
1099:  BSF    0A.4
109A:  MOVF   7A,W
109B:  MOVWF  6F
109C:  MOVF   79,W
109D:  MOVWF  6E
109E:  MOVF   78,W
109F:  MOVWF  6D
10A0:  MOVF   77,W
10A1:  MOVWF  6C
10A2:  MOVF   6F,F
10A3:  BTFSS  03.2
10A4:  GOTO   0B3
10A5:  MOVF   6E,F
10A6:  BTFSS  03.2
10A7:  GOTO   0B3
10A8:  MOVF   6D,W
10A9:  SUBLW  1D
10AA:  BTFSC  03.0
10AB:  GOTO   1E9
10AC:  XORLW  FF
10AD:  BTFSS  03.2
10AE:  GOTO   0B3
10AF:  MOVF   6C,W
10B0:  SUBLW  83
10B1:  BTFSC  03.0
10B2:  GOTO   1E9
....................          { 
....................             timeTick(); 
....................             PreviousTick = CurrentTick; 
*
11E1:  MOVF   67,W
11E2:  MOVWF  6B
11E3:  MOVF   66,W
11E4:  MOVWF  6A
11E5:  MOVF   65,W
11E6:  MOVWF  69
11E7:  MOVF   64,W
11E8:  MOVWF  68
....................          } 
....................       } 
11E9:  GOTO   07A
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
11EA:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
0334:  BTFSS  0C.5
0335:  GOTO   334
0336:  MOVF   1A,W
0337:  MOVWF  7B
.................... if(cmdGet) 
0338:  BTFSS  45.0
0339:  GOTO   36E
.................... { 
....................    if(c == '#' || c == '\r') 
033A:  MOVF   7B,W
033B:  SUBLW  23
033C:  BTFSC  03.2
033D:  GOTO   342
033E:  MOVF   7B,W
033F:  SUBLW  0D
0340:  BTFSS  03.2
0341:  GOTO   363
....................    { 
....................       cmdGet = false; 
0342:  BCF    45.0
....................       strcpy(cmd, rcmd); 
0343:  BSF    03.5
0344:  CLRF   23
0345:  MOVLW  3A
0346:  MOVWF  22
0347:  CLRF   21
0348:  MOVLW  30
0349:  MOVWF  20
034A:  MOVF   22,W
034B:  MOVWF  04
034C:  BCF    03.7
034D:  BTFSC  23.0
034E:  BSF    03.7
034F:  MOVF   00,W
0350:  MOVWF  24
0351:  MOVF   20,W
0352:  MOVWF  04
0353:  BCF    03.7
0354:  BTFSC  21.0
0355:  BSF    03.7
0356:  MOVF   24,W
0357:  MOVWF  00
0358:  MOVF   00,F
0359:  BTFSC  03.2
035A:  GOTO   35E
035B:  INCF   20,F
035C:  INCF   22,F
035D:  GOTO   34A
....................       parseCommand(); 
035E:  BSF    0A.3
035F:  BCF    03.5
0360:  GOTO   000
0361:  BCF    0A.3
....................    } 
0362:  GOTO   36E
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
0363:  MOVF   44,W
0364:  SUBLW  08
0365:  BTFSS  03.0
0366:  GOTO   36E
....................       { 
....................          rcmd[cmdIndex] = c; 
0367:  MOVLW  3A
0368:  ADDWF  44,W
0369:  MOVWF  04
036A:  BCF    03.7
036B:  MOVF   7B,W
036C:  MOVWF  00
....................          cmdIndex++; 
036D:  INCF   44,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
036E:  MOVF   7B,W
036F:  SUBLW  2D
0370:  BTFSS  03.2
0371:  GOTO   388
....................    { 
....................        cmdGet = true;  
0372:  BSF    45.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0"; 
0373:  BSF    03.5
0374:  CLRF   20
0375:  CLRF   21
0376:  MOVLW  3A
0377:  MOVWF  04
0378:  BCF    03.7
0379:  MOVF   20,W
037A:  ADDWF  04,F
037B:  MOVF   21,W
037C:  BCF    03.5
037D:  CALL   05A
037E:  MOVWF  00
037F:  IORLW  00
0380:  BTFSC  03.2
0381:  GOTO   387
0382:  BSF    03.5
0383:  INCF   21,F
0384:  INCF   20,F
0385:  GOTO   376
0386:  BCF    03.5
....................        cmdIndex = 0; 
0387:  CLRF   44
....................    } 
.................... } 
....................  
0388:  BCF    0C.5
0389:  BCF    0A.3
038A:  BCF    0A.4
038B:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
.................... { 
....................  
038C:  BCF    0C.3
038D:  BCF    0A.3
038E:  BCF    0A.4
038F:  GOTO   033
.................... } 
....................  
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick) 
.................... { 
....................    return(currTick-prevTick); 
*
079A:  MOVF   70,W
079B:  SUBWF  6C,W
079C:  MOVWF  77
079D:  MOVF   6D,W
079E:  MOVWF  78
079F:  MOVF   71,W
07A0:  BTFSS  03.0
07A1:  INCFSZ 71,W
07A2:  SUBWF  78,F
07A3:  MOVF   6E,W
07A4:  MOVWF  79
07A5:  MOVF   72,W
07A6:  BTFSS  03.0
07A7:  INCFSZ 72,W
07A8:  SUBWF  79,F
07A9:  MOVF   6F,W
07AA:  MOVWF  7A
07AB:  MOVF   73,W
07AC:  BTFSS  03.0
07AD:  INCFSZ 73,W
07AE:  SUBWF  7A,F
07AF:  BCF    0A.3
07B0:  BSF    0A.4
07B1:  GOTO   099 (RETURN)
.................... } 
....................  
.................... void timeTick(void) 
.................... { 
....................    if(enableTime) 
*
10B3:  BTFSS  45.1
10B4:  GOTO   188
....................       timePass(); 
....................    if(enableShot) 
*
1188:  BTFSS  45.2
1189:  GOTO   1E1
....................       shotPass(); 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
0DA7:  BTFSS  07.2
0DA8:  GOTO   5BA
0DA9:  MOVLW  90
0DAA:  BSF    03.6
0DAB:  MOVWF  0D
0DAC:  MOVLW  03
0DAD:  MOVWF  0F
0DAE:  BCF    0A.3
0DAF:  BCF    03.6
0DB0:  CALL   15B
0DB1:  BSF    0A.3
0DB2:  MOVLW  0D
0DB3:  BTFSS  0C.4
0DB4:  GOTO   5B3
0DB5:  MOVWF  19
0DB6:  MOVLW  0A
0DB7:  BTFSS  0C.4
0DB8:  GOTO   5B7
0DB9:  MOVWF  19
....................     
....................    if(DEBUG) {fputs("> Probando modulo tiempo",RS232);} 
0DBA:  BTFSS  07.2
0DBB:  GOTO   5CD
0DBC:  MOVLW  9A
0DBD:  BSF    03.6
0DBE:  MOVWF  0D
0DBF:  MOVLW  03
0DC0:  MOVWF  0F
0DC1:  BCF    0A.3
0DC2:  BCF    03.6
0DC3:  CALL   15B
0DC4:  BSF    0A.3
0DC5:  MOVLW  0D
0DC6:  BTFSS  0C.4
0DC7:  GOTO   5C6
0DC8:  MOVWF  19
0DC9:  MOVLW  0A
0DCA:  BTFSS  0C.4
0DCB:  GOTO   5CA
0DCC:  MOVWF  19
....................    i2c_send(I2C_TIMER, I2C_CMD_TEST); 
0DCD:  MOVLW  0A
0DCE:  BSF    03.5
0DCF:  MOVWF  36
0DD0:  MOVLW  FF
0DD1:  MOVWF  37
0DD2:  BCF    0A.3
0DD3:  BCF    03.5
0DD4:  CALL   2FD
0DD5:  BSF    0A.3
....................  
....................    if(DEBUG) {fputs("> Probando modulo puntos",RS232);} 
0DD6:  BTFSS  07.2
0DD7:  GOTO   5E9
0DD8:  MOVLW  A7
0DD9:  BSF    03.6
0DDA:  MOVWF  0D
0DDB:  MOVLW  03
0DDC:  MOVWF  0F
0DDD:  BCF    0A.3
0DDE:  BCF    03.6
0DDF:  CALL   15B
0DE0:  BSF    0A.3
0DE1:  MOVLW  0D
0DE2:  BTFSS  0C.4
0DE3:  GOTO   5E2
0DE4:  MOVWF  19
0DE5:  MOVLW  0A
0DE6:  BTFSS  0C.4
0DE7:  GOTO   5E6
0DE8:  MOVWF  19
....................    i2c_send(I2C_SCORE, I2C_CMD_TEST); 
0DE9:  MOVLW  0C
0DEA:  BSF    03.5
0DEB:  MOVWF  36
0DEC:  MOVLW  FF
0DED:  MOVWF  37
0DEE:  BCF    0A.3
0DEF:  BCF    03.5
0DF0:  CALL   2FD
0DF1:  BSF    0A.3
....................  
....................    if(DEBUG) {fputs("> Probando modulo comunicaciones",RS232);} 
0DF2:  BTFSS  07.2
0DF3:  GOTO   605
0DF4:  MOVLW  B4
0DF5:  BSF    03.6
0DF6:  MOVWF  0D
0DF7:  MOVLW  03
0DF8:  MOVWF  0F
0DF9:  BCF    0A.3
0DFA:  BCF    03.6
0DFB:  CALL   15B
0DFC:  BSF    0A.3
0DFD:  MOVLW  0D
0DFE:  BTFSS  0C.4
0DFF:  GOTO   5FE
0E00:  MOVWF  19
0E01:  MOVLW  0A
0E02:  BTFSS  0C.4
0E03:  GOTO   602
0E04:  MOVWF  19
....................    for(int i=0; i<10; i++) 
0E05:  BSF    03.5
0E06:  CLRF   2A
0E07:  MOVF   2A,W
0E08:  SUBLW  09
0E09:  BTFSS  03.0
0E0A:  GOTO   670
....................    { 
....................       showNumber(i, pNJugadorD); 
0E0B:  MOVF   2A,W
0E0C:  MOVWF  2B
0E0D:  BCF    03.5
0E0E:  MOVF   4D,W
0E0F:  BSF    03.5
0E10:  MOVWF  2F
0E11:  BCF    03.5
0E12:  MOVF   4C,W
0E13:  BSF    03.5
0E14:  MOVWF  2E
0E15:  BCF    03.5
0E16:  MOVF   4B,W
0E17:  BSF    03.5
0E18:  MOVWF  2D
0E19:  BCF    03.5
0E1A:  MOVF   4A,W
0E1B:  BSF    03.5
0E1C:  MOVWF  2C
0E1D:  BCF    0A.3
0E1E:  BCF    03.5
0E1F:  CALL   241
0E20:  BSF    0A.3
....................       showNumber(i, pNJugadorU); 
0E21:  BSF    03.5
0E22:  MOVF   2A,W
0E23:  MOVWF  2B
0E24:  BCF    03.5
0E25:  MOVF   49,W
0E26:  BSF    03.5
0E27:  MOVWF  2F
0E28:  BCF    03.5
0E29:  MOVF   48,W
0E2A:  BSF    03.5
0E2B:  MOVWF  2E
0E2C:  BCF    03.5
0E2D:  MOVF   47,W
0E2E:  BSF    03.5
0E2F:  MOVWF  2D
0E30:  BCF    03.5
0E31:  MOVF   46,W
0E32:  BSF    03.5
0E33:  MOVWF  2C
0E34:  BCF    0A.3
0E35:  BCF    03.5
0E36:  CALL   241
0E37:  BSF    0A.3
....................       showNumber(i, pFJugadorD); 
0E38:  BSF    03.5
0E39:  MOVF   2A,W
0E3A:  MOVWF  2B
0E3B:  BCF    03.5
0E3C:  MOVF   55,W
0E3D:  BSF    03.5
0E3E:  MOVWF  2F
0E3F:  BCF    03.5
0E40:  MOVF   54,W
0E41:  BSF    03.5
0E42:  MOVWF  2E
0E43:  BCF    03.5
0E44:  MOVF   53,W
0E45:  BSF    03.5
0E46:  MOVWF  2D
0E47:  BCF    03.5
0E48:  MOVF   52,W
0E49:  BSF    03.5
0E4A:  MOVWF  2C
0E4B:  BCF    0A.3
0E4C:  BCF    03.5
0E4D:  CALL   241
0E4E:  BSF    0A.3
....................       showNumber(i, pFJugadorU); 
0E4F:  BSF    03.5
0E50:  MOVF   2A,W
0E51:  MOVWF  2B
0E52:  BCF    03.5
0E53:  MOVF   51,W
0E54:  BSF    03.5
0E55:  MOVWF  2F
0E56:  BCF    03.5
0E57:  MOVF   50,W
0E58:  BSF    03.5
0E59:  MOVWF  2E
0E5A:  BCF    03.5
0E5B:  MOVF   4F,W
0E5C:  BSF    03.5
0E5D:  MOVWF  2D
0E5E:  BCF    03.5
0E5F:  MOVF   4E,W
0E60:  BSF    03.5
0E61:  MOVWF  2C
0E62:  BCF    0A.3
0E63:  BCF    03.5
0E64:  CALL   241
0E65:  BSF    0A.3
....................       delay_ms(DEFAULT_D); 
0E66:  MOVLW  C8
0E67:  BSF    03.5
0E68:  MOVWF  32
0E69:  BCF    0A.3
0E6A:  BCF    03.5
0E6B:  CALL   310
0E6C:  BSF    0A.3
0E6D:  BSF    03.5
0E6E:  INCF   2A,F
0E6F:  GOTO   607
....................    } 
.................... } 
....................  
.................... void doBuzz(int t) 
.................... { 
....................    i2c_start(); 
*
02E7:  BSF    03.5
02E8:  BSF    11.0
02E9:  BTFSC  11.0
02EA:  GOTO   2E9
....................    i2c_write(I2C_TIMER); 
02EB:  MOVLW  0A
02EC:  MOVWF  38
02ED:  BCF    03.5
02EE:  CALL   2D5
....................    i2c_write(0x80 + t); 
02EF:  MOVLW  80
02F0:  BSF    03.5
02F1:  ADDWF  2A,W
02F2:  MOVWF  2B
02F3:  MOVWF  38
02F4:  BCF    03.5
02F5:  CALL   2D5
....................    i2c_stop(); 
02F6:  BSF    03.5
02F7:  BSF    11.2
02F8:  BTFSC  11.2
02F9:  GOTO   2F8
02FA:  BCF    03.5
02FB:  RETURN
.................... } 
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
0800:  BSF    03.5
0801:  CLRF   2D
0802:  MOVLW  30
0803:  MOVWF  2C
0804:  CLRF   2B
0805:  MOVLW  A0
0806:  MOVWF  2A
0807:  MOVF   2C,W
0808:  MOVWF  04
0809:  BCF    03.7
080A:  BTFSC  2D.0
080B:  BSF    03.7
080C:  MOVF   00,W
080D:  MOVWF  2E
080E:  MOVF   2A,W
080F:  MOVWF  04
0810:  BCF    03.7
0811:  BTFSC  2B.0
0812:  BSF    03.7
0813:  MOVF   2E,W
0814:  MOVWF  00
0815:  MOVF   00,F
0816:  BTFSC  03.2
0817:  GOTO   01B
0818:  INCF   2A,F
0819:  INCF   2C,F
081A:  GOTO   007
....................    switch(c[0]) 
081B:  MOVF   20,W
081C:  XORLW  30
081D:  BCF    03.5
081E:  BTFSC  03.2
081F:  GOTO   045
0820:  XORLW  72
0821:  BTFSC  03.2
0822:  GOTO   0E8
0823:  XORLW  04
0824:  BTFSC  03.2
0825:  GOTO   147
0826:  XORLW  0C
0827:  BTFSC  03.2
0828:  GOTO   199
0829:  XORLW  06
082A:  BTFSC  03.2
082B:  GOTO   1EB
082C:  XORLW  1C
082D:  BTFSC  03.2
082E:  GOTO   2CD
082F:  XORLW  01
0830:  BTFSC  03.2
0831:  GOTO   2E2
0832:  XORLW  03
0833:  BTFSC  03.2
0834:  GOTO   2F7
0835:  XORLW  01
0836:  BTFSC  03.2
0837:  GOTO   3BC
0838:  XORLW  07
0839:  BTFSC  03.2
083A:  GOTO   413
083B:  XORLW  02
083C:  BTFSC  03.2
083D:  GOTO   4BE
083E:  XORLW  0E
083F:  BTFSC  03.2
0840:  GOTO   5A7
0841:  XORLW  02
0842:  BTFSC  03.2
0843:  GOTO   672
0844:  GOTO   6B2
....................    { 
....................       case '0':   if(DEBUG) {fputs("\r> Activacion manual de puerto",RS232);} 
0845:  BTFSS  07.2
0846:  GOTO   058
0847:  MOVLW  C5
0848:  BSF    03.6
0849:  MOVWF  0D
084A:  MOVLW  03
084B:  MOVWF  0F
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   15B
084F:  BSF    0A.3
0850:  MOVLW  0D
0851:  BTFSS  0C.4
0852:  GOTO   051
0853:  MOVWF  19
0854:  MOVLW  0A
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
....................                   switch(c[2]) 
0858:  MOVLW  31
0859:  BSF    03.5
085A:  SUBWF  22,W
085B:  ADDLW  FC
085C:  BTFSC  03.0
085D:  GOTO   0E6
085E:  ADDLW  04
085F:  BCF    03.5
0860:  GOTO   6B5
....................                   { 
....................                      case '1':   showNumber(char2int(c[3]), pNJugadorD); 
0861:  BSF    03.5
0862:  MOVF   23,W
0863:  MOVWF  2D
0864:  BCF    0A.3
0865:  BCF    03.5
0866:  CALL   1D1
0867:  BSF    0A.3
0868:  MOVF   78,W
0869:  BSF    03.5
086A:  MOVWF  2A
086B:  MOVWF  2B
086C:  BCF    03.5
086D:  MOVF   4D,W
086E:  BSF    03.5
086F:  MOVWF  2F
0870:  BCF    03.5
0871:  MOVF   4C,W
0872:  BSF    03.5
0873:  MOVWF  2E
0874:  BCF    03.5
0875:  MOVF   4B,W
0876:  BSF    03.5
0877:  MOVWF  2D
0878:  BCF    03.5
0879:  MOVF   4A,W
087A:  BSF    03.5
087B:  MOVWF  2C
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   241
087F:  BSF    0A.3
....................                                  break; 
0880:  BSF    03.5
0881:  GOTO   0E6
....................                      case '2':   showNumber(char2int(c[3]), pNJugadorU); 
0882:  BSF    03.5
0883:  MOVF   23,W
0884:  MOVWF  2D
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   1D1
0888:  BSF    0A.3
0889:  MOVF   78,W
088A:  BSF    03.5
088B:  MOVWF  2A
088C:  MOVWF  2B
088D:  BCF    03.5
088E:  MOVF   49,W
088F:  BSF    03.5
0890:  MOVWF  2F
0891:  BCF    03.5
0892:  MOVF   48,W
0893:  BSF    03.5
0894:  MOVWF  2E
0895:  BCF    03.5
0896:  MOVF   47,W
0897:  BSF    03.5
0898:  MOVWF  2D
0899:  BCF    03.5
089A:  MOVF   46,W
089B:  BSF    03.5
089C:  MOVWF  2C
089D:  BCF    0A.3
089E:  BCF    03.5
089F:  CALL   241
08A0:  BSF    0A.3
....................                                  break; 
08A1:  BSF    03.5
08A2:  GOTO   0E6
....................                      case '3':   showNumber(char2int(c[3]), pFJugadorD); 
08A3:  BSF    03.5
08A4:  MOVF   23,W
08A5:  MOVWF  2D
08A6:  BCF    0A.3
08A7:  BCF    03.5
08A8:  CALL   1D1
08A9:  BSF    0A.3
08AA:  MOVF   78,W
08AB:  BSF    03.5
08AC:  MOVWF  2A
08AD:  MOVWF  2B
08AE:  BCF    03.5
08AF:  MOVF   55,W
08B0:  BSF    03.5
08B1:  MOVWF  2F
08B2:  BCF    03.5
08B3:  MOVF   54,W
08B4:  BSF    03.5
08B5:  MOVWF  2E
08B6:  BCF    03.5
08B7:  MOVF   53,W
08B8:  BSF    03.5
08B9:  MOVWF  2D
08BA:  BCF    03.5
08BB:  MOVF   52,W
08BC:  BSF    03.5
08BD:  MOVWF  2C
08BE:  BCF    0A.3
08BF:  BCF    03.5
08C0:  CALL   241
08C1:  BSF    0A.3
....................                                  break; 
08C2:  BSF    03.5
08C3:  GOTO   0E6
....................                      case '4':   showNumber(char2int(c[3]), pFJugadorU); 
08C4:  BSF    03.5
08C5:  MOVF   23,W
08C6:  MOVWF  2D
08C7:  BCF    0A.3
08C8:  BCF    03.5
08C9:  CALL   1D1
08CA:  BSF    0A.3
08CB:  MOVF   78,W
08CC:  BSF    03.5
08CD:  MOVWF  2A
08CE:  MOVWF  2B
08CF:  BCF    03.5
08D0:  MOVF   51,W
08D1:  BSF    03.5
08D2:  MOVWF  2F
08D3:  BCF    03.5
08D4:  MOVF   50,W
08D5:  BSF    03.5
08D6:  MOVWF  2E
08D7:  BCF    03.5
08D8:  MOVF   4F,W
08D9:  BSF    03.5
08DA:  MOVWF  2D
08DB:  BCF    03.5
08DC:  MOVF   4E,W
08DD:  BSF    03.5
08DE:  MOVWF  2C
08DF:  BCF    0A.3
08E0:  BCF    03.5
08E1:  CALL   241
08E2:  BSF    0A.3
....................                                  break; 
08E3:  BSF    03.5
08E4:  GOTO   0E6
08E5:  BSF    03.5
....................                   } 
....................                   break; 
08E6:  BCF    03.5
08E7:  GOTO   6B2
....................       case 'B':   switch(c[1]) 
08E8:  BSF    03.5
08E9:  MOVF   21,W
08EA:  XORLW  31
08EB:  BCF    03.5
08EC:  BTFSC  03.2
08ED:  GOTO   0F5
08EE:  XORLW  03
08EF:  BTFSC  03.2
08F0:  GOTO   110
08F1:  XORLW  01
08F2:  BTFSC  03.2
08F3:  GOTO   12B
08F4:  GOTO   146
....................                   { 
....................                      case '1':   if(DEBUG) {fputs("\r> Toque corto",RS232);} 
08F5:  BTFSS  07.2
08F6:  GOTO   108
08F7:  MOVLW  D5
08F8:  BSF    03.6
08F9:  MOVWF  0D
08FA:  MOVLW  03
08FB:  MOVWF  0F
08FC:  BCF    0A.3
08FD:  BCF    03.6
08FE:  CALL   15B
08FF:  BSF    0A.3
0900:  MOVLW  0D
0901:  BTFSS  0C.4
0902:  GOTO   101
0903:  MOVWF  19
0904:  MOVLW  0A
0905:  BTFSS  0C.4
0906:  GOTO   105
0907:  MOVWF  19
....................                                  doBuzz(1); 
0908:  MOVLW  01
0909:  BSF    03.5
090A:  MOVWF  2A
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   2E7
090E:  BSF    0A.3
....................                                  break; 
090F:  GOTO   146
....................                      case '2':   if(DEBUG) {fputs("\r> Toque largo",RS232);} 
0910:  BTFSS  07.2
0911:  GOTO   123
0912:  MOVLW  DD
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  03
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   15B
091A:  BSF    0A.3
091B:  MOVLW  0D
091C:  BTFSS  0C.4
091D:  GOTO   11C
091E:  MOVWF  19
091F:  MOVLW  0A
0920:  BTFSS  0C.4
0921:  GOTO   120
0922:  MOVWF  19
....................                                  doBuzz(2); 
0923:  MOVLW  02
0924:  BSF    03.5
0925:  MOVWF  2A
0926:  BCF    0A.3
0927:  BCF    03.5
0928:  CALL   2E7
0929:  BSF    0A.3
....................                                  break; 
092A:  GOTO   146
....................                      case '3':   if(DEBUG) {fputs("\r> Toque doble",RS232);} 
092B:  BTFSS  07.2
092C:  GOTO   13E
092D:  MOVLW  E5
092E:  BSF    03.6
092F:  MOVWF  0D
0930:  MOVLW  03
0931:  MOVWF  0F
0932:  BCF    0A.3
0933:  BCF    03.6
0934:  CALL   15B
0935:  BSF    0A.3
0936:  MOVLW  0D
0937:  BTFSS  0C.4
0938:  GOTO   137
0939:  MOVWF  19
093A:  MOVLW  0A
093B:  BTFSS  0C.4
093C:  GOTO   13B
093D:  MOVWF  19
....................                                  doBuzz(3); 
093E:  MOVLW  03
093F:  BSF    03.5
0940:  MOVWF  2A
0941:  BCF    0A.3
0942:  BCF    03.5
0943:  CALL   2E7
0944:  BSF    0A.3
....................                                  break; 
0945:  GOTO   146
....................                   } 
....................                   break; 
0946:  GOTO   6B2
....................       case 'F':   if(DEBUG) {fputs("\r> Asignar faltas",RS232);} 
0947:  BTFSS  07.2
0948:  GOTO   15A
0949:  MOVLW  ED
094A:  BSF    03.6
094B:  MOVWF  0D
094C:  MOVLW  03
094D:  MOVWF  0F
094E:  BCF    0A.3
094F:  BCF    03.6
0950:  CALL   15B
0951:  BSF    0A.3
0952:  MOVLW  0D
0953:  BTFSS  0C.4
0954:  GOTO   153
0955:  MOVWF  19
0956:  MOVLW  0A
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
....................                   showNumber(char2int(c[1]), pFJugadorD); 
095A:  BSF    03.5
095B:  MOVF   21,W
095C:  MOVWF  2D
095D:  BCF    0A.3
095E:  BCF    03.5
095F:  CALL   1D1
0960:  BSF    0A.3
0961:  MOVF   78,W
0962:  BSF    03.5
0963:  MOVWF  2A
0964:  MOVWF  2B
0965:  BCF    03.5
0966:  MOVF   55,W
0967:  BSF    03.5
0968:  MOVWF  2F
0969:  BCF    03.5
096A:  MOVF   54,W
096B:  BSF    03.5
096C:  MOVWF  2E
096D:  BCF    03.5
096E:  MOVF   53,W
096F:  BSF    03.5
0970:  MOVWF  2D
0971:  BCF    03.5
0972:  MOVF   52,W
0973:  BSF    03.5
0974:  MOVWF  2C
0975:  BCF    0A.3
0976:  BCF    03.5
0977:  CALL   241
0978:  BSF    0A.3
....................                   showNumber(char2int(c[2]), pFJugadorU); 
0979:  BSF    03.5
097A:  MOVF   22,W
097B:  MOVWF  2D
097C:  BCF    0A.3
097D:  BCF    03.5
097E:  CALL   1D1
097F:  BSF    0A.3
0980:  MOVF   78,W
0981:  BSF    03.5
0982:  MOVWF  2A
0983:  MOVWF  2B
0984:  BCF    03.5
0985:  MOVF   51,W
0986:  BSF    03.5
0987:  MOVWF  2F
0988:  BCF    03.5
0989:  MOVF   50,W
098A:  BSF    03.5
098B:  MOVWF  2E
098C:  BCF    03.5
098D:  MOVF   4F,W
098E:  BSF    03.5
098F:  MOVWF  2D
0990:  BCF    03.5
0991:  MOVF   4E,W
0992:  BSF    03.5
0993:  MOVWF  2C
0994:  BCF    0A.3
0995:  BCF    03.5
0996:  CALL   241
0997:  BSF    0A.3
....................                   break; 
0998:  GOTO   6B2
....................       case 'J':   if(DEBUG) {fputs("\r> Asignar jugador",RS232);} 
0999:  BTFSS  07.2
099A:  GOTO   1AC
099B:  MOVLW  F6
099C:  BSF    03.6
099D:  MOVWF  0D
099E:  MOVLW  03
099F:  MOVWF  0F
09A0:  BCF    0A.3
09A1:  BCF    03.6
09A2:  CALL   15B
09A3:  BSF    0A.3
09A4:  MOVLW  0D
09A5:  BTFSS  0C.4
09A6:  GOTO   1A5
09A7:  MOVWF  19
09A8:  MOVLW  0A
09A9:  BTFSS  0C.4
09AA:  GOTO   1A9
09AB:  MOVWF  19
....................                   showNumber(char2int(c[1]), pNJugadorD); 
09AC:  BSF    03.5
09AD:  MOVF   21,W
09AE:  MOVWF  2D
09AF:  BCF    0A.3
09B0:  BCF    03.5
09B1:  CALL   1D1
09B2:  BSF    0A.3
09B3:  MOVF   78,W
09B4:  BSF    03.5
09B5:  MOVWF  2A
09B6:  MOVWF  2B
09B7:  BCF    03.5
09B8:  MOVF   4D,W
09B9:  BSF    03.5
09BA:  MOVWF  2F
09BB:  BCF    03.5
09BC:  MOVF   4C,W
09BD:  BSF    03.5
09BE:  MOVWF  2E
09BF:  BCF    03.5
09C0:  MOVF   4B,W
09C1:  BSF    03.5
09C2:  MOVWF  2D
09C3:  BCF    03.5
09C4:  MOVF   4A,W
09C5:  BSF    03.5
09C6:  MOVWF  2C
09C7:  BCF    0A.3
09C8:  BCF    03.5
09C9:  CALL   241
09CA:  BSF    0A.3
....................                   showNumber(char2int(c[2]), pNJugadorU); 
09CB:  BSF    03.5
09CC:  MOVF   22,W
09CD:  MOVWF  2D
09CE:  BCF    0A.3
09CF:  BCF    03.5
09D0:  CALL   1D1
09D1:  BSF    0A.3
09D2:  MOVF   78,W
09D3:  BSF    03.5
09D4:  MOVWF  2A
09D5:  MOVWF  2B
09D6:  BCF    03.5
09D7:  MOVF   49,W
09D8:  BSF    03.5
09D9:  MOVWF  2F
09DA:  BCF    03.5
09DB:  MOVF   48,W
09DC:  BSF    03.5
09DD:  MOVWF  2E
09DE:  BCF    03.5
09DF:  MOVF   47,W
09E0:  BSF    03.5
09E1:  MOVWF  2D
09E2:  BCF    03.5
09E3:  MOVF   46,W
09E4:  BSF    03.5
09E5:  MOVWF  2C
09E6:  BCF    0A.3
09E7:  BCF    03.5
09E8:  CALL   241
09E9:  BSF    0A.3
....................                   break; 
09EA:  GOTO   6B2
....................       case 'L':   if(DEBUG) {fputs("\r> Comando local",RS232);} 
09EB:  BTFSS  07.2
09EC:  GOTO   1FE
09ED:  MOVLW  00
09EE:  BSF    03.6
09EF:  MOVWF  0D
09F0:  MOVLW  04
09F1:  MOVWF  0F
09F2:  BCF    0A.3
09F3:  BCF    03.6
09F4:  CALL   15B
09F5:  BSF    0A.3
09F6:  MOVLW  0D
09F7:  BTFSS  0C.4
09F8:  GOTO   1F7
09F9:  MOVWF  19
09FA:  MOVLW  0A
09FB:  BTFSS  0C.4
09FC:  GOTO   1FB
09FD:  MOVWF  19
....................                   switch(c[1]) 
09FE:  BSF    03.5
09FF:  MOVF   21,W
0A00:  XORLW  30
0A01:  BCF    03.5
0A02:  BTFSC  03.2
0A03:  GOTO   217
0A04:  XORLW  01
0A05:  BTFSC  03.2
0A06:  GOTO   230
0A07:  XORLW  03
0A08:  BTFSC  03.2
0A09:  GOTO   24A
0A0A:  XORLW  01
0A0B:  BTFSC  03.2
0A0C:  GOTO   265
0A0D:  XORLW  77
0A0E:  BTFSC  03.2
0A0F:  GOTO   280
0A10:  XORLW  0D
0A11:  BTFSC  03.2
0A12:  GOTO   29B
0A13:  XORLW  19
0A14:  BTFSC  03.2
0A15:  GOTO   2AF
0A16:  GOTO   2CC
....................                   { 
....................                      case '0':   if(DEBUG) {fputs("\r> Resetea a 0",RS232);} 
0A17:  BTFSS  07.2
0A18:  GOTO   22A
0A19:  MOVLW  09
0A1A:  BSF    03.6
0A1B:  MOVWF  0D
0A1C:  MOVLW  04
0A1D:  MOVWF  0F
0A1E:  BCF    0A.3
0A1F:  BCF    03.6
0A20:  CALL   15B
0A21:  BSF    0A.3
0A22:  MOVLW  0D
0A23:  BTFSS  0C.4
0A24:  GOTO   223
0A25:  MOVWF  19
0A26:  MOVLW  0A
0A27:  BTFSS  0C.4
0A28:  GOTO   227
0A29:  MOVWF  19
....................                                  scoreL = 0; 
0A2A:  CLRF   5D
0A2B:  CLRF   5C
....................                                  showScoreL(); 
0A2C:  BCF    0A.3
0A2D:  CALL   2FC
0A2E:  BSF    0A.3
....................                                  break; 
0A2F:  GOTO   2CC
....................                      case '1':   if(DEBUG) {fputs("\r> Incrementar por 1",RS232);} 
0A30:  BTFSS  07.2
0A31:  GOTO   243
0A32:  MOVLW  11
0A33:  BSF    03.6
0A34:  MOVWF  0D
0A35:  MOVLW  04
0A36:  MOVWF  0F
0A37:  BCF    0A.3
0A38:  BCF    03.6
0A39:  CALL   15B
0A3A:  BSF    0A.3
0A3B:  MOVLW  0D
0A3C:  BTFSS  0C.4
0A3D:  GOTO   23C
0A3E:  MOVWF  19
0A3F:  MOVLW  0A
0A40:  BTFSS  0C.4
0A41:  GOTO   240
0A42:  MOVWF  19
....................                                  scoreL++; 
0A43:  INCF   5C,F
0A44:  BTFSC  03.2
0A45:  INCF   5D,F
....................                                  showScoreL(); 
0A46:  BCF    0A.3
0A47:  CALL   2FC
0A48:  BSF    0A.3
....................                                  break; 
0A49:  GOTO   2CC
....................                      case '2':   if(DEBUG) {fputs("\r> Incrementar por 2",RS232);} 
0A4A:  BTFSS  07.2
0A4B:  GOTO   25D
0A4C:  MOVLW  1C
0A4D:  BSF    03.6
0A4E:  MOVWF  0D
0A4F:  MOVLW  04
0A50:  MOVWF  0F
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   15B
0A54:  BSF    0A.3
0A55:  MOVLW  0D
0A56:  BTFSS  0C.4
0A57:  GOTO   256
0A58:  MOVWF  19
0A59:  MOVLW  0A
0A5A:  BTFSS  0C.4
0A5B:  GOTO   25A
0A5C:  MOVWF  19
....................                                  scoreL += 2; 
0A5D:  MOVLW  02
0A5E:  ADDWF  5C,F
0A5F:  BTFSC  03.0
0A60:  INCF   5D,F
....................                                  showScoreL(); 
0A61:  BCF    0A.3
0A62:  CALL   2FC
0A63:  BSF    0A.3
....................                                  break; 
0A64:  GOTO   2CC
....................                      case '3':   if(DEBUG) {fputs("\r> Incrementar por 3",RS232);} 
0A65:  BTFSS  07.2
0A66:  GOTO   278
0A67:  MOVLW  27
0A68:  BSF    03.6
0A69:  MOVWF  0D
0A6A:  MOVLW  04
0A6B:  MOVWF  0F
0A6C:  BCF    0A.3
0A6D:  BCF    03.6
0A6E:  CALL   15B
0A6F:  BSF    0A.3
0A70:  MOVLW  0D
0A71:  BTFSS  0C.4
0A72:  GOTO   271
0A73:  MOVWF  19
0A74:  MOVLW  0A
0A75:  BTFSS  0C.4
0A76:  GOTO   275
0A77:  MOVWF  19
....................                                  scoreL += 3; 
0A78:  MOVLW  03
0A79:  ADDWF  5C,F
0A7A:  BTFSC  03.0
0A7B:  INCF   5D,F
....................                                  showScoreL(); 
0A7C:  BCF    0A.3
0A7D:  CALL   2FC
0A7E:  BSF    0A.3
....................                                  break; 
0A7F:  GOTO   2CC
....................                      case 'D':   if(DEBUG) {fputs("\r> Decrementar por 1",RS232);} 
0A80:  BTFSS  07.2
0A81:  GOTO   293
0A82:  MOVLW  32
0A83:  BSF    03.6
0A84:  MOVWF  0D
0A85:  MOVLW  04
0A86:  MOVWF  0F
0A87:  BCF    0A.3
0A88:  BCF    03.6
0A89:  CALL   15B
0A8A:  BSF    0A.3
0A8B:  MOVLW  0D
0A8C:  BTFSS  0C.4
0A8D:  GOTO   28C
0A8E:  MOVWF  19
0A8F:  MOVLW  0A
0A90:  BTFSS  0C.4
0A91:  GOTO   290
0A92:  MOVWF  19
....................                                  scoreL--; 
0A93:  MOVF   5C,W
0A94:  BTFSC  03.2
0A95:  DECF   5D,F
0A96:  DECF   5C,F
....................                                  showScoreL(); 
0A97:  BCF    0A.3
0A98:  CALL   2FC
0A99:  BSF    0A.3
....................                                  break; 
0A9A:  GOTO   2CC
....................                      case 'I':   if(DEBUG) {fputs("\r> Inicializar",RS232);} 
0A9B:  BTFSS  07.2
0A9C:  GOTO   2AE
0A9D:  MOVLW  3D
0A9E:  BSF    03.6
0A9F:  MOVWF  0D
0AA0:  MOVLW  04
0AA1:  MOVWF  0F
0AA2:  BCF    0A.3
0AA3:  BCF    03.6
0AA4:  CALL   15B
0AA5:  BSF    0A.3
0AA6:  MOVLW  0D
0AA7:  BTFSS  0C.4
0AA8:  GOTO   2A7
0AA9:  MOVWF  19
0AAA:  MOVLW  0A
0AAB:  BTFSS  0C.4
0AAC:  GOTO   2AB
0AAD:  MOVWF  19
....................                                  break; 
0AAE:  GOTO   2CC
....................                      case 'P':   if(DEBUG) {fputs("\r> Asignar posicion",RS232);} 
0AAF:  BTFSS  07.2
0AB0:  GOTO   2C2
0AB1:  MOVLW  45
0AB2:  BSF    03.6
0AB3:  MOVWF  0D
0AB4:  MOVLW  04
0AB5:  MOVWF  0F
0AB6:  BCF    0A.3
0AB7:  BCF    03.6
0AB8:  CALL   15B
0AB9:  BSF    0A.3
0ABA:  MOVLW  0D
0ABB:  BTFSS  0C.4
0ABC:  GOTO   2BB
0ABD:  MOVWF  19
0ABE:  MOVLW  0A
0ABF:  BTFSS  0C.4
0AC0:  GOTO   2BF
0AC1:  MOVWF  19
....................                                  i2c_send(I2C_SCORE, I2C_CMD_POSL); 
0AC2:  MOVLW  0C
0AC3:  BSF    03.5
0AC4:  MOVWF  36
0AC5:  MOVLW  71
0AC6:  MOVWF  37
0AC7:  BCF    0A.3
0AC8:  BCF    03.5
0AC9:  CALL   2FD
0ACA:  BSF    0A.3
....................                                  break; 
0ACB:  GOTO   2CC
....................                   } 
....................                   break; 
0ACC:  GOTO   6B2
....................       case 'P':   if(DEBUG) {fputs("\r> Pausar tiempo",RS232);} 
0ACD:  BTFSS  07.2
0ACE:  GOTO   2E0
0ACF:  MOVLW  4F
0AD0:  BSF    03.6
0AD1:  MOVWF  0D
0AD2:  MOVLW  04
0AD3:  MOVWF  0F
0AD4:  BCF    0A.3
0AD5:  BCF    03.6
0AD6:  CALL   15B
0AD7:  BSF    0A.3
0AD8:  MOVLW  0D
0AD9:  BTFSS  0C.4
0ADA:  GOTO   2D9
0ADB:  MOVWF  19
0ADC:  MOVLW  0A
0ADD:  BTFSS  0C.4
0ADE:  GOTO   2DD
0ADF:  MOVWF  19
....................                   pauseTime = true; 
0AE0:  BSF    45.3
....................                   break; 
0AE1:  GOTO   6B2
....................       case 'Q':   if(DEBUG) {fputs("\r> Renudar tiempo",RS232);} 
0AE2:  BTFSS  07.2
0AE3:  GOTO   2F5
0AE4:  MOVLW  58
0AE5:  BSF    03.6
0AE6:  MOVWF  0D
0AE7:  MOVLW  04
0AE8:  MOVWF  0F
0AE9:  BCF    0A.3
0AEA:  BCF    03.6
0AEB:  CALL   15B
0AEC:  BSF    0A.3
0AED:  MOVLW  0D
0AEE:  BTFSS  0C.4
0AEF:  GOTO   2EE
0AF0:  MOVWF  19
0AF1:  MOVLW  0A
0AF2:  BTFSS  0C.4
0AF3:  GOTO   2F2
0AF4:  MOVWF  19
....................                   pauseTime = false; 
0AF5:  BCF    45.3
....................                   break; 
0AF6:  GOTO   6B2
....................       case 'R':    
....................                   switch(c[1]) 
0AF7:  MOVLW  30
0AF8:  BSF    03.5
0AF9:  SUBWF  21,W
0AFA:  ADDLW  FB
0AFB:  BTFSC  03.0
0AFC:  GOTO   3BA
0AFD:  ADDLW  05
0AFE:  BCF    03.5
0AFF:  GOTO   6BD
....................                   { 
....................                      case '0':   if(DEBUG) {fputs("\r> Apagar Periodos",RS232);} 
0B00:  BTFSS  07.2
0B01:  GOTO   313
0B02:  MOVLW  61
0B03:  BSF    03.6
0B04:  MOVWF  0D
0B05:  MOVLW  04
0B06:  MOVWF  0F
0B07:  BCF    0A.3
0B08:  BCF    03.6
0B09:  CALL   15B
0B0A:  BSF    0A.3
0B0B:  MOVLW  0D
0B0C:  BTFSS  0C.4
0B0D:  GOTO   30C
0B0E:  MOVWF  19
0B0F:  MOVLW  0A
0B10:  BTFSS  0C.4
0B11:  GOTO   310
0B12:  MOVWF  19
....................                                  i2c_send(I2C_TIMER, I2C_CMD_PER0); 
0B13:  MOVLW  0A
0B14:  BSF    03.5
0B15:  MOVWF  36
0B16:  MOVLW  70
0B17:  MOVWF  37
0B18:  BCF    0A.3
0B19:  BCF    03.5
0B1A:  CALL   2FD
0B1B:  BSF    0A.3
....................                                  delay_ms(I2CWAIT); 
0B1C:  MOVLW  32
0B1D:  BSF    03.5
0B1E:  MOVWF  32
0B1F:  BCF    0A.3
0B20:  BCF    03.5
0B21:  CALL   310
0B22:  BSF    0A.3
....................                                  break; 
0B23:  BSF    03.5
0B24:  GOTO   3BA
....................                      case '1':   if(DEBUG) {fputs("\r> Periodo 1",RS232);} 
0B25:  BTFSS  07.2
0B26:  GOTO   338
0B27:  MOVLW  6B
0B28:  BSF    03.6
0B29:  MOVWF  0D
0B2A:  MOVLW  04
0B2B:  MOVWF  0F
0B2C:  BCF    0A.3
0B2D:  BCF    03.6
0B2E:  CALL   15B
0B2F:  BSF    0A.3
0B30:  MOVLW  0D
0B31:  BTFSS  0C.4
0B32:  GOTO   331
0B33:  MOVWF  19
0B34:  MOVLW  0A
0B35:  BTFSS  0C.4
0B36:  GOTO   335
0B37:  MOVWF  19
....................                                  i2c_send(I2C_TIMER, I2C_CMD_PER1); 
0B38:  MOVLW  0A
0B39:  BSF    03.5
0B3A:  MOVWF  36
0B3B:  MOVLW  71
0B3C:  MOVWF  37
0B3D:  BCF    0A.3
0B3E:  BCF    03.5
0B3F:  CALL   2FD
0B40:  BSF    0A.3
....................                                  delay_ms(I2CWAIT); 
0B41:  MOVLW  32
0B42:  BSF    03.5
0B43:  MOVWF  32
0B44:  BCF    0A.3
0B45:  BCF    03.5
0B46:  CALL   310
0B47:  BSF    0A.3
....................                                  break; 
0B48:  BSF    03.5
0B49:  GOTO   3BA
....................                      case '2':   if(DEBUG) {fputs("\r> Periodo 2",RS232);} 
0B4A:  BTFSS  07.2
0B4B:  GOTO   35D
0B4C:  MOVLW  72
0B4D:  BSF    03.6
0B4E:  MOVWF  0D
0B4F:  MOVLW  04
0B50:  MOVWF  0F
0B51:  BCF    0A.3
0B52:  BCF    03.6
0B53:  CALL   15B
0B54:  BSF    0A.3
0B55:  MOVLW  0D
0B56:  BTFSS  0C.4
0B57:  GOTO   356
0B58:  MOVWF  19
0B59:  MOVLW  0A
0B5A:  BTFSS  0C.4
0B5B:  GOTO   35A
0B5C:  MOVWF  19
....................                                  i2c_send(I2C_TIMER, I2C_CMD_PER2); 
0B5D:  MOVLW  0A
0B5E:  BSF    03.5
0B5F:  MOVWF  36
0B60:  MOVLW  72
0B61:  MOVWF  37
0B62:  BCF    0A.3
0B63:  BCF    03.5
0B64:  CALL   2FD
0B65:  BSF    0A.3
....................                                  delay_ms(I2CWAIT); 
0B66:  MOVLW  32
0B67:  BSF    03.5
0B68:  MOVWF  32
0B69:  BCF    0A.3
0B6A:  BCF    03.5
0B6B:  CALL   310
0B6C:  BSF    0A.3
....................                                  break; 
0B6D:  BSF    03.5
0B6E:  GOTO   3BA
....................                      case '3':   if(DEBUG) {fputs("\r> Periodo 3",RS232);} 
0B6F:  BTFSS  07.2
0B70:  GOTO   382
0B71:  MOVLW  79
0B72:  BSF    03.6
0B73:  MOVWF  0D
0B74:  MOVLW  04
0B75:  MOVWF  0F
0B76:  BCF    0A.3
0B77:  BCF    03.6
0B78:  CALL   15B
0B79:  BSF    0A.3
0B7A:  MOVLW  0D
0B7B:  BTFSS  0C.4
0B7C:  GOTO   37B
0B7D:  MOVWF  19
0B7E:  MOVLW  0A
0B7F:  BTFSS  0C.4
0B80:  GOTO   37F
0B81:  MOVWF  19
....................                                  i2c_send(I2C_TIMER, I2C_CMD_PER3); 
0B82:  MOVLW  0A
0B83:  BSF    03.5
0B84:  MOVWF  36
0B85:  MOVLW  73
0B86:  MOVWF  37
0B87:  BCF    0A.3
0B88:  BCF    03.5
0B89:  CALL   2FD
0B8A:  BSF    0A.3
....................                                  delay_ms(I2CWAIT); 
0B8B:  MOVLW  32
0B8C:  BSF    03.5
0B8D:  MOVWF  32
0B8E:  BCF    0A.3
0B8F:  BCF    03.5
0B90:  CALL   310
0B91:  BSF    0A.3
....................                                  break; 
0B92:  BSF    03.5
0B93:  GOTO   3BA
....................                      case '4':   if(DEBUG) {fputs("\r> Periodo 4",RS232);} 
0B94:  BTFSS  07.2
0B95:  GOTO   3A7
0B96:  MOVLW  80
0B97:  BSF    03.6
0B98:  MOVWF  0D
0B99:  MOVLW  04
0B9A:  MOVWF  0F
0B9B:  BCF    0A.3
0B9C:  BCF    03.6
0B9D:  CALL   15B
0B9E:  BSF    0A.3
0B9F:  MOVLW  0D
0BA0:  BTFSS  0C.4
0BA1:  GOTO   3A0
0BA2:  MOVWF  19
0BA3:  MOVLW  0A
0BA4:  BTFSS  0C.4
0BA5:  GOTO   3A4
0BA6:  MOVWF  19
....................                                  i2c_send(I2C_TIMER, I2C_CMD_PER4); 
0BA7:  MOVLW  0A
0BA8:  BSF    03.5
0BA9:  MOVWF  36
0BAA:  MOVLW  74
0BAB:  MOVWF  37
0BAC:  BCF    0A.3
0BAD:  BCF    03.5
0BAE:  CALL   2FD
0BAF:  BSF    0A.3
....................                                  delay_ms(I2CWAIT); 
0BB0:  MOVLW  32
0BB1:  BSF    03.5
0BB2:  MOVWF  32
0BB3:  BCF    0A.3
0BB4:  BCF    03.5
0BB5:  CALL   310
0BB6:  BSF    0A.3
....................                                  break; 
0BB7:  BSF    03.5
0BB8:  GOTO   3BA
0BB9:  BSF    03.5
....................                   } 
....................                   break; 
0BBA:  BCF    03.5
0BBB:  GOTO   6B2
....................       case 'S':   if(DEBUG) {fputs("\r> Configuracion de tiro",RS232);} 
0BBC:  BTFSS  07.2
0BBD:  GOTO   3CF
0BBE:  MOVLW  87
0BBF:  BSF    03.6
0BC0:  MOVWF  0D
0BC1:  MOVLW  04
0BC2:  MOVWF  0F
0BC3:  BCF    0A.3
0BC4:  BCF    03.6
0BC5:  CALL   15B
0BC6:  BSF    0A.3
0BC7:  MOVLW  0D
0BC8:  BTFSS  0C.4
0BC9:  GOTO   3C8
0BCA:  MOVWF  19
0BCB:  MOVLW  0A
0BCC:  BTFSS  0C.4
0BCD:  GOTO   3CC
0BCE:  MOVWF  19
....................                   shotSet(char2int(c[1]),char2int(c[2])); 
0BCF:  BSF    03.5
0BD0:  MOVF   21,W
0BD1:  MOVWF  2D
0BD2:  BCF    0A.3
0BD3:  BCF    03.5
0BD4:  CALL   1D1
0BD5:  BSF    0A.3
0BD6:  MOVF   78,W
0BD7:  BSF    03.5
0BD8:  MOVWF  2A
0BD9:  MOVF   22,W
0BDA:  MOVWF  2D
0BDB:  BCF    0A.3
0BDC:  BCF    03.5
0BDD:  CALL   1D1
0BDE:  BSF    0A.3
0BDF:  MOVF   78,W
0BE0:  BSF    03.5
0BE1:  MOVWF  2B
0BE2:  MOVF   2A,W
0BE3:  MOVWF  2C
0BE4:  MOVF   2B,W
0BE5:  MOVWF  2D
....................                   break; 
*
0C12:  GOTO   6B2
....................       case 'T':   if(DEBUG) {fputs("\r> Configuracion de tiempo",RS232);} 
0C13:  BTFSS  07.2
0C14:  GOTO   426
0C15:  MOVLW  94
0C16:  BSF    03.6
0C17:  MOVWF  0D
0C18:  MOVLW  04
0C19:  MOVWF  0F
0C1A:  BCF    0A.3
0C1B:  BCF    03.6
0C1C:  CALL   15B
0C1D:  BSF    0A.3
0C1E:  MOVLW  0D
0C1F:  BTFSS  0C.4
0C20:  GOTO   41F
0C21:  MOVWF  19
0C22:  MOVLW  0A
0C23:  BTFSS  0C.4
0C24:  GOTO   423
0C25:  MOVWF  19
....................                   timeSet(char2int(c[1]),char2int(c[2]),char2int(c[3]),char2int(c[4])); 
0C26:  BSF    03.5
0C27:  MOVF   21,W
0C28:  MOVWF  2D
0C29:  BCF    0A.3
0C2A:  BCF    03.5
0C2B:  CALL   1D1
0C2C:  BSF    0A.3
0C2D:  MOVF   78,W
0C2E:  BSF    03.5
0C2F:  MOVWF  2A
0C30:  MOVF   22,W
0C31:  MOVWF  2D
0C32:  BCF    0A.3
0C33:  BCF    03.5
0C34:  CALL   1D1
0C35:  BSF    0A.3
0C36:  MOVF   78,W
0C37:  BSF    03.5
0C38:  MOVWF  2B
0C39:  MOVF   23,W
0C3A:  MOVWF  2D
0C3B:  BCF    0A.3
0C3C:  BCF    03.5
0C3D:  CALL   1D1
0C3E:  BSF    0A.3
0C3F:  MOVF   78,W
0C40:  BSF    03.5
0C41:  MOVWF  2C
0C42:  MOVF   24,W
0C43:  MOVWF  2D
0C44:  BCF    0A.3
0C45:  BCF    03.5
0C46:  CALL   1D1
0C47:  BSF    0A.3
0C48:  MOVF   78,W
0C49:  BSF    03.5
0C4A:  MOVWF  2D
0C4B:  MOVF   2A,W
0C4C:  MOVWF  2E
0C4D:  MOVF   2B,W
0C4E:  MOVWF  2F
0C4F:  MOVF   2C,W
0C50:  MOVWF  30
0C51:  MOVF   2D,W
0C52:  MOVWF  31
....................                   break; 
*
0CBD:  GOTO   6B2
....................       case 'V':   if(DEBUG) {fputs("\r> Comando visitante",RS232);} 
0CBE:  BTFSS  07.2
0CBF:  GOTO   4D1
0CC0:  MOVLW  A2
0CC1:  BSF    03.6
0CC2:  MOVWF  0D
0CC3:  MOVLW  04
0CC4:  MOVWF  0F
0CC5:  BCF    0A.3
0CC6:  BCF    03.6
0CC7:  CALL   15B
0CC8:  BSF    0A.3
0CC9:  MOVLW  0D
0CCA:  BTFSS  0C.4
0CCB:  GOTO   4CA
0CCC:  MOVWF  19
0CCD:  MOVLW  0A
0CCE:  BTFSS  0C.4
0CCF:  GOTO   4CE
0CD0:  MOVWF  19
....................                   switch(c[1]) 
0CD1:  BSF    03.5
0CD2:  MOVF   21,W
0CD3:  XORLW  30
0CD4:  BCF    03.5
0CD5:  BTFSC  03.2
0CD6:  GOTO   4EA
0CD7:  XORLW  01
0CD8:  BTFSC  03.2
0CD9:  GOTO   503
0CDA:  XORLW  03
0CDB:  BTFSC  03.2
0CDC:  GOTO   51D
0CDD:  XORLW  01
0CDE:  BTFSC  03.2
0CDF:  GOTO   538
0CE0:  XORLW  77
0CE1:  BTFSC  03.2
0CE2:  GOTO   553
0CE3:  XORLW  0D
0CE4:  BTFSC  03.2
0CE5:  GOTO   56E
0CE6:  XORLW  19
0CE7:  BTFSC  03.2
0CE8:  GOTO   582
0CE9:  GOTO   5A6
....................                   { 
....................                      case '0':   if(DEBUG) {fputs("\r> Resetea a 0",RS232);} 
0CEA:  BTFSS  07.2
0CEB:  GOTO   4FD
0CEC:  MOVLW  AD
0CED:  BSF    03.6
0CEE:  MOVWF  0D
0CEF:  MOVLW  04
0CF0:  MOVWF  0F
0CF1:  BCF    0A.3
0CF2:  BCF    03.6
0CF3:  CALL   15B
0CF4:  BSF    0A.3
0CF5:  MOVLW  0D
0CF6:  BTFSS  0C.4
0CF7:  GOTO   4F6
0CF8:  MOVWF  19
0CF9:  MOVLW  0A
0CFA:  BTFSS  0C.4
0CFB:  GOTO   4FA
0CFC:  MOVWF  19
....................                                  scoreV = 0; 
0CFD:  CLRF   5F
0CFE:  CLRF   5E
....................                                  showScoreV(); 
0CFF:  BCF    0A.3
0D00:  CALL   333
0D01:  BSF    0A.3
....................                                  break; 
0D02:  GOTO   5A6
....................                      case '1':   if(DEBUG) {fputs("\r> Incrementar por 1",RS232);} 
0D03:  BTFSS  07.2
0D04:  GOTO   516
0D05:  MOVLW  B5
0D06:  BSF    03.6
0D07:  MOVWF  0D
0D08:  MOVLW  04
0D09:  MOVWF  0F
0D0A:  BCF    0A.3
0D0B:  BCF    03.6
0D0C:  CALL   15B
0D0D:  BSF    0A.3
0D0E:  MOVLW  0D
0D0F:  BTFSS  0C.4
0D10:  GOTO   50F
0D11:  MOVWF  19
0D12:  MOVLW  0A
0D13:  BTFSS  0C.4
0D14:  GOTO   513
0D15:  MOVWF  19
....................                                  scoreV++; 
0D16:  INCF   5E,F
0D17:  BTFSC  03.2
0D18:  INCF   5F,F
....................                                  showScoreV(); 
0D19:  BCF    0A.3
0D1A:  CALL   333
0D1B:  BSF    0A.3
....................                                  break; 
0D1C:  GOTO   5A6
....................                      case '2':   if(DEBUG) {fputs("\r> Incrementar por 2",RS232);} 
0D1D:  BTFSS  07.2
0D1E:  GOTO   530
0D1F:  MOVLW  C0
0D20:  BSF    03.6
0D21:  MOVWF  0D
0D22:  MOVLW  04
0D23:  MOVWF  0F
0D24:  BCF    0A.3
0D25:  BCF    03.6
0D26:  CALL   15B
0D27:  BSF    0A.3
0D28:  MOVLW  0D
0D29:  BTFSS  0C.4
0D2A:  GOTO   529
0D2B:  MOVWF  19
0D2C:  MOVLW  0A
0D2D:  BTFSS  0C.4
0D2E:  GOTO   52D
0D2F:  MOVWF  19
....................                                  scoreV += 2; 
0D30:  MOVLW  02
0D31:  ADDWF  5E,F
0D32:  BTFSC  03.0
0D33:  INCF   5F,F
....................                                  showScoreV(); 
0D34:  BCF    0A.3
0D35:  CALL   333
0D36:  BSF    0A.3
....................                                  break; 
0D37:  GOTO   5A6
....................                      case '3':   if(DEBUG) {fputs("\r> Incrementar por 3",RS232);} 
0D38:  BTFSS  07.2
0D39:  GOTO   54B
0D3A:  MOVLW  CB
0D3B:  BSF    03.6
0D3C:  MOVWF  0D
0D3D:  MOVLW  04
0D3E:  MOVWF  0F
0D3F:  BCF    0A.3
0D40:  BCF    03.6
0D41:  CALL   15B
0D42:  BSF    0A.3
0D43:  MOVLW  0D
0D44:  BTFSS  0C.4
0D45:  GOTO   544
0D46:  MOVWF  19
0D47:  MOVLW  0A
0D48:  BTFSS  0C.4
0D49:  GOTO   548
0D4A:  MOVWF  19
....................                                  scoreV += 3; 
0D4B:  MOVLW  03
0D4C:  ADDWF  5E,F
0D4D:  BTFSC  03.0
0D4E:  INCF   5F,F
....................                                  showScoreV(); 
0D4F:  BCF    0A.3
0D50:  CALL   333
0D51:  BSF    0A.3
....................                                  break; 
0D52:  GOTO   5A6
....................                      case 'D':   if(DEBUG) {fputs("\r> Decrementar por 1",RS232);} 
0D53:  BTFSS  07.2
0D54:  GOTO   566
0D55:  MOVLW  D6
0D56:  BSF    03.6
0D57:  MOVWF  0D
0D58:  MOVLW  04
0D59:  MOVWF  0F
0D5A:  BCF    0A.3
0D5B:  BCF    03.6
0D5C:  CALL   15B
0D5D:  BSF    0A.3
0D5E:  MOVLW  0D
0D5F:  BTFSS  0C.4
0D60:  GOTO   55F
0D61:  MOVWF  19
0D62:  MOVLW  0A
0D63:  BTFSS  0C.4
0D64:  GOTO   563
0D65:  MOVWF  19
....................                                  scoreV--; 
0D66:  MOVF   5E,W
0D67:  BTFSC  03.2
0D68:  DECF   5F,F
0D69:  DECF   5E,F
....................                                  showScoreV(); 
0D6A:  BCF    0A.3
0D6B:  CALL   333
0D6C:  BSF    0A.3
....................                                  break; 
0D6D:  GOTO   5A6
....................                      case 'I':   if(DEBUG) {fputs("\r> Inicializar",RS232);} 
0D6E:  BTFSS  07.2
0D6F:  GOTO   581
0D70:  MOVLW  E1
0D71:  BSF    03.6
0D72:  MOVWF  0D
0D73:  MOVLW  04
0D74:  MOVWF  0F
0D75:  BCF    0A.3
0D76:  BCF    03.6
0D77:  CALL   15B
0D78:  BSF    0A.3
0D79:  MOVLW  0D
0D7A:  BTFSS  0C.4
0D7B:  GOTO   57A
0D7C:  MOVWF  19
0D7D:  MOVLW  0A
0D7E:  BTFSS  0C.4
0D7F:  GOTO   57E
0D80:  MOVWF  19
....................                                  break; 
0D81:  GOTO   5A6
....................                      case 'P':   if(DEBUG) {fputs("\r> Asignar posicion",RS232);} 
0D82:  BTFSS  07.2
0D83:  GOTO   595
0D84:  MOVLW  E9
0D85:  BSF    03.6
0D86:  MOVWF  0D
0D87:  MOVLW  04
0D88:  MOVWF  0F
0D89:  BCF    0A.3
0D8A:  BCF    03.6
0D8B:  CALL   15B
0D8C:  BSF    0A.3
0D8D:  MOVLW  0D
0D8E:  BTFSS  0C.4
0D8F:  GOTO   58E
0D90:  MOVWF  19
0D91:  MOVLW  0A
0D92:  BTFSS  0C.4
0D93:  GOTO   592
0D94:  MOVWF  19
....................                                  i2c_send(I2C_SCORE, I2C_CMD_POSV); 
0D95:  MOVLW  0C
0D96:  BSF    03.5
0D97:  MOVWF  36
0D98:  MOVLW  72
0D99:  MOVWF  37
0D9A:  BCF    0A.3
0D9B:  BCF    03.5
0D9C:  CALL   2FD
0D9D:  BSF    0A.3
....................                                  delay_ms(I2CWAIT); 
0D9E:  MOVLW  32
0D9F:  BSF    03.5
0DA0:  MOVWF  32
0DA1:  BCF    0A.3
0DA2:  BCF    03.5
0DA3:  CALL   310
0DA4:  BSF    0A.3
....................                                  break; 
0DA5:  GOTO   5A6
....................                   } 
....................                   break; 
0DA6:  GOTO   6B2
....................       case 'X':   doTest(); //Rutina de prueba 
....................                   break; 
*
0E70:  BCF    03.5
0E71:  GOTO   6B2
....................       case 'Z':   if(DEBUG) {fputs("\r> Reseteo general...!",RS232);} 
0E72:  BTFSS  07.2
0E73:  GOTO   685
0E74:  MOVLW  F3
0E75:  BSF    03.6
0E76:  MOVWF  0D
0E77:  MOVLW  04
0E78:  MOVWF  0F
0E79:  BCF    0A.3
0E7A:  BCF    03.6
0E7B:  CALL   15B
0E7C:  BSF    0A.3
0E7D:  MOVLW  0D
0E7E:  BTFSS  0C.4
0E7F:  GOTO   67E
0E80:  MOVWF  19
0E81:  MOVLW  0A
0E82:  BTFSS  0C.4
0E83:  GOTO   682
0E84:  MOVWF  19
....................                   delay_ms(500); 
0E85:  MOVLW  02
0E86:  BSF    03.5
0E87:  MOVWF  2A
0E88:  MOVLW  FA
0E89:  MOVWF  32
0E8A:  BCF    0A.3
0E8B:  BCF    03.5
0E8C:  CALL   310
0E8D:  BSF    0A.3
0E8E:  BSF    03.5
0E8F:  DECFSZ 2A,F
0E90:  GOTO   688
....................                   doReset(); 
....................                    
....................    } 
*
0EB2:  BCF    0A.3
0EB3:  BCF    0A.4
0EB4:  GOTO   361 (RETURN)
.................... } 
....................  
.................... void showScoreL() 
.................... { 
*
02FC:  RETURN
....................    //TODO: Codigo para mostrar puntos 
.................... } 
....................  
.................... void showScoreV() 
.................... { 
*
0333:  RETURN
....................    //TODO: Codigo para mostrar puntos 
.................... } 
....................  
.................... void shotSet(int8 shd, int8 shu) 
.................... { 
....................    sh_u = shu; 
*
0BE6:  MOVF   2D,W
0BE7:  BCF    03.5
0BE8:  MOVWF  5B
....................    sh_d = shd; 
0BE9:  BSF    03.5
0BEA:  MOVF   2C,W
0BEB:  BCF    03.5
0BEC:  MOVWF  5A
....................    sendN2Port(shd, I2C_TIMER, PuertoA); 
0BED:  BSF    03.5
0BEE:  MOVF   2C,W
0BEF:  MOVWF  32
0BF0:  MOVLW  0A
0BF1:  MOVWF  33
0BF2:  MOVLW  01
0BF3:  MOVWF  34
0BF4:  BCF    0A.3
0BF5:  BCF    03.5
0BF6:  CALL   324
0BF7:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0BF8:  MOVLW  32
0BF9:  BSF    03.5
0BFA:  MOVWF  32
0BFB:  BCF    0A.3
0BFC:  BCF    03.5
0BFD:  CALL   310
0BFE:  BSF    0A.3
....................    sendN2Port(shu, I2C_TIMER, PuertoB); 
0BFF:  BSF    03.5
0C00:  MOVF   2D,W
0C01:  MOVWF  32
0C02:  MOVLW  0A
0C03:  MOVWF  33
0C04:  MOVLW  02
0C05:  MOVWF  34
0C06:  BCF    0A.3
0C07:  BCF    03.5
0C08:  CALL   324
0C09:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0C0A:  MOVLW  32
0C0B:  BSF    03.5
0C0C:  MOVWF  32
0C0D:  BCF    0A.3
0C0E:  BCF    03.5
0C0F:  CALL   310
0C10:  BSF    0A.3
....................     
....................    enableShot = true; 
0C11:  BSF    45.2
.................... } 
....................  
.................... void timeSet(int8 md, int8 mu, int8 sd, int8 su) 
.................... { 
....................    m_u = mu; 
*
0C53:  MOVF   2F,W
0C54:  BCF    03.5
0C55:  MOVWF  57
....................    m_d = md; 
0C56:  BSF    03.5
0C57:  MOVF   2E,W
0C58:  BCF    03.5
0C59:  MOVWF  56
....................    s_d = sd; 
0C5A:  BSF    03.5
0C5B:  MOVF   30,W
0C5C:  BCF    03.5
0C5D:  MOVWF  58
....................    s_u = su; 
0C5E:  BSF    03.5
0C5F:  MOVF   31,W
0C60:  BCF    03.5
0C61:  MOVWF  59
....................     
....................    sendN2Port(su, I2C_TIMER, PuertoD); 
0C62:  BSF    03.5
0C63:  MOVF   31,W
0C64:  MOVWF  32
0C65:  MOVLW  0A
0C66:  MOVWF  33
0C67:  MOVLW  04
0C68:  MOVWF  34
0C69:  BCF    0A.3
0C6A:  BCF    03.5
0C6B:  CALL   324
0C6C:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0C6D:  MOVLW  32
0C6E:  BSF    03.5
0C6F:  MOVWF  32
0C70:  BCF    0A.3
0C71:  BCF    03.5
0C72:  CALL   310
0C73:  BSF    0A.3
....................    sendN2Port(sd, I2C_TIMER, PuertoC); 
0C74:  BSF    03.5
0C75:  MOVF   30,W
0C76:  MOVWF  32
0C77:  MOVLW  0A
0C78:  MOVWF  33
0C79:  MOVLW  03
0C7A:  MOVWF  34
0C7B:  BCF    0A.3
0C7C:  BCF    03.5
0C7D:  CALL   324
0C7E:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0C7F:  MOVLW  32
0C80:  BSF    03.5
0C81:  MOVWF  32
0C82:  BCF    0A.3
0C83:  BCF    03.5
0C84:  CALL   310
0C85:  BSF    0A.3
....................    sendN2Port(mu, I2C_TIMER, PuertoE); 
0C86:  BSF    03.5
0C87:  MOVF   2F,W
0C88:  MOVWF  32
0C89:  MOVLW  0A
0C8A:  MOVWF  33
0C8B:  MOVLW  05
0C8C:  MOVWF  34
0C8D:  BCF    0A.3
0C8E:  BCF    03.5
0C8F:  CALL   324
0C90:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0C91:  MOVLW  32
0C92:  BSF    03.5
0C93:  MOVWF  32
0C94:  BCF    0A.3
0C95:  BCF    03.5
0C96:  CALL   310
0C97:  BSF    0A.3
....................     
....................    if(md != 0) 
0C98:  BSF    03.5
0C99:  MOVF   2E,F
0C9A:  BTFSC  03.2
0C9B:  GOTO   4AD
....................    { 
....................       i2c_send(I2C_TIMER, I2C_CMD_MDON); 
0C9C:  MOVLW  0A
0C9D:  MOVWF  36
0C9E:  MOVLW  75
0C9F:  MOVWF  37
0CA0:  BCF    0A.3
0CA1:  BCF    03.5
0CA2:  CALL   2FD
0CA3:  BSF    0A.3
....................       delay_ms(I2CWAIT); 
0CA4:  MOVLW  32
0CA5:  BSF    03.5
0CA6:  MOVWF  32
0CA7:  BCF    0A.3
0CA8:  BCF    03.5
0CA9:  CALL   310
0CAA:  BSF    0A.3
....................    } 
0CAB:  GOTO   4BC
0CAC:  BSF    03.5
....................    else 
....................    { 
....................       i2c_send(I2C_TIMER, I2C_CMD_MDOF); 
0CAD:  MOVLW  0A
0CAE:  MOVWF  36
0CAF:  MOVLW  76
0CB0:  MOVWF  37
0CB1:  BCF    0A.3
0CB2:  BCF    03.5
0CB3:  CALL   2FD
0CB4:  BSF    0A.3
....................       delay_ms(I2CWAIT); 
0CB5:  MOVLW  32
0CB6:  BSF    03.5
0CB7:  MOVWF  32
0CB8:  BCF    0A.3
0CB9:  BCF    03.5
0CBA:  CALL   310
0CBB:  BSF    0A.3
....................    }   
....................    enableTime = true; 
0CBC:  BSF    45.1
.................... } 
....................  
.................... void shotPass() 
*
118A:  MOVF   5A,W
118B:  MOVWF  6C
118C:  MOVF   5B,W
118D:  MOVWF  6D
.................... { 
....................    int8 shd = sh_d; 
....................    int8 shu = sh_u; 
....................     
....................    if(sh_u > 0) 
118E:  MOVF   5B,F
118F:  BTFSC  03.2
1190:  GOTO   193
....................          sh_u--; 
1191:  DECF   5B,F
1192:  GOTO   19D
....................    else 
....................    { 
....................       if(sh_d > 0) 
1193:  MOVF   5A,F
1194:  BTFSC  03.2
1195:  GOTO   19A
....................          { 
....................             sh_u = 9; 
1196:  MOVLW  09
1197:  MOVWF  5B
....................             sh_d--; 
1198:  DECF   5A,F
....................          } 
1199:  GOTO   19D
....................          else 
....................                { 
....................                   //TODO: End count 
....................                   sh_d=0; 
119A:  CLRF   5A
....................                   sh_u=0; 
119B:  CLRF   5B
....................                   enableShot = false; 
119C:  BCF    45.2
....................                } 
....................    } 
....................    if(shu != sh_u) 
119D:  MOVF   5B,W
119E:  SUBWF  6D,W
119F:  BTFSC  03.2
11A0:  GOTO   1B2
11A1:  CLRF   2B
11A2:  BTFSC  0B.7
11A3:  BSF    2B.7
11A4:  BCF    0B.7
....................          sendN2Port(sh_u, I2C_TIMER, PuertoB); 
11A5:  MOVF   5B,W
11A6:  BSF    03.5
11A7:  MOVWF  32
11A8:  MOVLW  0A
11A9:  MOVWF  33
11AA:  MOVLW  02
11AB:  MOVWF  34
11AC:  BCF    0A.4
11AD:  BCF    03.5
11AE:  CALL   324
11AF:  BSF    0A.4
11B0:  BTFSC  2B.7
11B1:  BSF    0B.7
11B2:  CLRF   2B
11B3:  BTFSC  0B.7
11B4:  BSF    2B.7
11B5:  BCF    0B.7
....................          delay_ms(I2CWAIT); 
11B6:  MOVLW  32
11B7:  BSF    03.5
11B8:  MOVWF  32
11B9:  BCF    0A.4
11BA:  BCF    03.5
11BB:  CALL   310
11BC:  BSF    0A.4
11BD:  BTFSC  2B.7
11BE:  BSF    0B.7
....................       if(shd != sh_d) 
11BF:  MOVF   5A,W
11C0:  SUBWF  6C,W
11C1:  BTFSC  03.2
11C2:  GOTO   1D4
11C3:  CLRF   2B
11C4:  BTFSC  0B.7
11C5:  BSF    2B.7
11C6:  BCF    0B.7
....................          sendN2Port(sh_d, I2C_TIMER, PuertoA); 
11C7:  MOVF   5A,W
11C8:  BSF    03.5
11C9:  MOVWF  32
11CA:  MOVLW  0A
11CB:  MOVWF  33
11CC:  MOVLW  01
11CD:  MOVWF  34
11CE:  BCF    0A.4
11CF:  BCF    03.5
11D0:  CALL   324
11D1:  BSF    0A.4
11D2:  BTFSC  2B.7
11D3:  BSF    0B.7
11D4:  CLRF   2B
11D5:  BTFSC  0B.7
11D6:  BSF    2B.7
11D7:  BCF    0B.7
....................          delay_ms(I2CWAIT); 
11D8:  MOVLW  32
11D9:  BSF    03.5
11DA:  MOVWF  32
11DB:  BCF    0A.4
11DC:  BCF    03.5
11DD:  CALL   310
11DE:  BSF    0A.4
11DF:  BTFSC  2B.7
11E0:  BSF    0B.7
.................... } 
.................... void timePass() 
*
10B5:  MOVF   56,W
10B6:  MOVWF  6C
10B7:  MOVF   57,W
10B8:  MOVWF  6D
10B9:  MOVF   58,W
10BA:  MOVWF  6E
10BB:  MOVF   59,W
10BC:  MOVWF  6F
.................... { 
....................  
....................       int8 md = m_d; 
....................       int8 mu = m_u; 
....................       int8 sd = s_d; 
....................       int8 su = s_u; 
....................        
....................       if(s_u > 0) 
10BD:  MOVF   59,F
10BE:  BTFSC  03.2
10BF:  GOTO   0C2
....................          s_u--; 
10C0:  DECF   59,F
10C1:  GOTO   0E2
....................       else 
....................       { 
....................          if(s_d > 0) 
10C2:  MOVF   58,F
10C3:  BTFSC  03.2
10C4:  GOTO   0C9
....................          { 
....................             s_u = 9; 
10C5:  MOVLW  09
10C6:  MOVWF  59
....................             s_d--; 
10C7:  DECF   58,F
....................          } 
10C8:  GOTO   0E2
....................          else 
....................          { 
....................             if(m_u > 0) 
10C9:  MOVF   57,F
10CA:  BTFSC  03.2
10CB:  GOTO   0D2
....................             { 
....................                s_d = 5; 
10CC:  MOVLW  05
10CD:  MOVWF  58
....................                s_u = 9; 
10CE:  MOVLW  09
10CF:  MOVWF  59
....................                m_u--;  
10D0:  DECF   57,F
....................             } 
10D1:  GOTO   0E2
....................             else 
....................             { 
....................                if(m_d > 0) 
10D2:  MOVF   56,F
10D3:  BTFSC  03.2
10D4:  GOTO   0DD
....................                { 
....................                   m_d = 0; 
10D5:  CLRF   56
....................                   m_u = 9; 
10D6:  MOVLW  09
10D7:  MOVWF  57
....................                   s_d = 5; 
10D8:  MOVLW  05
10D9:  MOVWF  58
....................                   s_u = 9; 
10DA:  MOVLW  09
10DB:  MOVWF  59
....................                } 
10DC:  GOTO   0E2
....................                else 
....................                { 
....................                   //TODO: End count 
....................                   m_d=0; 
10DD:  CLRF   56
....................                   m_u=0; 
10DE:  CLRF   57
....................                   s_d=0; 
10DF:  CLRF   58
....................                   s_u=0; 
10E0:  CLRF   59
....................                   enableTime = false; 
10E1:  BCF    45.1
....................                } 
....................             } 
....................          } 
....................       } 
....................        
....................       if(su != s_u) 
10E2:  MOVF   59,W
10E3:  SUBWF  6F,W
10E4:  BTFSC  03.2
10E5:  GOTO   0F7
10E6:  CLRF   2B
10E7:  BTFSC  0B.7
10E8:  BSF    2B.7
10E9:  BCF    0B.7
....................          sendN2Port(s_u, I2C_TIMER, PuertoD); 
10EA:  MOVF   59,W
10EB:  BSF    03.5
10EC:  MOVWF  32
10ED:  MOVLW  0A
10EE:  MOVWF  33
10EF:  MOVLW  04
10F0:  MOVWF  34
10F1:  BCF    0A.4
10F2:  BCF    03.5
10F3:  CALL   324
10F4:  BSF    0A.4
10F5:  BTFSC  2B.7
10F6:  BSF    0B.7
10F7:  CLRF   2B
10F8:  BTFSC  0B.7
10F9:  BSF    2B.7
10FA:  BCF    0B.7
....................          delay_ms(I2CWAIT); 
10FB:  MOVLW  32
10FC:  BSF    03.5
10FD:  MOVWF  32
10FE:  BCF    0A.4
10FF:  BCF    03.5
1100:  CALL   310
1101:  BSF    0A.4
1102:  BTFSC  2B.7
1103:  BSF    0B.7
....................       if(sd != s_d) 
1104:  MOVF   58,W
1105:  SUBWF  6E,W
1106:  BTFSC  03.2
1107:  GOTO   119
1108:  CLRF   2B
1109:  BTFSC  0B.7
110A:  BSF    2B.7
110B:  BCF    0B.7
....................          sendN2Port(s_d, I2C_TIMER, PuertoC); 
110C:  MOVF   58,W
110D:  BSF    03.5
110E:  MOVWF  32
110F:  MOVLW  0A
1110:  MOVWF  33
1111:  MOVLW  03
1112:  MOVWF  34
1113:  BCF    0A.4
1114:  BCF    03.5
1115:  CALL   324
1116:  BSF    0A.4
1117:  BTFSC  2B.7
1118:  BSF    0B.7
1119:  CLRF   2B
111A:  BTFSC  0B.7
111B:  BSF    2B.7
111C:  BCF    0B.7
....................          delay_ms(I2CWAIT); 
111D:  MOVLW  32
111E:  BSF    03.5
111F:  MOVWF  32
1120:  BCF    0A.4
1121:  BCF    03.5
1122:  CALL   310
1123:  BSF    0A.4
1124:  BTFSC  2B.7
1125:  BSF    0B.7
....................       if(mu != m_u) 
1126:  MOVF   57,W
1127:  SUBWF  6D,W
1128:  BTFSC  03.2
1129:  GOTO   13B
112A:  CLRF   2B
112B:  BTFSC  0B.7
112C:  BSF    2B.7
112D:  BCF    0B.7
....................          sendN2Port(m_u, I2C_TIMER, PuertoE); 
112E:  MOVF   57,W
112F:  BSF    03.5
1130:  MOVWF  32
1131:  MOVLW  0A
1132:  MOVWF  33
1133:  MOVLW  05
1134:  MOVWF  34
1135:  BCF    0A.4
1136:  BCF    03.5
1137:  CALL   324
1138:  BSF    0A.4
1139:  BTFSC  2B.7
113A:  BSF    0B.7
113B:  CLRF   2B
113C:  BTFSC  0B.7
113D:  BSF    2B.7
113E:  BCF    0B.7
....................          delay_ms(I2CWAIT); 
113F:  MOVLW  32
1140:  BSF    03.5
1141:  MOVWF  32
1142:  BCF    0A.4
1143:  BCF    03.5
1144:  CALL   310
1145:  BSF    0A.4
1146:  BTFSC  2B.7
1147:  BSF    0B.7
....................       if(md != m_d) 
1148:  MOVF   56,W
1149:  SUBWF  6C,W
114A:  BTFSC  03.2
114B:  GOTO   188
....................          if(m_d ==0) 
114C:  MOVF   56,F
114D:  BTFSS  03.2
114E:  GOTO   16C
114F:  CLRF   2B
1150:  BTFSC  0B.7
1151:  BSF    2B.7
1152:  BCF    0B.7
....................          { 
....................             i2c_send(I2C_TIMER, I2C_CMD_MDOF); 
1153:  MOVLW  0A
1154:  BSF    03.5
1155:  MOVWF  36
1156:  MOVLW  76
1157:  MOVWF  37
1158:  BCF    0A.4
1159:  BCF    03.5
115A:  CALL   2FD
115B:  BSF    0A.4
115C:  BTFSC  2B.7
115D:  BSF    0B.7
115E:  CLRF   2B
115F:  BTFSC  0B.7
1160:  BSF    2B.7
1161:  BCF    0B.7
....................             delay_ms(I2CWAIT); 
1162:  MOVLW  32
1163:  BSF    03.5
1164:  MOVWF  32
1165:  BCF    0A.4
1166:  BCF    03.5
1167:  CALL   310
1168:  BSF    0A.4
1169:  BTFSC  2B.7
116A:  BSF    0B.7
....................          } 
116B:  GOTO   188
116C:  CLRF   2B
116D:  BTFSC  0B.7
116E:  BSF    2B.7
116F:  BCF    0B.7
....................          else 
....................          { 
....................             i2c_send(I2C_TIMER, I2C_CMD_MDON); 
1170:  MOVLW  0A
1171:  BSF    03.5
1172:  MOVWF  36
1173:  MOVLW  75
1174:  MOVWF  37
1175:  BCF    0A.4
1176:  BCF    03.5
1177:  CALL   2FD
1178:  BSF    0A.4
1179:  BTFSC  2B.7
117A:  BSF    0B.7
117B:  CLRF   2B
117C:  BTFSC  0B.7
117D:  BSF    2B.7
117E:  BCF    0B.7
....................             delay_ms(I2CWAIT); 
117F:  MOVLW  32
1180:  BSF    03.5
1181:  MOVWF  32
1182:  BCF    0A.4
1183:  BCF    03.5
1184:  CALL   310
1185:  BSF    0A.4
1186:  BTFSC  2B.7
1187:  BSF    0B.7
....................          } 
....................  
.................... } 
....................  
.................... void showNumber(int8 n, tPort p) 
*
0241:  BSF    03.5
0242:  BCF    30.0
0243:  BCF    30.1
0244:  BCF    30.2
0245:  BCF    30.3
.................... { 
....................    int1 a=0, b=0, c=0, d=0; 
....................    switch(n) 
0246:  MOVLW  01
0247:  SUBWF  2B,W
0248:  ADDLW  F7
0249:  BTFSC  03.0
024A:  GOTO   270
024B:  ADDLW  09
024C:  BCF    03.5
024D:  GOTO   2C8
....................    { 
....................       case 1:  a=1; 
024E:  BSF    03.5
024F:  BSF    30.0
....................                break; 
0250:  GOTO   270
....................       case 2:  b=1; 
0251:  BSF    03.5
0252:  BSF    30.1
....................                break; 
0253:  GOTO   270
....................       case 3:  a=1; b=1; 
0254:  BSF    03.5
0255:  BSF    30.0
0256:  BSF    30.1
....................                break; 
0257:  GOTO   270
....................       case 4:  c=1; 
0258:  BSF    03.5
0259:  BSF    30.2
....................                break; 
025A:  GOTO   270
....................       case 5:  c=1; a=1; 
025B:  BSF    03.5
025C:  BSF    30.2
025D:  BSF    30.0
....................                break; 
025E:  GOTO   270
....................       case 6:  c=1; b=1; 
025F:  BSF    03.5
0260:  BSF    30.2
0261:  BSF    30.1
....................                break; 
0262:  GOTO   270
....................       case 7:  c=1; b=1; a=1; 
0263:  BSF    03.5
0264:  BSF    30.2
0265:  BSF    30.1
0266:  BSF    30.0
....................                break; 
0267:  GOTO   270
....................       case 8:  d=1; 
0268:  BSF    03.5
0269:  BSF    30.3
....................                break; 
026A:  GOTO   270
....................       case 9:  d=1; a=1; 
026B:  BSF    03.5
026C:  BSF    30.3
026D:  BSF    30.0
....................                break; 
026E:  GOTO   270
026F:  BSF    03.5
....................    } 
....................    output_bit(p.a, a); 
0270:  MOVLW  00
0271:  BTFSC  30.0
0272:  MOVLW  01
0273:  MOVWF  77
0274:  MOVF   2C,W
0275:  MOVWF  31
0276:  MOVF   77,W
0277:  MOVWF  32
0278:  CLRF   34
0279:  CLRF   33
027A:  BCF    03.5
027B:  CALL   21F
027C:  BSF    03.5
027D:  MOVF   2C,W
027E:  MOVWF  31
027F:  CLRF   32
0280:  CLRF   34
0281:  MOVLW  80
0282:  MOVWF  33
0283:  BCF    03.5
0284:  CALL   21F
....................    output_bit(p.b, b); 
0285:  MOVLW  00
0286:  BSF    03.5
0287:  BTFSC  30.1
0288:  MOVLW  01
0289:  MOVWF  77
028A:  MOVF   2D,W
028B:  MOVWF  31
028C:  MOVF   77,W
028D:  MOVWF  32
028E:  CLRF   34
028F:  CLRF   33
0290:  BCF    03.5
0291:  CALL   21F
0292:  BSF    03.5
0293:  MOVF   2D,W
0294:  MOVWF  31
0295:  CLRF   32
0296:  CLRF   34
0297:  MOVLW  80
0298:  MOVWF  33
0299:  BCF    03.5
029A:  CALL   21F
....................    output_bit(p.c, c); 
029B:  MOVLW  00
029C:  BSF    03.5
029D:  BTFSC  30.2
029E:  MOVLW  01
029F:  MOVWF  77
02A0:  MOVF   2E,W
02A1:  MOVWF  31
02A2:  MOVF   77,W
02A3:  MOVWF  32
02A4:  CLRF   34
02A5:  CLRF   33
02A6:  BCF    03.5
02A7:  CALL   21F
02A8:  BSF    03.5
02A9:  MOVF   2E,W
02AA:  MOVWF  31
02AB:  CLRF   32
02AC:  CLRF   34
02AD:  MOVLW  80
02AE:  MOVWF  33
02AF:  BCF    03.5
02B0:  CALL   21F
....................    output_bit(p.d, d); 
02B1:  MOVLW  00
02B2:  BSF    03.5
02B3:  BTFSC  30.3
02B4:  MOVLW  01
02B5:  MOVWF  77
02B6:  MOVF   2F,W
02B7:  MOVWF  31
02B8:  MOVF   77,W
02B9:  MOVWF  32
02BA:  CLRF   34
02BB:  CLRF   33
02BC:  BCF    03.5
02BD:  CALL   21F
02BE:  BSF    03.5
02BF:  MOVF   2F,W
02C0:  MOVWF  31
02C1:  CLRF   32
02C2:  CLRF   34
02C3:  MOVLW  80
02C4:  MOVWF  33
02C5:  BCF    03.5
02C6:  CALL   21F
02C7:  RETURN
.................... } 
....................  
.................... int8 char2int(char c) 
.................... { 
....................    switch(c) 
*
01D1:  MOVLW  30
01D2:  BSF    03.5
01D3:  SUBWF  2D,W
01D4:  ADDLW  F6
01D5:  BTFSC  03.0
01D6:  GOTO   20D
01D7:  ADDLW  0A
01D8:  BCF    03.5
01D9:  GOTO   211
....................    { 
....................       case '0':   return 0; 
01DA:  MOVLW  00
01DB:  MOVWF  78
01DC:  GOTO   210
....................                   break; 
01DD:  BSF    03.5
01DE:  GOTO   20D
....................       case '1':   return 1; 
01DF:  MOVLW  01
01E0:  MOVWF  78
01E1:  GOTO   210
....................                   break; 
01E2:  BSF    03.5
01E3:  GOTO   20D
....................       case '2':   return 2; 
01E4:  MOVLW  02
01E5:  MOVWF  78
01E6:  GOTO   210
....................                   break; 
01E7:  BSF    03.5
01E8:  GOTO   20D
....................       case '3':   return 3; 
01E9:  MOVLW  03
01EA:  MOVWF  78
01EB:  GOTO   210
....................                   break; 
01EC:  BSF    03.5
01ED:  GOTO   20D
....................       case '4':   return 4; 
01EE:  MOVLW  04
01EF:  MOVWF  78
01F0:  GOTO   210
....................                   break; 
01F1:  BSF    03.5
01F2:  GOTO   20D
....................       case '5':   return 5; 
01F3:  MOVLW  05
01F4:  MOVWF  78
01F5:  GOTO   210
....................                   break; 
01F6:  BSF    03.5
01F7:  GOTO   20D
....................       case '6':   return 6; 
01F8:  MOVLW  06
01F9:  MOVWF  78
01FA:  GOTO   210
....................                   break; 
01FB:  BSF    03.5
01FC:  GOTO   20D
....................       case '7':   return 7; 
01FD:  MOVLW  07
01FE:  MOVWF  78
01FF:  GOTO   210
....................                   break; 
0200:  BSF    03.5
0201:  GOTO   20D
....................       case '8':   return 8; 
0202:  MOVLW  08
0203:  MOVWF  78
0204:  GOTO   210
....................                   break; 
0205:  BSF    03.5
0206:  GOTO   20D
....................       case '9':   return 9; 
0207:  MOVLW  09
0208:  MOVWF  78
0209:  GOTO   210
....................                   break; 
020A:  BSF    03.5
020B:  GOTO   20D
020C:  BSF    03.5
....................    } 
....................    return 0; 
020D:  MOVLW  00
020E:  MOVWF  78
020F:  BCF    03.5
0210:  RETURN
.................... } 
....................  
.................... void doReset(void) 
.................... { 
....................    i2c_send(I2C_TIMER, I2C_CMD_RESET); 
*
0E91:  MOVLW  0A
0E92:  MOVWF  36
0E93:  MOVLW  FD
0E94:  MOVWF  37
0E95:  BCF    0A.3
0E96:  BCF    03.5
0E97:  CALL   2FD
0E98:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0E99:  MOVLW  32
0E9A:  BSF    03.5
0E9B:  MOVWF  32
0E9C:  BCF    0A.3
0E9D:  BCF    03.5
0E9E:  CALL   310
0E9F:  BSF    0A.3
....................    i2c_send(I2C_SCORE, I2C_CMD_RESET); 
0EA0:  MOVLW  0C
0EA1:  BSF    03.5
0EA2:  MOVWF  36
0EA3:  MOVLW  FD
0EA4:  MOVWF  37
0EA5:  BCF    0A.3
0EA6:  BCF    03.5
0EA7:  CALL   2FD
0EA8:  BSF    0A.3
....................    delay_ms(I2CWAIT); 
0EA9:  MOVLW  32
0EAA:  BSF    03.5
0EAB:  MOVWF  32
0EAC:  BCF    0A.3
0EAD:  BCF    03.5
0EAE:  CALL   310
0EAF:  BSF    0A.3
....................    reset_cpu(); 
0EB0:  CLRF   0A
0EB1:  GOTO   000
.................... } 
....................  
.................... void sendN2Port(int8 n, int8 a, int8 p) 
*
0324:  BSF    03.5
0325:  SWAPF  34,W
0326:  MOVWF  77
0327:  MOVLW  F0
0328:  ANDWF  77,F
0329:  MOVF   77,W
032A:  ADDWF  32,W
032B:  MOVWF  35
.................... { 
....................    int c = (p * 16) + n; 
....................    i2c_send(a, c); 
032C:  MOVF   33,W
032D:  MOVWF  36
032E:  MOVF   35,W
032F:  MOVWF  37
0330:  BCF    03.5
0331:  CALL   2FD
0332:  RETURN
.................... } 
....................  
.................... void i2c_send(int8 a, int8 c) 
.................... { 
....................    i2c_start(); 
*
02FD:  BSF    03.5
02FE:  BSF    11.0
02FF:  BTFSC  11.0
0300:  GOTO   2FF
....................    i2c_write(a); 
0301:  MOVF   36,W
0302:  MOVWF  38
0303:  BCF    03.5
0304:  CALL   2D5
....................    i2c_write(c); 
0305:  BSF    03.5
0306:  MOVF   37,W
0307:  MOVWF  38
0308:  BCF    03.5
0309:  CALL   2D5
....................    i2c_stop(); 
030A:  BSF    03.5
030B:  BSF    11.2
030C:  BTFSC  11.2
030D:  GOTO   30C
030E:  BCF    03.5
030F:  RETURN
.................... } 

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

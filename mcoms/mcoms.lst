CCS PCM C Compiler, Version 5.076, 56587               07-mar.-20 22:54

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mcoms\mcoms.lst

               ROM used:   2079 words (25%)
                           Largest free fragment is 2048
               RAM used:   83 (23%) at main() level
                           111 (30%) worst case
               Stack used: 3 locations (1 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   3DA
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   430
....................  
.................... #include <mcoms.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  RETLW  00
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 2A,15
0079:  DATA 0D,00
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA A0,23
007E:  DATA F2,3A
007F:  DATA F0,37
0080:  DATA A0,20
0081:  DATA D0,26
0082:  DATA 20,14
0083:  DATA E3,14
0084:  DATA 20,19
0085:  DATA 30,19
0086:  DATA 30,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 0D,00
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA BD,1E
009B:  DATA 0D,00
009C:  DATA 42,36
009D:  DATA F5,32
009E:  DATA F4,37
009F:  DATA 6F,3A
00A0:  DATA 68,10
00A1:  DATA C2,30
00A2:  DATA F3,35
00A3:  DATA 65,3A
00A4:  DATA E2,30
00A5:  DATA 6C,36
00A6:  DATA A0,29
00A7:  DATA E3,37
00A8:  DATA F2,32
00A9:  DATA 20,21
00AA:  DATA EF,30
00AB:  DATA 72,32
00AC:  DATA 0D,00
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA BD,1E
00BD:  DATA 0D,00
00BE:  DATA D6,32
00BF:  DATA F2,39
00C0:  DATA E9,37
00C1:  DATA 6E,10
00C2:  DATA A5,39
00C3:  DATA A0,16
00C4:  DATA 20,39
00C5:  DATA 65,3B
00C6:  DATA A0,12
00C7:  DATA 73,10
00C8:  DATA 0D,00
00C9:  DATA 31,17
00CA:  DATA 30,00
00CB:  DATA 41,00
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 2A,15
00DC:  DATA 0D,00
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA C3,27
00E1:  DATA CE,29
00E2:  DATA 4F,26
00E3:  DATA 41,10
00E4:  DATA C4,22
00E5:  DATA 20,22
00E6:  DATA 45,28
00E7:  DATA 55,29
00E8:  DATA C1,21
00E9:  DATA C9,27
00EA:  DATA 4E,10
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 0D,00
00EE:  DATA 47,39
00EF:  DATA 75,38
00F0:  DATA 6F,10
00F1:  DATA 41,28
00F2:  DATA 4D,10
00F3:  DATA A8,31
00F4:  DATA 29,10
00F5:  DATA 32,18
00F6:  DATA 32,18
00F7:  DATA 20,1D
00F8:  DATA 3A,10
00F9:  DATA 42,21
00FA:  DATA 53,21
00FB:  DATA A0,18
00FC:  DATA 2E,18
00FD:  DATA 20,39
00FE:  DATA 65,3B
00FF:  DATA A0,20
0100:  DATA 00,00
0101:  DATA 3E,10
0102:  DATA C3,37
0103:  DATA 6E,33
0104:  DATA E9,33
0105:  DATA 75,39
0106:  DATA E1,31
0107:  DATA E9,37
0108:  DATA 6E,10
0109:  DATA E4,32
010A:  DATA 20,28
010B:  DATA F5,32
010C:  DATA 72,3A
010D:  DATA EF,39
010E:  DATA 00,01
010F:  DATA 3E,10
0110:  DATA 49,37
0111:  DATA E9,31
0112:  DATA E9,30
0113:  DATA EC,34
0114:  DATA FA,30
0115:  DATA E3,34
0116:  DATA 6F,37
0117:  DATA 20,32
0118:  DATA 65,10
0119:  DATA 49,19
011A:  DATA 43,00
011B:  DATA 3E,10
011C:  DATA 49,37
011D:  DATA E9,31
011E:  DATA E9,30
011F:  DATA EC,34
0120:  DATA FA,30
0121:  DATA E3,34
0122:  DATA 6F,37
0123:  DATA 20,32
0124:  DATA 65,10
0125:  DATA ED,37
0126:  DATA E4,3A
0127:  DATA EC,37
0128:  DATA 20,3A
0129:  DATA E9,32
012A:  DATA 6D,38
012B:  DATA 6F,00
012C:  DATA 3E,10
012D:  DATA 49,37
012E:  DATA E9,31
012F:  DATA E9,30
0130:  DATA EC,34
0131:  DATA FA,30
0132:  DATA E3,34
0133:  DATA 6F,37
0134:  DATA 20,32
0135:  DATA 65,10
0136:  DATA ED,37
0137:  DATA E4,3A
0138:  DATA EC,37
0139:  DATA 20,38
013A:  DATA 75,37
013B:  DATA F4,37
013C:  DATA 73,00
013D:  DATA 3E,10
013E:  DATA C8,30
013F:  DATA E2,34
0140:  DATA EC,34
0141:  DATA F4,30
0142:  DATA E3,34
0143:  DATA 6F,37
0144:  DATA 20,32
0145:  DATA 65,10
0146:  DATA 69,37
0147:  DATA F4,32
0148:  DATA 72,39
0149:  DATA 75,38
014A:  DATA E3,34
014B:  DATA 6F,37
014C:  DATA E5,39
014D:  DATA 00,00
014E:  MOVF   0B,W
014F:  BSF    03.5
0150:  MOVWF  2A
0151:  BCF    03.5
0152:  BCF    0B.7
0153:  BSF    03.5
0154:  BSF    03.6
0155:  BSF    0C.7
0156:  BSF    0C.0
0157:  NOP
0158:  NOP
0159:  BCF    03.6
015A:  BTFSS  2A.7
015B:  GOTO   15F
015C:  BCF    03.5
015D:  BSF    0B.7
015E:  BSF    03.5
015F:  BCF    03.5
0160:  BSF    03.6
0161:  MOVF   0C,W
0162:  ANDLW  7F
0163:  BTFSC  03.2
0164:  GOTO   1C2
0165:  BSF    03.5
0166:  BCF    03.6
0167:  MOVWF  2A
0168:  BCF    03.5
0169:  BSF    03.6
016A:  MOVF   0D,W
016B:  BSF    03.5
016C:  BCF    03.6
016D:  MOVWF  2B
016E:  BCF    03.5
016F:  BSF    03.6
0170:  MOVF   0F,W
0171:  BSF    03.5
0172:  BCF    03.6
0173:  MOVWF  2C
0174:  MOVF   2A,W
0175:  BCF    03.5
0176:  BTFSS  0C.4
0177:  GOTO   176
0178:  MOVWF  19
0179:  BSF    03.5
017A:  MOVF   2B,W
017B:  BCF    03.5
017C:  BSF    03.6
017D:  MOVWF  0D
017E:  BSF    03.5
017F:  BCF    03.6
0180:  MOVF   2C,W
0181:  BCF    03.5
0182:  BSF    03.6
0183:  MOVWF  0F
0184:  BCF    03.6
0185:  MOVF   0B,W
0186:  BSF    03.5
0187:  MOVWF  2D
0188:  BCF    03.5
0189:  BCF    0B.7
018A:  BSF    03.5
018B:  BSF    03.6
018C:  BSF    0C.7
018D:  BSF    0C.0
018E:  NOP
018F:  NOP
0190:  BCF    03.6
0191:  BTFSS  2D.7
0192:  GOTO   196
0193:  BCF    03.5
0194:  BSF    0B.7
0195:  BSF    03.5
0196:  BCF    03.5
0197:  BSF    03.6
0198:  RLF    0C,W
0199:  RLF    0E,W
019A:  ANDLW  7F
019B:  BTFSC  03.2
019C:  GOTO   1C2
019D:  BSF    03.5
019E:  BCF    03.6
019F:  MOVWF  2A
01A0:  BCF    03.5
01A1:  BSF    03.6
01A2:  MOVF   0D,W
01A3:  BSF    03.5
01A4:  BCF    03.6
01A5:  MOVWF  2B
01A6:  BCF    03.5
01A7:  BSF    03.6
01A8:  MOVF   0F,W
01A9:  BSF    03.5
01AA:  BCF    03.6
01AB:  MOVWF  2C
01AC:  MOVF   2A,W
01AD:  BCF    03.5
01AE:  BTFSS  0C.4
01AF:  GOTO   1AE
01B0:  MOVWF  19
01B1:  BSF    03.5
01B2:  MOVF   2B,W
01B3:  BCF    03.5
01B4:  BSF    03.6
01B5:  MOVWF  0D
01B6:  BSF    03.5
01B7:  BCF    03.6
01B8:  MOVF   2C,W
01B9:  BCF    03.5
01BA:  BSF    03.6
01BB:  MOVWF  0F
01BC:  INCF   0D,F
01BD:  BTFSC  03.2
01BE:  INCF   0F,F
01BF:  BCF    03.6
01C0:  GOTO   14E
01C1:  BSF    03.6
01C2:  BCF    03.6
01C3:  RETURN
*
03C9:  BSF    0A.0
03CA:  BSF    0A.1
03CB:  BCF    0A.2
03CC:  ADDWF  02,F
03CD:  GOTO   1F9
03CE:  GOTO   3C4
03CF:  GOTO   3C4
03D0:  GOTO   3C4
03D1:  GOTO   28D
03D2:  GOTO   2A0
03D3:  GOTO   3C4
03D4:  GOTO   3C4
03D5:  GOTO   2B3
03D6:  GOTO   3C4
03D7:  GOTO   2C6
03D8:  GOTO   3C4
03D9:  GOTO   35A
*
0434:  DATA 3E,10
0435:  DATA D2,3A
0436:  DATA F4,34
0437:  DATA EE,30
0438:  DATA 20,32
0439:  DATA 65,10
043A:  DATA 70,39
043B:  DATA F5,32
043C:  DATA E2,30
043D:  DATA 00,01
043E:  DATA 3E,10
043F:  DATA 50,39
0440:  DATA 6F,31
0441:  DATA 61,37
0442:  DATA E4,37
0443:  DATA A0,36
0444:  DATA 6F,32
0445:  DATA 75,36
0446:  DATA 6F,10
0447:  DATA F4,34
0448:  DATA E5,36
0449:  DATA F0,37
044A:  DATA 00,01
044B:  DATA 3E,10
044C:  DATA 50,39
044D:  DATA 6F,31
044E:  DATA 61,37
044F:  DATA E4,37
0450:  DATA A0,36
0451:  DATA 6F,32
0452:  DATA 75,36
0453:  DATA 6F,10
0454:  DATA F0,3A
0455:  DATA 6E,3A
0456:  DATA EF,39
0457:  DATA 00,01
0458:  DATA 3E,10
0459:  DATA 50,39
045A:  DATA 6F,31
045B:  DATA 61,37
045C:  DATA E4,37
045D:  DATA A0,36
045E:  DATA 6F,32
045F:  DATA 75,36
0460:  DATA 6F,10
0461:  DATA E3,37
0462:  DATA ED,3A
0463:  DATA EE,34
0464:  DATA E3,30
0465:  DATA E3,34
0466:  DATA 6F,37
0467:  DATA E5,39
0468:  DATA 00,00
0469:  DATA 0D,1F
046A:  DATA A0,21
046B:  DATA EF,36
046C:  DATA 61,37
046D:  DATA E4,37
046E:  DATA 20,36
046F:  DATA EF,31
0470:  DATA 61,36
0471:  DATA 00,01
0472:  DATA 0D,1F
0473:  DATA 20,29
0474:  DATA E5,39
0475:  DATA 65,3A
0476:  DATA E5,30
0477:  DATA A0,30
0478:  DATA 20,18
0479:  DATA 00,01
047A:  DATA 0D,1F
047B:  DATA A0,24
047C:  DATA EE,31
047D:  DATA F2,32
047E:  DATA ED,32
047F:  DATA 6E,3A
0480:  DATA 61,39
0481:  DATA 20,38
0482:  DATA 6F,39
0483:  DATA A0,18
0484:  DATA 00,01
0485:  DATA 0D,1F
0486:  DATA A0,24
0487:  DATA EE,31
0488:  DATA F2,32
0489:  DATA ED,32
048A:  DATA 6E,3A
048B:  DATA 61,39
048C:  DATA 20,38
048D:  DATA 6F,39
048E:  DATA 20,19
048F:  DATA 00,01
0490:  DATA 0D,1F
0491:  DATA A0,24
0492:  DATA EE,31
0493:  DATA F2,32
0494:  DATA ED,32
0495:  DATA 6E,3A
0496:  DATA 61,39
0497:  DATA 20,38
0498:  DATA 6F,39
0499:  DATA A0,19
049A:  DATA 00,01
049B:  DATA 0D,1F
049C:  DATA 20,22
049D:  DATA E5,31
049E:  DATA F2,32
049F:  DATA ED,32
04A0:  DATA 6E,3A
04A1:  DATA 61,39
04A2:  DATA 20,38
04A3:  DATA 6F,39
04A4:  DATA A0,18
04A5:  DATA 00,01
04A6:  DATA 0D,1F
04A7:  DATA A0,20
04A8:  DATA F3,34
04A9:  DATA 67,37
04AA:  DATA 61,39
04AB:  DATA 20,38
04AC:  DATA EF,39
04AD:  DATA E9,31
04AE:  DATA E9,37
04AF:  DATA 6E,00
04B0:  DATA 0D,1F
04B1:  DATA 20,28
04B2:  DATA E1,3A
04B3:  DATA F3,30
04B4:  DATA 72,10
04B5:  DATA F4,34
04B6:  DATA E5,36
04B7:  DATA F0,37
04B8:  DATA 00,01
04B9:  DATA 0D,1F
04BA:  DATA 20,29
04BB:  DATA 65,37
04BC:  DATA 75,32
04BD:  DATA 61,39
04BE:  DATA 20,3A
04BF:  DATA E9,32
04C0:  DATA 6D,38
04C1:  DATA 6F,00
04C2:  DATA 0D,1F
04C3:  DATA A0,21
04C4:  DATA 6F,37
04C5:  DATA E6,34
04C6:  DATA E7,3A
04C7:  DATA F2,30
04C8:  DATA E3,34
04C9:  DATA 6F,37
04CA:  DATA 20,32
04CB:  DATA 65,10
04CC:  DATA F4,34
04CD:  DATA E5,36
04CE:  DATA F0,37
04CF:  DATA 00,01
04D0:  DATA 0D,1F
04D1:  DATA A0,21
04D2:  DATA EF,36
04D3:  DATA 61,37
04D4:  DATA E4,37
04D5:  DATA 20,3B
04D6:  DATA E9,39
04D7:  DATA 69,3A
04D8:  DATA 61,37
04D9:  DATA F4,32
04DA:  DATA 00,01
04DB:  DATA 0D,1F
04DC:  DATA 20,29
04DD:  DATA E5,39
04DE:  DATA 65,3A
04DF:  DATA E5,30
04E0:  DATA A0,30
04E1:  DATA 20,18
04E2:  DATA 00,01
04E3:  DATA 0D,1F
04E4:  DATA A0,24
04E5:  DATA EE,31
04E6:  DATA F2,32
04E7:  DATA ED,32
04E8:  DATA 6E,3A
04E9:  DATA 61,39
04EA:  DATA 20,38
04EB:  DATA 6F,39
04EC:  DATA A0,18
04ED:  DATA 00,01
04EE:  DATA 0D,1F
04EF:  DATA A0,24
04F0:  DATA EE,31
04F1:  DATA F2,32
04F2:  DATA ED,32
04F3:  DATA 6E,3A
04F4:  DATA 61,39
04F5:  DATA 20,38
04F6:  DATA 6F,39
04F7:  DATA 20,19
04F8:  DATA 00,01
04F9:  DATA 0D,1F
04FA:  DATA A0,24
04FB:  DATA EE,31
04FC:  DATA F2,32
04FD:  DATA ED,32
04FE:  DATA 6E,3A
04FF:  DATA 61,39
0500:  DATA 20,38
0501:  DATA 6F,39
0502:  DATA A0,19
0503:  DATA 00,01
0504:  DATA 0D,1F
0505:  DATA 20,22
0506:  DATA E5,31
0507:  DATA F2,32
0508:  DATA ED,32
0509:  DATA 6E,3A
050A:  DATA 61,39
050B:  DATA 20,38
050C:  DATA 6F,39
050D:  DATA A0,18
050E:  DATA 00,01
050F:  DATA 0D,1F
0510:  DATA A0,20
0511:  DATA F3,34
0512:  DATA 67,37
0513:  DATA 61,39
0514:  DATA 20,38
0515:  DATA EF,39
0516:  DATA E9,31
0517:  DATA E9,37
0518:  DATA 6E,00
0519:  MOVF   0B,W
051A:  MOVWF  6A
051B:  BCF    0B.7
051C:  BSF    03.5
051D:  BSF    03.6
051E:  BSF    0C.7
051F:  BSF    0C.0
0520:  NOP
0521:  NOP
0522:  BCF    03.5
0523:  BCF    03.6
0524:  BTFSC  6A.7
0525:  BSF    0B.7
0526:  BSF    03.6
0527:  MOVF   0C,W
0528:  ANDLW  7F
0529:  BTFSC  03.2
052A:  GOTO   56F
052B:  BCF    03.6
052C:  MOVWF  6A
052D:  BSF    03.6
052E:  MOVF   0D,W
052F:  BCF    03.6
0530:  MOVWF  6B
0531:  BSF    03.6
0532:  MOVF   0F,W
0533:  BCF    03.6
0534:  MOVWF  6C
0535:  MOVF   6A,W
0536:  BTFSS  0C.4
0537:  GOTO   536
0538:  MOVWF  19
0539:  MOVF   6B,W
053A:  BSF    03.6
053B:  MOVWF  0D
053C:  BCF    03.6
053D:  MOVF   6C,W
053E:  BSF    03.6
053F:  MOVWF  0F
0540:  BCF    03.6
0541:  MOVF   0B,W
0542:  MOVWF  6D
0543:  BCF    0B.7
0544:  BSF    03.5
0545:  BSF    03.6
0546:  BSF    0C.7
0547:  BSF    0C.0
0548:  NOP
0549:  NOP
054A:  BCF    03.5
054B:  BCF    03.6
054C:  BTFSC  6D.7
054D:  BSF    0B.7
054E:  BSF    03.6
054F:  RLF    0C,W
0550:  RLF    0E,W
0551:  ANDLW  7F
0552:  BTFSC  03.2
0553:  GOTO   56F
0554:  BCF    03.6
0555:  MOVWF  6A
0556:  BSF    03.6
0557:  MOVF   0D,W
0558:  BCF    03.6
0559:  MOVWF  6B
055A:  BSF    03.6
055B:  MOVF   0F,W
055C:  BCF    03.6
055D:  MOVWF  6C
055E:  MOVF   6A,W
055F:  BTFSS  0C.4
0560:  GOTO   55F
0561:  MOVWF  19
0562:  MOVF   6B,W
0563:  BSF    03.6
0564:  MOVWF  0D
0565:  BCF    03.6
0566:  MOVF   6C,W
0567:  BSF    03.6
0568:  MOVWF  0F
0569:  INCF   0D,F
056A:  BTFSC  03.2
056B:  INCF   0F,F
056C:  BCF    03.6
056D:  GOTO   519
056E:  BSF    03.6
056F:  BCF    03.6
0570:  RETURN
0571:  MOVF   0B,W
0572:  MOVWF  6B
0573:  BCF    0B.7
0574:  BSF    03.5
0575:  BSF    03.6
0576:  BSF    0C.7
0577:  BSF    0C.0
0578:  NOP
0579:  NOP
057A:  BCF    03.5
057B:  BCF    03.6
057C:  BTFSC  6B.7
057D:  BSF    0B.7
057E:  BTFSC  03.0
057F:  GOTO   5A9
0580:  BSF    03.6
0581:  MOVF   0C,W
0582:  ANDLW  7F
0583:  BCF    03.6
0584:  MOVWF  6B
0585:  BSF    03.6
0586:  MOVF   0D,W
0587:  BCF    03.6
0588:  MOVWF  6C
0589:  BSF    03.6
058A:  MOVF   0F,W
058B:  BCF    03.6
058C:  MOVWF  6D
058D:  MOVF   6B,W
058E:  BTFSS  0C.4
058F:  GOTO   58E
0590:  MOVWF  19
0591:  MOVF   6C,W
0592:  BSF    03.6
0593:  MOVWF  0D
0594:  BCF    03.6
0595:  MOVF   6D,W
0596:  BSF    03.6
0597:  MOVWF  0F
0598:  BCF    03.6
0599:  MOVF   0B,W
059A:  MOVWF  6E
059B:  BCF    0B.7
059C:  BSF    03.5
059D:  BSF    03.6
059E:  BSF    0C.7
059F:  BSF    0C.0
05A0:  NOP
05A1:  NOP
05A2:  BCF    03.5
05A3:  BCF    03.6
05A4:  BTFSC  6E.7
05A5:  BSF    0B.7
05A6:  DECFSZ 6A,F
05A7:  GOTO   5A9
05A8:  GOTO   5C9
05A9:  BSF    03.6
05AA:  RLF    0C,W
05AB:  RLF    0E,W
05AC:  ANDLW  7F
05AD:  BCF    03.6
05AE:  MOVWF  6B
05AF:  BSF    03.6
05B0:  MOVF   0D,W
05B1:  BCF    03.6
05B2:  MOVWF  6C
05B3:  BSF    03.6
05B4:  MOVF   0F,W
05B5:  BCF    03.6
05B6:  MOVWF  6D
05B7:  MOVF   6B,W
05B8:  BTFSS  0C.4
05B9:  GOTO   5B8
05BA:  MOVWF  19
05BB:  MOVF   6C,W
05BC:  BSF    03.6
05BD:  MOVWF  0D
05BE:  BCF    03.6
05BF:  MOVF   6D,W
05C0:  BSF    03.6
05C1:  MOVWF  0F
05C2:  INCF   0D,F
05C3:  BTFSC  03.2
05C4:  INCF   0F,F
05C5:  BCF    03.0
05C6:  BCF    03.6
05C7:  DECFSZ 6A,F
05C8:  GOTO   571
05C9:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "1.0" 
.................... #define FW_REVISION  "A" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
05E5:  MOVLW  6A
05E6:  MOVWF  04
05E7:  BCF    03.7
05E8:  MOVF   00,W
05E9:  BTFSC  03.2
05EA:  GOTO   5F8
05EB:  MOVLW  02
05EC:  MOVWF  78
05ED:  CLRF   77
05EE:  DECFSZ 77,F
05EF:  GOTO   5EE
05F0:  DECFSZ 78,F
05F1:  GOTO   5ED
05F2:  MOVLW  97
05F3:  MOVWF  77
05F4:  DECFSZ 77,F
05F5:  GOTO   5F4
05F6:  DECFSZ 00,F
05F7:  GOTO   5EB
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Master,Fast,sda=I2C_SDA,scl=I2C_SCL) 
*
01C4:  BCF    14.7
01C5:  BCF    0C.3
01C6:  BSF    03.5
01C7:  MOVF   2A,W
01C8:  BCF    03.5
01C9:  MOVWF  13
01CA:  MOVLW  02
01CB:  BTFSC  14.7
01CC:  GOTO   1D4
01CD:  BTFSS  0C.3
01CE:  GOTO   1CD
01CF:  MOVLW  00
01D0:  BSF    03.5
01D1:  BTFSC  11.6
01D2:  MOVLW  01
01D3:  BCF    03.5
01D4:  MOVWF  78
01D5:  RETURN
.................... #use timer  (timer=0,tick=100us,bits=32,NOISR) 
*
0737:  MOVF   01,W
0738:  BTFSS  0B.2
0739:  GOTO   744
073A:  MOVLW  01
073B:  ADDWF  2C,F
073C:  BTFSC  03.0
073D:  INCF   2D,F
073E:  BTFSC  03.2
073F:  INCF   2E,F
0740:  BTFSC  03.2
0741:  INCF   2F,F
0742:  BCF    0B.2
0743:  MOVF   01,W
0744:  MOVWF  77
0745:  MOVF   2C,W
0746:  MOVWF  78
0747:  MOVF   2D,W
0748:  MOVWF  79
0749:  MOVF   2E,W
074A:  MOVWF  7A
074B:  MOVF   2F,W
074C:  MOVWF  6A
074D:  RRF    6A,F
074E:  RRF    7A,F
074F:  RRF    79,F
0750:  RRF    78,F
0751:  RRF    77,F
0752:  RETURN
....................  
.................... //-- DEFINICIONES -- 
.................... #define TICK_TYPE    unsigned int32 
.................... #define I2C_TIMER    0x0A 
.................... #define I2C_SCORE    0x0C 
....................  
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
....................  
.................... #define P_JUGADOR_D     puertoB 
.................... #define P_JUGADOR_U     puertoA 
.................... #define P_FALTASJ_D     PuertoC 
....................  
.................... //-- DECLARACIONES -- 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0\0"; 
*
0840:  BCF    03.6
0841:  CLRF   30
0842:  CLRF   31
0843:  CLRF   32
0844:  CLRF   33
0845:  CLRF   34
0846:  CLRF   35
0847:  CLRF   36
0848:  CLRF   37
0849:  CLRF   38
084A:  CLRF   39
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0\0"; 
084B:  CLRF   3A
084C:  CLRF   3B
084D:  CLRF   3C
084E:  CLRF   3D
084F:  CLRF   3E
0850:  CLRF   3F
0851:  CLRF   40
0852:  CLRF   41
0853:  CLRF   42
0854:  CLRF   43
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... struct sPuerto 
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } puertoA, puertoB, puertoC, puertoD, puertoE, puertoF; 
....................  
....................  
.................... //-- PROTOTIPOS -- 
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick); 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void timeTick(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
0855:  CLRF   5E
0856:  CLRF   5F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
05CA:  MOVLW  0F
05CB:  BSF    03.5
05CC:  MOVWF  05
05CD:  BCF    03.5
05CE:  CLRF   05
....................    output_b(0x00); 
05CF:  BSF    03.5
05D0:  CLRF   06
05D1:  BCF    03.5
05D2:  CLRF   06
....................    output_c(0x00); 
05D3:  MOVLW  DF
05D4:  BSF    03.5
05D5:  MOVWF  07
05D6:  BCF    03.5
05D7:  CLRF   07
....................    output_d(0x00); 
05D8:  BSF    03.5
05D9:  CLRF   08
05DA:  BCF    03.5
05DB:  CLRF   08
....................    output_e(0x00); 
05DC:  BSF    03.5
05DD:  BCF    09.0
05DE:  BCF    09.1
05DF:  BCF    09.2
05E0:  BCF    09.3
05E1:  BCF    03.5
05E2:  CLRF   09
....................     
....................    delay_ms(100); 
05E3:  MOVLW  64
05E4:  MOVWF  6A
....................     
....................    if(DEBUG) 
*
05F8:  BTFSS  07.2
05F9:  GOTO   656
....................    { 
....................       fprintf(RS232,"********************************\r"); 
05FA:  MOVLW  69
05FB:  BSF    03.6
05FC:  MOVWF  0D
05FD:  MOVLW  00
05FE:  MOVWF  0F
05FF:  BCF    03.6
0600:  CALL   519
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
0601:  MOVLW  7A
0602:  BSF    03.6
0603:  MOVWF  0D
0604:  MOVLW  00
0605:  MOVWF  0F
0606:  BCF    03.6
0607:  CALL   519
....................       fprintf(RS232,"================================\r"); 
0608:  MOVLW  8B
0609:  BSF    03.6
060A:  MOVWF  0D
060B:  MOVLW  00
060C:  MOVWF  0F
060D:  BCF    03.6
060E:  CALL   519
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
060F:  MOVLW  9C
0610:  BSF    03.6
0611:  MOVWF  0D
0612:  MOVLW  00
0613:  MOVWF  0F
0614:  BCF    03.6
0615:  CALL   519
....................       fprintf(RS232,"================================\r"); 
0616:  MOVLW  AD
0617:  BSF    03.6
0618:  MOVWF  0D
0619:  MOVLW  00
061A:  MOVWF  0F
061B:  BCF    03.6
061C:  CALL   519
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
061D:  MOVLW  BE
061E:  BSF    03.6
061F:  MOVWF  0D
0620:  MOVLW  00
0621:  MOVWF  0F
0622:  BCF    03.0
0623:  MOVLW  08
0624:  BCF    03.6
0625:  MOVWF  6A
0626:  CALL   571
0627:  MOVLW  C9
0628:  BSF    03.6
0629:  MOVWF  0D
062A:  MOVLW  00
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  CALL   519
062E:  MOVLW  C3
062F:  BSF    03.6
0630:  MOVWF  0D
0631:  MOVLW  00
0632:  MOVWF  0F
0633:  BCF    03.0
0634:  MOVLW  07
0635:  BCF    03.6
0636:  MOVWF  6A
0637:  CALL   571
0638:  MOVLW  CB
0639:  BSF    03.6
063A:  MOVWF  0D
063B:  MOVLW  00
063C:  MOVWF  0F
063D:  BCF    03.6
063E:  CALL   519
063F:  MOVLW  20
0640:  BTFSS  0C.4
0641:  GOTO   640
0642:  MOVWF  19
0643:  MOVLW  0D
0644:  BTFSS  0C.4
0645:  GOTO   644
0646:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0647:  MOVLW  CC
0648:  BSF    03.6
0649:  MOVWF  0D
064A:  MOVLW  00
064B:  MOVWF  0F
064C:  BCF    03.6
064D:  CALL   519
....................       fprintf(RS232,"      CONSOLA DE DEPURACION     \r"); 
064E:  MOVLW  DD
064F:  BSF    03.6
0650:  MOVWF  0D
0651:  MOVLW  00
0652:  MOVWF  0F
0653:  BCF    03.6
0654:  CALL   519
....................    } 
0655:  GOTO   66B
....................    else 
....................    { 
....................       fputs("Grupo APM (c) 2020 :: BBSB 1.0 rev A",RS232); 
0656:  MOVLW  EE
0657:  BSF    03.6
0658:  MOVWF  0D
0659:  MOVLW  00
065A:  MOVWF  0F
065B:  BCF    03.6
065C:  CLRF   2B
065D:  BTFSC  0B.7
065E:  BSF    2B.7
065F:  BCF    0B.7
0660:  CALL   14E
0661:  BTFSC  2B.7
0662:  BSF    0B.7
0663:  MOVLW  0D
0664:  BTFSS  0C.4
0665:  GOTO   664
0666:  MOVWF  19
0667:  MOVLW  0A
0668:  BTFSS  0C.4
0669:  GOTO   668
066A:  MOVWF  19
....................    } 
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
066B:  BTFSS  07.2
066C:  GOTO   682
066D:  MOVLW  01
066E:  BSF    03.6
066F:  MOVWF  0D
0670:  MOVLW  01
0671:  MOVWF  0F
0672:  BCF    03.6
0673:  CLRF   2B
0674:  BTFSC  0B.7
0675:  BSF    2B.7
0676:  BCF    0B.7
0677:  CALL   14E
0678:  BTFSC  2B.7
0679:  BSF    0B.7
067A:  MOVLW  0D
067B:  BTFSS  0C.4
067C:  GOTO   67B
067D:  MOVWF  19
067E:  MOVLW  0A
067F:  BTFSS  0C.4
0680:  GOTO   67F
0681:  MOVWF  19
....................     
....................    //Jugador Unidades 
....................    puertoA.a = PIN_B0; 
0682:  MOVLW  30
0683:  MOVWF  46
....................    puertoA.b = PIN_B1; 
0684:  MOVLW  31
0685:  MOVWF  47
....................    puertoA.c = PIN_B2; 
0686:  MOVLW  32
0687:  MOVWF  48
....................    puertoA.d = PIN_B3; 
0688:  MOVLW  33
0689:  MOVWF  49
....................     
....................    //Jugador Decenas 
....................    puertoB.a = PIN_B4; 
068A:  MOVLW  34
068B:  MOVWF  4A
....................    puertoB.b = PIN_B5; 
068C:  MOVLW  35
068D:  MOVWF  4B
....................    puertoB.c = PIN_B6; 
068E:  MOVLW  36
068F:  MOVWF  4C
....................    puertoB.d = PIN_B7; 
0690:  MOVLW  37
0691:  MOVWF  4D
....................     
....................    if(DEBUG) {fputs("> Inicializacion de I2C",RS232);} 
0692:  BTFSS  07.2
0693:  GOTO   6A9
0694:  MOVLW  0F
0695:  BSF    03.6
0696:  MOVWF  0D
0697:  MOVLW  01
0698:  MOVWF  0F
0699:  BCF    03.6
069A:  CLRF   2B
069B:  BTFSC  0B.7
069C:  BSF    2B.7
069D:  BCF    0B.7
069E:  CALL   14E
069F:  BTFSC  2B.7
06A0:  BSF    0B.7
06A1:  MOVLW  0D
06A2:  BTFSS  0C.4
06A3:  GOTO   6A2
06A4:  MOVWF  19
06A5:  MOVLW  0A
06A6:  BTFSS  0C.4
06A7:  GOTO   6A6
06A8:  MOVWF  19
....................     
....................    if(DEBUG) {fputs("> Inicializacion de modulo tiempo",RS232);} 
06A9:  BTFSS  07.2
06AA:  GOTO   6C0
06AB:  MOVLW  1B
06AC:  BSF    03.6
06AD:  MOVWF  0D
06AE:  MOVLW  01
06AF:  MOVWF  0F
06B0:  BCF    03.6
06B1:  CLRF   2B
06B2:  BTFSC  0B.7
06B3:  BSF    2B.7
06B4:  BCF    0B.7
06B5:  CALL   14E
06B6:  BTFSC  2B.7
06B7:  BSF    0B.7
06B8:  MOVLW  0D
06B9:  BTFSS  0C.4
06BA:  GOTO   6B9
06BB:  MOVWF  19
06BC:  MOVLW  0A
06BD:  BTFSS  0C.4
06BE:  GOTO   6BD
06BF:  MOVWF  19
....................    i2c_start(); 
06C0:  BSF    03.5
06C1:  BSF    11.0
06C2:  BTFSC  11.0
06C3:  GOTO   6C2
06C4:  BCF    03.5
06C5:  CLRF   2B
06C6:  BTFSC  0B.7
06C7:  BSF    2B.7
06C8:  BCF    0B.7
....................    i2c_write(I2C_TIMER); 
06C9:  MOVLW  0A
06CA:  BSF    03.5
06CB:  MOVWF  2A
06CC:  BCF    03.5
06CD:  CALL   1C4
06CE:  BTFSC  2B.7
06CF:  BSF    0B.7
06D0:  CLRF   2B
06D1:  BTFSC  0B.7
06D2:  BSF    2B.7
06D3:  BCF    0B.7
....................    i2c_write(I2C_CMD_INIT); 
06D4:  MOVLW  F0
06D5:  BSF    03.5
06D6:  MOVWF  2A
06D7:  BCF    03.5
06D8:  CALL   1C4
06D9:  BTFSC  2B.7
06DA:  BSF    0B.7
....................    i2c_stop(); 
06DB:  BSF    03.5
06DC:  BSF    11.2
06DD:  BTFSC  11.2
06DE:  GOTO   6DD
....................  
....................    if(DEBUG) {fputs("> Inicializacion de modulo puntos",RS232);} 
06DF:  BCF    03.5
06E0:  BTFSS  07.2
06E1:  GOTO   6F7
06E2:  MOVLW  2C
06E3:  BSF    03.6
06E4:  MOVWF  0D
06E5:  MOVLW  01
06E6:  MOVWF  0F
06E7:  BCF    03.6
06E8:  CLRF   2B
06E9:  BTFSC  0B.7
06EA:  BSF    2B.7
06EB:  BCF    0B.7
06EC:  CALL   14E
06ED:  BTFSC  2B.7
06EE:  BSF    0B.7
06EF:  MOVLW  0D
06F0:  BTFSS  0C.4
06F1:  GOTO   6F0
06F2:  MOVWF  19
06F3:  MOVLW  0A
06F4:  BTFSS  0C.4
06F5:  GOTO   6F4
06F6:  MOVWF  19
....................    i2c_start(); 
06F7:  BSF    03.5
06F8:  BSF    11.0
06F9:  BTFSC  11.0
06FA:  GOTO   6F9
06FB:  BCF    03.5
06FC:  CLRF   2B
06FD:  BTFSC  0B.7
06FE:  BSF    2B.7
06FF:  BCF    0B.7
....................    i2c_write(I2C_SCORE); 
0700:  MOVLW  0C
0701:  BSF    03.5
0702:  MOVWF  2A
0703:  BCF    03.5
0704:  CALL   1C4
0705:  BTFSC  2B.7
0706:  BSF    0B.7
0707:  CLRF   2B
0708:  BTFSC  0B.7
0709:  BSF    2B.7
070A:  BCF    0B.7
....................    i2c_write(I2C_CMD_INIT); 
070B:  MOVLW  F0
070C:  BSF    03.5
070D:  MOVWF  2A
070E:  BCF    03.5
070F:  CALL   1C4
0710:  BTFSC  2B.7
0711:  BSF    0B.7
....................    i2c_stop(); 
0712:  BSF    03.5
0713:  BSF    11.2
0714:  BTFSC  11.2
0715:  GOTO   714
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
0716:  BCF    03.5
0717:  BTFSS  07.2
0718:  GOTO   72E
0719:  MOVLW  3D
071A:  BSF    03.6
071B:  MOVWF  0D
071C:  MOVLW  01
071D:  MOVWF  0F
071E:  BCF    03.6
071F:  CLRF   2B
0720:  BTFSC  0B.7
0721:  BSF    2B.7
0722:  BCF    0B.7
0723:  CALL   14E
0724:  BTFSC  2B.7
0725:  BSF    0B.7
0726:  MOVLW  0D
0727:  BTFSS  0C.4
0728:  GOTO   727
0729:  MOVWF  19
072A:  MOVLW  0A
072B:  BTFSS  0C.4
072C:  GOTO   72B
072D:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
072E:  BSF    03.5
072F:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0730:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0731:  MOVLW  C0
0732:  BCF    03.5
0733:  IORWF  0B,F
0734:  BSF    0A.3
0735:  BCF    0A.4
0736:  GOTO   059 (RETURN)
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  71
0804:  BSF    03.5
0805:  MOVWF  0F
0806:  CLRF   10
0807:  MOVF   0F,W
0808:  BSF    03.6
0809:  BCF    07.3
080A:  MOVLW  0C
080B:  BCF    03.6
080C:  MOVWF  19
080D:  MOVLW  A2
080E:  MOVWF  18
080F:  MOVLW  90
0810:  BCF    03.5
0811:  MOVWF  18
0812:  MOVLW  DF
0813:  BSF    03.5
0814:  MOVWF  07
0815:  MOVLW  DF
0816:  MOVWF  07
0817:  MOVLW  04
0818:  MOVWF  13
0819:  MOVLW  28
081A:  BCF    03.5
081B:  MOVWF  14
081C:  BSF    03.5
081D:  BCF    14.7
081E:  BCF    14.6
081F:  BCF    03.5
0820:  CLRF   2F
0821:  CLRF   2E
0822:  CLRF   2D
0823:  CLRF   2C
0824:  BSF    03.5
0825:  MOVF   01,W
0826:  ANDLW  C0
0827:  IORLW  06
0828:  MOVWF  01
0829:  BCF    03.5
082A:  CLRF   01
082B:  BCF    0B.2
082C:  CLRF   44
082D:  BCF    45.0
082E:  CLRF   61
082F:  CLRF   60
0830:  BSF    03.5
0831:  BSF    03.6
0832:  MOVF   09,W
0833:  ANDLW  C0
0834:  MOVWF  09
0835:  BCF    03.6
0836:  BCF    1F.4
0837:  BCF    1F.5
0838:  MOVLW  00
0839:  BSF    03.6
083A:  MOVWF  08
083B:  BCF    03.5
083C:  CLRF   07
083D:  CLRF   08
083E:  CLRF   09
083F:  BCF    03.7
.................... { 
....................    setup(); 
*
0857:  BCF    0A.3
0858:  GOTO   5CA
0859:  BSF    0A.3
....................     
....................    TICK_TYPE CurrentTick,PreviousTick; 
....................  
....................    CurrentTick = PreviousTick = get_ticks(); 
085A:  BCF    0A.3
085B:  CALL   737
085C:  BSF    0A.3
085D:  MOVF   7A,W
085E:  MOVWF  69
085F:  MOVF   79,W
0860:  MOVWF  68
0861:  MOVF   78,W
0862:  MOVWF  67
0863:  MOVF   77,W
0864:  MOVWF  66
0865:  MOVF   69,W
0866:  MOVWF  65
0867:  MOVF   68,W
0868:  MOVWF  64
0869:  MOVF   67,W
086A:  MOVWF  63
086B:  MOVF   66,W
086C:  MOVWF  62
....................  
....................    while(TRUE) 
....................    { 
....................       CurrentTick = get_ticks(); 
086D:  BCF    0A.3
086E:  CALL   737
086F:  BSF    0A.3
0870:  MOVF   7A,W
0871:  MOVWF  65
0872:  MOVF   79,W
0873:  MOVWF  64
0874:  MOVF   78,W
0875:  MOVWF  63
0876:  MOVF   77,W
0877:  MOVWF  62
....................  
....................       if(GetTickDifference(CurrentTick, PreviousTick) >= (TICK_TYPE)TICKS_PER_SECOND) 
0878:  MOVF   65,W
0879:  MOVWF  6D
087A:  MOVF   64,W
087B:  MOVWF  6C
087C:  MOVF   63,W
087D:  MOVWF  6B
087E:  MOVF   62,W
087F:  MOVWF  6A
0880:  MOVF   69,W
0881:  MOVWF  71
0882:  MOVF   68,W
0883:  MOVWF  70
0884:  MOVF   67,W
0885:  MOVWF  6F
0886:  MOVF   66,W
0887:  MOVWF  6E
0888:  BCF    0A.3
0889:  GOTO   753
088A:  BSF    0A.3
088B:  MOVF   7A,W
088C:  MOVWF  6D
088D:  MOVF   79,W
088E:  MOVWF  6C
088F:  MOVF   78,W
0890:  MOVWF  6B
0891:  MOVF   77,W
0892:  MOVWF  6A
0893:  MOVF   6D,F
0894:  BTFSS  03.2
0895:  GOTO   0A4
0896:  MOVF   6C,F
0897:  BTFSS  03.2
0898:  GOTO   0A4
0899:  MOVF   6B,W
089A:  SUBLW  1D
089B:  BTFSC  03.0
089C:  GOTO   0AF
089D:  XORLW  FF
089E:  BTFSS  03.2
089F:  GOTO   0A4
08A0:  MOVF   6A,W
08A1:  SUBLW  83
08A2:  BTFSC  03.0
08A3:  GOTO   0AF
....................       { 
....................          timeTick(); 
08A4:  BCF    0A.3
08A5:  GOTO   76B
08A6:  BSF    0A.3
....................          PreviousTick = CurrentTick; 
08A7:  MOVF   65,W
08A8:  MOVWF  69
08A9:  MOVF   64,W
08AA:  MOVWF  68
08AB:  MOVF   63,W
08AC:  MOVWF  67
08AD:  MOVF   62,W
08AE:  MOVWF  66
....................       } 
08AF:  GOTO   06D
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
08B0:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
03DA:  BTFSS  0C.5
03DB:  GOTO   3DA
03DC:  MOVF   1A,W
03DD:  MOVWF  72
.................... if(cmdGet) 
03DE:  BTFSS  45.0
03DF:  GOTO   412
.................... { 
....................    if(c == '#' || c == '\r') 
03E0:  MOVF   72,W
03E1:  SUBLW  23
03E2:  BTFSC  03.2
03E3:  GOTO   3E8
03E4:  MOVF   72,W
03E5:  SUBLW  0D
03E6:  BTFSS  03.2
03E7:  GOTO   407
....................    { 
....................       cmdGet = false; 
03E8:  BCF    45.0
....................       strcpy(cmd, rcmd); 
03E9:  BSF    03.5
03EA:  CLRF   23
03EB:  MOVLW  3A
03EC:  MOVWF  22
03ED:  CLRF   21
03EE:  MOVLW  30
03EF:  MOVWF  20
03F0:  MOVF   22,W
03F1:  MOVWF  04
03F2:  BCF    03.7
03F3:  BTFSC  23.0
03F4:  BSF    03.7
03F5:  MOVF   00,W
03F6:  MOVWF  24
03F7:  MOVF   20,W
03F8:  MOVWF  04
03F9:  BCF    03.7
03FA:  BTFSC  21.0
03FB:  BSF    03.7
03FC:  MOVF   24,W
03FD:  MOVWF  00
03FE:  MOVF   00,F
03FF:  BTFSC  03.2
0400:  GOTO   404
0401:  INCF   20,F
0402:  INCF   22,F
0403:  GOTO   3F0
....................       parseCommand(); 
0404:  BCF    03.5
0405:  GOTO   1D6
....................    } 
0406:  GOTO   412
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
0407:  MOVF   44,W
0408:  SUBLW  08
0409:  BTFSS  03.0
040A:  GOTO   412
....................       { 
....................          rcmd[cmdIndex] = c; 
040B:  MOVLW  3A
040C:  ADDWF  44,W
040D:  MOVWF  04
040E:  BCF    03.7
040F:  MOVF   72,W
0410:  MOVWF  00
....................          cmdIndex++; 
0411:  INCF   44,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
0412:  MOVF   72,W
0413:  SUBLW  2D
0414:  BTFSS  03.2
0415:  GOTO   42C
....................    { 
....................        cmdGet = true;  
0416:  BSF    45.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0\0"; 
0417:  BSF    03.5
0418:  CLRF   20
0419:  CLRF   21
041A:  MOVLW  3A
041B:  MOVWF  04
041C:  BCF    03.7
041D:  MOVF   20,W
041E:  ADDWF  04,F
041F:  MOVF   21,W
0420:  BCF    03.5
0421:  CALL   05A
0422:  MOVWF  00
0423:  IORLW  00
0424:  BTFSC  03.2
0425:  GOTO   42B
0426:  BSF    03.5
0427:  INCF   21,F
0428:  INCF   20,F
0429:  GOTO   41A
042A:  BCF    03.5
....................        cmdIndex = 0; 
042B:  CLRF   44
....................    } 
.................... } 
....................  
042C:  BCF    0C.5
042D:  BCF    0A.3
042E:  BCF    0A.4
042F:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
.................... { 
....................  
0430:  BCF    0C.3
0431:  BCF    0A.3
0432:  BCF    0A.4
0433:  GOTO   033
.................... } 
....................  
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick) 
.................... { 
....................    return(currTick-prevTick); 
*
0753:  MOVF   6E,W
0754:  SUBWF  6A,W
0755:  MOVWF  77
0756:  MOVF   6B,W
0757:  MOVWF  78
0758:  MOVF   6F,W
0759:  BTFSS  03.0
075A:  INCFSZ 6F,W
075B:  SUBWF  78,F
075C:  MOVF   6C,W
075D:  MOVWF  79
075E:  MOVF   70,W
075F:  BTFSS  03.0
0760:  INCFSZ 70,W
0761:  SUBWF  79,F
0762:  MOVF   6D,W
0763:  MOVWF  7A
0764:  MOVF   71,W
0765:  BTFSS  03.0
0766:  INCFSZ 71,W
0767:  SUBWF  7A,F
0768:  BSF    0A.3
0769:  BCF    0A.4
076A:  GOTO   08A (RETURN)
.................... } 
....................  
.................... void timeTick(void) 
.................... { 
076B:  BSF    0A.3
076C:  BCF    0A.4
076D:  GOTO   0A6 (RETURN)
....................    //TODO: User Code 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
035A:  BTFSS  07.2
035B:  GOTO   36B
035C:  MOVLW  34
035D:  BSF    03.6
035E:  MOVWF  0D
035F:  MOVLW  04
0360:  MOVWF  0F
0361:  BCF    03.6
0362:  CALL   14E
0363:  MOVLW  0D
0364:  BTFSS  0C.4
0365:  GOTO   364
0366:  MOVWF  19
0367:  MOVLW  0A
0368:  BTFSS  0C.4
0369:  GOTO   368
036A:  MOVWF  19
....................     
....................    if(DEBUG) {fputs("> Probando modulo tiempo",RS232);} 
036B:  BTFSS  07.2
036C:  GOTO   37C
036D:  MOVLW  3E
036E:  BSF    03.6
036F:  MOVWF  0D
0370:  MOVLW  04
0371:  MOVWF  0F
0372:  BCF    03.6
0373:  CALL   14E
0374:  MOVLW  0D
0375:  BTFSS  0C.4
0376:  GOTO   375
0377:  MOVWF  19
0378:  MOVLW  0A
0379:  BTFSS  0C.4
037A:  GOTO   379
037B:  MOVWF  19
....................    i2c_start(); 
037C:  BSF    03.5
037D:  BSF    11.0
037E:  BTFSC  11.0
037F:  GOTO   37E
....................    i2c_write(I2C_TIMER); 
0380:  MOVLW  0A
0381:  MOVWF  2A
0382:  BCF    03.5
0383:  CALL   1C4
....................    i2c_write(I2C_CMD_TEST); 
0384:  MOVLW  FF
0385:  BSF    03.5
0386:  MOVWF  2A
0387:  BCF    03.5
0388:  CALL   1C4
....................    i2c_stop(); 
0389:  BSF    03.5
038A:  BSF    11.2
038B:  BTFSC  11.2
038C:  GOTO   38B
....................  
....................    if(DEBUG) {fputs("> Probando modulo puntos",RS232);} 
038D:  BCF    03.5
038E:  BTFSS  07.2
038F:  GOTO   39F
0390:  MOVLW  4B
0391:  BSF    03.6
0392:  MOVWF  0D
0393:  MOVLW  04
0394:  MOVWF  0F
0395:  BCF    03.6
0396:  CALL   14E
0397:  MOVLW  0D
0398:  BTFSS  0C.4
0399:  GOTO   398
039A:  MOVWF  19
039B:  MOVLW  0A
039C:  BTFSS  0C.4
039D:  GOTO   39C
039E:  MOVWF  19
....................    i2c_start(); 
039F:  BSF    03.5
03A0:  BSF    11.0
03A1:  BTFSC  11.0
03A2:  GOTO   3A1
....................    i2c_write(I2C_SCORE); 
03A3:  MOVLW  0C
03A4:  MOVWF  2A
03A5:  BCF    03.5
03A6:  CALL   1C4
....................    i2c_write(I2C_CMD_TEST); 
03A7:  MOVLW  FF
03A8:  BSF    03.5
03A9:  MOVWF  2A
03AA:  BCF    03.5
03AB:  CALL   1C4
....................    i2c_stop(); 
03AC:  BSF    03.5
03AD:  BSF    11.2
03AE:  BTFSC  11.2
03AF:  GOTO   3AE
....................  
....................    if(DEBUG) {fputs("> Probando modulo comunicaciones",RS232);} 
03B0:  BCF    03.5
03B1:  BTFSS  07.2
03B2:  GOTO   3C2
03B3:  MOVLW  58
03B4:  BSF    03.6
03B5:  MOVWF  0D
03B6:  MOVLW  04
03B7:  MOVWF  0F
03B8:  BCF    03.6
03B9:  CALL   14E
03BA:  MOVLW  0D
03BB:  BTFSS  0C.4
03BC:  GOTO   3BB
03BD:  MOVWF  19
03BE:  MOVLW  0A
03BF:  BTFSS  0C.4
03C0:  GOTO   3BF
03C1:  MOVWF  19
.................... } 
....................  
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
01D6:  BSF    03.5
01D7:  CLRF   2D
01D8:  MOVLW  30
01D9:  MOVWF  2C
01DA:  CLRF   2B
01DB:  MOVLW  A0
01DC:  MOVWF  2A
01DD:  MOVF   2C,W
01DE:  MOVWF  04
01DF:  BCF    03.7
01E0:  BTFSC  2D.0
01E1:  BSF    03.7
01E2:  MOVF   00,W
01E3:  MOVWF  2E
01E4:  MOVF   2A,W
01E5:  MOVWF  04
01E6:  BCF    03.7
01E7:  BTFSC  2B.0
01E8:  BSF    03.7
01E9:  MOVF   2E,W
01EA:  MOVWF  00
01EB:  MOVF   00,F
01EC:  BTFSC  03.2
01ED:  GOTO   1F1
01EE:  INCF   2A,F
01EF:  INCF   2C,F
01F0:  GOTO   1DD
....................    switch(c[0]) 
01F1:  MOVLW  4C
01F2:  SUBWF  20,W
01F3:  ADDLW  F3
01F4:  BTFSC  03.0
01F5:  GOTO   3C5
01F6:  ADDLW  0D
01F7:  BCF    03.5
01F8:  GOTO   3C9
....................    { 
....................       case 'L':   if(DEBUG) {fputs("\r> Comando local",RS232);} 
01F9:  BTFSS  07.2
01FA:  GOTO   20A
01FB:  MOVLW  69
01FC:  BSF    03.6
01FD:  MOVWF  0D
01FE:  MOVLW  04
01FF:  MOVWF  0F
0200:  BCF    03.6
0201:  CALL   14E
0202:  MOVLW  0D
0203:  BTFSS  0C.4
0204:  GOTO   203
0205:  MOVWF  19
0206:  MOVLW  0A
0207:  BTFSS  0C.4
0208:  GOTO   207
0209:  MOVWF  19
....................                   switch(c[1]) 
020A:  BSF    03.5
020B:  MOVF   21,W
020C:  XORLW  30
020D:  BCF    03.5
020E:  BTFSC  03.2
020F:  GOTO   220
0210:  XORLW  01
0211:  BTFSC  03.2
0212:  GOTO   232
0213:  XORLW  03
0214:  BTFSC  03.2
0215:  GOTO   244
0216:  XORLW  01
0217:  BTFSC  03.2
0218:  GOTO   256
0219:  XORLW  77
021A:  BTFSC  03.2
021B:  GOTO   268
021C:  XORLW  14
021D:  BTFSC  03.2
021E:  GOTO   27A
021F:  GOTO   28B
....................                   { 
....................                      case '0':   if(DEBUG) {fputs("\r> Resetea a 0",RS232);} 
0220:  BTFSS  07.2
0221:  GOTO   231
0222:  MOVLW  72
0223:  BSF    03.6
0224:  MOVWF  0D
0225:  MOVLW  04
0226:  MOVWF  0F
0227:  BCF    03.6
0228:  CALL   14E
0229:  MOVLW  0D
022A:  BTFSS  0C.4
022B:  GOTO   22A
022C:  MOVWF  19
022D:  MOVLW  0A
022E:  BTFSS  0C.4
022F:  GOTO   22E
0230:  MOVWF  19
....................                                  break; 
0231:  GOTO   28B
....................                      case '1':   if(DEBUG) {fputs("\r> Incrementar por 1",RS232);} 
0232:  BTFSS  07.2
0233:  GOTO   243
0234:  MOVLW  7A
0235:  BSF    03.6
0236:  MOVWF  0D
0237:  MOVLW  04
0238:  MOVWF  0F
0239:  BCF    03.6
023A:  CALL   14E
023B:  MOVLW  0D
023C:  BTFSS  0C.4
023D:  GOTO   23C
023E:  MOVWF  19
023F:  MOVLW  0A
0240:  BTFSS  0C.4
0241:  GOTO   240
0242:  MOVWF  19
....................                                  break; 
0243:  GOTO   28B
....................                      case '2':   if(DEBUG) {fputs("\r> Incrementar por 2",RS232);} 
0244:  BTFSS  07.2
0245:  GOTO   255
0246:  MOVLW  85
0247:  BSF    03.6
0248:  MOVWF  0D
0249:  MOVLW  04
024A:  MOVWF  0F
024B:  BCF    03.6
024C:  CALL   14E
024D:  MOVLW  0D
024E:  BTFSS  0C.4
024F:  GOTO   24E
0250:  MOVWF  19
0251:  MOVLW  0A
0252:  BTFSS  0C.4
0253:  GOTO   252
0254:  MOVWF  19
....................                                  break; 
0255:  GOTO   28B
....................                      case '3':   if(DEBUG) {fputs("\r> Incrementar por 3",RS232);} 
0256:  BTFSS  07.2
0257:  GOTO   267
0258:  MOVLW  90
0259:  BSF    03.6
025A:  MOVWF  0D
025B:  MOVLW  04
025C:  MOVWF  0F
025D:  BCF    03.6
025E:  CALL   14E
025F:  MOVLW  0D
0260:  BTFSS  0C.4
0261:  GOTO   260
0262:  MOVWF  19
0263:  MOVLW  0A
0264:  BTFSS  0C.4
0265:  GOTO   264
0266:  MOVWF  19
....................                                  break; 
0267:  GOTO   28B
....................                      case 'D':   if(DEBUG) {fputs("\r> Decrementar por 1",RS232);} 
0268:  BTFSS  07.2
0269:  GOTO   279
026A:  MOVLW  9B
026B:  BSF    03.6
026C:  MOVWF  0D
026D:  MOVLW  04
026E:  MOVWF  0F
026F:  BCF    03.6
0270:  CALL   14E
0271:  MOVLW  0D
0272:  BTFSS  0C.4
0273:  GOTO   272
0274:  MOVWF  19
0275:  MOVLW  0A
0276:  BTFSS  0C.4
0277:  GOTO   276
0278:  MOVWF  19
....................                                  break; 
0279:  GOTO   28B
....................                      case 'P':   if(DEBUG) {fputs("\r> Asignar posicion",RS232);} 
027A:  BTFSS  07.2
027B:  GOTO   28B
027C:  MOVLW  A6
027D:  BSF    03.6
027E:  MOVWF  0D
027F:  MOVLW  04
0280:  MOVWF  0F
0281:  BCF    03.6
0282:  CALL   14E
0283:  MOVLW  0D
0284:  BTFSS  0C.4
0285:  GOTO   284
0286:  MOVWF  19
0287:  MOVLW  0A
0288:  BTFSS  0C.4
0289:  GOTO   288
028A:  MOVWF  19
....................                                  break; 
....................                   } 
....................                   break; 
028B:  BSF    03.5
028C:  GOTO   3C5
....................       case 'P':   if(DEBUG) {fputs("\r> Pausar tiempo",RS232);} 
028D:  BTFSS  07.2
028E:  GOTO   29E
028F:  MOVLW  B0
0290:  BSF    03.6
0291:  MOVWF  0D
0292:  MOVLW  04
0293:  MOVWF  0F
0294:  BCF    03.6
0295:  CALL   14E
0296:  MOVLW  0D
0297:  BTFSS  0C.4
0298:  GOTO   297
0299:  MOVWF  19
029A:  MOVLW  0A
029B:  BTFSS  0C.4
029C:  GOTO   29B
029D:  MOVWF  19
....................                   break; 
029E:  BSF    03.5
029F:  GOTO   3C5
....................       case 'Q':   if(DEBUG) {fputs("\r> Renudar tiempo",RS232);} 
02A0:  BTFSS  07.2
02A1:  GOTO   2B1
02A2:  MOVLW  B9
02A3:  BSF    03.6
02A4:  MOVWF  0D
02A5:  MOVLW  04
02A6:  MOVWF  0F
02A7:  BCF    03.6
02A8:  CALL   14E
02A9:  MOVLW  0D
02AA:  BTFSS  0C.4
02AB:  GOTO   2AA
02AC:  MOVWF  19
02AD:  MOVLW  0A
02AE:  BTFSS  0C.4
02AF:  GOTO   2AE
02B0:  MOVWF  19
....................                   break; 
02B1:  BSF    03.5
02B2:  GOTO   3C5
....................       case 'T':   if(DEBUG) {fputs("\r> Configuracion de tiempo",RS232);} 
02B3:  BTFSS  07.2
02B4:  GOTO   2C4
02B5:  MOVLW  C2
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  MOVLW  04
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  CALL   14E
02BC:  MOVLW  0D
02BD:  BTFSS  0C.4
02BE:  GOTO   2BD
02BF:  MOVWF  19
02C0:  MOVLW  0A
02C1:  BTFSS  0C.4
02C2:  GOTO   2C1
02C3:  MOVWF  19
....................                   break; 
02C4:  BSF    03.5
02C5:  GOTO   3C5
....................       case 'V':   if(DEBUG) {fputs("\r> Comando visitante",RS232);} 
02C6:  BTFSS  07.2
02C7:  GOTO   2D7
02C8:  MOVLW  D0
02C9:  BSF    03.6
02CA:  MOVWF  0D
02CB:  MOVLW  04
02CC:  MOVWF  0F
02CD:  BCF    03.6
02CE:  CALL   14E
02CF:  MOVLW  0D
02D0:  BTFSS  0C.4
02D1:  GOTO   2D0
02D2:  MOVWF  19
02D3:  MOVLW  0A
02D4:  BTFSS  0C.4
02D5:  GOTO   2D4
02D6:  MOVWF  19
....................                   switch(c[1]) 
02D7:  BSF    03.5
02D8:  MOVF   21,W
02D9:  XORLW  30
02DA:  BCF    03.5
02DB:  BTFSC  03.2
02DC:  GOTO   2ED
02DD:  XORLW  01
02DE:  BTFSC  03.2
02DF:  GOTO   2FF
02E0:  XORLW  03
02E1:  BTFSC  03.2
02E2:  GOTO   311
02E3:  XORLW  01
02E4:  BTFSC  03.2
02E5:  GOTO   323
02E6:  XORLW  77
02E7:  BTFSC  03.2
02E8:  GOTO   335
02E9:  XORLW  14
02EA:  BTFSC  03.2
02EB:  GOTO   347
02EC:  GOTO   358
....................                   { 
....................                      case '0':   if(DEBUG) {fputs("\r> Resetea a 0",RS232);} 
02ED:  BTFSS  07.2
02EE:  GOTO   2FE
02EF:  MOVLW  DB
02F0:  BSF    03.6
02F1:  MOVWF  0D
02F2:  MOVLW  04
02F3:  MOVWF  0F
02F4:  BCF    03.6
02F5:  CALL   14E
02F6:  MOVLW  0D
02F7:  BTFSS  0C.4
02F8:  GOTO   2F7
02F9:  MOVWF  19
02FA:  MOVLW  0A
02FB:  BTFSS  0C.4
02FC:  GOTO   2FB
02FD:  MOVWF  19
....................                                  break; 
02FE:  GOTO   358
....................                      case '1':   if(DEBUG) {fputs("\r> Incrementar por 1",RS232);} 
02FF:  BTFSS  07.2
0300:  GOTO   310
0301:  MOVLW  E3
0302:  BSF    03.6
0303:  MOVWF  0D
0304:  MOVLW  04
0305:  MOVWF  0F
0306:  BCF    03.6
0307:  CALL   14E
0308:  MOVLW  0D
0309:  BTFSS  0C.4
030A:  GOTO   309
030B:  MOVWF  19
030C:  MOVLW  0A
030D:  BTFSS  0C.4
030E:  GOTO   30D
030F:  MOVWF  19
....................                                  break; 
0310:  GOTO   358
....................                      case '2':   if(DEBUG) {fputs("\r> Incrementar por 2",RS232);} 
0311:  BTFSS  07.2
0312:  GOTO   322
0313:  MOVLW  EE
0314:  BSF    03.6
0315:  MOVWF  0D
0316:  MOVLW  04
0317:  MOVWF  0F
0318:  BCF    03.6
0319:  CALL   14E
031A:  MOVLW  0D
031B:  BTFSS  0C.4
031C:  GOTO   31B
031D:  MOVWF  19
031E:  MOVLW  0A
031F:  BTFSS  0C.4
0320:  GOTO   31F
0321:  MOVWF  19
....................                                  break; 
0322:  GOTO   358
....................                      case '3':   if(DEBUG) {fputs("\r> Incrementar por 3",RS232);} 
0323:  BTFSS  07.2
0324:  GOTO   334
0325:  MOVLW  F9
0326:  BSF    03.6
0327:  MOVWF  0D
0328:  MOVLW  04
0329:  MOVWF  0F
032A:  BCF    03.6
032B:  CALL   14E
032C:  MOVLW  0D
032D:  BTFSS  0C.4
032E:  GOTO   32D
032F:  MOVWF  19
0330:  MOVLW  0A
0331:  BTFSS  0C.4
0332:  GOTO   331
0333:  MOVWF  19
....................                                  break; 
0334:  GOTO   358
....................                      case 'D':   if(DEBUG) {fputs("\r> Decrementar por 1",RS232);} 
0335:  BTFSS  07.2
0336:  GOTO   346
0337:  MOVLW  04
0338:  BSF    03.6
0339:  MOVWF  0D
033A:  MOVLW  05
033B:  MOVWF  0F
033C:  BCF    03.6
033D:  CALL   14E
033E:  MOVLW  0D
033F:  BTFSS  0C.4
0340:  GOTO   33F
0341:  MOVWF  19
0342:  MOVLW  0A
0343:  BTFSS  0C.4
0344:  GOTO   343
0345:  MOVWF  19
....................                                  break; 
0346:  GOTO   358
....................                      case 'P':   if(DEBUG) {fputs("\r> Asignar posicion",RS232);} 
0347:  BTFSS  07.2
0348:  GOTO   358
0349:  MOVLW  0F
034A:  BSF    03.6
034B:  MOVWF  0D
034C:  MOVLW  05
034D:  MOVWF  0F
034E:  BCF    03.6
034F:  CALL   14E
0350:  MOVLW  0D
0351:  BTFSS  0C.4
0352:  GOTO   351
0353:  MOVWF  19
0354:  MOVLW  0A
0355:  BTFSS  0C.4
0356:  GOTO   355
0357:  MOVWF  19
....................                                  break; 
....................                   } 
....................                   break; 
0358:  BSF    03.5
0359:  GOTO   3C5
....................       case 'X':   doTest(); //Rutina de prueba 
....................                   break; 
*
03C2:  BSF    03.5
03C3:  GOTO   3C5
03C4:  BSF    03.5
....................    } 
03C5:  BCF    03.5
03C6:  BCF    0A.3
03C7:  BCF    0A.4
03C8:  GOTO   406 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

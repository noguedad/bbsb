CCS PCM C Compiler, Version 5.076, 56587               29-ene.-23 18:46

               Filename:   C:\Users\nogue\Proyectos\bbsb\mcoms\mcoms.lst

               ROM used:   4174 words (51%)
                           Largest free fragment is 2048
               RAM used:   89 (24%) at main() level
                           135 (37%) worst case
               Stack used: 6 locations (1 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   6B0
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   42E
....................  
....................  
.................... /**:COPYRIGHT 
....................             _ /      _ /  
....................         _ /_ /_ /  _/_/ 
....................          _ /       _ /  
....................         _ /       _ /  
....................        _ / _ / _/_ / _ / 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo APM 
....................      
....................  */ 
.................... // * AUTOR: Victor Noguedad 
.................... // * ARCHIVO: mscoms.c 
.................... // * RESUMEN: Programa principal del modulo de comunicaciones 
.................... // ::[CABECERAS]:: 
.................... #include <mcoms.h> 
.................... /**:COPYRIGHT 
....................  
....................            _/       _/ 
....................         _/_/_/   _/_/ 
....................          _/       _/ 
....................         _/       _/ 
....................        _/_/   _/_/_/ 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo  APM 
....................      
....................  */ 
....................  
.................... // *AUTOR:    Victor Noguedad 
.................... // *ARCHIVO:  mscoms.c 
.................... // *RESUMEN:  Programa principal del modulo de comunicaciones 
....................  
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  00
0056:  RETLW  00
0057:  DATA 2A,15
0058:  DATA 2A,15
0059:  DATA 2A,15
005A:  DATA 2A,15
005B:  DATA 2A,15
005C:  DATA 2A,15
005D:  DATA 2A,15
005E:  DATA 2A,15
005F:  DATA 2A,15
0060:  DATA 2A,15
0061:  DATA 2A,15
0062:  DATA 2A,15
0063:  DATA 2A,15
0064:  DATA 2A,15
0065:  DATA 2A,15
0066:  DATA 2A,15
0067:  DATA 0D,00
0068:  DATA A0,23
0069:  DATA F2,3A
006A:  DATA F0,37
006B:  DATA A0,20
006C:  DATA D0,26
006D:  DATA 20,14
006E:  DATA E3,14
006F:  DATA 20,19
0070:  DATA 30,19
0071:  DATA 30,10
0072:  DATA 0D,00
0073:  DATA BD,1E
0074:  DATA BD,1E
0075:  DATA BD,1E
0076:  DATA BD,1E
0077:  DATA BD,1E
0078:  DATA BD,1E
0079:  DATA BD,1E
007A:  DATA BD,1E
007B:  DATA BD,1E
007C:  DATA BD,1E
007D:  DATA BD,1E
007E:  DATA BD,1E
007F:  DATA BD,1E
0080:  DATA BD,1E
0081:  DATA BD,1E
0082:  DATA BD,1E
0083:  DATA 0D,00
0084:  DATA 42,36
0085:  DATA F5,32
0086:  DATA F4,37
0087:  DATA 6F,3A
0088:  DATA 68,10
0089:  DATA C2,30
008A:  DATA F3,35
008B:  DATA 65,3A
008C:  DATA E2,30
008D:  DATA 6C,36
008E:  DATA A0,29
008F:  DATA E3,37
0090:  DATA F2,32
0091:  DATA 20,21
0092:  DATA EF,30
0093:  DATA 72,32
0094:  DATA 0D,00
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA BD,1E
009B:  DATA BD,1E
009C:  DATA BD,1E
009D:  DATA BD,1E
009E:  DATA BD,1E
009F:  DATA BD,1E
00A0:  DATA BD,1E
00A1:  DATA BD,1E
00A2:  DATA BD,1E
00A3:  DATA BD,1E
00A4:  DATA BD,1E
00A5:  DATA 0D,00
00A6:  DATA D6,32
00A7:  DATA F2,39
00A8:  DATA E9,37
00A9:  DATA 6E,10
00AA:  DATA A5,39
00AB:  DATA A0,16
00AC:  DATA 20,39
00AD:  DATA 65,3B
00AE:  DATA A0,12
00AF:  DATA 73,10
00B0:  DATA 0D,00
00B1:  DATA 32,17
00B2:  DATA 30,00
00B3:  DATA 46,00
00B4:  DATA 2A,15
00B5:  DATA 2A,15
00B6:  DATA 2A,15
00B7:  DATA 2A,15
00B8:  DATA 2A,15
00B9:  DATA 2A,15
00BA:  DATA 2A,15
00BB:  DATA 2A,15
00BC:  DATA 2A,15
00BD:  DATA 2A,15
00BE:  DATA 2A,15
00BF:  DATA 2A,15
00C0:  DATA 2A,15
00C1:  DATA 2A,15
00C2:  DATA 2A,15
00C3:  DATA 2A,15
00C4:  DATA 0D,00
00C5:  DATA 20,22
00C6:  DATA 45,28
00C7:  DATA 55,29
00C8:  DATA C1,21
00C9:  DATA C9,27
00CA:  DATA 4E,10
00CB:  DATA 3A,1D
00CC:  DATA A0,21
00CD:  DATA CF,26
00CE:  DATA 55,27
00CF:  DATA C9,21
00D0:  DATA C1,21
00D1:  DATA C9,27
00D2:  DATA CE,22
00D3:  DATA 53,10
00D4:  DATA 0D,00
00D5:  DATA 20,1F
00D6:  DATA A0,21
00D7:  DATA 6F,37
00D8:  DATA E6,34
00D9:  DATA E7,3A
00DA:  DATA F2,30
00DB:  DATA E3,34
00DC:  DATA 6F,37
00DD:  DATA 20,32
00DE:  DATA 65,10
00DF:  DATA D0,3A
00E0:  DATA 65,39
00E1:  DATA F4,37
00E2:  DATA 73,00
00E3:  DATA 20,1F
00E4:  DATA A0,24
00E5:  DATA EE,34
00E6:  DATA E3,34
00E7:  DATA 61,36
00E8:  DATA 69,3D
00E9:  DATA E1,31
00EA:  DATA E9,37
00EB:  DATA 6E,10
00EC:  DATA E4,32
00ED:  DATA A0,24
00EE:  DATA B2,21
00EF:  DATA 00,01
00F0:  DATA 20,1F
00F1:  DATA 20,24
00F2:  DATA 61,31
00F3:  DATA 69,36
00F4:  DATA 69,3A
00F5:  DATA E1,31
00F6:  DATA E9,37
00F7:  DATA 6E,10
00F8:  DATA E4,32
00F9:  DATA 20,32
00FA:  DATA E9,39
00FB:  DATA 70,36
00FC:  DATA E1,3C
00FD:  DATA 73,00
00FE:  DATA 20,1F
00FF:  DATA 20,24
0100:  DATA 61,31
0101:  DATA 69,36
0102:  DATA 69,3A
0103:  DATA E1,31
0104:  DATA E9,37
0105:  DATA 6E,10
0106:  DATA E4,32
0107:  DATA A0,34
0108:  DATA 6E,3A
0109:  DATA 65,39
010A:  DATA F2,3A
010B:  DATA F0,31
010C:  DATA E9,37
010D:  DATA EE,32
010E:  DATA 73,00
010F:  MOVF   0B,W
0110:  BSF    03.5
0111:  MOVWF  39
0112:  BCF    03.5
0113:  BCF    0B.7
0114:  BSF    03.5
0115:  BSF    03.6
0116:  BSF    0C.7
0117:  BSF    0C.0
0118:  NOP
0119:  NOP
011A:  BCF    03.6
011B:  BTFSS  39.7
011C:  GOTO   120
011D:  BCF    03.5
011E:  BSF    0B.7
011F:  BSF    03.5
0120:  BCF    03.5
0121:  BSF    03.6
0122:  MOVF   0C,W
0123:  ANDLW  7F
0124:  BTFSC  03.2
0125:  GOTO   183
0126:  BSF    03.5
0127:  BCF    03.6
0128:  MOVWF  39
0129:  BCF    03.5
012A:  BSF    03.6
012B:  MOVF   0D,W
012C:  BSF    03.5
012D:  BCF    03.6
012E:  MOVWF  3A
012F:  BCF    03.5
0130:  BSF    03.6
0131:  MOVF   0F,W
0132:  BSF    03.5
0133:  BCF    03.6
0134:  MOVWF  3B
0135:  MOVF   39,W
0136:  BCF    03.5
0137:  BTFSS  0C.4
0138:  GOTO   137
0139:  MOVWF  19
013A:  BSF    03.5
013B:  MOVF   3A,W
013C:  BCF    03.5
013D:  BSF    03.6
013E:  MOVWF  0D
013F:  BSF    03.5
0140:  BCF    03.6
0141:  MOVF   3B,W
0142:  BCF    03.5
0143:  BSF    03.6
0144:  MOVWF  0F
0145:  BCF    03.6
0146:  MOVF   0B,W
0147:  BSF    03.5
0148:  MOVWF  3C
0149:  BCF    03.5
014A:  BCF    0B.7
014B:  BSF    03.5
014C:  BSF    03.6
014D:  BSF    0C.7
014E:  BSF    0C.0
014F:  NOP
0150:  NOP
0151:  BCF    03.6
0152:  BTFSS  3C.7
0153:  GOTO   157
0154:  BCF    03.5
0155:  BSF    0B.7
0156:  BSF    03.5
0157:  BCF    03.5
0158:  BSF    03.6
0159:  RLF    0C,W
015A:  RLF    0E,W
015B:  ANDLW  7F
015C:  BTFSC  03.2
015D:  GOTO   183
015E:  BSF    03.5
015F:  BCF    03.6
0160:  MOVWF  39
0161:  BCF    03.5
0162:  BSF    03.6
0163:  MOVF   0D,W
0164:  BSF    03.5
0165:  BCF    03.6
0166:  MOVWF  3A
0167:  BCF    03.5
0168:  BSF    03.6
0169:  MOVF   0F,W
016A:  BSF    03.5
016B:  BCF    03.6
016C:  MOVWF  3B
016D:  MOVF   39,W
016E:  BCF    03.5
016F:  BTFSS  0C.4
0170:  GOTO   16F
0171:  MOVWF  19
0172:  BSF    03.5
0173:  MOVF   3A,W
0174:  BCF    03.5
0175:  BSF    03.6
0176:  MOVWF  0D
0177:  BSF    03.5
0178:  BCF    03.6
0179:  MOVF   3B,W
017A:  BCF    03.5
017B:  BSF    03.6
017C:  MOVWF  0F
017D:  INCF   0D,F
017E:  BTFSC  03.2
017F:  INCF   0F,F
0180:  BCF    03.6
0181:  GOTO   10F
0182:  BSF    03.6
0183:  BCF    03.6
0184:  RETURN
*
01C5:  BSF    0A.0
01C6:  BCF    0A.1
01C7:  BCF    0A.2
01C8:  ADDWF  02,F
01C9:  GOTO   18E
01CA:  GOTO   193
01CB:  GOTO   198
01CC:  GOTO   19D
01CD:  GOTO   1A2
01CE:  GOTO   1A7
01CF:  GOTO   1AC
01D0:  GOTO   1B1
01D1:  GOTO   1B6
01D2:  GOTO   1BB
01D3:  BSF    03.5
01D4:  MOVF   3F,W
01D5:  ANDLW  07
01D6:  MOVWF  77
01D7:  RRF    3F,W
01D8:  MOVWF  78
01D9:  RRF    78,F
01DA:  RRF    78,F
01DB:  MOVLW  1F
01DC:  ANDWF  78,F
01DD:  MOVF   78,W
01DE:  ADDWF  41,W
01DF:  MOVWF  04
01E0:  BCF    03.7
01E1:  BTFSC  42.0
01E2:  BSF    03.7
01E3:  CLRF   78
01E4:  INCF   78,F
01E5:  INCF   77,F
01E6:  GOTO   1E8
01E7:  RLF    78,F
01E8:  DECFSZ 77,F
01E9:  GOTO   1E7
01EA:  MOVF   40,F
01EB:  BTFSC  03.2
01EC:  GOTO   1F0
01ED:  MOVF   78,W
01EE:  IORWF  00,F
01EF:  GOTO   1F3
01F0:  COMF   78,F
01F1:  MOVF   78,W
01F2:  ANDWF  00,F
01F3:  BCF    03.5
01F4:  RETURN
*
027C:  BCF    0A.0
027D:  BSF    0A.1
027E:  BCF    0A.2
027F:  ADDWF  02,F
0280:  GOTO   202
0281:  GOTO   205
0282:  GOTO   208
0283:  GOTO   20C
0284:  GOTO   20F
0285:  GOTO   213
0286:  GOTO   217
0287:  GOTO   21C
0288:  GOTO   21F
*
0492:  DATA 20,1F
0493:  DATA 20,29
0494:  DATA 75,3A
0495:  DATA 69,37
0496:  DATA 61,10
0497:  DATA E4,32
0498:  DATA 20,38
0499:  DATA F2,3A
049A:  DATA 65,31
049B:  DATA 61,00
049C:  DATA 20,1F
049D:  DATA 20,28
049E:  DATA F2,37
049F:  DATA E2,30
04A0:  DATA 6E,32
04A1:  DATA 6F,10
04A2:  DATA ED,37
04A3:  DATA E4,3A
04A4:  DATA EC,37
04A5:  DATA 20,3A
04A6:  DATA E9,32
04A7:  DATA 6D,38
04A8:  DATA 6F,00
04A9:  DATA 20,1F
04AA:  DATA 20,28
04AB:  DATA F2,37
04AC:  DATA E2,30
04AD:  DATA 6E,32
04AE:  DATA 6F,10
04AF:  DATA ED,37
04B0:  DATA E4,3A
04B1:  DATA EC,37
04B2:  DATA 20,38
04B3:  DATA 75,37
04B4:  DATA F4,37
04B5:  DATA 73,00
04B6:  DATA 20,1F
04B7:  DATA 20,28
04B8:  DATA F2,37
04B9:  DATA E2,30
04BA:  DATA 6E,32
04BB:  DATA 6F,10
04BC:  DATA ED,37
04BD:  DATA E4,3A
04BE:  DATA EC,37
04BF:  DATA A0,31
04C0:  DATA EF,36
04C1:  DATA 75,37
04C2:  DATA E9,31
04C3:  DATA E1,31
04C4:  DATA E9,37
04C5:  DATA EE,32
04C6:  DATA 73,00
04C7:  DATA 0D,10
04C8:  DATA 3E,10
04C9:  DATA C1,31
04CA:  DATA F4,34
04CB:  DATA F6,30
04CC:  DATA E3,34
04CD:  DATA 6F,37
04CE:  DATA A0,36
04CF:  DATA 61,37
04D0:  DATA F5,30
04D1:  DATA 6C,10
04D2:  DATA E4,32
04D3:  DATA 20,38
04D4:  DATA F5,32
04D5:  DATA 72,3A
04D6:  DATA 6F,00
04D7:  DATA 0D,10
04D8:  DATA 3E,10
04D9:  DATA D4,37
04DA:  DATA F1,3A
04DB:  DATA 65,10
04DC:  DATA E3,37
04DD:  DATA 72,3A
04DE:  DATA 6F,00
04DF:  DATA 0D,10
04E0:  DATA 3E,10
04E1:  DATA D4,37
04E2:  DATA F1,3A
04E3:  DATA 65,10
04E4:  DATA EC,30
04E5:  DATA F2,33
04E6:  DATA 6F,00
04E7:  DATA 0D,10
04E8:  DATA 3E,10
04E9:  DATA D4,37
04EA:  DATA F1,3A
04EB:  DATA 65,10
04EC:  DATA E4,37
04ED:  DATA 62,36
04EE:  DATA 65,00
04EF:  DATA 0D,10
04F0:  DATA 3E,10
04F1:  DATA C1,39
04F2:  DATA E9,33
04F3:  DATA EE,30
04F4:  DATA 72,10
04F5:  DATA E6,30
04F6:  DATA 6C,3A
04F7:  DATA E1,39
04F8:  DATA 00,01
04F9:  DATA 0D,10
04FA:  DATA 3E,10
04FB:  DATA C1,39
04FC:  DATA E9,33
04FD:  DATA EE,30
04FE:  DATA 72,10
04FF:  DATA EA,3A
0500:  DATA E7,30
0501:  DATA E4,37
0502:  DATA 72,00
0503:  DATA 0D,10
0504:  DATA 3E,10
0505:  DATA D2,32
0506:  DATA F3,32
0507:  DATA F4,32
0508:  DATA 61,10
0509:  DATA 61,10
050A:  DATA 30,00
050B:  DATA 0D,10
050C:  DATA 3E,10
050D:  DATA 49,37
050E:  DATA 63,39
050F:  DATA E5,36
0510:  DATA 65,37
0511:  DATA F4,30
0512:  DATA 72,10
0513:  DATA F0,37
0514:  DATA 72,10
0515:  DATA 31,00
0516:  DATA 0D,10
0517:  DATA 3E,10
0518:  DATA 49,37
0519:  DATA 63,39
051A:  DATA E5,36
051B:  DATA 65,37
051C:  DATA F4,30
051D:  DATA 72,10
051E:  DATA F0,37
051F:  DATA 72,10
0520:  DATA 32,00
0521:  DATA 0D,10
0522:  DATA 3E,10
0523:  DATA 49,37
0524:  DATA 63,39
0525:  DATA E5,36
0526:  DATA 65,37
0527:  DATA F4,30
0528:  DATA 72,10
0529:  DATA F0,37
052A:  DATA 72,10
052B:  DATA 33,00
052C:  DATA 0D,10
052D:  DATA 3E,10
052E:  DATA C4,32
052F:  DATA 63,39
0530:  DATA E5,36
0531:  DATA 65,37
0532:  DATA F4,30
0533:  DATA 72,10
0534:  DATA F0,37
0535:  DATA 72,10
0536:  DATA 31,00
0537:  DATA 0D,10
0538:  DATA 3E,10
0539:  DATA C1,39
053A:  DATA E9,33
053B:  DATA EE,30
053C:  DATA 72,10
053D:  DATA E6,30
053E:  DATA 6C,3A
053F:  DATA E1,39
0540:  DATA 00,01
0541:  DATA 0D,10
0542:  DATA 3E,10
0543:  DATA 49,37
0544:  DATA E9,31
0545:  DATA E9,30
0546:  DATA EC,34
0547:  DATA FA,30
0548:  DATA 72,00
0549:  DATA 0D,10
054A:  DATA 3E,10
054B:  DATA C1,39
054C:  DATA E9,33
054D:  DATA EE,30
054E:  DATA 72,10
054F:  DATA F0,37
0550:  DATA F3,34
0551:  DATA E3,34
0552:  DATA 6F,37
0553:  DATA 00,01
0554:  DATA 0D,10
0555:  DATA 3E,10
0556:  DATA D0,30
0557:  DATA F5,39
0558:  DATA 61,39
0559:  DATA 20,3A
055A:  DATA E9,32
055B:  DATA 6D,38
055C:  DATA 6F,00
055D:  DATA 0D,10
055E:  DATA 3E,10
055F:  DATA D2,32
0560:  DATA EE,3A
0561:  DATA E4,30
0562:  DATA 72,10
0563:  DATA F4,34
0564:  DATA E5,36
0565:  DATA F0,37
0566:  DATA 00,01
0567:  DATA 0D,10
0568:  DATA 3E,10
0569:  DATA 41,38
056A:  DATA E1,33
056B:  DATA 61,39
056C:  DATA 20,28
056D:  DATA 65,39
056E:  DATA E9,37
056F:  DATA E4,37
0570:  DATA 73,00
0571:  DATA 0D,10
0572:  DATA 3E,10
0573:  DATA D0,32
0574:  DATA F2,34
0575:  DATA 6F,32
0576:  DATA 6F,10
0577:  DATA 31,00
0578:  DATA 0D,10
0579:  DATA 3E,10
057A:  DATA D0,32
057B:  DATA F2,34
057C:  DATA 6F,32
057D:  DATA 6F,10
057E:  DATA 32,00
057F:  DATA 0D,10
0580:  DATA 3E,10
0581:  DATA D0,32
0582:  DATA F2,34
0583:  DATA 6F,32
0584:  DATA 6F,10
0585:  DATA 33,00
0586:  DATA 0D,10
0587:  DATA 3E,10
0588:  DATA D0,32
0589:  DATA F2,34
058A:  DATA 6F,32
058B:  DATA 6F,10
058C:  DATA 34,00
058D:  DATA 0D,10
058E:  DATA 3E,10
058F:  DATA D2,32
0590:  DATA F3,32
0591:  DATA F4,32
0592:  DATA 61,10
0593:  DATA 61,10
0594:  DATA 30,00
0595:  DATA 0D,10
0596:  DATA 3E,10
0597:  DATA 49,37
0598:  DATA 63,39
0599:  DATA E5,36
059A:  DATA 65,37
059B:  DATA F4,30
059C:  DATA 72,10
059D:  DATA F0,37
059E:  DATA 72,10
059F:  DATA 31,00
05A0:  DATA 0D,10
05A1:  DATA 3E,10
05A2:  DATA 49,37
05A3:  DATA 63,39
05A4:  DATA E5,36
05A5:  DATA 65,37
05A6:  DATA F4,30
05A7:  DATA 72,10
05A8:  DATA F0,37
05A9:  DATA 72,10
05AA:  DATA 32,00
05AB:  DATA 0D,10
05AC:  DATA 3E,10
05AD:  DATA 49,37
05AE:  DATA 63,39
05AF:  DATA E5,36
05B0:  DATA 65,37
05B1:  DATA F4,30
05B2:  DATA 72,10
05B3:  DATA F0,37
05B4:  DATA 72,10
05B5:  DATA 33,00
05B6:  DATA 0D,10
05B7:  DATA 3E,10
05B8:  DATA C4,32
05B9:  DATA 63,39
05BA:  DATA E5,36
05BB:  DATA 65,37
05BC:  DATA F4,30
05BD:  DATA 72,10
05BE:  DATA F0,37
05BF:  DATA 72,10
05C0:  DATA 31,00
05C1:  DATA 0D,10
05C2:  DATA 3E,10
05C3:  DATA C1,39
05C4:  DATA E9,33
05C5:  DATA EE,30
05C6:  DATA 72,10
05C7:  DATA E6,30
05C8:  DATA 6C,3A
05C9:  DATA E1,39
05CA:  DATA 00,01
05CB:  DATA 0D,10
05CC:  DATA 3E,10
05CD:  DATA 49,37
05CE:  DATA E9,31
05CF:  DATA E9,30
05D0:  DATA EC,34
05D1:  DATA FA,30
05D2:  DATA 72,00
05D3:  DATA 0D,10
05D4:  DATA 3E,10
05D5:  DATA C1,39
05D6:  DATA E9,33
05D7:  DATA EE,30
05D8:  DATA 72,10
05D9:  DATA F0,37
05DA:  DATA F3,34
05DB:  DATA E3,34
05DC:  DATA 6F,37
05DD:  DATA 00,01
05DE:  DATA 0D,10
05DF:  DATA 3E,10
05E0:  DATA D2,32
05E1:  DATA F3,32
05E2:  DATA F4,32
05E3:  DATA 6F,10
05E4:  DATA E7,32
05E5:  DATA EE,32
05E6:  DATA F2,30
05E7:  DATA 6C,17
05E8:  DATA 2E,17
05E9:  DATA A0,10
05EA:  DATA 20,00
05EB:  DATA 0D,10
05EC:  DATA 3E,10
05ED:  DATA C3,37
05EE:  DATA 6E,33
05EF:  DATA E9,33
05F0:  DATA 75,39
05F1:  DATA E1,31
05F2:  DATA E9,37
05F3:  DATA 6E,10
05F4:  DATA E4,32
05F5:  DATA 20,3A
05F6:  DATA 69,39
05F7:  DATA 6F,00
05F8:  DATA 0D,10
05F9:  DATA 3E,10
05FA:  DATA C3,37
05FB:  DATA 6E,33
05FC:  DATA E9,33
05FD:  DATA 75,39
05FE:  DATA E1,31
05FF:  DATA E9,37
0600:  DATA 6E,10
0601:  DATA E4,32
0602:  DATA 20,3A
0603:  DATA E9,32
0604:  DATA 6D,38
0605:  DATA 6F,00
0606:  MOVF   0B,W
0607:  MOVWF  7B
0608:  BCF    0B.7
0609:  BSF    03.5
060A:  BSF    03.6
060B:  BSF    0C.7
060C:  BSF    0C.0
060D:  NOP
060E:  NOP
060F:  BTFSS  7B.7
0610:  GOTO   616
0611:  BCF    03.5
0612:  BCF    03.6
0613:  BSF    0B.7
0614:  BSF    03.5
0615:  BSF    03.6
0616:  BCF    03.5
0617:  MOVF   0C,W
0618:  ANDLW  7F
0619:  BTFSC  03.2
061A:  GOTO   656
061B:  MOVWF  7B
061C:  MOVF   0D,W
061D:  MOVWF  7C
061E:  MOVF   0F,W
061F:  MOVWF  7D
0620:  MOVF   7B,W
0621:  BCF    03.6
0622:  BTFSS  0C.4
0623:  GOTO   622
0624:  MOVWF  19
0625:  MOVF   7C,W
0626:  BSF    03.6
0627:  MOVWF  0D
0628:  MOVF   7D,W
0629:  MOVWF  0F
062A:  BCF    03.6
062B:  MOVF   0B,W
062C:  MOVWF  7E
062D:  BCF    0B.7
062E:  BSF    03.5
062F:  BSF    03.6
0630:  BSF    0C.7
0631:  BSF    0C.0
0632:  NOP
0633:  NOP
0634:  BTFSS  7E.7
0635:  GOTO   63B
0636:  BCF    03.5
0637:  BCF    03.6
0638:  BSF    0B.7
0639:  BSF    03.5
063A:  BSF    03.6
063B:  BCF    03.5
063C:  RLF    0C,W
063D:  RLF    0E,W
063E:  ANDLW  7F
063F:  BTFSC  03.2
0640:  GOTO   656
0641:  MOVWF  7B
0642:  MOVF   0D,W
0643:  MOVWF  7C
0644:  MOVF   0F,W
0645:  MOVWF  7D
0646:  MOVF   7B,W
0647:  BCF    03.6
0648:  BTFSS  0C.4
0649:  GOTO   648
064A:  MOVWF  19
064B:  MOVF   7C,W
064C:  BSF    03.6
064D:  MOVWF  0D
064E:  MOVF   7D,W
064F:  MOVWF  0F
0650:  INCF   0D,F
0651:  BTFSC  03.2
0652:  INCF   0F,F
0653:  BCF    03.6
0654:  GOTO   606
0655:  BSF    03.6
0656:  BCF    03.6
0657:  RETURN
0658:  MOVF   0B,W
0659:  MOVWF  7B
065A:  BCF    0B.7
065B:  BSF    03.5
065C:  BSF    03.6
065D:  BSF    0C.7
065E:  BSF    0C.0
065F:  NOP
0660:  NOP
0661:  BTFSS  7B.7
0662:  GOTO   668
0663:  BCF    03.5
0664:  BCF    03.6
0665:  BSF    0B.7
0666:  BSF    03.5
0667:  BSF    03.6
0668:  BTFSC  03.0
0669:  GOTO   690
066A:  BCF    03.5
066B:  MOVF   0C,W
066C:  ANDLW  7F
066D:  MOVWF  7B
066E:  MOVF   0D,W
066F:  MOVWF  7C
0670:  MOVF   0F,W
0671:  MOVWF  7D
0672:  MOVF   7B,W
0673:  BCF    03.6
0674:  BTFSS  0C.4
0675:  GOTO   674
0676:  MOVWF  19
0677:  MOVF   7C,W
0678:  BSF    03.6
0679:  MOVWF  0D
067A:  MOVF   7D,W
067B:  MOVWF  0F
067C:  BCF    03.6
067D:  MOVF   0B,W
067E:  MOVWF  7E
067F:  BCF    0B.7
0680:  BSF    03.5
0681:  BSF    03.6
0682:  BSF    0C.7
0683:  BSF    0C.0
0684:  NOP
0685:  NOP
0686:  BTFSS  7E.7
0687:  GOTO   68D
0688:  BCF    03.5
0689:  BCF    03.6
068A:  BSF    0B.7
068B:  BSF    03.5
068C:  BSF    03.6
068D:  DECFSZ 74,F
068E:  GOTO   690
068F:  GOTO   6AD
0690:  BCF    03.5
0691:  RLF    0C,W
0692:  RLF    0E,W
0693:  ANDLW  7F
0694:  MOVWF  7B
0695:  MOVF   0D,W
0696:  MOVWF  7C
0697:  MOVF   0F,W
0698:  MOVWF  7D
0699:  MOVF   7B,W
069A:  BCF    03.6
069B:  BTFSS  0C.4
069C:  GOTO   69B
069D:  MOVWF  19
069E:  MOVF   7C,W
069F:  BSF    03.6
06A0:  MOVWF  0D
06A1:  MOVF   7D,W
06A2:  MOVWF  0F
06A3:  INCF   0D,F
06A4:  BTFSC  03.2
06A5:  INCF   0F,F
06A6:  BCF    03.0
06A7:  DECFSZ 74,F
06A8:  GOTO   6AA
06A9:  GOTO   6AC
06AA:  BCF    03.6
06AB:  GOTO   658
06AC:  BSF    03.5
06AD:  BCF    03.5
06AE:  BCF    03.6
06AF:  RETURN
*
0FC3:  BSF    0A.0
0FC4:  BSF    0A.1
0FC5:  BSF    0A.2
0FC6:  ADDWF  02,F
0FC7:  GOTO   061
0FC8:  GOTO   082
0FC9:  GOTO   0A3
0FCA:  GOTO   0C4
0FCB:  BSF    0A.0
0FCC:  BSF    0A.1
0FCD:  BSF    0A.2
0FCE:  ADDWF  02,F
0FCF:  GOTO   3A7
0FD0:  GOTO   3C5
0FD1:  GOTO   3E3
0FD2:  GOTO   401
0FD3:  GOTO   41F
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... // ::[CONFIGURACION DE PIC]:: 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
02D2:  MOVLW  C0
02D3:  MOVWF  04
02D4:  BCF    03.7
02D5:  MOVF   00,W
02D6:  BTFSC  03.2
02D7:  GOTO   2E5
02D8:  MOVLW  02
02D9:  MOVWF  78
02DA:  CLRF   77
02DB:  DECFSZ 77,F
02DC:  GOTO   2DB
02DD:  DECFSZ 78,F
02DE:  GOTO   2DA
02DF:  MOVLW  97
02E0:  MOVWF  77
02E1:  DECFSZ 77,F
02E2:  GOTO   2E1
02E3:  DECFSZ 00,F
02E4:  GOTO   2D8
02E5:  RETURN
....................  
.................... // ::[CONFIGURACION DE IO]:: 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0 ) 
....................  
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
....................  
.................... // ::[CONFIGURACION PUERTOS]:: 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... //#use i2c    (Master,Fast,sda=I2C_SDA,scl=I2C_SCL) 
.................... #use i2c    (master, scl=I2C_SCL, sda=I2C_SDA, fast) 
*
0289:  BCF    14.7
028A:  BCF    0C.3
028B:  BSF    03.5
028C:  MOVF   46,W
028D:  BCF    03.5
028E:  MOVWF  13
028F:  MOVLW  02
0290:  BTFSC  14.7
0291:  GOTO   299
0292:  BTFSS  0C.3
0293:  GOTO   292
0294:  MOVLW  00
0295:  BSF    03.5
0296:  BTFSC  11.6
0297:  MOVLW  01
0298:  BCF    03.5
0299:  MOVWF  78
029A:  RETURN
....................  
.................... // ::[DEFINICIONES]:: 
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       10 
.................... #define I2CWAIT         50 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... // ::[DECLARACIONES]:: 
.................... //Estructura para el puerto 
....................  
.................... typedef struct sPort { 
....................     int a; 
....................     int b; 
....................     int c; 
....................     int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char cmd[20] = "\0"; 
*
06F0:  BCF    03.6
06F1:  CLRF   2C
06F2:  CLRF   2D
.................... char rcmd[20] = "\0"; 
06F3:  CLRF   40
06F4:  CLRF   41
.................... int8 cmdIndex = 0; 
.................... int1 cmdGet = false; 
....................  
.................... //Puertos de Displays 
.................... tPort pNJugadorU; 
.................... tPort pNJugadorD; 
.................... tPort pFJugadorU; 
.................... tPort pFJugadorD; 
....................  
.................... //Tiempo 
.................... int8 m_d = 0; 
.................... int8 m_u = 0; 
.................... int8 s_d = 0; 
.................... int8 s_u = 0; 
....................  
.................... //Tiro 
.................... int8 sh_d = 0; 
.................... int8 sh_u = 0; 
....................  
.................... int8 scoreLU = 0; 
.................... int8 scoreLD = 0; 
.................... int1 scoreLC = 0; 
.................... int8 scoreVU = 0; 
.................... int8 scoreVD = 0; 
.................... int1 scoreVC = 0; 
....................  
.................... // ::[PROTOTIPOS]:: 
....................  
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8 char2int(char); 
.................... void doReset(void); 
.................... void sendN2Port(int8, int8, int8); 
.................... void timeSet(int8, int8, int8, int8); 
.................... void shotSet(int8, int8); 
.................... void doBuzz(int); 
.................... void setScoreL(int8, int8, int8); 
.................... void setScoreV(int8, int8, int8); 
.................... void i2c_send(int8, int8); 
.................... void addScoreL(int8); 
.................... void addScoreV(int8); 
.................... void resScoreL(void); 
.................... void resScoreV(void); 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
06F5:  CLRF   70
06F6:  CLRF   71
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // *FUNCION:      setup() 
.................... // *PARAMETROS:   ninguno 
.................... // *REGRESA:      VOID 
.................... // *RESUMEN:      Configuracion inicial del dispositivo 
....................  
.................... void setup() { 
....................     output_a(0x00); 
*
1000:  MOVLW  0F
1001:  BSF    03.5
1002:  MOVWF  05
1003:  BCF    03.5
1004:  CLRF   05
....................     output_b(0x00); 
1005:  BSF    03.5
1006:  CLRF   06
1007:  BCF    03.5
1008:  CLRF   06
....................     output_c(0x00); 
1009:  MOVLW  DF
100A:  BSF    03.5
100B:  MOVWF  07
100C:  BCF    03.5
100D:  CLRF   07
....................     output_d(0x00); 
100E:  BSF    03.5
100F:  CLRF   08
1010:  BCF    03.5
1011:  CLRF   08
....................     output_e(0x00); 
1012:  BSF    03.5
1013:  BCF    09.0
1014:  BCF    09.1
1015:  BCF    09.2
1016:  BCF    09.3
1017:  BCF    03.5
1018:  CLRF   09
1019:  CLRF   2B
101A:  BTFSC  0B.7
101B:  BSF    2B.7
101C:  BCF    0B.7
....................  
....................     delay_ms(DEFAULT_D); 
101D:  MOVLW  0A
101E:  BSF    03.5
101F:  MOVWF  40
1020:  BCF    0A.4
1021:  BCF    03.5
1022:  CALL   2D2
1023:  BSF    0A.4
1024:  BTFSC  2B.7
1025:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
1026:  BTFSS  07.2
1027:  GOTO   099
....................         fprintf(RS232, "********************************\r"); 
1028:  MOVLW  57
1029:  BSF    03.6
102A:  MOVWF  0D
102B:  MOVLW  00
102C:  MOVWF  0F
102D:  BCF    0A.4
102E:  BCF    03.6
102F:  CALL   606
1030:  BSF    0A.4
....................         fprintf(RS232, " Grupo APM (c) 2020 \r"); 
1031:  MOVLW  68
1032:  BSF    03.6
1033:  MOVWF  0D
1034:  MOVLW  00
1035:  MOVWF  0F
1036:  BCF    0A.4
1037:  BCF    03.6
1038:  CALL   606
1039:  BSF    0A.4
....................         fprintf(RS232, "================================\r"); 
103A:  MOVLW  73
103B:  BSF    03.6
103C:  MOVWF  0D
103D:  MOVLW  00
103E:  MOVWF  0F
103F:  BCF    0A.4
1040:  BCF    03.6
1041:  CALL   606
1042:  BSF    0A.4
....................         fprintf(RS232, "Bluetooth Basketball Score Board\r"); 
1043:  MOVLW  84
1044:  BSF    03.6
1045:  MOVWF  0D
1046:  MOVLW  00
1047:  MOVWF  0F
1048:  BCF    0A.4
1049:  BCF    03.6
104A:  CALL   606
104B:  BSF    0A.4
....................         fprintf(RS232, "================================\r"); 
104C:  MOVLW  95
104D:  BSF    03.6
104E:  MOVWF  0D
104F:  MOVLW  00
1050:  MOVWF  0F
1051:  BCF    0A.4
1052:  BCF    03.6
1053:  CALL   606
1054:  BSF    0A.4
....................         fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
1055:  MOVLW  A6
1056:  BSF    03.6
1057:  MOVWF  0D
1058:  MOVLW  00
1059:  MOVWF  0F
105A:  BCF    03.0
105B:  MOVLW  08
105C:  MOVWF  74
105D:  BCF    0A.4
105E:  BCF    03.6
105F:  CALL   658
1060:  BSF    0A.4
1061:  MOVLW  B1
1062:  BSF    03.6
1063:  MOVWF  0D
1064:  MOVLW  00
1065:  MOVWF  0F
1066:  BCF    0A.4
1067:  BCF    03.6
1068:  CALL   606
1069:  BSF    0A.4
106A:  MOVLW  AB
106B:  BSF    03.6
106C:  MOVWF  0D
106D:  MOVLW  00
106E:  MOVWF  0F
106F:  BCF    03.0
1070:  MOVLW  07
1071:  MOVWF  74
1072:  BCF    0A.4
1073:  BCF    03.6
1074:  CALL   658
1075:  BSF    0A.4
1076:  MOVLW  B3
1077:  BSF    03.6
1078:  MOVWF  0D
1079:  MOVLW  00
107A:  MOVWF  0F
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   606
107E:  BSF    0A.4
107F:  MOVLW  20
1080:  BTFSS  0C.4
1081:  GOTO   080
1082:  MOVWF  19
1083:  MOVLW  0D
1084:  BTFSS  0C.4
1085:  GOTO   084
1086:  MOVWF  19
....................         fprintf(RS232, "********************************\r"); 
1087:  MOVLW  B4
1088:  BSF    03.6
1089:  MOVWF  0D
108A:  MOVLW  00
108B:  MOVWF  0F
108C:  BCF    0A.4
108D:  BCF    03.6
108E:  CALL   606
108F:  BSF    0A.4
....................         fprintf(RS232, " DEPURACION :: COMUNICACIONES \r"); 
1090:  MOVLW  C5
1091:  BSF    03.6
1092:  MOVWF  0D
1093:  MOVLW  00
1094:  MOVWF  0F
1095:  BCF    0A.4
1096:  BCF    03.6
1097:  CALL   606
1098:  BSF    0A.4
1099:  CLRF   2B
109A:  BTFSC  0B.7
109B:  BSF    2B.7
109C:  BCF    0B.7
....................     } 
....................  
....................     delay_ms(DEFAULT_D); 
109D:  MOVLW  0A
109E:  BSF    03.5
109F:  MOVWF  40
10A0:  BCF    0A.4
10A1:  BCF    03.5
10A2:  CALL   2D2
10A3:  BSF    0A.4
10A4:  BTFSC  2B.7
10A5:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
10A6:  BTFSS  07.2
10A7:  GOTO   0BF
....................         fputs(" > Configuracion de Puertos", RS232); 
10A8:  MOVLW  D5
10A9:  BSF    03.6
10AA:  MOVWF  0D
10AB:  MOVLW  00
10AC:  MOVWF  0F
10AD:  BCF    03.6
10AE:  CLRF   2B
10AF:  BTFSC  0B.7
10B0:  BSF    2B.7
10B1:  BCF    0B.7
10B2:  BCF    0A.4
10B3:  CALL   10F
10B4:  BSF    0A.4
10B5:  BTFSC  2B.7
10B6:  BSF    0B.7
10B7:  MOVLW  0D
10B8:  BTFSS  0C.4
10B9:  GOTO   0B8
10BA:  MOVWF  19
10BB:  MOVLW  0A
10BC:  BTFSS  0C.4
10BD:  GOTO   0BC
10BE:  MOVWF  19
....................     } 
....................  
....................     pNJugadorU.a = PIN_B0; 
10BF:  MOVLW  30
10C0:  MOVWF  56
....................     pNJugadorU.b = PIN_B1; 
10C1:  MOVLW  31
10C2:  MOVWF  57
....................     pNJugadorU.c = PIN_B2; 
10C3:  MOVLW  32
10C4:  MOVWF  58
....................     pNJugadorU.d = PIN_B3; 
10C5:  MOVLW  33
10C6:  MOVWF  59
....................  
....................     pNJugadorD.a = PIN_B4; 
10C7:  MOVLW  34
10C8:  MOVWF  5A
....................     pNJugadorD.b = PIN_B5; 
10C9:  MOVLW  35
10CA:  MOVWF  5B
....................     pNJugadorD.c = PIN_B6; 
10CB:  MOVLW  36
10CC:  MOVWF  5C
....................     pNJugadorD.d = PIN_B7; 
10CD:  MOVLW  37
10CE:  MOVWF  5D
....................  
....................     pFJugadorU.a = PIN_D0; 
10CF:  MOVLW  40
10D0:  MOVWF  5E
....................     pFJugadorU.b = PIN_D1; 
10D1:  MOVLW  41
10D2:  MOVWF  5F
....................     pFJugadorU.c = PIN_D2; 
10D3:  MOVLW  42
10D4:  MOVWF  60
....................     pFJugadorU.d = PIN_D3; 
10D5:  MOVLW  43
10D6:  MOVWF  61
....................  
....................     pFJugadorD.a = PIN_D4; 
10D7:  MOVLW  44
10D8:  MOVWF  62
....................     pFJugadorD.b = PIN_D5; 
10D9:  MOVLW  45
10DA:  MOVWF  63
....................     pFJugadorD.c = PIN_D6; 
10DB:  MOVLW  46
10DC:  MOVWF  64
....................     pFJugadorD.d = PIN_D7; 
10DD:  MOVLW  47
10DE:  MOVWF  65
10DF:  CLRF   2B
10E0:  BTFSC  0B.7
10E1:  BSF    2B.7
10E2:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
10E3:  MOVLW  0A
10E4:  BSF    03.5
10E5:  MOVWF  40
10E6:  BCF    0A.4
10E7:  BCF    03.5
10E8:  CALL   2D2
10E9:  BSF    0A.4
10EA:  BTFSC  2B.7
10EB:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
10EC:  BTFSS  07.2
10ED:  GOTO   105
....................         fputs(" > Inicializacion de I2C", RS232); 
10EE:  MOVLW  E3
10EF:  BSF    03.6
10F0:  MOVWF  0D
10F1:  MOVLW  00
10F2:  MOVWF  0F
10F3:  BCF    03.6
10F4:  CLRF   2B
10F5:  BTFSC  0B.7
10F6:  BSF    2B.7
10F7:  BCF    0B.7
10F8:  BCF    0A.4
10F9:  CALL   10F
10FA:  BSF    0A.4
10FB:  BTFSC  2B.7
10FC:  BSF    0B.7
10FD:  MOVLW  0D
10FE:  BTFSS  0C.4
10FF:  GOTO   0FE
1100:  MOVWF  19
1101:  MOVLW  0A
1102:  BTFSS  0C.4
1103:  GOTO   102
1104:  MOVWF  19
....................     } 
....................     i2c_speed (100000) ; 
1105:  MOVLW  13
1106:  BSF    03.5
1107:  MOVWF  13
1108:  MOVLW  28
1109:  BCF    03.5
110A:  MOVWF  14
110B:  BSF    03.5
110C:  BSF    14.7
....................  
....................     IF(DEBUG) { 
110D:  BCF    03.5
110E:  BTFSS  07.2
110F:  GOTO   127
....................         fputs(" > Habilitacion de displays", RS232); 
1110:  MOVLW  F0
1111:  BSF    03.6
1112:  MOVWF  0D
1113:  MOVLW  00
1114:  MOVWF  0F
1115:  BCF    03.6
1116:  CLRF   2B
1117:  BTFSC  0B.7
1118:  BSF    2B.7
1119:  BCF    0B.7
111A:  BCF    0A.4
111B:  CALL   10F
111C:  BSF    0A.4
111D:  BTFSC  2B.7
111E:  BSF    0B.7
111F:  MOVLW  0D
1120:  BTFSS  0C.4
1121:  GOTO   120
1122:  MOVWF  19
1123:  MOVLW  0A
1124:  BTFSS  0C.4
1125:  GOTO   124
1126:  MOVWF  19
....................     } 
....................     output_bit(DISPLAY, ON); 
1127:  BSF    09.0
1128:  MOVLW  EE
1129:  BSF    03.5
112A:  MOVWF  09
112B:  BCF    03.5
112C:  CLRF   2B
112D:  BTFSC  0B.7
112E:  BSF    2B.7
112F:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
1130:  MOVLW  0A
1131:  BSF    03.5
1132:  MOVWF  40
1133:  BCF    0A.4
1134:  BCF    03.5
1135:  CALL   2D2
1136:  BSF    0A.4
1137:  BTFSC  2B.7
1138:  BSF    0B.7
....................     output_bit(DISPLAY, OFF); 
1139:  BCF    09.0
113A:  MOVLW  EE
113B:  BSF    03.5
113C:  MOVWF  09
113D:  BCF    03.5
113E:  CLRF   2B
113F:  BTFSC  0B.7
1140:  BSF    2B.7
1141:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
1142:  MOVLW  0A
1143:  BSF    03.5
1144:  MOVWF  40
1145:  BCF    0A.4
1146:  BCF    03.5
1147:  CALL   2D2
1148:  BSF    0A.4
1149:  BTFSC  2B.7
114A:  BSF    0B.7
....................     output_bit(DISPLAY, ON); 
114B:  BSF    09.0
114C:  MOVLW  EE
114D:  BSF    03.5
114E:  MOVWF  09
114F:  BCF    03.5
1150:  CLRF   2B
1151:  BTFSC  0B.7
1152:  BSF    2B.7
1153:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
1154:  MOVLW  0A
1155:  BSF    03.5
1156:  MOVWF  40
1157:  BCF    0A.4
1158:  BCF    03.5
1159:  CALL   2D2
115A:  BSF    0A.4
115B:  BTFSC  2B.7
115C:  BSF    0B.7
....................  
....................     if (DEBUG) { 
115D:  BTFSS  07.2
115E:  GOTO   176
....................         fputs(" > Habilitacion de interrupciones", RS232); 
115F:  MOVLW  FE
1160:  BSF    03.6
1161:  MOVWF  0D
1162:  MOVLW  00
1163:  MOVWF  0F
1164:  BCF    03.6
1165:  CLRF   2B
1166:  BTFSC  0B.7
1167:  BSF    2B.7
1168:  BCF    0B.7
1169:  BCF    0A.4
116A:  CALL   10F
116B:  BSF    0A.4
116C:  BTFSC  2B.7
116D:  BSF    0B.7
116E:  MOVLW  0D
116F:  BTFSS  0C.4
1170:  GOTO   16F
1171:  MOVWF  19
1172:  MOVLW  0A
1173:  BTFSS  0C.4
1174:  GOTO   173
1175:  MOVWF  19
....................     } 
....................     enable_interrupts(INT_RDA); 
1176:  BSF    03.5
1177:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
1178:  MOVLW  C0
1179:  BCF    03.5
117A:  IORWF  0B,F
117B:  BCF    0A.3
117C:  BCF    0A.4
117D:  GOTO   6F9 (RETURN)
.................... } 
....................  
.................... void main() { 
*
06B0:  MOVF   03,W
06B1:  ANDLW  1F
06B2:  MOVWF  03
06B3:  MOVLW  71
06B4:  BSF    03.5
06B5:  MOVWF  0F
06B6:  CLRF   10
06B7:  MOVF   0F,W
06B8:  BSF    03.6
06B9:  BCF    07.3
06BA:  MOVLW  0C
06BB:  BCF    03.6
06BC:  MOVWF  19
06BD:  MOVLW  A2
06BE:  MOVWF  18
06BF:  MOVLW  90
06C0:  BCF    03.5
06C1:  MOVWF  18
06C2:  MOVLW  DF
06C3:  BSF    03.5
06C4:  MOVWF  07
06C5:  MOVLW  DF
06C6:  MOVWF  07
06C7:  MOVLW  04
06C8:  MOVWF  13
06C9:  MOVLW  28
06CA:  BCF    03.5
06CB:  MOVWF  14
06CC:  BSF    03.5
06CD:  BCF    14.7
06CE:  BCF    14.6
06CF:  BCF    03.5
06D0:  CLRF   54
06D1:  BCF    55.0
06D2:  CLRF   66
06D3:  CLRF   67
06D4:  CLRF   68
06D5:  CLRF   69
06D6:  CLRF   6A
06D7:  CLRF   6B
06D8:  CLRF   6C
06D9:  CLRF   6D
06DA:  BCF    55.1
06DB:  CLRF   6E
06DC:  CLRF   6F
06DD:  BCF    55.2
06DE:  CLRF   73
06DF:  CLRF   72
06E0:  BSF    03.5
06E1:  BSF    03.6
06E2:  MOVF   09,W
06E3:  ANDLW  C0
06E4:  MOVWF  09
06E5:  BCF    03.6
06E6:  BCF    1F.4
06E7:  BCF    1F.5
06E8:  MOVLW  00
06E9:  BSF    03.6
06EA:  MOVWF  08
06EB:  BCF    03.5
06EC:  CLRF   07
06ED:  CLRF   08
06EE:  CLRF   09
06EF:  BCF    03.7
....................     setup(); 
*
06F7:  BSF    0A.4
06F8:  GOTO   000
06F9:  BCF    0A.4
....................  
....................     WHILE(TRUE) { 
06FA:  GOTO   6FA
....................     } 
.................... } 
....................  
.................... #INT_RDA 
.................... void RDA_isr(VOID) { 
06FB:  SLEEP
....................     CHAR c; 
....................     c = fgetc(RS232); 
*
042E:  BTFSS  0C.5
042F:  GOTO   42E
0430:  MOVF   1A,W
0431:  BSF    03.5
0432:  MOVWF  23
....................  
....................     IF(cmdGet) { 
0433:  BCF    03.5
0434:  BTFSS  55.0
0435:  GOTO   470
....................  
....................         IF(c == '#' || c == '\r') { 
0436:  BSF    03.5
0437:  MOVF   23,W
0438:  SUBLW  23
0439:  BTFSC  03.2
043A:  GOTO   43F
043B:  MOVF   23,W
043C:  SUBLW  0D
043D:  BTFSS  03.2
043E:  GOTO   462
....................             cmdGet = false; 
043F:  BCF    03.5
0440:  BCF    55.0
....................             strcpy(cmd, rcmd); 
0441:  BSF    03.5
0442:  CLRF   27
0443:  MOVLW  40
0444:  MOVWF  26
0445:  CLRF   25
0446:  MOVLW  2C
0447:  MOVWF  24
0448:  MOVF   26,W
0449:  MOVWF  04
044A:  BCF    03.7
044B:  BTFSC  27.0
044C:  BSF    03.7
044D:  MOVF   00,W
044E:  MOVWF  28
044F:  MOVF   24,W
0450:  MOVWF  04
0451:  BCF    03.7
0452:  BTFSC  25.0
0453:  BSF    03.7
0454:  MOVF   28,W
0455:  MOVWF  00
0456:  MOVF   00,F
0457:  BTFSC  03.2
0458:  GOTO   45C
0459:  INCF   24,F
045A:  INCF   26,F
045B:  GOTO   448
....................             parseCommand(); 
045C:  BSF    0A.3
045D:  BCF    03.5
045E:  GOTO   000
045F:  BCF    0A.3
....................         } 
0460:  GOTO   470
0461:  BSF    03.5
....................  
....................         ELSE{ 
....................             IF(cmdIndex < 20) { 
0462:  BCF    03.5
0463:  MOVF   54,W
0464:  SUBLW  13
0465:  BTFSS  03.0
0466:  GOTO   470
....................                 rcmd[cmdIndex] = c; 
0467:  MOVLW  40
0468:  ADDWF  54,W
0469:  MOVWF  04
046A:  BCF    03.7
046B:  BSF    03.5
046C:  MOVF   23,W
046D:  MOVWF  00
....................                 cmdIndex++; 
046E:  BCF    03.5
046F:  INCF   54,F
....................             } 
....................         } 
....................     } 
....................  
....................     IF(c == '-') { 
0470:  BSF    03.5
0471:  MOVF   23,W
0472:  SUBLW  2D
0473:  BTFSS  03.2
0474:  GOTO   48D
....................         cmdGet = true; 
0475:  BCF    03.5
0476:  BSF    55.0
....................         rcmd = "\0"; 
0477:  BSF    03.5
0478:  CLRF   24
0479:  CLRF   25
047A:  MOVLW  40
047B:  MOVWF  04
047C:  BCF    03.7
047D:  MOVF   24,W
047E:  ADDWF  04,F
047F:  MOVF   25,W
0480:  BCF    03.5
0481:  CALL   051
0482:  MOVWF  00
0483:  IORLW  00
0484:  BTFSC  03.2
0485:  GOTO   48B
0486:  BSF    03.5
0487:  INCF   25,F
0488:  INCF   24,F
0489:  GOTO   47A
048A:  BCF    03.5
....................         cmdIndex = 0; 
048B:  CLRF   54
048C:  BSF    03.5
....................     } 
048D:  BCF    03.5
048E:  BCF    0C.5
048F:  BCF    0A.3
0490:  BCF    0A.4
0491:  GOTO   02D
.................... } 
....................  
.................... void doTest(VOID) { 
....................  
....................     IF(DEBUG) { 
*
0DD0:  BTFSS  07.2
0DD1:  GOTO   5E3
....................         fputs(" > Rutina de prueba", RS232); 
0DD2:  MOVLW  92
0DD3:  BSF    03.6
0DD4:  MOVWF  0D
0DD5:  MOVLW  04
0DD6:  MOVWF  0F
0DD7:  BCF    0A.3
0DD8:  BCF    03.6
0DD9:  CALL   10F
0DDA:  BSF    0A.3
0DDB:  MOVLW  0D
0DDC:  BTFSS  0C.4
0DDD:  GOTO   5DC
0DDE:  MOVWF  19
0DDF:  MOVLW  0A
0DE0:  BTFSS  0C.4
0DE1:  GOTO   5E0
0DE2:  MOVWF  19
....................     } 
....................  
....................     IF(DEBUG) { 
0DE3:  BTFSS  07.2
0DE4:  GOTO   5F6
....................         fputs(" > Probando modulo tiempo", RS232); 
0DE5:  MOVLW  9C
0DE6:  BSF    03.6
0DE7:  MOVWF  0D
0DE8:  MOVLW  04
0DE9:  MOVWF  0F
0DEA:  BCF    0A.3
0DEB:  BCF    03.6
0DEC:  CALL   10F
0DED:  BSF    0A.3
0DEE:  MOVLW  0D
0DEF:  BTFSS  0C.4
0DF0:  GOTO   5EF
0DF1:  MOVWF  19
0DF2:  MOVLW  0A
0DF3:  BTFSS  0C.4
0DF4:  GOTO   5F3
0DF5:  MOVWF  19
....................     } 
....................     i2c_send(I2C_TIMER, I2C_CMD_TEST); 
0DF6:  MOVLW  0A
0DF7:  BSF    03.5
0DF8:  MOVWF  44
0DF9:  MOVLW  FF
0DFA:  MOVWF  45
0DFB:  BCF    0A.3
0DFC:  BCF    03.5
0DFD:  CALL   2B0
0DFE:  BSF    0A.3
....................  
....................     IF(DEBUG) { 
0DFF:  BTFSS  07.2
0E00:  GOTO   612
....................         fputs(" > Probando modulo puntos", RS232); 
0E01:  MOVLW  A9
0E02:  BSF    03.6
0E03:  MOVWF  0D
0E04:  MOVLW  04
0E05:  MOVWF  0F
0E06:  BCF    0A.3
0E07:  BCF    03.6
0E08:  CALL   10F
0E09:  BSF    0A.3
0E0A:  MOVLW  0D
0E0B:  BTFSS  0C.4
0E0C:  GOTO   60B
0E0D:  MOVWF  19
0E0E:  MOVLW  0A
0E0F:  BTFSS  0C.4
0E10:  GOTO   60F
0E11:  MOVWF  19
....................     } 
....................     i2c_send(I2C_SCORE, I2C_CMD_TEST); 
0E12:  MOVLW  0C
0E13:  BSF    03.5
0E14:  MOVWF  44
0E15:  MOVLW  FF
0E16:  MOVWF  45
0E17:  BCF    0A.3
0E18:  BCF    03.5
0E19:  CALL   2B0
0E1A:  BSF    0A.3
....................  
....................     IF(DEBUG) { 
0E1B:  BTFSS  07.2
0E1C:  GOTO   62E
....................         fputs(" > Probando modulo comunicaciones", RS232); 
0E1D:  MOVLW  B6
0E1E:  BSF    03.6
0E1F:  MOVWF  0D
0E20:  MOVLW  04
0E21:  MOVWF  0F
0E22:  BCF    0A.3
0E23:  BCF    03.6
0E24:  CALL   10F
0E25:  BSF    0A.3
0E26:  MOVLW  0D
0E27:  BTFSS  0C.4
0E28:  GOTO   627
0E29:  MOVWF  19
0E2A:  MOVLW  0A
0E2B:  BTFSS  0C.4
0E2C:  GOTO   62B
0E2D:  MOVWF  19
....................     } 
....................     for (INT i = 0; i < 10; i++) { 
0E2E:  BSF    03.5
0E2F:  CLRF   38
0E30:  MOVF   38,W
0E31:  SUBLW  09
0E32:  BTFSS  03.0
0E33:  GOTO   699
....................         showNumber(i, pNJugadorD); 
0E34:  MOVF   38,W
0E35:  MOVWF  39
0E36:  BCF    03.5
0E37:  MOVF   5D,W
0E38:  BSF    03.5
0E39:  MOVWF  3D
0E3A:  BCF    03.5
0E3B:  MOVF   5C,W
0E3C:  BSF    03.5
0E3D:  MOVWF  3C
0E3E:  BCF    03.5
0E3F:  MOVF   5B,W
0E40:  BSF    03.5
0E41:  MOVWF  3B
0E42:  BCF    03.5
0E43:  MOVF   5A,W
0E44:  BSF    03.5
0E45:  MOVWF  3A
0E46:  BCF    0A.3
0E47:  BCF    03.5
0E48:  CALL   1F5
0E49:  BSF    0A.3
....................         showNumber(i, pNJugadorU); 
0E4A:  BSF    03.5
0E4B:  MOVF   38,W
0E4C:  MOVWF  39
0E4D:  BCF    03.5
0E4E:  MOVF   59,W
0E4F:  BSF    03.5
0E50:  MOVWF  3D
0E51:  BCF    03.5
0E52:  MOVF   58,W
0E53:  BSF    03.5
0E54:  MOVWF  3C
0E55:  BCF    03.5
0E56:  MOVF   57,W
0E57:  BSF    03.5
0E58:  MOVWF  3B
0E59:  BCF    03.5
0E5A:  MOVF   56,W
0E5B:  BSF    03.5
0E5C:  MOVWF  3A
0E5D:  BCF    0A.3
0E5E:  BCF    03.5
0E5F:  CALL   1F5
0E60:  BSF    0A.3
....................         showNumber(i, pFJugadorD); 
0E61:  BSF    03.5
0E62:  MOVF   38,W
0E63:  MOVWF  39
0E64:  BCF    03.5
0E65:  MOVF   65,W
0E66:  BSF    03.5
0E67:  MOVWF  3D
0E68:  BCF    03.5
0E69:  MOVF   64,W
0E6A:  BSF    03.5
0E6B:  MOVWF  3C
0E6C:  BCF    03.5
0E6D:  MOVF   63,W
0E6E:  BSF    03.5
0E6F:  MOVWF  3B
0E70:  BCF    03.5
0E71:  MOVF   62,W
0E72:  BSF    03.5
0E73:  MOVWF  3A
0E74:  BCF    0A.3
0E75:  BCF    03.5
0E76:  CALL   1F5
0E77:  BSF    0A.3
....................         showNumber(i, pFJugadorU); 
0E78:  BSF    03.5
0E79:  MOVF   38,W
0E7A:  MOVWF  39
0E7B:  BCF    03.5
0E7C:  MOVF   61,W
0E7D:  BSF    03.5
0E7E:  MOVWF  3D
0E7F:  BCF    03.5
0E80:  MOVF   60,W
0E81:  BSF    03.5
0E82:  MOVWF  3C
0E83:  BCF    03.5
0E84:  MOVF   5F,W
0E85:  BSF    03.5
0E86:  MOVWF  3B
0E87:  BCF    03.5
0E88:  MOVF   5E,W
0E89:  BSF    03.5
0E8A:  MOVWF  3A
0E8B:  BCF    0A.3
0E8C:  BCF    03.5
0E8D:  CALL   1F5
0E8E:  BSF    0A.3
....................         delay_ms(I2CWAIT); 
0E8F:  MOVLW  32
0E90:  BSF    03.5
0E91:  MOVWF  40
0E92:  BCF    0A.3
0E93:  BCF    03.5
0E94:  CALL   2D2
0E95:  BSF    0A.3
0E96:  BSF    03.5
0E97:  INCF   38,F
0E98:  GOTO   630
....................     } 
.................... } 
....................  
.................... void doBuzz(INT t) { 
....................     i2c_start(); 
*
029B:  BSF    03.5
029C:  BSF    11.0
029D:  BTFSC  11.0
029E:  GOTO   29D
....................     i2c_write(I2C_TIMER); 
029F:  MOVLW  0A
02A0:  MOVWF  46
02A1:  BCF    03.5
02A2:  CALL   289
....................     i2c_write(0x80 + t); 
02A3:  MOVLW  80
02A4:  BSF    03.5
02A5:  ADDWF  38,W
02A6:  MOVWF  39
02A7:  MOVWF  46
02A8:  BCF    03.5
02A9:  CALL   289
....................     i2c_stop(); 
02AA:  BSF    03.5
02AB:  BSF    11.2
02AC:  BTFSC  11.2
02AD:  GOTO   2AC
02AE:  BCF    03.5
02AF:  RETURN
.................... } 
....................  
.................... void parseCommand(VOID) { 
....................     CHAR c[20]; 
....................     strcpy(c, cmd); 
*
0800:  BSF    03.5
0801:  CLRF   3B
0802:  MOVLW  2C
0803:  MOVWF  3A
0804:  CLRF   39
0805:  MOVLW  A4
0806:  MOVWF  38
0807:  MOVF   3A,W
0808:  MOVWF  04
0809:  BCF    03.7
080A:  BTFSC  3B.0
080B:  BSF    03.7
080C:  MOVF   00,W
080D:  MOVWF  3C
080E:  MOVF   38,W
080F:  MOVWF  04
0810:  BCF    03.7
0811:  BTFSC  39.0
0812:  BSF    03.7
0813:  MOVF   3C,W
0814:  MOVWF  00
0815:  MOVF   00,F
0816:  BTFSC  03.2
0817:  GOTO   01B
0818:  INCF   38,F
0819:  INCF   3A,F
081A:  GOTO   007
....................  
....................     SWITCH(c[0]) { 
081B:  MOVF   24,W
081C:  XORLW  30
081D:  BCF    03.5
081E:  BTFSC  03.2
081F:  GOTO   045
0820:  XORLW  72
0821:  BTFSC  03.2
0822:  GOTO   0E8
0823:  XORLW  04
0824:  BTFSC  03.2
0825:  GOTO   147
0826:  XORLW  0C
0827:  BTFSC  03.2
0828:  GOTO   199
0829:  XORLW  06
082A:  BTFSC  03.2
082B:  GOTO   1EB
082C:  XORLW  1C
082D:  BTFSC  03.2
082E:  GOTO   376
082F:  XORLW  01
0830:  BTFSC  03.2
0831:  GOTO   38A
0832:  XORLW  03
0833:  BTFSC  03.2
0834:  GOTO   39E
0835:  XORLW  04
0836:  BTFSC  03.2
0837:  GOTO   445
0838:  XORLW  0E
0839:  BTFSC  03.2
083A:  GOTO   5D0
083B:  XORLW  02
083C:  BTFSC  03.2
083D:  GOTO   69B
083E:  XORLW  09
083F:  BTFSC  03.2
0840:  GOTO   6D5
0841:  XORLW  07
0842:  BTFSC  03.2
0843:  GOTO   724
0844:  GOTO   7C0
....................         case '0': IF(DEBUG) 
0845:  BTFSS  07.2
0846:  GOTO   058
....................         { 
....................             fputs("\r > Activacion manual de puerto", RS232); 
0847:  MOVLW  C7
0848:  BSF    03.6
0849:  MOVWF  0D
084A:  MOVLW  04
084B:  MOVWF  0F
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   10F
084F:  BSF    0A.3
0850:  MOVLW  0D
0851:  BTFSS  0C.4
0852:  GOTO   051
0853:  MOVWF  19
0854:  MOVLW  0A
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
....................         } 
....................  
....................         SWITCH(c[2]) { 
0858:  MOVLW  31
0859:  BSF    03.5
085A:  SUBWF  26,W
085B:  ADDLW  FC
085C:  BTFSC  03.0
085D:  GOTO   0E6
085E:  ADDLW  04
085F:  BCF    03.5
0860:  GOTO   7C3
....................             CASE '1' : showNumber(char2int(c[3]), pNJugadorD); 
0861:  BSF    03.5
0862:  MOVF   27,W
0863:  MOVWF  3B
0864:  BCF    0A.3
0865:  BCF    03.5
0866:  CALL   185
0867:  BSF    0A.3
0868:  MOVF   78,W
0869:  BSF    03.5
086A:  MOVWF  38
086B:  MOVWF  39
086C:  BCF    03.5
086D:  MOVF   5D,W
086E:  BSF    03.5
086F:  MOVWF  3D
0870:  BCF    03.5
0871:  MOVF   5C,W
0872:  BSF    03.5
0873:  MOVWF  3C
0874:  BCF    03.5
0875:  MOVF   5B,W
0876:  BSF    03.5
0877:  MOVWF  3B
0878:  BCF    03.5
0879:  MOVF   5A,W
087A:  BSF    03.5
087B:  MOVWF  3A
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   1F5
087F:  BSF    0A.3
....................             BREAK; 
0880:  BSF    03.5
0881:  GOTO   0E6
....................             CASE '2' : showNumber(char2int(c[3]), pNJugadorU); 
0882:  BSF    03.5
0883:  MOVF   27,W
0884:  MOVWF  3B
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   185
0888:  BSF    0A.3
0889:  MOVF   78,W
088A:  BSF    03.5
088B:  MOVWF  38
088C:  MOVWF  39
088D:  BCF    03.5
088E:  MOVF   59,W
088F:  BSF    03.5
0890:  MOVWF  3D
0891:  BCF    03.5
0892:  MOVF   58,W
0893:  BSF    03.5
0894:  MOVWF  3C
0895:  BCF    03.5
0896:  MOVF   57,W
0897:  BSF    03.5
0898:  MOVWF  3B
0899:  BCF    03.5
089A:  MOVF   56,W
089B:  BSF    03.5
089C:  MOVWF  3A
089D:  BCF    0A.3
089E:  BCF    03.5
089F:  CALL   1F5
08A0:  BSF    0A.3
....................             BREAK; 
08A1:  BSF    03.5
08A2:  GOTO   0E6
....................             CASE '3' : showNumber(char2int(c[3]), pFJugadorD); 
08A3:  BSF    03.5
08A4:  MOVF   27,W
08A5:  MOVWF  3B
08A6:  BCF    0A.3
08A7:  BCF    03.5
08A8:  CALL   185
08A9:  BSF    0A.3
08AA:  MOVF   78,W
08AB:  BSF    03.5
08AC:  MOVWF  38
08AD:  MOVWF  39
08AE:  BCF    03.5
08AF:  MOVF   65,W
08B0:  BSF    03.5
08B1:  MOVWF  3D
08B2:  BCF    03.5
08B3:  MOVF   64,W
08B4:  BSF    03.5
08B5:  MOVWF  3C
08B6:  BCF    03.5
08B7:  MOVF   63,W
08B8:  BSF    03.5
08B9:  MOVWF  3B
08BA:  BCF    03.5
08BB:  MOVF   62,W
08BC:  BSF    03.5
08BD:  MOVWF  3A
08BE:  BCF    0A.3
08BF:  BCF    03.5
08C0:  CALL   1F5
08C1:  BSF    0A.3
....................             BREAK; 
08C2:  BSF    03.5
08C3:  GOTO   0E6
....................             CASE '4' : showNumber(char2int(c[3]), pFJugadorU); 
08C4:  BSF    03.5
08C5:  MOVF   27,W
08C6:  MOVWF  3B
08C7:  BCF    0A.3
08C8:  BCF    03.5
08C9:  CALL   185
08CA:  BSF    0A.3
08CB:  MOVF   78,W
08CC:  BSF    03.5
08CD:  MOVWF  38
08CE:  MOVWF  39
08CF:  BCF    03.5
08D0:  MOVF   61,W
08D1:  BSF    03.5
08D2:  MOVWF  3D
08D3:  BCF    03.5
08D4:  MOVF   60,W
08D5:  BSF    03.5
08D6:  MOVWF  3C
08D7:  BCF    03.5
08D8:  MOVF   5F,W
08D9:  BSF    03.5
08DA:  MOVWF  3B
08DB:  BCF    03.5
08DC:  MOVF   5E,W
08DD:  BSF    03.5
08DE:  MOVWF  3A
08DF:  BCF    0A.3
08E0:  BCF    03.5
08E1:  CALL   1F5
08E2:  BSF    0A.3
....................             BREAK; 
08E3:  BSF    03.5
08E4:  GOTO   0E6
08E5:  BSF    03.5
....................         } 
....................  
....................         BREAK; 
08E6:  BCF    03.5
08E7:  GOTO   7C0
....................  
....................         case 'B': SWITCH(c[1]) 
08E8:  BSF    03.5
08E9:  MOVF   25,W
08EA:  XORLW  31
08EB:  BCF    03.5
08EC:  BTFSC  03.2
08ED:  GOTO   0F5
08EE:  XORLW  03
08EF:  BTFSC  03.2
08F0:  GOTO   110
08F1:  XORLW  01
08F2:  BTFSC  03.2
08F3:  GOTO   12B
08F4:  GOTO   146
....................         { 
....................             case '1': IF(DEBUG) 
08F5:  BTFSS  07.2
08F6:  GOTO   108
....................             { 
....................                 fputs("\r > Toque corto", RS232); 
08F7:  MOVLW  D7
08F8:  BSF    03.6
08F9:  MOVWF  0D
08FA:  MOVLW  04
08FB:  MOVWF  0F
08FC:  BCF    0A.3
08FD:  BCF    03.6
08FE:  CALL   10F
08FF:  BSF    0A.3
0900:  MOVLW  0D
0901:  BTFSS  0C.4
0902:  GOTO   101
0903:  MOVWF  19
0904:  MOVLW  0A
0905:  BTFSS  0C.4
0906:  GOTO   105
0907:  MOVWF  19
....................             } 
....................             doBuzz(1); 
0908:  MOVLW  01
0909:  BSF    03.5
090A:  MOVWF  38
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   29B
090E:  BSF    0A.3
....................             BREAK; 
090F:  GOTO   146
....................             case '2': IF(DEBUG) 
0910:  BTFSS  07.2
0911:  GOTO   123
....................             { 
....................                 fputs("\r > Toque largo", RS232); 
0912:  MOVLW  DF
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  04
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   10F
091A:  BSF    0A.3
091B:  MOVLW  0D
091C:  BTFSS  0C.4
091D:  GOTO   11C
091E:  MOVWF  19
091F:  MOVLW  0A
0920:  BTFSS  0C.4
0921:  GOTO   120
0922:  MOVWF  19
....................             } 
....................             doBuzz(2); 
0923:  MOVLW  02
0924:  BSF    03.5
0925:  MOVWF  38
0926:  BCF    0A.3
0927:  BCF    03.5
0928:  CALL   29B
0929:  BSF    0A.3
....................             BREAK; 
092A:  GOTO   146
....................             case '3': IF(DEBUG) 
092B:  BTFSS  07.2
092C:  GOTO   13E
....................             { 
....................                 fputs("\r > Toque doble", RS232); 
092D:  MOVLW  E7
092E:  BSF    03.6
092F:  MOVWF  0D
0930:  MOVLW  04
0931:  MOVWF  0F
0932:  BCF    0A.3
0933:  BCF    03.6
0934:  CALL   10F
0935:  BSF    0A.3
0936:  MOVLW  0D
0937:  BTFSS  0C.4
0938:  GOTO   137
0939:  MOVWF  19
093A:  MOVLW  0A
093B:  BTFSS  0C.4
093C:  GOTO   13B
093D:  MOVWF  19
....................             } 
....................             doBuzz(3); 
093E:  MOVLW  03
093F:  BSF    03.5
0940:  MOVWF  38
0941:  BCF    0A.3
0942:  BCF    03.5
0943:  CALL   29B
0944:  BSF    0A.3
....................             BREAK; 
0945:  GOTO   146
....................         } 
....................  
....................         BREAK; 
0946:  GOTO   7C0
....................         case 'F': IF(DEBUG) 
0947:  BTFSS  07.2
0948:  GOTO   15A
....................         { 
....................             fputs("\r > Asignar faltas", RS232); 
0949:  MOVLW  EF
094A:  BSF    03.6
094B:  MOVWF  0D
094C:  MOVLW  04
094D:  MOVWF  0F
094E:  BCF    0A.3
094F:  BCF    03.6
0950:  CALL   10F
0951:  BSF    0A.3
0952:  MOVLW  0D
0953:  BTFSS  0C.4
0954:  GOTO   153
0955:  MOVWF  19
0956:  MOVLW  0A
0957:  BTFSS  0C.4
0958:  GOTO   157
0959:  MOVWF  19
....................         } 
....................         showNumber(char2int(c[1]), pFJugadorD); 
095A:  BSF    03.5
095B:  MOVF   25,W
095C:  MOVWF  3B
095D:  BCF    0A.3
095E:  BCF    03.5
095F:  CALL   185
0960:  BSF    0A.3
0961:  MOVF   78,W
0962:  BSF    03.5
0963:  MOVWF  38
0964:  MOVWF  39
0965:  BCF    03.5
0966:  MOVF   65,W
0967:  BSF    03.5
0968:  MOVWF  3D
0969:  BCF    03.5
096A:  MOVF   64,W
096B:  BSF    03.5
096C:  MOVWF  3C
096D:  BCF    03.5
096E:  MOVF   63,W
096F:  BSF    03.5
0970:  MOVWF  3B
0971:  BCF    03.5
0972:  MOVF   62,W
0973:  BSF    03.5
0974:  MOVWF  3A
0975:  BCF    0A.3
0976:  BCF    03.5
0977:  CALL   1F5
0978:  BSF    0A.3
....................         showNumber(char2int(c[2]), pFJugadorU); 
0979:  BSF    03.5
097A:  MOVF   26,W
097B:  MOVWF  3B
097C:  BCF    0A.3
097D:  BCF    03.5
097E:  CALL   185
097F:  BSF    0A.3
0980:  MOVF   78,W
0981:  BSF    03.5
0982:  MOVWF  38
0983:  MOVWF  39
0984:  BCF    03.5
0985:  MOVF   61,W
0986:  BSF    03.5
0987:  MOVWF  3D
0988:  BCF    03.5
0989:  MOVF   60,W
098A:  BSF    03.5
098B:  MOVWF  3C
098C:  BCF    03.5
098D:  MOVF   5F,W
098E:  BSF    03.5
098F:  MOVWF  3B
0990:  BCF    03.5
0991:  MOVF   5E,W
0992:  BSF    03.5
0993:  MOVWF  3A
0994:  BCF    0A.3
0995:  BCF    03.5
0996:  CALL   1F5
0997:  BSF    0A.3
....................         BREAK; 
0998:  GOTO   7C0
....................         case 'J': IF(DEBUG) 
0999:  BTFSS  07.2
099A:  GOTO   1AC
....................         { 
....................             fputs("\r > Asignar jugador", RS232); 
099B:  MOVLW  F9
099C:  BSF    03.6
099D:  MOVWF  0D
099E:  MOVLW  04
099F:  MOVWF  0F
09A0:  BCF    0A.3
09A1:  BCF    03.6
09A2:  CALL   10F
09A3:  BSF    0A.3
09A4:  MOVLW  0D
09A5:  BTFSS  0C.4
09A6:  GOTO   1A5
09A7:  MOVWF  19
09A8:  MOVLW  0A
09A9:  BTFSS  0C.4
09AA:  GOTO   1A9
09AB:  MOVWF  19
....................         } 
....................         showNumber(char2int(c[1]), pNJugadorD); 
09AC:  BSF    03.5
09AD:  MOVF   25,W
09AE:  MOVWF  3B
09AF:  BCF    0A.3
09B0:  BCF    03.5
09B1:  CALL   185
09B2:  BSF    0A.3
09B3:  MOVF   78,W
09B4:  BSF    03.5
09B5:  MOVWF  38
09B6:  MOVWF  39
09B7:  BCF    03.5
09B8:  MOVF   5D,W
09B9:  BSF    03.5
09BA:  MOVWF  3D
09BB:  BCF    03.5
09BC:  MOVF   5C,W
09BD:  BSF    03.5
09BE:  MOVWF  3C
09BF:  BCF    03.5
09C0:  MOVF   5B,W
09C1:  BSF    03.5
09C2:  MOVWF  3B
09C3:  BCF    03.5
09C4:  MOVF   5A,W
09C5:  BSF    03.5
09C6:  MOVWF  3A
09C7:  BCF    0A.3
09C8:  BCF    03.5
09C9:  CALL   1F5
09CA:  BSF    0A.3
....................         showNumber(char2int(c[2]), pNJugadorU); 
09CB:  BSF    03.5
09CC:  MOVF   26,W
09CD:  MOVWF  3B
09CE:  BCF    0A.3
09CF:  BCF    03.5
09D0:  CALL   185
09D1:  BSF    0A.3
09D2:  MOVF   78,W
09D3:  BSF    03.5
09D4:  MOVWF  38
09D5:  MOVWF  39
09D6:  BCF    03.5
09D7:  MOVF   59,W
09D8:  BSF    03.5
09D9:  MOVWF  3D
09DA:  BCF    03.5
09DB:  MOVF   58,W
09DC:  BSF    03.5
09DD:  MOVWF  3C
09DE:  BCF    03.5
09DF:  MOVF   57,W
09E0:  BSF    03.5
09E1:  MOVWF  3B
09E2:  BCF    03.5
09E3:  MOVF   56,W
09E4:  BSF    03.5
09E5:  MOVWF  3A
09E6:  BCF    0A.3
09E7:  BCF    03.5
09E8:  CALL   1F5
09E9:  BSF    0A.3
....................         BREAK; 
09EA:  GOTO   7C0
....................         case 'L': 
....................         SWITCH(c[1]) 
09EB:  BSF    03.5
09EC:  MOVF   25,W
09ED:  XORLW  30
09EE:  BCF    03.5
09EF:  BTFSC  03.2
09F0:  GOTO   207
09F1:  XORLW  01
09F2:  BTFSC  03.2
09F3:  GOTO   223
09F4:  XORLW  03
09F5:  BTFSC  03.2
09F6:  GOTO   23E
09F7:  XORLW  01
09F8:  BTFSC  03.2
09F9:  GOTO   259
09FA:  XORLW  77
09FB:  BTFSC  03.2
09FC:  GOTO   274
09FD:  XORLW  02
09FE:  BTFSC  03.2
09FF:  GOTO   2F7
0A00:  XORLW  0F
0A01:  BTFSC  03.2
0A02:  GOTO   31E
0A03:  XORLW  19
0A04:  BTFSC  03.2
0A05:  GOTO   358
0A06:  GOTO   375
....................         { 
....................             case '0': IF(DEBUG) 
0A07:  BTFSS  07.2
0A08:  GOTO   21A
....................             { 
....................                 fputs("\r > Resetea a 0", RS232); 
0A09:  MOVLW  03
0A0A:  BSF    03.6
0A0B:  MOVWF  0D
0A0C:  MOVLW  05
0A0D:  MOVWF  0F
0A0E:  BCF    0A.3
0A0F:  BCF    03.6
0A10:  CALL   10F
0A11:  BSF    0A.3
0A12:  MOVLW  0D
0A13:  BTFSS  0C.4
0A14:  GOTO   213
0A15:  MOVWF  19
0A16:  MOVLW  0A
0A17:  BTFSS  0C.4
0A18:  GOTO   217
0A19:  MOVWF  19
....................             } 
....................             setScoreL(0, 0, 0); 
0A1A:  BSF    03.5
0A1B:  CLRF   3B
0A1C:  CLRF   3C
0A1D:  CLRF   3D
0A1E:  BCF    0A.3
0A1F:  BCF    03.5
0A20:  CALL   2E6
0A21:  BSF    0A.3
....................             BREAK; 
0A22:  GOTO   375
....................             case '1': IF(DEBUG) 
0A23:  BTFSS  07.2
0A24:  GOTO   236
....................             { 
....................                 fputs("\r > Incrementar por 1", RS232); 
0A25:  MOVLW  0B
0A26:  BSF    03.6
0A27:  MOVWF  0D
0A28:  MOVLW  05
0A29:  MOVWF  0F
0A2A:  BCF    0A.3
0A2B:  BCF    03.6
0A2C:  CALL   10F
0A2D:  BSF    0A.3
0A2E:  MOVLW  0D
0A2F:  BTFSS  0C.4
0A30:  GOTO   22F
0A31:  MOVWF  19
0A32:  MOVLW  0A
0A33:  BTFSS  0C.4
0A34:  GOTO   233
0A35:  MOVWF  19
....................             } 
....................             addScoreL(1); 
0A36:  MOVLW  01
0A37:  BSF    03.5
0A38:  MOVWF  38
0A39:  BCF    0A.3
0A3A:  BCF    03.5
0A3B:  CALL   326
0A3C:  BSF    0A.3
....................             BREAK; 
0A3D:  GOTO   375
....................             case '2': IF(DEBUG) 
0A3E:  BTFSS  07.2
0A3F:  GOTO   251
....................             { 
....................                 fputs("\r > Incrementar por 2", RS232); 
0A40:  MOVLW  16
0A41:  BSF    03.6
0A42:  MOVWF  0D
0A43:  MOVLW  05
0A44:  MOVWF  0F
0A45:  BCF    0A.3
0A46:  BCF    03.6
0A47:  CALL   10F
0A48:  BSF    0A.3
0A49:  MOVLW  0D
0A4A:  BTFSS  0C.4
0A4B:  GOTO   24A
0A4C:  MOVWF  19
0A4D:  MOVLW  0A
0A4E:  BTFSS  0C.4
0A4F:  GOTO   24E
0A50:  MOVWF  19
....................             } 
....................             addScoreL(2); 
0A51:  MOVLW  02
0A52:  BSF    03.5
0A53:  MOVWF  38
0A54:  BCF    0A.3
0A55:  BCF    03.5
0A56:  CALL   326
0A57:  BSF    0A.3
....................             BREAK; 
0A58:  GOTO   375
....................             case '3': IF(DEBUG) 
0A59:  BTFSS  07.2
0A5A:  GOTO   26C
....................             { 
....................                 fputs("\r > Incrementar por 3", RS232); 
0A5B:  MOVLW  21
0A5C:  BSF    03.6
0A5D:  MOVWF  0D
0A5E:  MOVLW  05
0A5F:  MOVWF  0F
0A60:  BCF    0A.3
0A61:  BCF    03.6
0A62:  CALL   10F
0A63:  BSF    0A.3
0A64:  MOVLW  0D
0A65:  BTFSS  0C.4
0A66:  GOTO   265
0A67:  MOVWF  19
0A68:  MOVLW  0A
0A69:  BTFSS  0C.4
0A6A:  GOTO   269
0A6B:  MOVWF  19
....................             } 
....................             addScoreL(3); 
0A6C:  MOVLW  03
0A6D:  BSF    03.5
0A6E:  MOVWF  38
0A6F:  BCF    0A.3
0A70:  BCF    03.5
0A71:  CALL   326
0A72:  BSF    0A.3
....................             BREAK; 
0A73:  GOTO   375
....................             case 'D': IF(DEBUG) 
0A74:  BTFSS  07.2
0A75:  GOTO   287
....................             { 
....................                 fputs("\r > Decrementar por 1", RS232); 
0A76:  MOVLW  2C
0A77:  BSF    03.6
0A78:  MOVWF  0D
0A79:  MOVLW  05
0A7A:  MOVWF  0F
0A7B:  BCF    0A.3
0A7C:  BCF    03.6
0A7D:  CALL   10F
0A7E:  BSF    0A.3
0A7F:  MOVLW  0D
0A80:  BTFSS  0C.4
0A81:  GOTO   280
0A82:  MOVWF  19
0A83:  MOVLW  0A
0A84:  BTFSS  0C.4
0A85:  GOTO   284
0A86:  MOVWF  19
....................             } 
....................             resScoreL(); 
....................             BREAK; 
*
0AF6:  GOTO   375
....................             case 'F': IF(DEBUG) 
0AF7:  BTFSS  07.2
0AF8:  GOTO   30A
....................             { 
....................                 fputs("\r > Asignar faltas", RS232); 
0AF9:  MOVLW  37
0AFA:  BSF    03.6
0AFB:  MOVWF  0D
0AFC:  MOVLW  05
0AFD:  MOVWF  0F
0AFE:  BCF    0A.3
0AFF:  BCF    03.6
0B00:  CALL   10F
0B01:  BSF    0A.3
0B02:  MOVLW  0D
0B03:  BTFSS  0C.4
0B04:  GOTO   303
0B05:  MOVWF  19
0B06:  MOVLW  0A
0B07:  BTFSS  0C.4
0B08:  GOTO   307
0B09:  MOVWF  19
....................             } 
....................             sendN2Port(char2int(c[2]), I2C_SCORE, PuertoE); 
0B0A:  BSF    03.5
0B0B:  MOVF   26,W
0B0C:  MOVWF  3B
0B0D:  BCF    0A.3
0B0E:  BCF    03.5
0B0F:  CALL   185
0B10:  BSF    0A.3
0B11:  MOVF   78,W
0B12:  BSF    03.5
0B13:  MOVWF  38
0B14:  MOVWF  40
0B15:  MOVLW  0C
0B16:  MOVWF  41
0B17:  MOVLW  05
0B18:  MOVWF  42
0B19:  BCF    0A.3
0B1A:  BCF    03.5
0B1B:  CALL   2C3
0B1C:  BSF    0A.3
....................             BREAK; 
0B1D:  GOTO   375
....................             case 'I': IF(DEBUG) 
0B1E:  BTFSS  07.2
0B1F:  GOTO   331
....................             { 
....................                 fputs("\r > Inicializar", RS232); 
0B20:  MOVLW  41
0B21:  BSF    03.6
0B22:  MOVWF  0D
0B23:  MOVLW  05
0B24:  MOVWF  0F
0B25:  BCF    0A.3
0B26:  BCF    03.6
0B27:  CALL   10F
0B28:  BSF    0A.3
0B29:  MOVLW  0D
0B2A:  BTFSS  0C.4
0B2B:  GOTO   32A
0B2C:  MOVWF  19
0B2D:  MOVLW  0A
0B2E:  BTFSS  0C.4
0B2F:  GOTO   32E
0B30:  MOVWF  19
....................             } 
....................             setScoreL(char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0B31:  BSF    03.5
0B32:  MOVF   26,W
0B33:  MOVWF  3B
0B34:  BCF    0A.3
0B35:  BCF    03.5
0B36:  CALL   185
0B37:  BSF    0A.3
0B38:  MOVF   78,W
0B39:  BSF    03.5
0B3A:  MOVWF  38
0B3B:  MOVF   27,W
0B3C:  MOVWF  3B
0B3D:  BCF    0A.3
0B3E:  BCF    03.5
0B3F:  CALL   185
0B40:  BSF    0A.3
0B41:  MOVF   78,W
0B42:  BSF    03.5
0B43:  MOVWF  39
0B44:  MOVF   28,W
0B45:  MOVWF  3B
0B46:  BCF    0A.3
0B47:  BCF    03.5
0B48:  CALL   185
0B49:  BSF    0A.3
0B4A:  MOVF   78,W
0B4B:  BSF    03.5
0B4C:  MOVWF  3A
0B4D:  MOVF   38,W
0B4E:  MOVWF  3B
0B4F:  MOVF   39,W
0B50:  MOVWF  3C
0B51:  MOVF   3A,W
0B52:  MOVWF  3D
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   2E6
0B56:  BSF    0A.3
....................             BREAK; 
0B57:  GOTO   375
....................             case 'P': IF(DEBUG) 
0B58:  BTFSS  07.2
0B59:  GOTO   36B
....................             { 
....................                 fputs("\r > Asignar posicion", RS232); 
0B5A:  MOVLW  49
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  05
0B5E:  MOVWF  0F
0B5F:  BCF    0A.3
0B60:  BCF    03.6
0B61:  CALL   10F
0B62:  BSF    0A.3
0B63:  MOVLW  0D
0B64:  BTFSS  0C.4
0B65:  GOTO   364
0B66:  MOVWF  19
0B67:  MOVLW  0A
0B68:  BTFSS  0C.4
0B69:  GOTO   368
0B6A:  MOVWF  19
....................             } 
....................             i2c_send(I2C_SCORE, I2C_CMD_POSL); 
0B6B:  MOVLW  0C
0B6C:  BSF    03.5
0B6D:  MOVWF  44
0B6E:  MOVLW  71
0B6F:  MOVWF  45
0B70:  BCF    0A.3
0B71:  BCF    03.5
0B72:  CALL   2B0
0B73:  BSF    0A.3
....................             BREAK; 
0B74:  GOTO   375
....................         } 
....................         BREAK; 
0B75:  GOTO   7C0
....................         case 'P': IF(DEBUG) 
0B76:  BTFSS  07.2
0B77:  GOTO   389
....................         { 
....................             fputs("\r > Pausar tiempo", RS232); 
0B78:  MOVLW  54
0B79:  BSF    03.6
0B7A:  MOVWF  0D
0B7B:  MOVLW  05
0B7C:  MOVWF  0F
0B7D:  BCF    0A.3
0B7E:  BCF    03.6
0B7F:  CALL   10F
0B80:  BSF    0A.3
0B81:  MOVLW  0D
0B82:  BTFSS  0C.4
0B83:  GOTO   382
0B84:  MOVWF  19
0B85:  MOVLW  0A
0B86:  BTFSS  0C.4
0B87:  GOTO   386
0B88:  MOVWF  19
....................         } 
....................         BREAK; 
0B89:  GOTO   7C0
....................         case 'Q': IF(DEBUG) 
0B8A:  BTFSS  07.2
0B8B:  GOTO   39D
....................         { 
....................             fputs("\r > Renudar tiempo", RS232); 
0B8C:  MOVLW  5D
0B8D:  BSF    03.6
0B8E:  MOVWF  0D
0B8F:  MOVLW  05
0B90:  MOVWF  0F
0B91:  BCF    0A.3
0B92:  BCF    03.6
0B93:  CALL   10F
0B94:  BSF    0A.3
0B95:  MOVLW  0D
0B96:  BTFSS  0C.4
0B97:  GOTO   396
0B98:  MOVWF  19
0B99:  MOVLW  0A
0B9A:  BTFSS  0C.4
0B9B:  GOTO   39A
0B9C:  MOVWF  19
....................         } 
....................         BREAK; 
0B9D:  GOTO   7C0
....................  
....................         CASE 'R' : 
....................                 SWITCH(c[1]) { 
0B9E:  MOVLW  30
0B9F:  BSF    03.5
0BA0:  SUBWF  25,W
0BA1:  ADDLW  FB
0BA2:  BTFSC  03.0
0BA3:  GOTO   43E
0BA4:  ADDLW  05
0BA5:  BCF    03.5
0BA6:  GOTO   7CB
....................             case '0': IF(DEBUG) 
0BA7:  BTFSS  07.2
0BA8:  GOTO   3BA
....................             { 
....................                 fputs("\r > Apagar Periodos", RS232); 
0BA9:  MOVLW  67
0BAA:  BSF    03.6
0BAB:  MOVWF  0D
0BAC:  MOVLW  05
0BAD:  MOVWF  0F
0BAE:  BCF    0A.3
0BAF:  BCF    03.6
0BB0:  CALL   10F
0BB1:  BSF    0A.3
0BB2:  MOVLW  0D
0BB3:  BTFSS  0C.4
0BB4:  GOTO   3B3
0BB5:  MOVWF  19
0BB6:  MOVLW  0A
0BB7:  BTFSS  0C.4
0BB8:  GOTO   3B7
0BB9:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER0); 
0BBA:  MOVLW  0A
0BBB:  BSF    03.5
0BBC:  MOVWF  44
0BBD:  MOVLW  70
0BBE:  MOVWF  45
0BBF:  BCF    0A.3
0BC0:  BCF    03.5
0BC1:  CALL   2B0
0BC2:  BSF    0A.3
....................             BREAK; 
0BC3:  BSF    03.5
0BC4:  GOTO   43E
....................             case '1': IF(DEBUG) 
0BC5:  BTFSS  07.2
0BC6:  GOTO   3D8
....................             { 
....................                 fputs("\r > Periodo 1", RS232); 
0BC7:  MOVLW  71
0BC8:  BSF    03.6
0BC9:  MOVWF  0D
0BCA:  MOVLW  05
0BCB:  MOVWF  0F
0BCC:  BCF    0A.3
0BCD:  BCF    03.6
0BCE:  CALL   10F
0BCF:  BSF    0A.3
0BD0:  MOVLW  0D
0BD1:  BTFSS  0C.4
0BD2:  GOTO   3D1
0BD3:  MOVWF  19
0BD4:  MOVLW  0A
0BD5:  BTFSS  0C.4
0BD6:  GOTO   3D5
0BD7:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER1); 
0BD8:  MOVLW  0A
0BD9:  BSF    03.5
0BDA:  MOVWF  44
0BDB:  MOVLW  71
0BDC:  MOVWF  45
0BDD:  BCF    0A.3
0BDE:  BCF    03.5
0BDF:  CALL   2B0
0BE0:  BSF    0A.3
....................             BREAK; 
0BE1:  BSF    03.5
0BE2:  GOTO   43E
....................             case '2': IF(DEBUG) 
0BE3:  BTFSS  07.2
0BE4:  GOTO   3F6
....................             { 
....................                 fputs("\r > Periodo 2", RS232); 
0BE5:  MOVLW  78
0BE6:  BSF    03.6
0BE7:  MOVWF  0D
0BE8:  MOVLW  05
0BE9:  MOVWF  0F
0BEA:  BCF    0A.3
0BEB:  BCF    03.6
0BEC:  CALL   10F
0BED:  BSF    0A.3
0BEE:  MOVLW  0D
0BEF:  BTFSS  0C.4
0BF0:  GOTO   3EF
0BF1:  MOVWF  19
0BF2:  MOVLW  0A
0BF3:  BTFSS  0C.4
0BF4:  GOTO   3F3
0BF5:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER2); 
0BF6:  MOVLW  0A
0BF7:  BSF    03.5
0BF8:  MOVWF  44
0BF9:  MOVLW  72
0BFA:  MOVWF  45
0BFB:  BCF    0A.3
0BFC:  BCF    03.5
0BFD:  CALL   2B0
0BFE:  BSF    0A.3
....................             BREAK; 
0BFF:  BSF    03.5
0C00:  GOTO   43E
....................             case '3': IF(DEBUG) 
0C01:  BTFSS  07.2
0C02:  GOTO   414
....................             { 
....................                 fputs("\r > Periodo 3", RS232); 
0C03:  MOVLW  7F
0C04:  BSF    03.6
0C05:  MOVWF  0D
0C06:  MOVLW  05
0C07:  MOVWF  0F
0C08:  BCF    0A.3
0C09:  BCF    03.6
0C0A:  CALL   10F
0C0B:  BSF    0A.3
0C0C:  MOVLW  0D
0C0D:  BTFSS  0C.4
0C0E:  GOTO   40D
0C0F:  MOVWF  19
0C10:  MOVLW  0A
0C11:  BTFSS  0C.4
0C12:  GOTO   411
0C13:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER3); 
0C14:  MOVLW  0A
0C15:  BSF    03.5
0C16:  MOVWF  44
0C17:  MOVLW  73
0C18:  MOVWF  45
0C19:  BCF    0A.3
0C1A:  BCF    03.5
0C1B:  CALL   2B0
0C1C:  BSF    0A.3
....................             BREAK; 
0C1D:  BSF    03.5
0C1E:  GOTO   43E
....................             case '4': IF(DEBUG) 
0C1F:  BTFSS  07.2
0C20:  GOTO   432
....................             { 
....................                 fputs("\r > Periodo 4", RS232); 
0C21:  MOVLW  86
0C22:  BSF    03.6
0C23:  MOVWF  0D
0C24:  MOVLW  05
0C25:  MOVWF  0F
0C26:  BCF    0A.3
0C27:  BCF    03.6
0C28:  CALL   10F
0C29:  BSF    0A.3
0C2A:  MOVLW  0D
0C2B:  BTFSS  0C.4
0C2C:  GOTO   42B
0C2D:  MOVWF  19
0C2E:  MOVLW  0A
0C2F:  BTFSS  0C.4
0C30:  GOTO   42F
0C31:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER4); 
0C32:  MOVLW  0A
0C33:  BSF    03.5
0C34:  MOVWF  44
0C35:  MOVLW  74
0C36:  MOVWF  45
0C37:  BCF    0A.3
0C38:  BCF    03.5
0C39:  CALL   2B0
0C3A:  BSF    0A.3
....................             BREAK; 
0C3B:  BSF    03.5
0C3C:  GOTO   43E
0C3D:  BSF    03.5
....................         } 
....................         delay_ms(I2CWAIT); 
0C3E:  MOVLW  32
0C3F:  MOVWF  40
0C40:  BCF    0A.3
0C41:  BCF    03.5
0C42:  CALL   2D2
0C43:  BSF    0A.3
....................         BREAK; 
0C44:  GOTO   7C0
....................         case 'V': 
....................         SWITCH(c[1]) 
0C45:  BSF    03.5
0C46:  MOVF   25,W
0C47:  XORLW  30
0C48:  BCF    03.5
0C49:  BTFSC  03.2
0C4A:  GOTO   461
0C4B:  XORLW  01
0C4C:  BTFSC  03.2
0C4D:  GOTO   47D
0C4E:  XORLW  03
0C4F:  BTFSC  03.2
0C50:  GOTO   498
0C51:  XORLW  01
0C52:  BTFSC  03.2
0C53:  GOTO   4B3
0C54:  XORLW  77
0C55:  BTFSC  03.2
0C56:  GOTO   4CE
0C57:  XORLW  02
0C58:  BTFSC  03.2
0C59:  GOTO   551
0C5A:  XORLW  0F
0C5B:  BTFSC  03.2
0C5C:  GOTO   578
0C5D:  XORLW  19
0C5E:  BTFSC  03.2
0C5F:  GOTO   5B2
0C60:  GOTO   5CF
....................         { 
....................             case '0': IF(DEBUG) 
0C61:  BTFSS  07.2
0C62:  GOTO   474
....................             { 
....................                 fputs("\r > Resetea a 0", RS232); 
0C63:  MOVLW  8D
0C64:  BSF    03.6
0C65:  MOVWF  0D
0C66:  MOVLW  05
0C67:  MOVWF  0F
0C68:  BCF    0A.3
0C69:  BCF    03.6
0C6A:  CALL   10F
0C6B:  BSF    0A.3
0C6C:  MOVLW  0D
0C6D:  BTFSS  0C.4
0C6E:  GOTO   46D
0C6F:  MOVWF  19
0C70:  MOVLW  0A
0C71:  BTFSS  0C.4
0C72:  GOTO   471
0C73:  MOVWF  19
....................             } 
....................             setScoreV(0, 0, 0); 
0C74:  BSF    03.5
0C75:  CLRF   3B
0C76:  CLRF   3C
0C77:  CLRF   3D
0C78:  BCF    0A.3
0C79:  BCF    03.5
0C7A:  CALL   38A
0C7B:  BSF    0A.3
....................             BREAK; 
0C7C:  GOTO   5CF
....................             case '1': IF(DEBUG) 
0C7D:  BTFSS  07.2
0C7E:  GOTO   490
....................             { 
....................                 fputs("\r > Incrementar por 1", RS232); 
0C7F:  MOVLW  95
0C80:  BSF    03.6
0C81:  MOVWF  0D
0C82:  MOVLW  05
0C83:  MOVWF  0F
0C84:  BCF    0A.3
0C85:  BCF    03.6
0C86:  CALL   10F
0C87:  BSF    0A.3
0C88:  MOVLW  0D
0C89:  BTFSS  0C.4
0C8A:  GOTO   489
0C8B:  MOVWF  19
0C8C:  MOVLW  0A
0C8D:  BTFSS  0C.4
0C8E:  GOTO   48D
0C8F:  MOVWF  19
....................             } 
....................             addScoreV(1); 
0C90:  MOVLW  01
0C91:  BSF    03.5
0C92:  MOVWF  38
0C93:  BCF    0A.3
0C94:  BCF    03.5
0C95:  CALL   3CA
0C96:  BSF    0A.3
....................             BREAK; 
0C97:  GOTO   5CF
....................             case '2': IF(DEBUG) 
0C98:  BTFSS  07.2
0C99:  GOTO   4AB
....................             { 
....................                 fputs("\r > Incrementar por 2", RS232); 
0C9A:  MOVLW  A0
0C9B:  BSF    03.6
0C9C:  MOVWF  0D
0C9D:  MOVLW  05
0C9E:  MOVWF  0F
0C9F:  BCF    0A.3
0CA0:  BCF    03.6
0CA1:  CALL   10F
0CA2:  BSF    0A.3
0CA3:  MOVLW  0D
0CA4:  BTFSS  0C.4
0CA5:  GOTO   4A4
0CA6:  MOVWF  19
0CA7:  MOVLW  0A
0CA8:  BTFSS  0C.4
0CA9:  GOTO   4A8
0CAA:  MOVWF  19
....................             } 
....................             addScoreV(2); 
0CAB:  MOVLW  02
0CAC:  BSF    03.5
0CAD:  MOVWF  38
0CAE:  BCF    0A.3
0CAF:  BCF    03.5
0CB0:  CALL   3CA
0CB1:  BSF    0A.3
....................             BREAK; 
0CB2:  GOTO   5CF
....................             case '3': IF(DEBUG) 
0CB3:  BTFSS  07.2
0CB4:  GOTO   4C6
....................             { 
....................                 fputs("\r > Incrementar por 3", RS232); 
0CB5:  MOVLW  AB
0CB6:  BSF    03.6
0CB7:  MOVWF  0D
0CB8:  MOVLW  05
0CB9:  MOVWF  0F
0CBA:  BCF    0A.3
0CBB:  BCF    03.6
0CBC:  CALL   10F
0CBD:  BSF    0A.3
0CBE:  MOVLW  0D
0CBF:  BTFSS  0C.4
0CC0:  GOTO   4BF
0CC1:  MOVWF  19
0CC2:  MOVLW  0A
0CC3:  BTFSS  0C.4
0CC4:  GOTO   4C3
0CC5:  MOVWF  19
....................             } 
....................             addScoreV(3); 
0CC6:  MOVLW  03
0CC7:  BSF    03.5
0CC8:  MOVWF  38
0CC9:  BCF    0A.3
0CCA:  BCF    03.5
0CCB:  CALL   3CA
0CCC:  BSF    0A.3
....................             BREAK; 
0CCD:  GOTO   5CF
....................             case 'D': IF(DEBUG) 
0CCE:  BTFSS  07.2
0CCF:  GOTO   4E1
....................             { 
....................                 fputs("\r > Decrementar por 1", RS232); 
0CD0:  MOVLW  B6
0CD1:  BSF    03.6
0CD2:  MOVWF  0D
0CD3:  MOVLW  05
0CD4:  MOVWF  0F
0CD5:  BCF    0A.3
0CD6:  BCF    03.6
0CD7:  CALL   10F
0CD8:  BSF    0A.3
0CD9:  MOVLW  0D
0CDA:  BTFSS  0C.4
0CDB:  GOTO   4DA
0CDC:  MOVWF  19
0CDD:  MOVLW  0A
0CDE:  BTFSS  0C.4
0CDF:  GOTO   4DE
0CE0:  MOVWF  19
....................             } 
....................             resScoreV(); 
....................             BREAK; 
*
0D50:  GOTO   5CF
....................             case 'F': IF(DEBUG) 
0D51:  BTFSS  07.2
0D52:  GOTO   564
....................             { 
....................                 fputs("\r > Asignar faltas", RS232); 
0D53:  MOVLW  C1
0D54:  BSF    03.6
0D55:  MOVWF  0D
0D56:  MOVLW  05
0D57:  MOVWF  0F
0D58:  BCF    0A.3
0D59:  BCF    03.6
0D5A:  CALL   10F
0D5B:  BSF    0A.3
0D5C:  MOVLW  0D
0D5D:  BTFSS  0C.4
0D5E:  GOTO   55D
0D5F:  MOVWF  19
0D60:  MOVLW  0A
0D61:  BTFSS  0C.4
0D62:  GOTO   561
0D63:  MOVWF  19
....................             } 
....................             sendN2Port(char2int(c[2]), I2C_SCORE, PuertoF); 
0D64:  BSF    03.5
0D65:  MOVF   26,W
0D66:  MOVWF  3B
0D67:  BCF    0A.3
0D68:  BCF    03.5
0D69:  CALL   185
0D6A:  BSF    0A.3
0D6B:  MOVF   78,W
0D6C:  BSF    03.5
0D6D:  MOVWF  38
0D6E:  MOVWF  40
0D6F:  MOVLW  0C
0D70:  MOVWF  41
0D71:  MOVLW  06
0D72:  MOVWF  42
0D73:  BCF    0A.3
0D74:  BCF    03.5
0D75:  CALL   2C3
0D76:  BSF    0A.3
....................             BREAK; 
0D77:  GOTO   5CF
....................             case 'I': IF(DEBUG) 
0D78:  BTFSS  07.2
0D79:  GOTO   58B
....................             { 
....................                 fputs("\r > Inicializar", RS232); 
0D7A:  MOVLW  CB
0D7B:  BSF    03.6
0D7C:  MOVWF  0D
0D7D:  MOVLW  05
0D7E:  MOVWF  0F
0D7F:  BCF    0A.3
0D80:  BCF    03.6
0D81:  CALL   10F
0D82:  BSF    0A.3
0D83:  MOVLW  0D
0D84:  BTFSS  0C.4
0D85:  GOTO   584
0D86:  MOVWF  19
0D87:  MOVLW  0A
0D88:  BTFSS  0C.4
0D89:  GOTO   588
0D8A:  MOVWF  19
....................             } 
....................             setScoreV(char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0D8B:  BSF    03.5
0D8C:  MOVF   26,W
0D8D:  MOVWF  3B
0D8E:  BCF    0A.3
0D8F:  BCF    03.5
0D90:  CALL   185
0D91:  BSF    0A.3
0D92:  MOVF   78,W
0D93:  BSF    03.5
0D94:  MOVWF  38
0D95:  MOVF   27,W
0D96:  MOVWF  3B
0D97:  BCF    0A.3
0D98:  BCF    03.5
0D99:  CALL   185
0D9A:  BSF    0A.3
0D9B:  MOVF   78,W
0D9C:  BSF    03.5
0D9D:  MOVWF  39
0D9E:  MOVF   28,W
0D9F:  MOVWF  3B
0DA0:  BCF    0A.3
0DA1:  BCF    03.5
0DA2:  CALL   185
0DA3:  BSF    0A.3
0DA4:  MOVF   78,W
0DA5:  BSF    03.5
0DA6:  MOVWF  3A
0DA7:  MOVF   38,W
0DA8:  MOVWF  3B
0DA9:  MOVF   39,W
0DAA:  MOVWF  3C
0DAB:  MOVF   3A,W
0DAC:  MOVWF  3D
0DAD:  BCF    0A.3
0DAE:  BCF    03.5
0DAF:  CALL   38A
0DB0:  BSF    0A.3
....................             BREAK; 
0DB1:  GOTO   5CF
....................             case 'P': IF(DEBUG) 
0DB2:  BTFSS  07.2
0DB3:  GOTO   5C5
....................             { 
....................                 fputs("\r > Asignar posicion", RS232); 
0DB4:  MOVLW  D3
0DB5:  BSF    03.6
0DB6:  MOVWF  0D
0DB7:  MOVLW  05
0DB8:  MOVWF  0F
0DB9:  BCF    0A.3
0DBA:  BCF    03.6
0DBB:  CALL   10F
0DBC:  BSF    0A.3
0DBD:  MOVLW  0D
0DBE:  BTFSS  0C.4
0DBF:  GOTO   5BE
0DC0:  MOVWF  19
0DC1:  MOVLW  0A
0DC2:  BTFSS  0C.4
0DC3:  GOTO   5C2
0DC4:  MOVWF  19
....................             } 
....................             i2c_send(I2C_SCORE, I2C_CMD_POSV); 
0DC5:  MOVLW  0C
0DC6:  BSF    03.5
0DC7:  MOVWF  44
0DC8:  MOVLW  72
0DC9:  MOVWF  45
0DCA:  BCF    0A.3
0DCB:  BCF    03.5
0DCC:  CALL   2B0
0DCD:  BSF    0A.3
....................             BREAK; 
0DCE:  GOTO   5CF
....................         } 
....................         BREAK; 
0DCF:  GOTO   7C0
....................         CASE 'X' : doTest(); //Rutina de prueba 
....................         BREAK; 
*
0E99:  BCF    03.5
0E9A:  GOTO   7C0
....................         case 'Z': IF(DEBUG) 
0E9B:  BTFSS  07.2
0E9C:  GOTO   6AE
....................         { 
....................             fputs("\r > Reseteo general... ! ", RS232); 
0E9D:  MOVLW  DE
0E9E:  BSF    03.6
0E9F:  MOVWF  0D
0EA0:  MOVLW  05
0EA1:  MOVWF  0F
0EA2:  BCF    0A.3
0EA3:  BCF    03.6
0EA4:  CALL   10F
0EA5:  BSF    0A.3
0EA6:  MOVLW  0D
0EA7:  BTFSS  0C.4
0EA8:  GOTO   6A7
0EA9:  MOVWF  19
0EAA:  MOVLW  0A
0EAB:  BTFSS  0C.4
0EAC:  GOTO   6AB
0EAD:  MOVWF  19
....................         } 
....................         delay_ms(500); 
0EAE:  MOVLW  02
0EAF:  BSF    03.5
0EB0:  MOVWF  38
0EB1:  MOVLW  FA
0EB2:  MOVWF  40
0EB3:  BCF    0A.3
0EB4:  BCF    03.5
0EB5:  CALL   2D2
0EB6:  BSF    0A.3
0EB7:  BSF    03.5
0EB8:  DECFSZ 38,F
0EB9:  GOTO   6B1
....................         doReset(); 
....................         BREAK; 
*
0ED4:  GOTO   7C0
....................         case 'S': IF(DEBUG) 
0ED5:  BTFSS  07.2
0ED6:  GOTO   6E8
....................         { 
....................             fputs("\r > Configuracion de tiro", RS232); 
0ED7:  MOVLW  EB
0ED8:  BSF    03.6
0ED9:  MOVWF  0D
0EDA:  MOVLW  05
0EDB:  MOVWF  0F
0EDC:  BCF    0A.3
0EDD:  BCF    03.6
0EDE:  CALL   10F
0EDF:  BSF    0A.3
0EE0:  MOVLW  0D
0EE1:  BTFSS  0C.4
0EE2:  GOTO   6E1
0EE3:  MOVWF  19
0EE4:  MOVLW  0A
0EE5:  BTFSS  0C.4
0EE6:  GOTO   6E5
0EE7:  MOVWF  19
....................         } 
....................         shotSet(char2int(c[1]), char2int(c[2])); 
0EE8:  BSF    03.5
0EE9:  MOVF   25,W
0EEA:  MOVWF  3B
0EEB:  BCF    0A.3
0EEC:  BCF    03.5
0EED:  CALL   185
0EEE:  BSF    0A.3
0EEF:  MOVF   78,W
0EF0:  BSF    03.5
0EF1:  MOVWF  38
0EF2:  MOVF   26,W
0EF3:  MOVWF  3B
0EF4:  BCF    0A.3
0EF5:  BCF    03.5
0EF6:  CALL   185
0EF7:  BSF    0A.3
0EF8:  MOVF   78,W
0EF9:  BSF    03.5
0EFA:  MOVWF  39
0EFB:  MOVF   38,W
0EFC:  MOVWF  3A
0EFD:  MOVF   39,W
0EFE:  MOVWF  3B
....................         BREAK; 
*
0F23:  GOTO   7C0
....................         case 'T': IF(DEBUG) 
0F24:  BTFSS  07.2
0F25:  GOTO   737
....................         { 
....................             fputs("\r > Configuracion de tiempo", RS232); 
0F26:  MOVLW  F8
0F27:  BSF    03.6
0F28:  MOVWF  0D
0F29:  MOVLW  05
0F2A:  MOVWF  0F
0F2B:  BCF    0A.3
0F2C:  BCF    03.6
0F2D:  CALL   10F
0F2E:  BSF    0A.3
0F2F:  MOVLW  0D
0F30:  BTFSS  0C.4
0F31:  GOTO   730
0F32:  MOVWF  19
0F33:  MOVLW  0A
0F34:  BTFSS  0C.4
0F35:  GOTO   734
0F36:  MOVWF  19
....................         } 
....................         timeSet(char2int(c[1]), char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0F37:  BSF    03.5
0F38:  MOVF   25,W
0F39:  MOVWF  3B
0F3A:  BCF    0A.3
0F3B:  BCF    03.5
0F3C:  CALL   185
0F3D:  BSF    0A.3
0F3E:  MOVF   78,W
0F3F:  BSF    03.5
0F40:  MOVWF  38
0F41:  MOVF   26,W
0F42:  MOVWF  3B
0F43:  BCF    0A.3
0F44:  BCF    03.5
0F45:  CALL   185
0F46:  BSF    0A.3
0F47:  MOVF   78,W
0F48:  BSF    03.5
0F49:  MOVWF  39
0F4A:  MOVF   27,W
0F4B:  MOVWF  3B
0F4C:  BCF    0A.3
0F4D:  BCF    03.5
0F4E:  CALL   185
0F4F:  BSF    0A.3
0F50:  MOVF   78,W
0F51:  BSF    03.5
0F52:  MOVWF  3A
0F53:  MOVF   28,W
0F54:  MOVWF  3B
0F55:  BCF    0A.3
0F56:  BCF    03.5
0F57:  CALL   185
0F58:  BSF    0A.3
0F59:  MOVF   78,W
0F5A:  BSF    03.5
0F5B:  MOVWF  3B
0F5C:  MOVF   38,W
0F5D:  MOVWF  3C
0F5E:  MOVF   39,W
0F5F:  MOVWF  3D
0F60:  MOVF   3A,W
0F61:  MOVWF  3E
0F62:  MOVF   3B,W
0F63:  MOVWF  3F
....................         BREAK; 
*
0FBF:  GOTO   7C0
....................     } 
0FC0:  BCF    0A.3
0FC1:  BCF    0A.4
0FC2:  GOTO   45F (RETURN)
.................... } 
....................  
.................... void setScoreL(int8 c, int8 d, int8 u) { 
....................     //TODO: Codigo para mostrar puntos 
....................     scoreLU = u; 
*
02E6:  BSF    03.5
02E7:  MOVF   3D,W
02E8:  BCF    03.5
02E9:  MOVWF  6C
....................     scoreLD = d; 
02EA:  BSF    03.5
02EB:  MOVF   3C,W
02EC:  BCF    03.5
02ED:  MOVWF  6D
....................     if (c > 0) 
02EE:  BSF    03.5
02EF:  MOVF   3B,F
02F0:  BTFSC  03.2
02F1:  GOTO   2F6
....................         scoreLC = true; 
02F2:  BCF    03.5
02F3:  BSF    55.1
02F4:  GOTO   2F8
02F5:  BSF    03.5
....................     else 
....................         scoreLC = false; 
02F6:  BCF    03.5
02F7:  BCF    55.1
....................  
....................     sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
02F8:  MOVF   6C,W
02F9:  BSF    03.5
02FA:  MOVWF  40
02FB:  MOVLW  0C
02FC:  MOVWF  41
02FD:  MOVLW  01
02FE:  MOVWF  42
02FF:  BCF    03.5
0300:  CALL   2C3
....................     delay_ms(I2CWAIT); 
0301:  MOVLW  32
0302:  BSF    03.5
0303:  MOVWF  40
0304:  BCF    03.5
0305:  CALL   2D2
....................     sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0306:  MOVF   6D,W
0307:  BSF    03.5
0308:  MOVWF  40
0309:  MOVLW  0C
030A:  MOVWF  41
030B:  MOVLW  02
030C:  MOVWF  42
030D:  BCF    03.5
030E:  CALL   2C3
....................     delay_ms(I2CWAIT); 
030F:  MOVLW  32
0310:  BSF    03.5
0311:  MOVWF  40
0312:  BCF    03.5
0313:  CALL   2D2
....................     if (scoreLC) 
0314:  BTFSS  55.1
0315:  GOTO   31E
....................         i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0316:  MOVLW  0C
0317:  BSF    03.5
0318:  MOVWF  44
0319:  MOVLW  73
031A:  MOVWF  45
031B:  BCF    03.5
031C:  CALL   2B0
031D:  GOTO   325
....................     else 
....................         i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
031E:  MOVLW  0C
031F:  BSF    03.5
0320:  MOVWF  44
0321:  MOVLW  74
0322:  MOVWF  45
0323:  BCF    03.5
0324:  CALL   2B0
0325:  RETURN
.................... } 
....................  
.................... void setScoreV(int8 c, int8 d, int8 u) { 
....................     //TODO: Codigo para mostrar puntos 
....................     scoreVU = u; 
*
038A:  BSF    03.5
038B:  MOVF   3D,W
038C:  BCF    03.5
038D:  MOVWF  6E
....................     scoreVD = d; 
038E:  BSF    03.5
038F:  MOVF   3C,W
0390:  BCF    03.5
0391:  MOVWF  6F
....................     if (c > 0) 
0392:  BSF    03.5
0393:  MOVF   3B,F
0394:  BTFSC  03.2
0395:  GOTO   39A
....................         scoreVC = true; 
0396:  BCF    03.5
0397:  BSF    55.2
0398:  GOTO   39C
0399:  BSF    03.5
....................     else 
....................         scoreVC = false; 
039A:  BCF    03.5
039B:  BCF    55.2
....................  
....................     sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
039C:  MOVF   6E,W
039D:  BSF    03.5
039E:  MOVWF  40
039F:  MOVLW  0C
03A0:  MOVWF  41
03A1:  MOVLW  04
03A2:  MOVWF  42
03A3:  BCF    03.5
03A4:  CALL   2C3
....................     delay_ms(I2CWAIT); 
03A5:  MOVLW  32
03A6:  BSF    03.5
03A7:  MOVWF  40
03A8:  BCF    03.5
03A9:  CALL   2D2
....................     sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
03AA:  MOVF   6F,W
03AB:  BSF    03.5
03AC:  MOVWF  40
03AD:  MOVLW  0C
03AE:  MOVWF  41
03AF:  MOVLW  03
03B0:  MOVWF  42
03B1:  BCF    03.5
03B2:  CALL   2C3
....................     delay_ms(I2CWAIT); 
03B3:  MOVLW  32
03B4:  BSF    03.5
03B5:  MOVWF  40
03B6:  BCF    03.5
03B7:  CALL   2D2
....................  
....................     if (scoreVC) 
03B8:  BTFSS  55.2
03B9:  GOTO   3C2
....................         i2c_send(I2C_SCORE, I2C_CMD_CVON); 
03BA:  MOVLW  0C
03BB:  BSF    03.5
03BC:  MOVWF  44
03BD:  MOVLW  75
03BE:  MOVWF  45
03BF:  BCF    03.5
03C0:  CALL   2B0
03C1:  GOTO   3C9
....................     else 
....................         i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
03C2:  MOVLW  0C
03C3:  BSF    03.5
03C4:  MOVWF  44
03C5:  MOVLW  76
03C6:  MOVWF  45
03C7:  BCF    03.5
03C8:  CALL   2B0
03C9:  RETURN
....................  
.................... } 
....................  
.................... void addScoreV(int8 a) { 
03CA:  BSF    03.5
03CB:  BCF    39.0
03CC:  BCF    03.5
03CD:  BTFSS  55.2
03CE:  GOTO   3D2
03CF:  BSF    03.5
03D0:  BSF    39.0
03D1:  BCF    03.5
03D2:  MOVF   6F,W
03D3:  BSF    03.5
03D4:  MOVWF  3A
03D5:  BCF    03.5
03D6:  MOVF   6E,W
03D7:  BSF    03.5
03D8:  MOVWF  3B
....................     int1 tc = scoreVC; 
....................     int8 td = scoreVD; 
....................     int8 tu = scoreVU; 
....................  
....................     scoreVU += a; 
03D9:  MOVF   38,W
03DA:  BCF    03.5
03DB:  ADDWF  6E,F
....................  
....................     if (scoreVU > 10) { 
03DC:  MOVF   6E,W
03DD:  SUBLW  0A
03DE:  BTFSC  03.0
03DF:  GOTO   3E3
....................         scoreVD++; 
03E0:  INCF   6F,F
....................         scoreVU-=10; 
03E1:  MOVLW  0A
03E2:  SUBWF  6E,F
....................     } 
....................     if (scoreVD > 10) { 
03E3:  MOVF   6F,W
03E4:  SUBLW  0A
03E5:  BTFSC  03.0
03E6:  GOTO   3EA
....................         scoreVC = true; 
03E7:  BSF    55.2
....................         scoreVD-=10; 
03E8:  MOVLW  0A
03E9:  SUBWF  6F,F
....................     } 
....................  
....................     if (scoreVC != tc) { 
03EA:  CLRF   77
03EB:  BSF    03.5
03EC:  BTFSC  39.0
03ED:  BSF    77.2
03EE:  BCF    03.5
03EF:  MOVF   55,W
03F0:  XORWF  77,W
03F1:  ANDLW  04
03F2:  BTFSC  03.2
03F3:  GOTO   405
....................         if (scoreVC) 
03F4:  BTFSS  55.2
03F5:  GOTO   3FE
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
03F6:  MOVLW  0C
03F7:  BSF    03.5
03F8:  MOVWF  44
03F9:  MOVLW  73
03FA:  MOVWF  45
03FB:  BCF    03.5
03FC:  CALL   2B0
03FD:  GOTO   405
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
03FE:  MOVLW  0C
03FF:  BSF    03.5
0400:  MOVWF  44
0401:  MOVLW  74
0402:  MOVWF  45
0403:  BCF    03.5
0404:  CALL   2B0
....................     } 
....................  
....................     delay_ms(I2CWAIT); 
0405:  MOVLW  32
0406:  BSF    03.5
0407:  MOVWF  40
0408:  BCF    03.5
0409:  CALL   2D2
....................     if (scoreVD != td) 
040A:  BSF    03.5
040B:  MOVF   3A,W
040C:  BCF    03.5
040D:  SUBWF  6F,W
040E:  BTFSC  03.2
040F:  GOTO   419
....................         sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0410:  MOVF   6F,W
0411:  BSF    03.5
0412:  MOVWF  40
0413:  MOVLW  0C
0414:  MOVWF  41
0415:  MOVLW  03
0416:  MOVWF  42
0417:  BCF    03.5
0418:  CALL   2C3
....................     delay_ms(I2CWAIT); 
0419:  MOVLW  32
041A:  BSF    03.5
041B:  MOVWF  40
041C:  BCF    03.5
041D:  CALL   2D2
....................     if (scoreVU != tu) 
041E:  BSF    03.5
041F:  MOVF   3B,W
0420:  BCF    03.5
0421:  SUBWF  6E,W
0422:  BTFSC  03.2
0423:  GOTO   42D
....................         sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0424:  MOVF   6E,W
0425:  BSF    03.5
0426:  MOVWF  40
0427:  MOVLW  0C
0428:  MOVWF  41
0429:  MOVLW  04
042A:  MOVWF  42
042B:  BCF    03.5
042C:  CALL   2C3
042D:  RETURN
.................... } 
....................  
.................... void resScoreV() { 
*
0CE1:  BSF    03.5
0CE2:  BCF    38.0
0CE3:  BCF    03.5
0CE4:  BTFSS  55.2
0CE5:  GOTO   4E9
0CE6:  BSF    03.5
0CE7:  BSF    38.0
0CE8:  BCF    03.5
0CE9:  MOVF   6F,W
0CEA:  BSF    03.5
0CEB:  MOVWF  39
0CEC:  BCF    03.5
0CED:  MOVF   6E,W
0CEE:  BSF    03.5
0CEF:  MOVWF  3A
....................     int1 tc = scoreVC; 
....................     int8 td = scoreVD; 
....................     int8 tu = scoreVU; 
....................  
....................     if (scoreVU > 0) 
0CF0:  BCF    03.5
0CF1:  MOVF   6E,F
0CF2:  BTFSC  03.2
0CF3:  GOTO   4F6
....................         scoreVU--; 
0CF4:  DECF   6E,F
0CF5:  GOTO   501
....................     else { 
....................         if (scoreVD > 0) { 
0CF6:  MOVF   6F,F
0CF7:  BTFSC  03.2
0CF8:  GOTO   4FD
....................             scoreVD--; 
0CF9:  DECF   6F,F
....................             scoreVU = 9; 
0CFA:  MOVLW  09
0CFB:  MOVWF  6E
....................         } else { 
0CFC:  GOTO   501
....................             scoreVC = false; 
0CFD:  BCF    55.2
....................             scoreVD = 9; 
0CFE:  MOVLW  09
0CFF:  MOVWF  6F
....................             scoreVU = 9; 
0D00:  MOVWF  6E
....................         } 
....................     } 
....................  
....................     if (scoreVC != tc) { 
0D01:  CLRF   77
0D02:  BSF    03.5
0D03:  BTFSC  38.0
0D04:  BSF    77.2
0D05:  BCF    03.5
0D06:  MOVF   55,W
0D07:  XORWF  77,W
0D08:  ANDLW  04
0D09:  BTFSC  03.2
0D0A:  GOTO   520
....................         if (scoreVC) 
0D0B:  BTFSS  55.2
0D0C:  GOTO   517
....................             i2c_send(I2C_SCORE, I2C_CMD_CVON); 
0D0D:  MOVLW  0C
0D0E:  BSF    03.5
0D0F:  MOVWF  44
0D10:  MOVLW  75
0D11:  MOVWF  45
0D12:  BCF    0A.3
0D13:  BCF    03.5
0D14:  CALL   2B0
0D15:  BSF    0A.3
0D16:  GOTO   520
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
0D17:  MOVLW  0C
0D18:  BSF    03.5
0D19:  MOVWF  44
0D1A:  MOVLW  76
0D1B:  MOVWF  45
0D1C:  BCF    0A.3
0D1D:  BCF    03.5
0D1E:  CALL   2B0
0D1F:  BSF    0A.3
....................     } 
....................     delay_ms(I2CWAIT); 
0D20:  MOVLW  32
0D21:  BSF    03.5
0D22:  MOVWF  40
0D23:  BCF    0A.3
0D24:  BCF    03.5
0D25:  CALL   2D2
0D26:  BSF    0A.3
....................     if (scoreVD != td) 
0D27:  BSF    03.5
0D28:  MOVF   39,W
0D29:  BCF    03.5
0D2A:  SUBWF  6F,W
0D2B:  BTFSC  03.2
0D2C:  GOTO   538
....................         sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0D2D:  MOVF   6F,W
0D2E:  BSF    03.5
0D2F:  MOVWF  40
0D30:  MOVLW  0C
0D31:  MOVWF  41
0D32:  MOVLW  03
0D33:  MOVWF  42
0D34:  BCF    0A.3
0D35:  BCF    03.5
0D36:  CALL   2C3
0D37:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0D38:  MOVLW  32
0D39:  BSF    03.5
0D3A:  MOVWF  40
0D3B:  BCF    0A.3
0D3C:  BCF    03.5
0D3D:  CALL   2D2
0D3E:  BSF    0A.3
....................     if (scoreVU != tu) 
0D3F:  BSF    03.5
0D40:  MOVF   3A,W
0D41:  BCF    03.5
0D42:  SUBWF  6E,W
0D43:  BTFSC  03.2
0D44:  GOTO   550
....................         sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0D45:  MOVF   6E,W
0D46:  BSF    03.5
0D47:  MOVWF  40
0D48:  MOVLW  0C
0D49:  MOVWF  41
0D4A:  MOVLW  04
0D4B:  MOVWF  42
0D4C:  BCF    0A.3
0D4D:  BCF    03.5
0D4E:  CALL   2C3
0D4F:  BSF    0A.3
.................... } 
....................  
.................... void addScoreL(int8 a) { 
*
0326:  BSF    03.5
0327:  BCF    39.0
0328:  BCF    03.5
0329:  BTFSS  55.1
032A:  GOTO   32E
032B:  BSF    03.5
032C:  BSF    39.0
032D:  BCF    03.5
032E:  MOVF   6D,W
032F:  BSF    03.5
0330:  MOVWF  3A
0331:  BCF    03.5
0332:  MOVF   6C,W
0333:  BSF    03.5
0334:  MOVWF  3B
....................     int1 tc = scoreLC; 
....................     int8 td = scoreLD; 
....................     int8 tu = scoreLU; 
....................  
....................     scoreLU += a; 
0335:  MOVF   38,W
0336:  BCF    03.5
0337:  ADDWF  6C,F
....................  
....................     if (scoreLU > 10) { 
0338:  MOVF   6C,W
0339:  SUBLW  0A
033A:  BTFSC  03.0
033B:  GOTO   33F
....................         scoreLD++; 
033C:  INCF   6D,F
....................         scoreLU -=10; 
033D:  MOVLW  0A
033E:  SUBWF  6C,F
....................     } 
....................     if (scoreLD > 10) { 
033F:  MOVF   6D,W
0340:  SUBLW  0A
0341:  BTFSC  03.0
0342:  GOTO   346
....................         scoreLC = true; 
0343:  BSF    55.1
....................         scoreLD -= 10; 
0344:  MOVLW  0A
0345:  SUBWF  6D,F
....................     } 
....................  
....................     if (scoreLC != tc) { 
0346:  CLRF   77
0347:  BSF    03.5
0348:  BTFSC  39.0
0349:  BSF    77.1
034A:  BCF    03.5
034B:  MOVF   55,W
034C:  XORWF  77,W
034D:  ANDLW  02
034E:  BTFSC  03.2
034F:  GOTO   361
....................         if (scoreLC) 
0350:  BTFSS  55.1
0351:  GOTO   35A
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0352:  MOVLW  0C
0353:  BSF    03.5
0354:  MOVWF  44
0355:  MOVLW  73
0356:  MOVWF  45
0357:  BCF    03.5
0358:  CALL   2B0
0359:  GOTO   361
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
035A:  MOVLW  0C
035B:  BSF    03.5
035C:  MOVWF  44
035D:  MOVLW  74
035E:  MOVWF  45
035F:  BCF    03.5
0360:  CALL   2B0
....................     } 
....................     delay_ms(I2CWAIT); 
0361:  MOVLW  32
0362:  BSF    03.5
0363:  MOVWF  40
0364:  BCF    03.5
0365:  CALL   2D2
....................     if (scoreLD != td) 
0366:  BSF    03.5
0367:  MOVF   3A,W
0368:  BCF    03.5
0369:  SUBWF  6D,W
036A:  BTFSC  03.2
036B:  GOTO   375
....................         sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
036C:  MOVF   6D,W
036D:  BSF    03.5
036E:  MOVWF  40
036F:  MOVLW  0C
0370:  MOVWF  41
0371:  MOVLW  02
0372:  MOVWF  42
0373:  BCF    03.5
0374:  CALL   2C3
....................     delay_ms(I2CWAIT); 
0375:  MOVLW  32
0376:  BSF    03.5
0377:  MOVWF  40
0378:  BCF    03.5
0379:  CALL   2D2
....................     if (scoreLU != tu) 
037A:  BSF    03.5
037B:  MOVF   3B,W
037C:  BCF    03.5
037D:  SUBWF  6C,W
037E:  BTFSC  03.2
037F:  GOTO   389
....................         sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0380:  MOVF   6C,W
0381:  BSF    03.5
0382:  MOVWF  40
0383:  MOVLW  0C
0384:  MOVWF  41
0385:  MOVLW  01
0386:  MOVWF  42
0387:  BCF    03.5
0388:  CALL   2C3
0389:  RETURN
.................... } 
....................  
.................... void resScoreL() { 
*
0A87:  BSF    03.5
0A88:  BCF    38.0
0A89:  BCF    03.5
0A8A:  BTFSS  55.1
0A8B:  GOTO   28F
0A8C:  BSF    03.5
0A8D:  BSF    38.0
0A8E:  BCF    03.5
0A8F:  MOVF   6D,W
0A90:  BSF    03.5
0A91:  MOVWF  39
0A92:  BCF    03.5
0A93:  MOVF   6C,W
0A94:  BSF    03.5
0A95:  MOVWF  3A
....................     int1 tc = scoreLC; 
....................     int8 td = scoreLD; 
....................     int8 tu = scoreLU; 
....................  
....................     if (scoreLU > 0) 
0A96:  BCF    03.5
0A97:  MOVF   6C,F
0A98:  BTFSC  03.2
0A99:  GOTO   29C
....................         scoreLU--; 
0A9A:  DECF   6C,F
0A9B:  GOTO   2A7
....................     else { 
....................         if (scoreLD > 0) { 
0A9C:  MOVF   6D,F
0A9D:  BTFSC  03.2
0A9E:  GOTO   2A3
....................             scoreLD--; 
0A9F:  DECF   6D,F
....................             scoreLU = 9; 
0AA0:  MOVLW  09
0AA1:  MOVWF  6C
....................         } else { 
0AA2:  GOTO   2A7
....................             scoreLC = false; 
0AA3:  BCF    55.1
....................             scoreLD = 9; 
0AA4:  MOVLW  09
0AA5:  MOVWF  6D
....................             scoreLU = 9; 
0AA6:  MOVWF  6C
....................         } 
....................     } 
....................  
....................     if (scoreLC != tc) { 
0AA7:  CLRF   77
0AA8:  BSF    03.5
0AA9:  BTFSC  38.0
0AAA:  BSF    77.1
0AAB:  BCF    03.5
0AAC:  MOVF   55,W
0AAD:  XORWF  77,W
0AAE:  ANDLW  02
0AAF:  BTFSC  03.2
0AB0:  GOTO   2C6
....................         if (scoreLC) 
0AB1:  BTFSS  55.1
0AB2:  GOTO   2BD
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0AB3:  MOVLW  0C
0AB4:  BSF    03.5
0AB5:  MOVWF  44
0AB6:  MOVLW  73
0AB7:  MOVWF  45
0AB8:  BCF    0A.3
0AB9:  BCF    03.5
0ABA:  CALL   2B0
0ABB:  BSF    0A.3
0ABC:  GOTO   2C6
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0ABD:  MOVLW  0C
0ABE:  BSF    03.5
0ABF:  MOVWF  44
0AC0:  MOVLW  74
0AC1:  MOVWF  45
0AC2:  BCF    0A.3
0AC3:  BCF    03.5
0AC4:  CALL   2B0
0AC5:  BSF    0A.3
....................     } 
....................     delay_ms(I2CWAIT); 
0AC6:  MOVLW  32
0AC7:  BSF    03.5
0AC8:  MOVWF  40
0AC9:  BCF    0A.3
0ACA:  BCF    03.5
0ACB:  CALL   2D2
0ACC:  BSF    0A.3
....................     if (scoreLD != td) 
0ACD:  BSF    03.5
0ACE:  MOVF   39,W
0ACF:  BCF    03.5
0AD0:  SUBWF  6D,W
0AD1:  BTFSC  03.2
0AD2:  GOTO   2DE
....................         sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0AD3:  MOVF   6D,W
0AD4:  BSF    03.5
0AD5:  MOVWF  40
0AD6:  MOVLW  0C
0AD7:  MOVWF  41
0AD8:  MOVLW  02
0AD9:  MOVWF  42
0ADA:  BCF    0A.3
0ADB:  BCF    03.5
0ADC:  CALL   2C3
0ADD:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0ADE:  MOVLW  32
0ADF:  BSF    03.5
0AE0:  MOVWF  40
0AE1:  BCF    0A.3
0AE2:  BCF    03.5
0AE3:  CALL   2D2
0AE4:  BSF    0A.3
....................     if (scoreLU != tu) 
0AE5:  BSF    03.5
0AE6:  MOVF   3A,W
0AE7:  BCF    03.5
0AE8:  SUBWF  6C,W
0AE9:  BTFSC  03.2
0AEA:  GOTO   2F6
....................         sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0AEB:  MOVF   6C,W
0AEC:  BSF    03.5
0AED:  MOVWF  40
0AEE:  MOVLW  0C
0AEF:  MOVWF  41
0AF0:  MOVLW  01
0AF1:  MOVWF  42
0AF2:  BCF    0A.3
0AF3:  BCF    03.5
0AF4:  CALL   2C3
0AF5:  BSF    0A.3
.................... } 
....................  
.................... void shotSet(int8 shd, int8 shu) { 
....................     sh_u = shu; 
*
0EFF:  MOVF   3B,W
0F00:  BCF    03.5
0F01:  MOVWF  6B
....................     sh_d = shd; 
0F02:  BSF    03.5
0F03:  MOVF   3A,W
0F04:  BCF    03.5
0F05:  MOVWF  6A
....................     sendN2Port(shd, I2C_TIMER, PuertoA); 
0F06:  BSF    03.5
0F07:  MOVF   3A,W
0F08:  MOVWF  40
0F09:  MOVLW  0A
0F0A:  MOVWF  41
0F0B:  MOVLW  01
0F0C:  MOVWF  42
0F0D:  BCF    0A.3
0F0E:  BCF    03.5
0F0F:  CALL   2C3
0F10:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0F11:  MOVLW  32
0F12:  BSF    03.5
0F13:  MOVWF  40
0F14:  BCF    0A.3
0F15:  BCF    03.5
0F16:  CALL   2D2
0F17:  BSF    0A.3
....................     sendN2Port(shu, I2C_TIMER, PuertoB); 
0F18:  BSF    03.5
0F19:  MOVF   3B,W
0F1A:  MOVWF  40
0F1B:  MOVLW  0A
0F1C:  MOVWF  41
0F1D:  MOVLW  02
0F1E:  MOVWF  42
0F1F:  BCF    0A.3
0F20:  BCF    03.5
0F21:  CALL   2C3
0F22:  BSF    0A.3
.................... } 
....................  
.................... void timeSet(INT8 md, int8 mu, int8 sd, int8 su) { 
....................     m_u = mu; 
*
0F64:  MOVF   3D,W
0F65:  BCF    03.5
0F66:  MOVWF  67
....................     m_d = md; 
0F67:  BSF    03.5
0F68:  MOVF   3C,W
0F69:  BCF    03.5
0F6A:  MOVWF  66
....................     s_d = sd; 
0F6B:  BSF    03.5
0F6C:  MOVF   3E,W
0F6D:  BCF    03.5
0F6E:  MOVWF  68
....................     s_u = su; 
0F6F:  BSF    03.5
0F70:  MOVF   3F,W
0F71:  BCF    03.5
0F72:  MOVWF  69
....................  
....................     sendN2Port(su, I2C_TIMER, PuertoD); 
0F73:  BSF    03.5
0F74:  MOVF   3F,W
0F75:  MOVWF  40
0F76:  MOVLW  0A
0F77:  MOVWF  41
0F78:  MOVLW  04
0F79:  MOVWF  42
0F7A:  BCF    0A.3
0F7B:  BCF    03.5
0F7C:  CALL   2C3
0F7D:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0F7E:  MOVLW  32
0F7F:  BSF    03.5
0F80:  MOVWF  40
0F81:  BCF    0A.3
0F82:  BCF    03.5
0F83:  CALL   2D2
0F84:  BSF    0A.3
....................     sendN2Port(sd, I2C_TIMER, PuertoC); 
0F85:  BSF    03.5
0F86:  MOVF   3E,W
0F87:  MOVWF  40
0F88:  MOVLW  0A
0F89:  MOVWF  41
0F8A:  MOVLW  03
0F8B:  MOVWF  42
0F8C:  BCF    0A.3
0F8D:  BCF    03.5
0F8E:  CALL   2C3
0F8F:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0F90:  MOVLW  32
0F91:  BSF    03.5
0F92:  MOVWF  40
0F93:  BCF    0A.3
0F94:  BCF    03.5
0F95:  CALL   2D2
0F96:  BSF    0A.3
....................     sendN2Port(mu, I2C_TIMER, PuertoE); 
0F97:  BSF    03.5
0F98:  MOVF   3D,W
0F99:  MOVWF  40
0F9A:  MOVLW  0A
0F9B:  MOVWF  41
0F9C:  MOVLW  05
0F9D:  MOVWF  42
0F9E:  BCF    0A.3
0F9F:  BCF    03.5
0FA0:  CALL   2C3
0FA1:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0FA2:  MOVLW  32
0FA3:  BSF    03.5
0FA4:  MOVWF  40
0FA5:  BCF    0A.3
0FA6:  BCF    03.5
0FA7:  CALL   2D2
0FA8:  BSF    0A.3
....................  
....................     IF(md != 0) { 
0FA9:  BSF    03.5
0FAA:  MOVF   3C,F
0FAB:  BTFSC  03.2
0FAC:  GOTO   7B7
....................         i2c_send(I2C_TIMER, I2C_CMD_MDON); 
0FAD:  MOVLW  0A
0FAE:  MOVWF  44
0FAF:  MOVLW  75
0FB0:  MOVWF  45
0FB1:  BCF    0A.3
0FB2:  BCF    03.5
0FB3:  CALL   2B0
0FB4:  BSF    0A.3
....................     } 
0FB5:  GOTO   7BF
0FB6:  BSF    03.5
....................  
....................     ELSE{ 
....................         i2c_send(I2C_TIMER, I2C_CMD_MDOF); 
0FB7:  MOVLW  0A
0FB8:  MOVWF  44
0FB9:  MOVLW  76
0FBA:  MOVWF  45
0FBB:  BCF    0A.3
0FBC:  BCF    03.5
0FBD:  CALL   2B0
0FBE:  BSF    0A.3
....................     } 
....................  
.................... } 
....................  
.................... void showNumber(INT8 n, tPort p) { 
*
01F5:  BSF    03.5
01F6:  BCF    3E.0
01F7:  BCF    3E.1
01F8:  BCF    3E.2
01F9:  BCF    3E.3
....................     INT1 a = 0, b = 0, c = 0, d = 0; 
....................  
....................     SWITCH(n) { 
01FA:  MOVLW  01
01FB:  SUBWF  39,W
01FC:  ADDLW  F7
01FD:  BTFSC  03.0
01FE:  GOTO   224
01FF:  ADDLW  09
0200:  BCF    03.5
0201:  GOTO   27C
....................         CASE 1 : a = 1; 
0202:  BSF    03.5
0203:  BSF    3E.0
....................         BREAK; 
0204:  GOTO   224
....................         CASE 2 : b = 1; 
0205:  BSF    03.5
0206:  BSF    3E.1
....................         BREAK; 
0207:  GOTO   224
....................         CASE 3 : a = 1; 
0208:  BSF    03.5
0209:  BSF    3E.0
....................         b = 1; 
020A:  BSF    3E.1
....................         BREAK; 
020B:  GOTO   224
....................         CASE 4 : c = 1; 
020C:  BSF    03.5
020D:  BSF    3E.2
....................         BREAK; 
020E:  GOTO   224
....................         CASE 5 : c = 1; 
020F:  BSF    03.5
0210:  BSF    3E.2
....................         a = 1; 
0211:  BSF    3E.0
....................         BREAK; 
0212:  GOTO   224
....................         CASE 6 : c = 1; 
0213:  BSF    03.5
0214:  BSF    3E.2
....................         b = 1; 
0215:  BSF    3E.1
....................         BREAK; 
0216:  GOTO   224
....................         CASE 7 : c = 1; 
0217:  BSF    03.5
0218:  BSF    3E.2
....................         b = 1; 
0219:  BSF    3E.1
....................         a = 1; 
021A:  BSF    3E.0
....................         BREAK; 
021B:  GOTO   224
....................         CASE 8 : d = 1; 
021C:  BSF    03.5
021D:  BSF    3E.3
....................         BREAK; 
021E:  GOTO   224
....................         CASE 9 : d = 1; 
021F:  BSF    03.5
0220:  BSF    3E.3
....................         a = 1; 
0221:  BSF    3E.0
....................         BREAK; 
0222:  GOTO   224
0223:  BSF    03.5
....................     } 
....................  
....................     output_bit(p.a, a); 
0224:  MOVLW  00
0225:  BTFSC  3E.0
0226:  MOVLW  01
0227:  MOVWF  77
0228:  MOVF   3A,W
0229:  MOVWF  3F
022A:  MOVF   77,W
022B:  MOVWF  40
022C:  CLRF   42
022D:  CLRF   41
022E:  BCF    03.5
022F:  CALL   1D3
0230:  BSF    03.5
0231:  MOVF   3A,W
0232:  MOVWF  3F
0233:  CLRF   40
0234:  CLRF   42
0235:  MOVLW  80
0236:  MOVWF  41
0237:  BCF    03.5
0238:  CALL   1D3
....................     output_bit(p.b, b); 
0239:  MOVLW  00
023A:  BSF    03.5
023B:  BTFSC  3E.1
023C:  MOVLW  01
023D:  MOVWF  77
023E:  MOVF   3B,W
023F:  MOVWF  3F
0240:  MOVF   77,W
0241:  MOVWF  40
0242:  CLRF   42
0243:  CLRF   41
0244:  BCF    03.5
0245:  CALL   1D3
0246:  BSF    03.5
0247:  MOVF   3B,W
0248:  MOVWF  3F
0249:  CLRF   40
024A:  CLRF   42
024B:  MOVLW  80
024C:  MOVWF  41
024D:  BCF    03.5
024E:  CALL   1D3
....................     output_bit(p.c, c); 
024F:  MOVLW  00
0250:  BSF    03.5
0251:  BTFSC  3E.2
0252:  MOVLW  01
0253:  MOVWF  77
0254:  MOVF   3C,W
0255:  MOVWF  3F
0256:  MOVF   77,W
0257:  MOVWF  40
0258:  CLRF   42
0259:  CLRF   41
025A:  BCF    03.5
025B:  CALL   1D3
025C:  BSF    03.5
025D:  MOVF   3C,W
025E:  MOVWF  3F
025F:  CLRF   40
0260:  CLRF   42
0261:  MOVLW  80
0262:  MOVWF  41
0263:  BCF    03.5
0264:  CALL   1D3
....................     output_bit(p.d, d); 
0265:  MOVLW  00
0266:  BSF    03.5
0267:  BTFSC  3E.3
0268:  MOVLW  01
0269:  MOVWF  77
026A:  MOVF   3D,W
026B:  MOVWF  3F
026C:  MOVF   77,W
026D:  MOVWF  40
026E:  CLRF   42
026F:  CLRF   41
0270:  BCF    03.5
0271:  CALL   1D3
0272:  BSF    03.5
0273:  MOVF   3D,W
0274:  MOVWF  3F
0275:  CLRF   40
0276:  CLRF   42
0277:  MOVLW  80
0278:  MOVWF  41
0279:  BCF    03.5
027A:  CALL   1D3
027B:  RETURN
.................... } 
....................  
.................... int8 char2int(CHAR c) { 
....................  
....................     SWITCH(c) { 
*
0185:  MOVLW  30
0186:  BSF    03.5
0187:  SUBWF  3B,W
0188:  ADDLW  F6
0189:  BTFSC  03.0
018A:  GOTO   1C1
018B:  ADDLW  0A
018C:  BCF    03.5
018D:  GOTO   1C5
....................         case '0': RETURN 0; 
018E:  MOVLW  00
018F:  MOVWF  78
0190:  GOTO   1C4
....................         BREAK; 
0191:  BSF    03.5
0192:  GOTO   1C1
....................         case '1': RETURN 1; 
0193:  MOVLW  01
0194:  MOVWF  78
0195:  GOTO   1C4
....................         BREAK; 
0196:  BSF    03.5
0197:  GOTO   1C1
....................         case '2': RETURN 2; 
0198:  MOVLW  02
0199:  MOVWF  78
019A:  GOTO   1C4
....................         BREAK; 
019B:  BSF    03.5
019C:  GOTO   1C1
....................         case '3': RETURN 3; 
019D:  MOVLW  03
019E:  MOVWF  78
019F:  GOTO   1C4
....................         BREAK; 
01A0:  BSF    03.5
01A1:  GOTO   1C1
....................         case '4': RETURN 4; 
01A2:  MOVLW  04
01A3:  MOVWF  78
01A4:  GOTO   1C4
....................         BREAK; 
01A5:  BSF    03.5
01A6:  GOTO   1C1
....................         case '5': RETURN 5; 
01A7:  MOVLW  05
01A8:  MOVWF  78
01A9:  GOTO   1C4
....................         BREAK; 
01AA:  BSF    03.5
01AB:  GOTO   1C1
....................         case '6': RETURN 6; 
01AC:  MOVLW  06
01AD:  MOVWF  78
01AE:  GOTO   1C4
....................         BREAK; 
01AF:  BSF    03.5
01B0:  GOTO   1C1
....................         case '7': RETURN 7; 
01B1:  MOVLW  07
01B2:  MOVWF  78
01B3:  GOTO   1C4
....................         BREAK; 
01B4:  BSF    03.5
01B5:  GOTO   1C1
....................         case '8': RETURN 8; 
01B6:  MOVLW  08
01B7:  MOVWF  78
01B8:  GOTO   1C4
....................         BREAK; 
01B9:  BSF    03.5
01BA:  GOTO   1C1
....................         case '9': RETURN 9; 
01BB:  MOVLW  09
01BC:  MOVWF  78
01BD:  GOTO   1C4
....................         BREAK; 
01BE:  BSF    03.5
01BF:  GOTO   1C1
01C0:  BSF    03.5
....................     } 
....................  
....................     RETURN 0; 
01C1:  MOVLW  00
01C2:  MOVWF  78
01C3:  BCF    03.5
01C4:  RETURN
.................... } 
....................  
.................... void doReset(VOID) { 
....................     i2c_send(I2C_TIMER, I2C_CMD_RESET); 
*
0EBA:  MOVLW  0A
0EBB:  MOVWF  44
0EBC:  MOVLW  FD
0EBD:  MOVWF  45
0EBE:  BCF    0A.3
0EBF:  BCF    03.5
0EC0:  CALL   2B0
0EC1:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0EC2:  MOVLW  32
0EC3:  BSF    03.5
0EC4:  MOVWF  40
0EC5:  BCF    0A.3
0EC6:  BCF    03.5
0EC7:  CALL   2D2
0EC8:  BSF    0A.3
....................     i2c_send(I2C_SCORE, I2C_CMD_RESET); 
0EC9:  MOVLW  0C
0ECA:  BSF    03.5
0ECB:  MOVWF  44
0ECC:  MOVLW  FD
0ECD:  MOVWF  45
0ECE:  BCF    0A.3
0ECF:  BCF    03.5
0ED0:  CALL   2B0
0ED1:  BSF    0A.3
....................     reset_cpu(); 
0ED2:  CLRF   0A
0ED3:  GOTO   000
.................... } 
....................  
.................... void sendN2Port(INT8 n, int8 a, int8 p) { 
*
02C3:  BSF    03.5
02C4:  SWAPF  42,W
02C5:  MOVWF  77
02C6:  MOVLW  F0
02C7:  ANDWF  77,F
02C8:  MOVF   77,W
02C9:  ADDWF  40,W
02CA:  MOVWF  43
....................     INT c = (p * 16) + n; 
....................     i2c_send(a, c); 
02CB:  MOVF   41,W
02CC:  MOVWF  44
02CD:  MOVF   43,W
02CE:  MOVWF  45
02CF:  BCF    03.5
02D0:  CALL   2B0
02D1:  RETURN
.................... } 
....................  
.................... void i2c_send(INT8 a, int8 c) { 
....................     i2c_start(); 
*
02B0:  BSF    03.5
02B1:  BSF    11.0
02B2:  BTFSC  11.0
02B3:  GOTO   2B2
....................     i2c_write(a); 
02B4:  MOVF   44,W
02B5:  MOVWF  46
02B6:  BCF    03.5
02B7:  CALL   289
....................     i2c_write(c); 
02B8:  BSF    03.5
02B9:  MOVF   45,W
02BA:  MOVWF  46
02BB:  BCF    03.5
02BC:  CALL   289
....................     i2c_stop(); 
02BD:  BSF    03.5
02BE:  BSF    11.2
02BF:  BTFSC  11.2
02C0:  GOTO   2BF
02C1:  BCF    03.5
02C2:  RETURN
.................... } 

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

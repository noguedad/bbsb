CCS PCM C Compiler, Version 5.076, 56587               23-mar.-22 19:13

               Filename:   C:\Users\nogue\Proyectos\bbsb\mcoms\mcoms.lst

               ROM used:   3669 words (45%)
                           Largest free fragment is 2048
               RAM used:   69 (19%) at main() level
                           100 (27%) worst case
               Stack used: 6 locations (1 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  07
0001:  MOVWF  0A
0002:  GOTO   756
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   397
....................  
....................  
.................... /**:COPYRIGHT 
....................             _ /      _ /  
....................         _ /_ /_ /  _/_/ 
....................          _ /       _ /  
....................         _ /       _ /  
....................        _ / _ / _/_ / _ / 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo APM 
....................      
....................  */ 
.................... // * AUTOR: Victor Noguedad 
.................... // * ARCHIVO: mscoms.c 
.................... // * RESUMEN: Programa principal del modulo de comunicaciones 
.................... // ::[CABECERAS]:: 
.................... #include <mcoms.h> 
.................... /**:COPYRIGHT 
....................  
....................            _/       _/ 
....................         _/_/_/   _/_/ 
....................          _/       _/ 
....................         _/       _/ 
....................        _/_/   _/_/_/ 
....................      
....................    t1soluciones © 2020 
....................           PARA 
....................        Grupo  APM 
....................      
....................  */ 
....................  
.................... // *AUTOR:    Victor Noguedad 
.................... // *ARCHIVO:  mscoms.c 
.................... // *RESUMEN:  Programa principal del modulo de comunicaciones 
....................  
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  00
0056:  RETLW  00
0057:  RETLW  00
0058:  RETLW  00
0059:  RETLW  00
005A:  RETLW  00
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  00
005F:  DATA 2A,15
0060:  DATA 2A,15
0061:  DATA 2A,15
0062:  DATA 2A,15
0063:  DATA 2A,15
0064:  DATA 2A,15
0065:  DATA 2A,15
0066:  DATA 2A,15
0067:  DATA 2A,15
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 0D,00
0070:  DATA A0,23
0071:  DATA F2,3A
0072:  DATA F0,37
0073:  DATA A0,20
0074:  DATA D0,26
0075:  DATA 20,14
0076:  DATA E3,14
0077:  DATA 20,19
0078:  DATA 30,19
0079:  DATA 30,10
007A:  DATA 0D,00
007B:  DATA BD,1E
007C:  DATA BD,1E
007D:  DATA BD,1E
007E:  DATA BD,1E
007F:  DATA BD,1E
0080:  DATA BD,1E
0081:  DATA BD,1E
0082:  DATA BD,1E
0083:  DATA BD,1E
0084:  DATA BD,1E
0085:  DATA BD,1E
0086:  DATA BD,1E
0087:  DATA BD,1E
0088:  DATA BD,1E
0089:  DATA BD,1E
008A:  DATA BD,1E
008B:  DATA 0D,00
008C:  DATA 42,36
008D:  DATA F5,32
008E:  DATA F4,37
008F:  DATA 6F,3A
0090:  DATA 68,10
0091:  DATA C2,30
0092:  DATA F3,35
0093:  DATA 65,3A
0094:  DATA E2,30
0095:  DATA 6C,36
0096:  DATA A0,29
0097:  DATA E3,37
0098:  DATA F2,32
0099:  DATA 20,21
009A:  DATA EF,30
009B:  DATA 72,32
009C:  DATA 0D,00
009D:  DATA BD,1E
009E:  DATA BD,1E
009F:  DATA BD,1E
00A0:  DATA BD,1E
00A1:  DATA BD,1E
00A2:  DATA BD,1E
00A3:  DATA BD,1E
00A4:  DATA BD,1E
00A5:  DATA BD,1E
00A6:  DATA BD,1E
00A7:  DATA BD,1E
00A8:  DATA BD,1E
00A9:  DATA BD,1E
00AA:  DATA BD,1E
00AB:  DATA BD,1E
00AC:  DATA BD,1E
00AD:  DATA 0D,00
00AE:  DATA D6,32
00AF:  DATA F2,39
00B0:  DATA E9,37
00B1:  DATA 6E,10
00B2:  DATA A5,39
00B3:  DATA A0,16
00B4:  DATA 20,39
00B5:  DATA 65,3B
00B6:  DATA A0,12
00B7:  DATA 73,10
00B8:  DATA 0D,00
00B9:  DATA 32,17
00BA:  DATA 30,00
00BB:  DATA 46,00
00BC:  DATA 2A,15
00BD:  DATA 2A,15
00BE:  DATA 2A,15
00BF:  DATA 2A,15
00C0:  DATA 2A,15
00C1:  DATA 2A,15
00C2:  DATA 2A,15
00C3:  DATA 2A,15
00C4:  DATA 2A,15
00C5:  DATA 2A,15
00C6:  DATA 2A,15
00C7:  DATA 2A,15
00C8:  DATA 2A,15
00C9:  DATA 2A,15
00CA:  DATA 2A,15
00CB:  DATA 2A,15
00CC:  DATA 0D,00
00CD:  DATA 20,22
00CE:  DATA 45,28
00CF:  DATA 55,29
00D0:  DATA C1,21
00D1:  DATA C9,27
00D2:  DATA 4E,10
00D3:  DATA 3A,1D
00D4:  DATA A0,21
00D5:  DATA CF,26
00D6:  DATA 55,27
00D7:  DATA C9,21
00D8:  DATA C1,21
00D9:  DATA C9,27
00DA:  DATA CE,22
00DB:  DATA 53,10
00DC:  DATA 0D,00
00DD:  DATA 20,1F
00DE:  DATA A0,21
00DF:  DATA 6F,37
00E0:  DATA E6,34
00E1:  DATA E7,3A
00E2:  DATA F2,30
00E3:  DATA E3,34
00E4:  DATA 6F,37
00E5:  DATA 20,32
00E6:  DATA 65,10
00E7:  DATA D0,3A
00E8:  DATA 65,39
00E9:  DATA F4,37
00EA:  DATA 73,00
00EB:  DATA 20,1F
00EC:  DATA A0,24
00ED:  DATA EE,34
00EE:  DATA E3,34
00EF:  DATA 61,36
00F0:  DATA 69,3D
00F1:  DATA E1,31
00F2:  DATA E9,37
00F3:  DATA 6E,10
00F4:  DATA E4,32
00F5:  DATA A0,24
00F6:  DATA B2,21
00F7:  DATA 00,01
00F8:  DATA 20,1F
00F9:  DATA 20,24
00FA:  DATA 61,31
00FB:  DATA 69,36
00FC:  DATA 69,3A
00FD:  DATA E1,31
00FE:  DATA E9,37
00FF:  DATA 6E,10
0100:  DATA E4,32
0101:  DATA 20,32
0102:  DATA E9,39
0103:  DATA 70,36
0104:  DATA E1,3C
0105:  DATA 73,00
0106:  DATA 20,1F
0107:  DATA 20,24
0108:  DATA 61,31
0109:  DATA 69,36
010A:  DATA 69,3A
010B:  DATA E1,31
010C:  DATA E9,37
010D:  DATA 6E,10
010E:  DATA E4,32
010F:  DATA A0,34
0110:  DATA 6E,3A
0111:  DATA 65,39
0112:  DATA F2,3A
0113:  DATA F0,31
0114:  DATA E9,37
0115:  DATA EE,32
0116:  DATA 73,00
0117:  MOVF   0B,W
0118:  MOVWF  71
0119:  BCF    0B.7
011A:  BSF    03.5
011B:  BSF    03.6
011C:  BSF    0C.7
011D:  BSF    0C.0
011E:  NOP
011F:  NOP
0120:  BTFSS  71.7
0121:  GOTO   127
0122:  BCF    03.5
0123:  BCF    03.6
0124:  BSF    0B.7
0125:  BSF    03.5
0126:  BSF    03.6
0127:  BCF    03.5
0128:  MOVF   0C,W
0129:  ANDLW  7F
012A:  BTFSC  03.2
012B:  GOTO   167
012C:  MOVWF  71
012D:  MOVF   0D,W
012E:  MOVWF  72
012F:  MOVF   0F,W
0130:  MOVWF  73
0131:  MOVF   71,W
0132:  BCF    03.6
0133:  BTFSS  0C.4
0134:  GOTO   133
0135:  MOVWF  19
0136:  MOVF   72,W
0137:  BSF    03.6
0138:  MOVWF  0D
0139:  MOVF   73,W
013A:  MOVWF  0F
013B:  BCF    03.6
013C:  MOVF   0B,W
013D:  MOVWF  74
013E:  BCF    0B.7
013F:  BSF    03.5
0140:  BSF    03.6
0141:  BSF    0C.7
0142:  BSF    0C.0
0143:  NOP
0144:  NOP
0145:  BTFSS  74.7
0146:  GOTO   14C
0147:  BCF    03.5
0148:  BCF    03.6
0149:  BSF    0B.7
014A:  BSF    03.5
014B:  BSF    03.6
014C:  BCF    03.5
014D:  RLF    0C,W
014E:  RLF    0E,W
014F:  ANDLW  7F
0150:  BTFSC  03.2
0151:  GOTO   167
0152:  MOVWF  71
0153:  MOVF   0D,W
0154:  MOVWF  72
0155:  MOVF   0F,W
0156:  MOVWF  73
0157:  MOVF   71,W
0158:  BCF    03.6
0159:  BTFSS  0C.4
015A:  GOTO   159
015B:  MOVWF  19
015C:  MOVF   72,W
015D:  BSF    03.6
015E:  MOVWF  0D
015F:  MOVF   73,W
0160:  MOVWF  0F
0161:  INCF   0D,F
0162:  BTFSC  03.2
0163:  INCF   0F,F
0164:  BCF    03.6
0165:  GOTO   117
0166:  BSF    03.6
0167:  BCF    03.6
0168:  RETURN
*
019A:  BSF    0A.0
019B:  BCF    0A.1
019C:  BCF    0A.2
019D:  ADDWF  02,F
019E:  GOTO   170
019F:  GOTO   174
01A0:  GOTO   178
01A1:  GOTO   17C
01A2:  GOTO   180
01A3:  GOTO   184
01A4:  GOTO   188
01A5:  GOTO   18C
01A6:  GOTO   190
01A7:  GOTO   194
01A8:  MOVF   7B,W
01A9:  ANDLW  07
01AA:  MOVWF  77
01AB:  RRF    7B,W
01AC:  MOVWF  78
01AD:  RRF    78,F
01AE:  RRF    78,F
01AF:  MOVLW  1F
01B0:  ANDWF  78,F
01B1:  MOVF   78,W
01B2:  ADDWF  7D,W
01B3:  MOVWF  04
01B4:  BCF    03.7
01B5:  BTFSC  7E.0
01B6:  BSF    03.7
01B7:  CLRF   78
01B8:  INCF   78,F
01B9:  INCF   77,F
01BA:  GOTO   1BC
01BB:  RLF    78,F
01BC:  DECFSZ 77,F
01BD:  GOTO   1BB
01BE:  MOVF   7C,F
01BF:  BTFSC  03.2
01C0:  GOTO   1C4
01C1:  MOVF   78,W
01C2:  IORWF  00,F
01C3:  GOTO   1C7
01C4:  COMF   78,F
01C5:  MOVF   78,W
01C6:  ANDWF  00,F
01C7:  RETURN
*
0233:  BCF    0A.0
0234:  BSF    0A.1
0235:  BCF    0A.2
0236:  ADDWF  02,F
0237:  GOTO   1D3
0238:  GOTO   1D5
0239:  GOTO   1D7
023A:  GOTO   1DA
023B:  GOTO   1DC
023C:  GOTO   1DF
023D:  GOTO   1E2
023E:  GOTO   1E6
023F:  GOTO   1E8
*
03E9:  DATA 20,1F
03EA:  DATA 20,29
03EB:  DATA 75,3A
03EC:  DATA 69,37
03ED:  DATA 61,10
03EE:  DATA E4,32
03EF:  DATA 20,38
03F0:  DATA F2,3A
03F1:  DATA 65,31
03F2:  DATA 61,00
03F3:  DATA 20,1F
03F4:  DATA 20,28
03F5:  DATA F2,37
03F6:  DATA E2,30
03F7:  DATA 6E,32
03F8:  DATA 6F,10
03F9:  DATA ED,37
03FA:  DATA E4,3A
03FB:  DATA EC,37
03FC:  DATA 20,3A
03FD:  DATA E9,32
03FE:  DATA 6D,38
03FF:  DATA 6F,00
0400:  DATA 20,1F
0401:  DATA 20,28
0402:  DATA F2,37
0403:  DATA E2,30
0404:  DATA 6E,32
0405:  DATA 6F,10
0406:  DATA ED,37
0407:  DATA E4,3A
0408:  DATA EC,37
0409:  DATA 20,38
040A:  DATA 75,37
040B:  DATA F4,37
040C:  DATA 73,00
040D:  DATA 20,1F
040E:  DATA 20,28
040F:  DATA F2,37
0410:  DATA E2,30
0411:  DATA 6E,32
0412:  DATA 6F,10
0413:  DATA ED,37
0414:  DATA E4,3A
0415:  DATA EC,37
0416:  DATA A0,31
0417:  DATA EF,36
0418:  DATA 75,37
0419:  DATA E9,31
041A:  DATA E1,31
041B:  DATA E9,37
041C:  DATA EE,32
041D:  DATA 73,00
041E:  DATA 0D,10
041F:  DATA 3E,10
0420:  DATA C1,31
0421:  DATA F4,34
0422:  DATA F6,30
0423:  DATA E3,34
0424:  DATA 6F,37
0425:  DATA A0,36
0426:  DATA 61,37
0427:  DATA F5,30
0428:  DATA 6C,10
0429:  DATA E4,32
042A:  DATA 20,38
042B:  DATA F5,32
042C:  DATA 72,3A
042D:  DATA 6F,00
042E:  DATA 0D,10
042F:  DATA 3E,10
0430:  DATA D4,37
0431:  DATA F1,3A
0432:  DATA 65,10
0433:  DATA E3,37
0434:  DATA 72,3A
0435:  DATA 6F,00
0436:  DATA 0D,10
0437:  DATA 3E,10
0438:  DATA D4,37
0439:  DATA F1,3A
043A:  DATA 65,10
043B:  DATA EC,30
043C:  DATA F2,33
043D:  DATA 6F,00
043E:  DATA 0D,10
043F:  DATA 3E,10
0440:  DATA D4,37
0441:  DATA F1,3A
0442:  DATA 65,10
0443:  DATA E4,37
0444:  DATA 62,36
0445:  DATA 65,00
0446:  DATA 0D,10
0447:  DATA 3E,10
0448:  DATA C1,39
0449:  DATA E9,33
044A:  DATA EE,30
044B:  DATA 72,10
044C:  DATA E6,30
044D:  DATA 6C,3A
044E:  DATA E1,39
044F:  DATA 00,01
0450:  DATA 0D,10
0451:  DATA 3E,10
0452:  DATA C1,39
0453:  DATA E9,33
0454:  DATA EE,30
0455:  DATA 72,10
0456:  DATA EA,3A
0457:  DATA E7,30
0458:  DATA E4,37
0459:  DATA 72,00
045A:  DATA 0D,10
045B:  DATA 3E,10
045C:  DATA D2,32
045D:  DATA F3,32
045E:  DATA F4,32
045F:  DATA 61,10
0460:  DATA 61,10
0461:  DATA 30,00
0462:  DATA 0D,10
0463:  DATA 3E,10
0464:  DATA 49,37
0465:  DATA 63,39
0466:  DATA E5,36
0467:  DATA 65,37
0468:  DATA F4,30
0469:  DATA 72,10
046A:  DATA F0,37
046B:  DATA 72,10
046C:  DATA 31,00
046D:  DATA 0D,10
046E:  DATA 3E,10
046F:  DATA 49,37
0470:  DATA 63,39
0471:  DATA E5,36
0472:  DATA 65,37
0473:  DATA F4,30
0474:  DATA 72,10
0475:  DATA F0,37
0476:  DATA 72,10
0477:  DATA 32,00
0478:  DATA 0D,10
0479:  DATA 3E,10
047A:  DATA 49,37
047B:  DATA 63,39
047C:  DATA E5,36
047D:  DATA 65,37
047E:  DATA F4,30
047F:  DATA 72,10
0480:  DATA F0,37
0481:  DATA 72,10
0482:  DATA 33,00
0483:  DATA 0D,10
0484:  DATA 3E,10
0485:  DATA C4,32
0486:  DATA 63,39
0487:  DATA E5,36
0488:  DATA 65,37
0489:  DATA F4,30
048A:  DATA 72,10
048B:  DATA F0,37
048C:  DATA 72,10
048D:  DATA 31,00
048E:  DATA 0D,10
048F:  DATA 3E,10
0490:  DATA C1,39
0491:  DATA E9,33
0492:  DATA EE,30
0493:  DATA 72,10
0494:  DATA E6,30
0495:  DATA 6C,3A
0496:  DATA E1,39
0497:  DATA 00,01
0498:  DATA 0D,10
0499:  DATA 3E,10
049A:  DATA 49,37
049B:  DATA E9,31
049C:  DATA E9,30
049D:  DATA EC,34
049E:  DATA FA,30
049F:  DATA 72,00
04A0:  DATA 0D,10
04A1:  DATA 3E,10
04A2:  DATA C1,39
04A3:  DATA E9,33
04A4:  DATA EE,30
04A5:  DATA 72,10
04A6:  DATA F0,37
04A7:  DATA F3,34
04A8:  DATA E3,34
04A9:  DATA 6F,37
04AA:  DATA 00,01
04AB:  DATA 0D,10
04AC:  DATA 3E,10
04AD:  DATA D0,30
04AE:  DATA F5,39
04AF:  DATA 61,39
04B0:  DATA 20,3A
04B1:  DATA E9,32
04B2:  DATA 6D,38
04B3:  DATA 6F,00
04B4:  DATA 0D,10
04B5:  DATA 3E,10
04B6:  DATA D2,32
04B7:  DATA EE,3A
04B8:  DATA E4,30
04B9:  DATA 72,10
04BA:  DATA F4,34
04BB:  DATA E5,36
04BC:  DATA F0,37
04BD:  DATA 00,01
04BE:  DATA 0D,10
04BF:  DATA 3E,10
04C0:  DATA 41,38
04C1:  DATA E1,33
04C2:  DATA 61,39
04C3:  DATA 20,28
04C4:  DATA 65,39
04C5:  DATA E9,37
04C6:  DATA E4,37
04C7:  DATA 73,00
04C8:  DATA 0D,10
04C9:  DATA 3E,10
04CA:  DATA D0,32
04CB:  DATA F2,34
04CC:  DATA 6F,32
04CD:  DATA 6F,10
04CE:  DATA 31,00
04CF:  DATA 0D,10
04D0:  DATA 3E,10
04D1:  DATA D0,32
04D2:  DATA F2,34
04D3:  DATA 6F,32
04D4:  DATA 6F,10
04D5:  DATA 32,00
04D6:  DATA 0D,10
04D7:  DATA 3E,10
04D8:  DATA D0,32
04D9:  DATA F2,34
04DA:  DATA 6F,32
04DB:  DATA 6F,10
04DC:  DATA 33,00
04DD:  DATA 0D,10
04DE:  DATA 3E,10
04DF:  DATA D0,32
04E0:  DATA F2,34
04E1:  DATA 6F,32
04E2:  DATA 6F,10
04E3:  DATA 34,00
04E4:  DATA 0D,10
04E5:  DATA 3E,10
04E6:  DATA D2,32
04E7:  DATA F3,32
04E8:  DATA F4,32
04E9:  DATA 61,10
04EA:  DATA 61,10
04EB:  DATA 30,00
04EC:  DATA 0D,10
04ED:  DATA 3E,10
04EE:  DATA 49,37
04EF:  DATA 63,39
04F0:  DATA E5,36
04F1:  DATA 65,37
04F2:  DATA F4,30
04F3:  DATA 72,10
04F4:  DATA F0,37
04F5:  DATA 72,10
04F6:  DATA 31,00
04F7:  DATA 0D,10
04F8:  DATA 3E,10
04F9:  DATA 49,37
04FA:  DATA 63,39
04FB:  DATA E5,36
04FC:  DATA 65,37
04FD:  DATA F4,30
04FE:  DATA 72,10
04FF:  DATA F0,37
0500:  DATA 72,10
0501:  DATA 32,00
0502:  DATA 0D,10
0503:  DATA 3E,10
0504:  DATA 49,37
0505:  DATA 63,39
0506:  DATA E5,36
0507:  DATA 65,37
0508:  DATA F4,30
0509:  DATA 72,10
050A:  DATA F0,37
050B:  DATA 72,10
050C:  DATA 33,00
050D:  DATA 0D,10
050E:  DATA 3E,10
050F:  DATA C4,32
0510:  DATA 63,39
0511:  DATA E5,36
0512:  DATA 65,37
0513:  DATA F4,30
0514:  DATA 72,10
0515:  DATA F0,37
0516:  DATA 72,10
0517:  DATA 31,00
0518:  DATA 0D,10
0519:  DATA 3E,10
051A:  DATA C1,39
051B:  DATA E9,33
051C:  DATA EE,30
051D:  DATA 72,10
051E:  DATA E6,30
051F:  DATA 6C,3A
0520:  DATA E1,39
0521:  DATA 00,01
0522:  DATA 0D,10
0523:  DATA 3E,10
0524:  DATA 49,37
0525:  DATA E9,31
0526:  DATA E9,30
0527:  DATA EC,34
0528:  DATA FA,30
0529:  DATA 72,00
052A:  DATA 0D,10
052B:  DATA 3E,10
052C:  DATA C1,39
052D:  DATA E9,33
052E:  DATA EE,30
052F:  DATA 72,10
0530:  DATA F0,37
0531:  DATA F3,34
0532:  DATA E3,34
0533:  DATA 6F,37
0534:  DATA 00,01
0535:  DATA 0D,10
0536:  DATA 3E,10
0537:  DATA D2,32
0538:  DATA F3,32
0539:  DATA F4,32
053A:  DATA 6F,10
053B:  DATA E7,32
053C:  DATA EE,32
053D:  DATA F2,30
053E:  DATA 6C,17
053F:  DATA 2E,17
0540:  DATA A0,10
0541:  DATA 20,00
0542:  DATA 0D,10
0543:  DATA 3E,10
0544:  DATA C3,37
0545:  DATA 6E,33
0546:  DATA E9,33
0547:  DATA 75,39
0548:  DATA E1,31
0549:  DATA E9,37
054A:  DATA 6E,10
054B:  DATA E4,32
054C:  DATA 20,3A
054D:  DATA 69,39
054E:  DATA 6F,00
054F:  DATA 0D,10
0550:  DATA 3E,10
0551:  DATA C3,37
0552:  DATA 6E,33
0553:  DATA E9,33
0554:  DATA 75,39
0555:  DATA E1,31
0556:  DATA E9,37
0557:  DATA 6E,10
0558:  DATA E4,32
0559:  DATA 20,3A
055A:  DATA E9,32
055B:  DATA 6D,38
055C:  DATA 6F,00
055D:  MOVF   0B,W
055E:  MOVWF  60
055F:  BCF    0B.7
0560:  BSF    03.5
0561:  BSF    03.6
0562:  BSF    0C.7
0563:  BSF    0C.0
0564:  NOP
0565:  NOP
0566:  BCF    03.5
0567:  BCF    03.6
0568:  BTFSC  60.7
0569:  BSF    0B.7
056A:  BSF    03.6
056B:  MOVF   0C,W
056C:  ANDLW  7F
056D:  BTFSC  03.2
056E:  GOTO   5B3
056F:  BCF    03.6
0570:  MOVWF  60
0571:  BSF    03.6
0572:  MOVF   0D,W
0573:  BCF    03.6
0574:  MOVWF  61
0575:  BSF    03.6
0576:  MOVF   0F,W
0577:  BCF    03.6
0578:  MOVWF  62
0579:  MOVF   60,W
057A:  BTFSS  0C.4
057B:  GOTO   57A
057C:  MOVWF  19
057D:  MOVF   61,W
057E:  BSF    03.6
057F:  MOVWF  0D
0580:  BCF    03.6
0581:  MOVF   62,W
0582:  BSF    03.6
0583:  MOVWF  0F
0584:  BCF    03.6
0585:  MOVF   0B,W
0586:  MOVWF  63
0587:  BCF    0B.7
0588:  BSF    03.5
0589:  BSF    03.6
058A:  BSF    0C.7
058B:  BSF    0C.0
058C:  NOP
058D:  NOP
058E:  BCF    03.5
058F:  BCF    03.6
0590:  BTFSC  63.7
0591:  BSF    0B.7
0592:  BSF    03.6
0593:  RLF    0C,W
0594:  RLF    0E,W
0595:  ANDLW  7F
0596:  BTFSC  03.2
0597:  GOTO   5B3
0598:  BCF    03.6
0599:  MOVWF  60
059A:  BSF    03.6
059B:  MOVF   0D,W
059C:  BCF    03.6
059D:  MOVWF  61
059E:  BSF    03.6
059F:  MOVF   0F,W
05A0:  BCF    03.6
05A1:  MOVWF  62
05A2:  MOVF   60,W
05A3:  BTFSS  0C.4
05A4:  GOTO   5A3
05A5:  MOVWF  19
05A6:  MOVF   61,W
05A7:  BSF    03.6
05A8:  MOVWF  0D
05A9:  BCF    03.6
05AA:  MOVF   62,W
05AB:  BSF    03.6
05AC:  MOVWF  0F
05AD:  INCF   0D,F
05AE:  BTFSC  03.2
05AF:  INCF   0F,F
05B0:  BCF    03.6
05B1:  GOTO   55D
05B2:  BSF    03.6
05B3:  BCF    03.6
05B4:  RETURN
05B5:  MOVF   0B,W
05B6:  MOVWF  61
05B7:  BCF    0B.7
05B8:  BSF    03.5
05B9:  BSF    03.6
05BA:  BSF    0C.7
05BB:  BSF    0C.0
05BC:  NOP
05BD:  NOP
05BE:  BCF    03.5
05BF:  BCF    03.6
05C0:  BTFSC  61.7
05C1:  BSF    0B.7
05C2:  BTFSC  03.0
05C3:  GOTO   5ED
05C4:  BSF    03.6
05C5:  MOVF   0C,W
05C6:  ANDLW  7F
05C7:  BCF    03.6
05C8:  MOVWF  61
05C9:  BSF    03.6
05CA:  MOVF   0D,W
05CB:  BCF    03.6
05CC:  MOVWF  62
05CD:  BSF    03.6
05CE:  MOVF   0F,W
05CF:  BCF    03.6
05D0:  MOVWF  63
05D1:  MOVF   61,W
05D2:  BTFSS  0C.4
05D3:  GOTO   5D2
05D4:  MOVWF  19
05D5:  MOVF   62,W
05D6:  BSF    03.6
05D7:  MOVWF  0D
05D8:  BCF    03.6
05D9:  MOVF   63,W
05DA:  BSF    03.6
05DB:  MOVWF  0F
05DC:  BCF    03.6
05DD:  MOVF   0B,W
05DE:  MOVWF  64
05DF:  BCF    0B.7
05E0:  BSF    03.5
05E1:  BSF    03.6
05E2:  BSF    0C.7
05E3:  BSF    0C.0
05E4:  NOP
05E5:  NOP
05E6:  BCF    03.5
05E7:  BCF    03.6
05E8:  BTFSC  64.7
05E9:  BSF    0B.7
05EA:  DECFSZ 60,F
05EB:  GOTO   5ED
05EC:  GOTO   60D
05ED:  BSF    03.6
05EE:  RLF    0C,W
05EF:  RLF    0E,W
05F0:  ANDLW  7F
05F1:  BCF    03.6
05F2:  MOVWF  61
05F3:  BSF    03.6
05F4:  MOVF   0D,W
05F5:  BCF    03.6
05F6:  MOVWF  62
05F7:  BSF    03.6
05F8:  MOVF   0F,W
05F9:  BCF    03.6
05FA:  MOVWF  63
05FB:  MOVF   61,W
05FC:  BTFSS  0C.4
05FD:  GOTO   5FC
05FE:  MOVWF  19
05FF:  MOVF   62,W
0600:  BSF    03.6
0601:  MOVWF  0D
0602:  BCF    03.6
0603:  MOVF   63,W
0604:  BSF    03.6
0605:  MOVWF  0F
0606:  INCF   0D,F
0607:  BTFSC  03.2
0608:  INCF   0F,F
0609:  BCF    03.0
060A:  BCF    03.6
060B:  DECFSZ 60,F
060C:  GOTO   5B5
060D:  RETURN
*
0E94:  BCF    0A.0
0E95:  BSF    0A.1
0E96:  BSF    0A.2
0E97:  ADDWF  02,F
0E98:  GOTO   05D
0E99:  GOTO   071
0E9A:  GOTO   085
0E9B:  GOTO   099
0E9C:  BCF    0A.0
0E9D:  BSF    0A.1
0E9E:  BSF    0A.2
0E9F:  ADDWF  02,F
0EA0:  GOTO   306
0EA1:  GOTO   323
0EA2:  GOTO   340
0EA3:  GOTO   35D
0EA4:  GOTO   37A
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... // ::[CONFIGURACION DE PIC]:: 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
0289:  MOVLW  7C
028A:  MOVWF  04
028B:  BCF    03.7
028C:  MOVF   00,W
028D:  BTFSC  03.2
028E:  GOTO   29C
028F:  MOVLW  02
0290:  MOVWF  78
0291:  CLRF   77
0292:  DECFSZ 77,F
0293:  GOTO   292
0294:  DECFSZ 78,F
0295:  GOTO   291
0296:  MOVLW  97
0297:  MOVWF  77
0298:  DECFSZ 77,F
0299:  GOTO   298
029A:  DECFSZ 00,F
029B:  GOTO   28F
029C:  RETURN
....................  
.................... // ::[CONFIGURACION DE IO]:: 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E0 ) 
....................  
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_C2) 
....................  
.................... // ::[CONFIGURACION PUERTOS]:: 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... //#use i2c    (Master,Fast,sda=I2C_SDA,scl=I2C_SCL) 
.................... #use i2c    (master, scl=I2C_SCL, sda=I2C_SDA, fast) 
*
0240:  BCF    14.7
0241:  BCF    0C.3
0242:  BSF    03.5
0243:  MOVF   23,W
0244:  BCF    03.5
0245:  MOVWF  13
0246:  MOVLW  02
0247:  BTFSC  14.7
0248:  GOTO   250
0249:  BTFSS  0C.3
024A:  GOTO   249
024B:  MOVLW  00
024C:  BSF    03.5
024D:  BTFSC  11.6
024E:  MOVLW  01
024F:  BCF    03.5
0250:  MOVWF  78
0251:  RETURN
....................  
.................... // ::[DEFINICIONES]:: 
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
.................... #define I2C_CMD_PER0    0x70 
.................... #define I2C_CMD_PER1    0x71 
.................... #define I2C_CMD_PER2    0x72 
.................... #define I2C_CMD_PER3    0x73 
.................... #define I2C_CMD_PER4    0x74 
.................... #define I2C_CMD_MDON    0x75 
.................... #define I2C_CMD_MDOF    0x76 
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
.................... #define I2C_CMD_BUZ1    0x81 
.................... #define I2C_CMD_BUZ2    0x82 
.................... #define I2C_CMD_BUZ3    0x83 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       10 
.................... #define I2CWAIT         50 
....................  
.................... #define   PuertoA    1 
.................... #define   PuertoB    2 
.................... #define   PuertoC    3 
.................... #define   PuertoD    4 
.................... #define   PuertoE    5 
.................... #define   PuertoF    6 
....................  
.................... // ::[DECLARACIONES]:: 
.................... //Estructura para el puerto 
....................  
.................... typedef struct sPort { 
....................     int a; 
....................     int b; 
....................     int c; 
....................     int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char cmd[10] = "\0\0\0\0\0\0\0\0\0"; 
*
0796:  BCF    03.6
0797:  CLRF   2C
0798:  CLRF   2D
0799:  CLRF   2E
079A:  CLRF   2F
079B:  CLRF   30
079C:  CLRF   31
079D:  CLRF   32
079E:  CLRF   33
079F:  CLRF   34
07A0:  CLRF   35
.................... char rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
07A1:  CLRF   36
07A2:  CLRF   37
07A3:  CLRF   38
07A4:  CLRF   39
07A5:  CLRF   3A
07A6:  CLRF   3B
07A7:  CLRF   3C
07A8:  CLRF   3D
07A9:  CLRF   3E
07AA:  CLRF   3F
.................... int8 cmdIndex = 0; 
.................... int1 cmdGet = false; 
....................  
.................... //Puertos de Displays 
.................... tPort pNJugadorU; 
.................... tPort pNJugadorD; 
.................... tPort pFJugadorU; 
.................... tPort pFJugadorD; 
....................  
.................... //Tiempo 
.................... int8 m_d = 0; 
.................... int8 m_u = 0; 
.................... int8 s_d = 0; 
.................... int8 s_u = 0; 
....................  
.................... //Tiro 
.................... int8 sh_d = 0; 
.................... int8 sh_u = 0; 
....................  
.................... int8 scoreLU = 0; 
.................... int8 scoreLD = 0; 
.................... int1 scoreLC = 0; 
.................... int8 scoreVU = 0; 
.................... int8 scoreVD = 0; 
.................... int1 scoreVC = 0; 
....................  
.................... // ::[PROTOTIPOS]:: 
....................  
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8 char2int(char); 
.................... void doReset(void); 
.................... void sendN2Port(int8, int8, int8); 
.................... void timeSet(int8, int8, int8, int8); 
.................... void shotSet(int8, int8); 
.................... void doBuzz(int); 
.................... void setScoreL(int8, int8, int8); 
.................... void setScoreV(int8, int8, int8); 
.................... void i2c_send(int8, int8); 
.................... void addScoreL(int8); 
.................... void addScoreV(int8); 
.................... void resScoreL(void); 
.................... void resScoreV(void); 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
07AB:  CLRF   5C
07AC:  CLRF   5D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // *FUNCION:      setup() 
.................... // *PARAMETROS:   ninguno 
.................... // *REGRESA:      VOID 
.................... // *RESUMEN:      Configuracion inicial del dispositivo 
....................  
.................... void setup() { 
....................     output_a(0x00); 
*
060E:  MOVLW  0F
060F:  BSF    03.5
0610:  MOVWF  05
0611:  BCF    03.5
0612:  CLRF   05
....................     output_b(0x00); 
0613:  BSF    03.5
0614:  CLRF   06
0615:  BCF    03.5
0616:  CLRF   06
....................     output_c(0x00); 
0617:  MOVLW  DF
0618:  BSF    03.5
0619:  MOVWF  07
061A:  BCF    03.5
061B:  CLRF   07
....................     output_d(0x00); 
061C:  BSF    03.5
061D:  CLRF   08
061E:  BCF    03.5
061F:  CLRF   08
....................     output_e(0x00); 
0620:  BSF    03.5
0621:  BCF    09.0
0622:  BCF    09.1
0623:  BCF    09.2
0624:  BCF    09.3
0625:  BCF    03.5
0626:  CLRF   09
0627:  CLRF   2B
0628:  BTFSC  0B.7
0629:  BSF    2B.7
062A:  BCF    0B.7
....................  
....................     delay_ms(DEFAULT_D); 
062B:  MOVLW  0A
062C:  MOVWF  7C
062D:  CALL   289
062E:  BTFSC  2B.7
062F:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
0630:  BTFSS  07.2
0631:  GOTO   68D
....................         fprintf(RS232, "********************************\r"); 
0632:  MOVLW  5F
0633:  BSF    03.6
0634:  MOVWF  0D
0635:  MOVLW  00
0636:  MOVWF  0F
0637:  BCF    03.6
0638:  CALL   55D
....................         fprintf(RS232, " Grupo APM (c) 2020 \r"); 
0639:  MOVLW  70
063A:  BSF    03.6
063B:  MOVWF  0D
063C:  MOVLW  00
063D:  MOVWF  0F
063E:  BCF    03.6
063F:  CALL   55D
....................         fprintf(RS232, "================================\r"); 
0640:  MOVLW  7B
0641:  BSF    03.6
0642:  MOVWF  0D
0643:  MOVLW  00
0644:  MOVWF  0F
0645:  BCF    03.6
0646:  CALL   55D
....................         fprintf(RS232, "Bluetooth Basketball Score Board\r"); 
0647:  MOVLW  8C
0648:  BSF    03.6
0649:  MOVWF  0D
064A:  MOVLW  00
064B:  MOVWF  0F
064C:  BCF    03.6
064D:  CALL   55D
....................         fprintf(RS232, "================================\r"); 
064E:  MOVLW  9D
064F:  BSF    03.6
0650:  MOVWF  0D
0651:  MOVLW  00
0652:  MOVWF  0F
0653:  BCF    03.6
0654:  CALL   55D
....................         fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
0655:  MOVLW  AE
0656:  BSF    03.6
0657:  MOVWF  0D
0658:  MOVLW  00
0659:  MOVWF  0F
065A:  BCF    03.0
065B:  MOVLW  08
065C:  BCF    03.6
065D:  MOVWF  60
065E:  CALL   5B5
065F:  MOVLW  B9
0660:  BSF    03.6
0661:  MOVWF  0D
0662:  MOVLW  00
0663:  MOVWF  0F
0664:  BCF    03.6
0665:  CALL   55D
0666:  MOVLW  B3
0667:  BSF    03.6
0668:  MOVWF  0D
0669:  MOVLW  00
066A:  MOVWF  0F
066B:  BCF    03.0
066C:  MOVLW  07
066D:  BCF    03.6
066E:  MOVWF  60
066F:  CALL   5B5
0670:  MOVLW  BB
0671:  BSF    03.6
0672:  MOVWF  0D
0673:  MOVLW  00
0674:  MOVWF  0F
0675:  BCF    03.6
0676:  CALL   55D
0677:  MOVLW  20
0678:  BTFSS  0C.4
0679:  GOTO   678
067A:  MOVWF  19
067B:  MOVLW  0D
067C:  BTFSS  0C.4
067D:  GOTO   67C
067E:  MOVWF  19
....................         fprintf(RS232, "********************************\r"); 
067F:  MOVLW  BC
0680:  BSF    03.6
0681:  MOVWF  0D
0682:  MOVLW  00
0683:  MOVWF  0F
0684:  BCF    03.6
0685:  CALL   55D
....................         fprintf(RS232, " DEPURACION :: COMUNICACIONES \r"); 
0686:  MOVLW  CD
0687:  BSF    03.6
0688:  MOVWF  0D
0689:  MOVLW  00
068A:  MOVWF  0F
068B:  BCF    03.6
068C:  CALL   55D
068D:  CLRF   2B
068E:  BTFSC  0B.7
068F:  BSF    2B.7
0690:  BCF    0B.7
....................     } 
....................  
....................     delay_ms(DEFAULT_D); 
0691:  MOVLW  0A
0692:  MOVWF  7C
0693:  CALL   289
0694:  BTFSC  2B.7
0695:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
0696:  BTFSS  07.2
0697:  GOTO   6AD
....................         fputs(" > Configuracion de Puertos", RS232); 
0698:  MOVLW  DD
0699:  BSF    03.6
069A:  MOVWF  0D
069B:  MOVLW  00
069C:  MOVWF  0F
069D:  BCF    03.6
069E:  CLRF   2B
069F:  BTFSC  0B.7
06A0:  BSF    2B.7
06A1:  BCF    0B.7
06A2:  CALL   117
06A3:  BTFSC  2B.7
06A4:  BSF    0B.7
06A5:  MOVLW  0D
06A6:  BTFSS  0C.4
06A7:  GOTO   6A6
06A8:  MOVWF  19
06A9:  MOVLW  0A
06AA:  BTFSS  0C.4
06AB:  GOTO   6AA
06AC:  MOVWF  19
....................     } 
....................  
....................     pNJugadorU.a = PIN_B0; 
06AD:  MOVLW  30
06AE:  MOVWF  42
....................     pNJugadorU.b = PIN_B1; 
06AF:  MOVLW  31
06B0:  MOVWF  43
....................     pNJugadorU.c = PIN_B2; 
06B1:  MOVLW  32
06B2:  MOVWF  44
....................     pNJugadorU.d = PIN_B3; 
06B3:  MOVLW  33
06B4:  MOVWF  45
....................  
....................     pNJugadorD.a = PIN_B4; 
06B5:  MOVLW  34
06B6:  MOVWF  46
....................     pNJugadorD.b = PIN_B5; 
06B7:  MOVLW  35
06B8:  MOVWF  47
....................     pNJugadorD.c = PIN_B6; 
06B9:  MOVLW  36
06BA:  MOVWF  48
....................     pNJugadorD.d = PIN_B7; 
06BB:  MOVLW  37
06BC:  MOVWF  49
....................  
....................     pFJugadorU.a = PIN_D0; 
06BD:  MOVLW  40
06BE:  MOVWF  4A
....................     pFJugadorU.b = PIN_D1; 
06BF:  MOVLW  41
06C0:  MOVWF  4B
....................     pFJugadorU.c = PIN_D2; 
06C1:  MOVLW  42
06C2:  MOVWF  4C
....................     pFJugadorU.d = PIN_D3; 
06C3:  MOVLW  43
06C4:  MOVWF  4D
....................  
....................     pFJugadorD.a = PIN_D4; 
06C5:  MOVLW  44
06C6:  MOVWF  4E
....................     pFJugadorD.b = PIN_D5; 
06C7:  MOVLW  45
06C8:  MOVWF  4F
....................     pFJugadorD.c = PIN_D6; 
06C9:  MOVLW  46
06CA:  MOVWF  50
....................     pFJugadorD.d = PIN_D7; 
06CB:  MOVLW  47
06CC:  MOVWF  51
06CD:  CLRF   2B
06CE:  BTFSC  0B.7
06CF:  BSF    2B.7
06D0:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
06D1:  MOVLW  0A
06D2:  MOVWF  7C
06D3:  CALL   289
06D4:  BTFSC  2B.7
06D5:  BSF    0B.7
....................  
....................     IF(DEBUG) { 
06D6:  BTFSS  07.2
06D7:  GOTO   6ED
....................         fputs(" > Inicializacion de I2C", RS232); 
06D8:  MOVLW  EB
06D9:  BSF    03.6
06DA:  MOVWF  0D
06DB:  MOVLW  00
06DC:  MOVWF  0F
06DD:  BCF    03.6
06DE:  CLRF   2B
06DF:  BTFSC  0B.7
06E0:  BSF    2B.7
06E1:  BCF    0B.7
06E2:  CALL   117
06E3:  BTFSC  2B.7
06E4:  BSF    0B.7
06E5:  MOVLW  0D
06E6:  BTFSS  0C.4
06E7:  GOTO   6E6
06E8:  MOVWF  19
06E9:  MOVLW  0A
06EA:  BTFSS  0C.4
06EB:  GOTO   6EA
06EC:  MOVWF  19
....................     } 
....................     i2c_speed (100000) ; 
06ED:  MOVLW  13
06EE:  BSF    03.5
06EF:  MOVWF  13
06F0:  MOVLW  28
06F1:  BCF    03.5
06F2:  MOVWF  14
06F3:  BSF    03.5
06F4:  BSF    14.7
....................  
....................     IF(DEBUG) { 
06F5:  BCF    03.5
06F6:  BTFSS  07.2
06F7:  GOTO   70D
....................         fputs(" > Habilitacion de displays", RS232); 
06F8:  MOVLW  F8
06F9:  BSF    03.6
06FA:  MOVWF  0D
06FB:  MOVLW  00
06FC:  MOVWF  0F
06FD:  BCF    03.6
06FE:  CLRF   2B
06FF:  BTFSC  0B.7
0700:  BSF    2B.7
0701:  BCF    0B.7
0702:  CALL   117
0703:  BTFSC  2B.7
0704:  BSF    0B.7
0705:  MOVLW  0D
0706:  BTFSS  0C.4
0707:  GOTO   706
0708:  MOVWF  19
0709:  MOVLW  0A
070A:  BTFSS  0C.4
070B:  GOTO   70A
070C:  MOVWF  19
....................     } 
....................     output_bit(DISPLAY, ON); 
070D:  BSF    09.0
070E:  MOVLW  EE
070F:  BSF    03.5
0710:  MOVWF  09
0711:  BCF    03.5
0712:  CLRF   2B
0713:  BTFSC  0B.7
0714:  BSF    2B.7
0715:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
0716:  MOVLW  0A
0717:  MOVWF  7C
0718:  CALL   289
0719:  BTFSC  2B.7
071A:  BSF    0B.7
....................     output_bit(DISPLAY, OFF); 
071B:  BCF    09.0
071C:  MOVLW  EE
071D:  BSF    03.5
071E:  MOVWF  09
071F:  BCF    03.5
0720:  CLRF   2B
0721:  BTFSC  0B.7
0722:  BSF    2B.7
0723:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
0724:  MOVLW  0A
0725:  MOVWF  7C
0726:  CALL   289
0727:  BTFSC  2B.7
0728:  BSF    0B.7
....................     output_bit(DISPLAY, ON); 
0729:  BSF    09.0
072A:  MOVLW  EE
072B:  BSF    03.5
072C:  MOVWF  09
072D:  BCF    03.5
072E:  CLRF   2B
072F:  BTFSC  0B.7
0730:  BSF    2B.7
0731:  BCF    0B.7
....................     delay_ms(DEFAULT_D); 
0732:  MOVLW  0A
0733:  MOVWF  7C
0734:  CALL   289
0735:  BTFSC  2B.7
0736:  BSF    0B.7
....................  
....................     if (DEBUG) { 
0737:  BTFSS  07.2
0738:  GOTO   74E
....................         fputs(" > Habilitacion de interrupciones", RS232); 
0739:  MOVLW  06
073A:  BSF    03.6
073B:  MOVWF  0D
073C:  MOVLW  01
073D:  MOVWF  0F
073E:  BCF    03.6
073F:  CLRF   2B
0740:  BTFSC  0B.7
0741:  BSF    2B.7
0742:  BCF    0B.7
0743:  CALL   117
0744:  BTFSC  2B.7
0745:  BSF    0B.7
0746:  MOVLW  0D
0747:  BTFSS  0C.4
0748:  GOTO   747
0749:  MOVWF  19
074A:  MOVLW  0A
074B:  BTFSS  0C.4
074C:  GOTO   74B
074D:  MOVWF  19
....................     } 
....................     enable_interrupts(INT_RDA); 
074E:  BSF    03.5
074F:  BSF    0C.5
....................     enable_interrupts(GLOBAL); 
0750:  MOVLW  C0
0751:  BCF    03.5
0752:  IORWF  0B,F
0753:  BCF    0A.3
0754:  BCF    0A.4
0755:  GOTO   7AE (RETURN)
.................... } 
....................  
.................... void main() { 
0756:  MOVF   03,W
0757:  ANDLW  1F
0758:  MOVWF  03
0759:  MOVLW  71
075A:  BSF    03.5
075B:  MOVWF  0F
075C:  CLRF   10
075D:  MOVF   0F,W
075E:  BSF    03.6
075F:  BCF    07.3
0760:  MOVLW  0C
0761:  BCF    03.6
0762:  MOVWF  19
0763:  MOVLW  A2
0764:  MOVWF  18
0765:  MOVLW  90
0766:  BCF    03.5
0767:  MOVWF  18
0768:  MOVLW  DF
0769:  BSF    03.5
076A:  MOVWF  07
076B:  MOVLW  DF
076C:  MOVWF  07
076D:  MOVLW  04
076E:  MOVWF  13
076F:  MOVLW  28
0770:  BCF    03.5
0771:  MOVWF  14
0772:  BSF    03.5
0773:  BCF    14.7
0774:  BCF    14.6
0775:  BCF    03.5
0776:  CLRF   40
0777:  BCF    41.0
0778:  CLRF   52
0779:  CLRF   53
077A:  CLRF   54
077B:  CLRF   55
077C:  CLRF   56
077D:  CLRF   57
077E:  CLRF   58
077F:  CLRF   59
0780:  BCF    41.1
0781:  CLRF   5A
0782:  CLRF   5B
0783:  BCF    41.2
0784:  CLRF   5F
0785:  CLRF   5E
0786:  BSF    03.5
0787:  BSF    03.6
0788:  MOVF   09,W
0789:  ANDLW  C0
078A:  MOVWF  09
078B:  BCF    03.6
078C:  BCF    1F.4
078D:  BCF    1F.5
078E:  MOVLW  00
078F:  BSF    03.6
0790:  MOVWF  08
0791:  BCF    03.5
0792:  CLRF   07
0793:  CLRF   08
0794:  CLRF   09
0795:  BCF    03.7
....................     setup(); 
*
07AD:  GOTO   60E
....................  
....................     WHILE(TRUE) { 
07AE:  GOTO   7AE
....................     } 
.................... } 
....................  
.................... #INT_RDA 
.................... void RDA_isr(VOID) { 
07AF:  SLEEP
....................     CHAR c; 
....................     c = fgetc(RS232); 
*
0397:  BTFSS  0C.5
0398:  GOTO   397
0399:  MOVF   1A,W
039A:  MOVWF  65
....................  
....................     IF(cmdGet) { 
039B:  BTFSS  41.0
039C:  GOTO   3CF
....................  
....................         IF(c == '#' || c == '\r') { 
039D:  MOVF   65,W
039E:  SUBLW  23
039F:  BTFSC  03.2
03A0:  GOTO   3A5
03A1:  MOVF   65,W
03A2:  SUBLW  0D
03A3:  BTFSS  03.2
03A4:  GOTO   3C4
....................             cmdGet = false; 
03A5:  BCF    41.0
....................             strcpy(cmd, rcmd); 
03A6:  CLRF   69
03A7:  MOVLW  36
03A8:  MOVWF  68
03A9:  CLRF   67
03AA:  MOVLW  2C
03AB:  MOVWF  66
03AC:  MOVF   68,W
03AD:  MOVWF  04
03AE:  BCF    03.7
03AF:  BTFSC  69.0
03B0:  BSF    03.7
03B1:  MOVF   00,W
03B2:  MOVWF  6A
03B3:  MOVF   66,W
03B4:  MOVWF  04
03B5:  BCF    03.7
03B6:  BTFSC  67.0
03B7:  BSF    03.7
03B8:  MOVF   6A,W
03B9:  MOVWF  00
03BA:  MOVF   00,F
03BB:  BTFSC  03.2
03BC:  GOTO   3C0
03BD:  INCF   66,F
03BE:  INCF   68,F
03BF:  GOTO   3AC
....................             parseCommand(); 
03C0:  BSF    0A.3
03C1:  GOTO   000
03C2:  BCF    0A.3
....................         } 
03C3:  GOTO   3CF
....................  
....................         ELSE{ 
....................             IF(cmdIndex < 9) { 
03C4:  MOVF   40,W
03C5:  SUBLW  08
03C6:  BTFSS  03.0
03C7:  GOTO   3CF
....................                 rcmd[cmdIndex] = c; 
03C8:  MOVLW  36
03C9:  ADDWF  40,W
03CA:  MOVWF  04
03CB:  BCF    03.7
03CC:  MOVF   65,W
03CD:  MOVWF  00
....................                 cmdIndex++; 
03CE:  INCF   40,F
....................             } 
....................         } 
....................     } 
....................  
....................     IF(c == '-') { 
03CF:  MOVF   65,W
03D0:  SUBLW  2D
03D1:  BTFSS  03.2
03D2:  GOTO   3E5
....................         cmdGet = true; 
03D3:  BSF    41.0
....................         rcmd = "\0\0\0\0\0\0\0\0\0"; 
03D4:  CLRF   66
03D5:  CLRF   67
03D6:  MOVLW  36
03D7:  MOVWF  04
03D8:  BCF    03.7
03D9:  MOVF   66,W
03DA:  ADDWF  04,F
03DB:  MOVF   67,W
03DC:  CALL   051
03DD:  MOVWF  00
03DE:  IORLW  00
03DF:  BTFSC  03.2
03E0:  GOTO   3E4
03E1:  INCF   67,F
03E2:  INCF   66,F
03E3:  GOTO   3D6
....................         cmdIndex = 0; 
03E4:  CLRF   40
....................     } 
03E5:  BCF    0C.5
03E6:  BCF    0A.3
03E7:  BCF    0A.4
03E8:  GOTO   02D
.................... } 
....................  
.................... void doTest(VOID) { 
....................  
....................     IF(DEBUG) { 
*
0CFB:  BTFSS  07.2
0CFC:  GOTO   50E
....................         fputs(" > Rutina de prueba", RS232); 
0CFD:  MOVLW  E9
0CFE:  BSF    03.6
0CFF:  MOVWF  0D
0D00:  MOVLW  03
0D01:  MOVWF  0F
0D02:  BCF    0A.3
0D03:  BCF    03.6
0D04:  CALL   117
0D05:  BSF    0A.3
0D06:  MOVLW  0D
0D07:  BTFSS  0C.4
0D08:  GOTO   507
0D09:  MOVWF  19
0D0A:  MOVLW  0A
0D0B:  BTFSS  0C.4
0D0C:  GOTO   50B
0D0D:  MOVWF  19
....................     } 
....................  
....................     IF(DEBUG) { 
0D0E:  BTFSS  07.2
0D0F:  GOTO   521
....................         fputs(" > Probando modulo tiempo", RS232); 
0D10:  MOVLW  F3
0D11:  BSF    03.6
0D12:  MOVWF  0D
0D13:  MOVLW  03
0D14:  MOVWF  0F
0D15:  BCF    0A.3
0D16:  BCF    03.6
0D17:  CALL   117
0D18:  BSF    0A.3
0D19:  MOVLW  0D
0D1A:  BTFSS  0C.4
0D1B:  GOTO   51A
0D1C:  MOVWF  19
0D1D:  MOVLW  0A
0D1E:  BTFSS  0C.4
0D1F:  GOTO   51E
0D20:  MOVWF  19
....................     } 
....................     i2c_send(I2C_TIMER, I2C_CMD_TEST); 
0D21:  MOVLW  0A
0D22:  BSF    03.5
0D23:  MOVWF  21
0D24:  MOVLW  FF
0D25:  MOVWF  22
0D26:  BCF    0A.3
0D27:  BCF    03.5
0D28:  CALL   267
0D29:  BSF    0A.3
....................  
....................     IF(DEBUG) { 
0D2A:  BTFSS  07.2
0D2B:  GOTO   53D
....................         fputs(" > Probando modulo puntos", RS232); 
0D2C:  MOVLW  00
0D2D:  BSF    03.6
0D2E:  MOVWF  0D
0D2F:  MOVLW  04
0D30:  MOVWF  0F
0D31:  BCF    0A.3
0D32:  BCF    03.6
0D33:  CALL   117
0D34:  BSF    0A.3
0D35:  MOVLW  0D
0D36:  BTFSS  0C.4
0D37:  GOTO   536
0D38:  MOVWF  19
0D39:  MOVLW  0A
0D3A:  BTFSS  0C.4
0D3B:  GOTO   53A
0D3C:  MOVWF  19
....................     } 
....................     i2c_send(I2C_SCORE, I2C_CMD_TEST); 
0D3D:  MOVLW  0C
0D3E:  BSF    03.5
0D3F:  MOVWF  21
0D40:  MOVLW  FF
0D41:  MOVWF  22
0D42:  BCF    0A.3
0D43:  BCF    03.5
0D44:  CALL   267
0D45:  BSF    0A.3
....................  
....................     IF(DEBUG) { 
0D46:  BTFSS  07.2
0D47:  GOTO   559
....................         fputs(" > Probando modulo comunicaciones", RS232); 
0D48:  MOVLW  0D
0D49:  BSF    03.6
0D4A:  MOVWF  0D
0D4B:  MOVLW  04
0D4C:  MOVWF  0F
0D4D:  BCF    0A.3
0D4E:  BCF    03.6
0D4F:  CALL   117
0D50:  BSF    0A.3
0D51:  MOVLW  0D
0D52:  BTFSS  0C.4
0D53:  GOTO   552
0D54:  MOVWF  19
0D55:  MOVLW  0A
0D56:  BTFSS  0C.4
0D57:  GOTO   556
0D58:  MOVWF  19
....................     } 
....................     for (INT i = 0; i < 10; i++) { 
0D59:  CLRF   70
0D5A:  MOVF   70,W
0D5B:  SUBLW  09
0D5C:  BTFSS  03.0
0D5D:  GOTO   599
....................         showNumber(i, pNJugadorD); 
0D5E:  MOVF   70,W
0D5F:  MOVWF  71
0D60:  MOVF   49,W
0D61:  MOVWF  75
0D62:  MOVF   48,W
0D63:  MOVWF  74
0D64:  MOVF   47,W
0D65:  MOVWF  73
0D66:  MOVF   46,W
0D67:  MOVWF  72
0D68:  BCF    0A.3
0D69:  CALL   1C8
0D6A:  BSF    0A.3
....................         showNumber(i, pNJugadorU); 
0D6B:  MOVF   70,W
0D6C:  MOVWF  71
0D6D:  MOVF   45,W
0D6E:  MOVWF  75
0D6F:  MOVF   44,W
0D70:  MOVWF  74
0D71:  MOVF   43,W
0D72:  MOVWF  73
0D73:  MOVF   42,W
0D74:  MOVWF  72
0D75:  BCF    0A.3
0D76:  CALL   1C8
0D77:  BSF    0A.3
....................         showNumber(i, pFJugadorD); 
0D78:  MOVF   70,W
0D79:  MOVWF  71
0D7A:  MOVF   51,W
0D7B:  MOVWF  75
0D7C:  MOVF   50,W
0D7D:  MOVWF  74
0D7E:  MOVF   4F,W
0D7F:  MOVWF  73
0D80:  MOVF   4E,W
0D81:  MOVWF  72
0D82:  BCF    0A.3
0D83:  CALL   1C8
0D84:  BSF    0A.3
....................         showNumber(i, pFJugadorU); 
0D85:  MOVF   70,W
0D86:  MOVWF  71
0D87:  MOVF   4D,W
0D88:  MOVWF  75
0D89:  MOVF   4C,W
0D8A:  MOVWF  74
0D8B:  MOVF   4B,W
0D8C:  MOVWF  73
0D8D:  MOVF   4A,W
0D8E:  MOVWF  72
0D8F:  BCF    0A.3
0D90:  CALL   1C8
0D91:  BSF    0A.3
....................         delay_ms(I2CWAIT); 
0D92:  MOVLW  32
0D93:  MOVWF  7C
0D94:  BCF    0A.3
0D95:  CALL   289
0D96:  BSF    0A.3
0D97:  INCF   70,F
0D98:  GOTO   55A
....................     } 
.................... } 
....................  
.................... void doBuzz(INT t) { 
....................     i2c_start(); 
*
0252:  BSF    03.5
0253:  BSF    11.0
0254:  BTFSC  11.0
0255:  GOTO   254
....................     i2c_write(I2C_TIMER); 
0256:  MOVLW  0A
0257:  MOVWF  23
0258:  BCF    03.5
0259:  CALL   240
....................     i2c_write(0x80 + t); 
025A:  MOVLW  80
025B:  ADDWF  70,W
025C:  MOVWF  71
025D:  BSF    03.5
025E:  MOVWF  23
025F:  BCF    03.5
0260:  CALL   240
....................     i2c_stop(); 
0261:  BSF    03.5
0262:  BSF    11.2
0263:  BTFSC  11.2
0264:  GOTO   263
0265:  BCF    03.5
0266:  RETURN
.................... } 
....................  
.................... void parseCommand(VOID) { 
....................     CHAR c[10]; 
....................     strcpy(c, cmd); 
*
0800:  CLRF   73
0801:  MOVLW  2C
0802:  MOVWF  72
0803:  CLRF   71
0804:  MOVLW  66
0805:  MOVWF  70
0806:  MOVF   72,W
0807:  MOVWF  04
0808:  BCF    03.7
0809:  BTFSC  73.0
080A:  BSF    03.7
080B:  MOVF   00,W
080C:  MOVWF  74
080D:  MOVF   70,W
080E:  MOVWF  04
080F:  BCF    03.7
0810:  BTFSC  71.0
0811:  BSF    03.7
0812:  MOVF   74,W
0813:  MOVWF  00
0814:  MOVF   00,F
0815:  BTFSC  03.2
0816:  GOTO   01A
0817:  INCF   70,F
0818:  INCF   72,F
0819:  GOTO   006
....................  
....................     SWITCH(c[0]) { 
081A:  MOVF   66,W
081B:  XORLW  30
081C:  BTFSC  03.2
081D:  GOTO   043
081E:  XORLW  72
081F:  BTFSC  03.2
0820:  GOTO   0AE
0821:  XORLW  04
0822:  BTFSC  03.2
0823:  GOTO   105
0824:  XORLW  0C
0825:  BTFSC  03.2
0826:  GOTO   13F
0827:  XORLW  06
0828:  BTFSC  03.2
0829:  GOTO   179
082A:  XORLW  1C
082B:  BTFSC  03.2
082C:  GOTO   2D7
082D:  XORLW  01
082E:  BTFSC  03.2
082F:  GOTO   2EB
0830:  XORLW  03
0831:  BTFSC  03.2
0832:  GOTO   2FF
0833:  XORLW  04
0834:  BTFSC  03.2
0835:  GOTO   39D
0836:  XORLW  0E
0837:  BTFSC  03.2
0838:  GOTO   4FB
0839:  XORLW  02
083A:  BTFSC  03.2
083B:  GOTO   59A
083C:  XORLW  09
083D:  BTFSC  03.2
083E:  GOTO   5D0
083F:  XORLW  07
0840:  BTFSC  03.2
0841:  GOTO   611
0842:  GOTO   691
....................         case '0': IF(DEBUG) 
0843:  BTFSS  07.2
0844:  GOTO   056
....................         { 
....................             fputs("\r > Activacion manual de puerto", RS232); 
0845:  MOVLW  1E
0846:  BSF    03.6
0847:  MOVWF  0D
0848:  MOVLW  04
0849:  MOVWF  0F
084A:  BCF    0A.3
084B:  BCF    03.6
084C:  CALL   117
084D:  BSF    0A.3
084E:  MOVLW  0D
084F:  BTFSS  0C.4
0850:  GOTO   04F
0851:  MOVWF  19
0852:  MOVLW  0A
0853:  BTFSS  0C.4
0854:  GOTO   053
0855:  MOVWF  19
....................         } 
....................  
....................         SWITCH(c[2]) { 
0856:  MOVLW  31
0857:  SUBWF  68,W
0858:  ADDLW  FC
0859:  BTFSC  03.0
085A:  GOTO   0AD
085B:  ADDLW  04
085C:  GOTO   694
....................             CASE '1' : showNumber(char2int(c[3]), pNJugadorD); 
085D:  MOVF   69,W
085E:  MOVWF  73
085F:  BCF    0A.3
0860:  CALL   169
0861:  BSF    0A.3
0862:  MOVF   78,W
0863:  MOVWF  70
0864:  MOVWF  71
0865:  MOVF   49,W
0866:  MOVWF  75
0867:  MOVF   48,W
0868:  MOVWF  74
0869:  MOVF   47,W
086A:  MOVWF  73
086B:  MOVF   46,W
086C:  MOVWF  72
086D:  BCF    0A.3
086E:  CALL   1C8
086F:  BSF    0A.3
....................             BREAK; 
0870:  GOTO   0AD
....................             CASE '2' : showNumber(char2int(c[3]), pNJugadorU); 
0871:  MOVF   69,W
0872:  MOVWF  73
0873:  BCF    0A.3
0874:  CALL   169
0875:  BSF    0A.3
0876:  MOVF   78,W
0877:  MOVWF  70
0878:  MOVWF  71
0879:  MOVF   45,W
087A:  MOVWF  75
087B:  MOVF   44,W
087C:  MOVWF  74
087D:  MOVF   43,W
087E:  MOVWF  73
087F:  MOVF   42,W
0880:  MOVWF  72
0881:  BCF    0A.3
0882:  CALL   1C8
0883:  BSF    0A.3
....................             BREAK; 
0884:  GOTO   0AD
....................             CASE '3' : showNumber(char2int(c[3]), pFJugadorD); 
0885:  MOVF   69,W
0886:  MOVWF  73
0887:  BCF    0A.3
0888:  CALL   169
0889:  BSF    0A.3
088A:  MOVF   78,W
088B:  MOVWF  70
088C:  MOVWF  71
088D:  MOVF   51,W
088E:  MOVWF  75
088F:  MOVF   50,W
0890:  MOVWF  74
0891:  MOVF   4F,W
0892:  MOVWF  73
0893:  MOVF   4E,W
0894:  MOVWF  72
0895:  BCF    0A.3
0896:  CALL   1C8
0897:  BSF    0A.3
....................             BREAK; 
0898:  GOTO   0AD
....................             CASE '4' : showNumber(char2int(c[3]), pFJugadorU); 
0899:  MOVF   69,W
089A:  MOVWF  73
089B:  BCF    0A.3
089C:  CALL   169
089D:  BSF    0A.3
089E:  MOVF   78,W
089F:  MOVWF  70
08A0:  MOVWF  71
08A1:  MOVF   4D,W
08A2:  MOVWF  75
08A3:  MOVF   4C,W
08A4:  MOVWF  74
08A5:  MOVF   4B,W
08A6:  MOVWF  73
08A7:  MOVF   4A,W
08A8:  MOVWF  72
08A9:  BCF    0A.3
08AA:  CALL   1C8
08AB:  BSF    0A.3
....................             BREAK; 
08AC:  GOTO   0AD
....................         } 
....................  
....................         BREAK; 
08AD:  GOTO   691
....................  
....................         case 'B': SWITCH(c[1]) 
08AE:  MOVF   67,W
08AF:  XORLW  31
08B0:  BTFSC  03.2
08B1:  GOTO   0B9
08B2:  XORLW  03
08B3:  BTFSC  03.2
08B4:  GOTO   0D2
08B5:  XORLW  01
08B6:  BTFSC  03.2
08B7:  GOTO   0EB
08B8:  GOTO   104
....................         { 
....................             case '1': IF(DEBUG) 
08B9:  BTFSS  07.2
08BA:  GOTO   0CC
....................             { 
....................                 fputs("\r > Toque corto", RS232); 
08BB:  MOVLW  2E
08BC:  BSF    03.6
08BD:  MOVWF  0D
08BE:  MOVLW  04
08BF:  MOVWF  0F
08C0:  BCF    0A.3
08C1:  BCF    03.6
08C2:  CALL   117
08C3:  BSF    0A.3
08C4:  MOVLW  0D
08C5:  BTFSS  0C.4
08C6:  GOTO   0C5
08C7:  MOVWF  19
08C8:  MOVLW  0A
08C9:  BTFSS  0C.4
08CA:  GOTO   0C9
08CB:  MOVWF  19
....................             } 
....................             doBuzz(1); 
08CC:  MOVLW  01
08CD:  MOVWF  70
08CE:  BCF    0A.3
08CF:  CALL   252
08D0:  BSF    0A.3
....................             BREAK; 
08D1:  GOTO   104
....................             case '2': IF(DEBUG) 
08D2:  BTFSS  07.2
08D3:  GOTO   0E5
....................             { 
....................                 fputs("\r > Toque largo", RS232); 
08D4:  MOVLW  36
08D5:  BSF    03.6
08D6:  MOVWF  0D
08D7:  MOVLW  04
08D8:  MOVWF  0F
08D9:  BCF    0A.3
08DA:  BCF    03.6
08DB:  CALL   117
08DC:  BSF    0A.3
08DD:  MOVLW  0D
08DE:  BTFSS  0C.4
08DF:  GOTO   0DE
08E0:  MOVWF  19
08E1:  MOVLW  0A
08E2:  BTFSS  0C.4
08E3:  GOTO   0E2
08E4:  MOVWF  19
....................             } 
....................             doBuzz(2); 
08E5:  MOVLW  02
08E6:  MOVWF  70
08E7:  BCF    0A.3
08E8:  CALL   252
08E9:  BSF    0A.3
....................             BREAK; 
08EA:  GOTO   104
....................             case '3': IF(DEBUG) 
08EB:  BTFSS  07.2
08EC:  GOTO   0FE
....................             { 
....................                 fputs("\r > Toque doble", RS232); 
08ED:  MOVLW  3E
08EE:  BSF    03.6
08EF:  MOVWF  0D
08F0:  MOVLW  04
08F1:  MOVWF  0F
08F2:  BCF    0A.3
08F3:  BCF    03.6
08F4:  CALL   117
08F5:  BSF    0A.3
08F6:  MOVLW  0D
08F7:  BTFSS  0C.4
08F8:  GOTO   0F7
08F9:  MOVWF  19
08FA:  MOVLW  0A
08FB:  BTFSS  0C.4
08FC:  GOTO   0FB
08FD:  MOVWF  19
....................             } 
....................             doBuzz(3); 
08FE:  MOVLW  03
08FF:  MOVWF  70
0900:  BCF    0A.3
0901:  CALL   252
0902:  BSF    0A.3
....................             BREAK; 
0903:  GOTO   104
....................         } 
....................  
....................         BREAK; 
0904:  GOTO   691
....................         case 'F': IF(DEBUG) 
0905:  BTFSS  07.2
0906:  GOTO   118
....................         { 
....................             fputs("\r > Asignar faltas", RS232); 
0907:  MOVLW  46
0908:  BSF    03.6
0909:  MOVWF  0D
090A:  MOVLW  04
090B:  MOVWF  0F
090C:  BCF    0A.3
090D:  BCF    03.6
090E:  CALL   117
090F:  BSF    0A.3
0910:  MOVLW  0D
0911:  BTFSS  0C.4
0912:  GOTO   111
0913:  MOVWF  19
0914:  MOVLW  0A
0915:  BTFSS  0C.4
0916:  GOTO   115
0917:  MOVWF  19
....................         } 
....................         showNumber(char2int(c[1]), pFJugadorD); 
0918:  MOVF   67,W
0919:  MOVWF  73
091A:  BCF    0A.3
091B:  CALL   169
091C:  BSF    0A.3
091D:  MOVF   78,W
091E:  MOVWF  70
091F:  MOVWF  71
0920:  MOVF   51,W
0921:  MOVWF  75
0922:  MOVF   50,W
0923:  MOVWF  74
0924:  MOVF   4F,W
0925:  MOVWF  73
0926:  MOVF   4E,W
0927:  MOVWF  72
0928:  BCF    0A.3
0929:  CALL   1C8
092A:  BSF    0A.3
....................         showNumber(char2int(c[2]), pFJugadorU); 
092B:  MOVF   68,W
092C:  MOVWF  73
092D:  BCF    0A.3
092E:  CALL   169
092F:  BSF    0A.3
0930:  MOVF   78,W
0931:  MOVWF  70
0932:  MOVWF  71
0933:  MOVF   4D,W
0934:  MOVWF  75
0935:  MOVF   4C,W
0936:  MOVWF  74
0937:  MOVF   4B,W
0938:  MOVWF  73
0939:  MOVF   4A,W
093A:  MOVWF  72
093B:  BCF    0A.3
093C:  CALL   1C8
093D:  BSF    0A.3
....................         BREAK; 
093E:  GOTO   691
....................         case 'J': IF(DEBUG) 
093F:  BTFSS  07.2
0940:  GOTO   152
....................         { 
....................             fputs("\r > Asignar jugador", RS232); 
0941:  MOVLW  50
0942:  BSF    03.6
0943:  MOVWF  0D
0944:  MOVLW  04
0945:  MOVWF  0F
0946:  BCF    0A.3
0947:  BCF    03.6
0948:  CALL   117
0949:  BSF    0A.3
094A:  MOVLW  0D
094B:  BTFSS  0C.4
094C:  GOTO   14B
094D:  MOVWF  19
094E:  MOVLW  0A
094F:  BTFSS  0C.4
0950:  GOTO   14F
0951:  MOVWF  19
....................         } 
....................         showNumber(char2int(c[1]), pNJugadorD); 
0952:  MOVF   67,W
0953:  MOVWF  73
0954:  BCF    0A.3
0955:  CALL   169
0956:  BSF    0A.3
0957:  MOVF   78,W
0958:  MOVWF  70
0959:  MOVWF  71
095A:  MOVF   49,W
095B:  MOVWF  75
095C:  MOVF   48,W
095D:  MOVWF  74
095E:  MOVF   47,W
095F:  MOVWF  73
0960:  MOVF   46,W
0961:  MOVWF  72
0962:  BCF    0A.3
0963:  CALL   1C8
0964:  BSF    0A.3
....................         showNumber(char2int(c[2]), pNJugadorU); 
0965:  MOVF   68,W
0966:  MOVWF  73
0967:  BCF    0A.3
0968:  CALL   169
0969:  BSF    0A.3
096A:  MOVF   78,W
096B:  MOVWF  70
096C:  MOVWF  71
096D:  MOVF   45,W
096E:  MOVWF  75
096F:  MOVF   44,W
0970:  MOVWF  74
0971:  MOVF   43,W
0972:  MOVWF  73
0973:  MOVF   42,W
0974:  MOVWF  72
0975:  BCF    0A.3
0976:  CALL   1C8
0977:  BSF    0A.3
....................         BREAK; 
0978:  GOTO   691
....................         case 'L': 
....................         SWITCH(c[1]) 
0979:  MOVF   67,W
097A:  XORLW  30
097B:  BTFSC  03.2
097C:  GOTO   193
097D:  XORLW  01
097E:  BTFSC  03.2
097F:  GOTO   1AD
0980:  XORLW  03
0981:  BTFSC  03.2
0982:  GOTO   1C6
0983:  XORLW  01
0984:  BTFSC  03.2
0985:  GOTO   1DF
0986:  XORLW  77
0987:  BTFSC  03.2
0988:  GOTO   1F8
0989:  XORLW  02
098A:  BTFSC  03.2
098B:  GOTO   264
098C:  XORLW  0F
098D:  BTFSC  03.2
098E:  GOTO   287
098F:  XORLW  19
0990:  BTFSC  03.2
0991:  GOTO   2B9
0992:  GOTO   2D6
....................         { 
....................             case '0': IF(DEBUG) 
0993:  BTFSS  07.2
0994:  GOTO   1A6
....................             { 
....................                 fputs("\r > Resetea a 0", RS232); 
0995:  MOVLW  5A
0996:  BSF    03.6
0997:  MOVWF  0D
0998:  MOVLW  04
0999:  MOVWF  0F
099A:  BCF    0A.3
099B:  BCF    03.6
099C:  CALL   117
099D:  BSF    0A.3
099E:  MOVLW  0D
099F:  BTFSS  0C.4
09A0:  GOTO   19F
09A1:  MOVWF  19
09A2:  MOVLW  0A
09A3:  BTFSS  0C.4
09A4:  GOTO   1A3
09A5:  MOVWF  19
....................             } 
....................             setScoreL(0, 0, 0); 
09A6:  CLRF   73
09A7:  CLRF   74
09A8:  CLRF   75
09A9:  BCF    0A.3
09AA:  CALL   29D
09AB:  BSF    0A.3
....................             BREAK; 
09AC:  GOTO   2D6
....................             case '1': IF(DEBUG) 
09AD:  BTFSS  07.2
09AE:  GOTO   1C0
....................             { 
....................                 fputs("\r > Incrementar por 1", RS232); 
09AF:  MOVLW  62
09B0:  BSF    03.6
09B1:  MOVWF  0D
09B2:  MOVLW  04
09B3:  MOVWF  0F
09B4:  BCF    0A.3
09B5:  BCF    03.6
09B6:  CALL   117
09B7:  BSF    0A.3
09B8:  MOVLW  0D
09B9:  BTFSS  0C.4
09BA:  GOTO   1B9
09BB:  MOVWF  19
09BC:  MOVLW  0A
09BD:  BTFSS  0C.4
09BE:  GOTO   1BD
09BF:  MOVWF  19
....................             } 
....................             addScoreL(1); 
09C0:  MOVLW  01
09C1:  MOVWF  70
09C2:  BCF    0A.3
09C3:  CALL   2CD
09C4:  BSF    0A.3
....................             BREAK; 
09C5:  GOTO   2D6
....................             case '2': IF(DEBUG) 
09C6:  BTFSS  07.2
09C7:  GOTO   1D9
....................             { 
....................                 fputs("\r > Incrementar por 2", RS232); 
09C8:  MOVLW  6D
09C9:  BSF    03.6
09CA:  MOVWF  0D
09CB:  MOVLW  04
09CC:  MOVWF  0F
09CD:  BCF    0A.3
09CE:  BCF    03.6
09CF:  CALL   117
09D0:  BSF    0A.3
09D1:  MOVLW  0D
09D2:  BTFSS  0C.4
09D3:  GOTO   1D2
09D4:  MOVWF  19
09D5:  MOVLW  0A
09D6:  BTFSS  0C.4
09D7:  GOTO   1D6
09D8:  MOVWF  19
....................             } 
....................             addScoreL(2); 
09D9:  MOVLW  02
09DA:  MOVWF  70
09DB:  BCF    0A.3
09DC:  CALL   2CD
09DD:  BSF    0A.3
....................             BREAK; 
09DE:  GOTO   2D6
....................             case '3': IF(DEBUG) 
09DF:  BTFSS  07.2
09E0:  GOTO   1F2
....................             { 
....................                 fputs("\r > Incrementar por 3", RS232); 
09E1:  MOVLW  78
09E2:  BSF    03.6
09E3:  MOVWF  0D
09E4:  MOVLW  04
09E5:  MOVWF  0F
09E6:  BCF    0A.3
09E7:  BCF    03.6
09E8:  CALL   117
09E9:  BSF    0A.3
09EA:  MOVLW  0D
09EB:  BTFSS  0C.4
09EC:  GOTO   1EB
09ED:  MOVWF  19
09EE:  MOVLW  0A
09EF:  BTFSS  0C.4
09F0:  GOTO   1EF
09F1:  MOVWF  19
....................             } 
....................             addScoreL(3); 
09F2:  MOVLW  03
09F3:  MOVWF  70
09F4:  BCF    0A.3
09F5:  CALL   2CD
09F6:  BSF    0A.3
....................             BREAK; 
09F7:  GOTO   2D6
....................             case 'D': IF(DEBUG) 
09F8:  BTFSS  07.2
09F9:  GOTO   20B
....................             { 
....................                 fputs("\r > Decrementar por 1", RS232); 
09FA:  MOVLW  83
09FB:  BSF    03.6
09FC:  MOVWF  0D
09FD:  MOVLW  04
09FE:  MOVWF  0F
09FF:  BCF    0A.3
0A00:  BCF    03.6
0A01:  CALL   117
0A02:  BSF    0A.3
0A03:  MOVLW  0D
0A04:  BTFSS  0C.4
0A05:  GOTO   204
0A06:  MOVWF  19
0A07:  MOVLW  0A
0A08:  BTFSS  0C.4
0A09:  GOTO   208
0A0A:  MOVWF  19
....................             } 
....................             resScoreL(); 
....................             BREAK; 
*
0A63:  GOTO   2D6
....................             case 'F': IF(DEBUG) 
0A64:  BTFSS  07.2
0A65:  GOTO   277
....................             { 
....................                 fputs("\r > Asignar faltas", RS232); 
0A66:  MOVLW  8E
0A67:  BSF    03.6
0A68:  MOVWF  0D
0A69:  MOVLW  04
0A6A:  MOVWF  0F
0A6B:  BCF    0A.3
0A6C:  BCF    03.6
0A6D:  CALL   117
0A6E:  BSF    0A.3
0A6F:  MOVLW  0D
0A70:  BTFSS  0C.4
0A71:  GOTO   270
0A72:  MOVWF  19
0A73:  MOVLW  0A
0A74:  BTFSS  0C.4
0A75:  GOTO   274
0A76:  MOVWF  19
....................             } 
....................             sendN2Port(char2int(c[2]), I2C_SCORE, PuertoE); 
0A77:  MOVF   68,W
0A78:  MOVWF  73
0A79:  BCF    0A.3
0A7A:  CALL   169
0A7B:  BSF    0A.3
0A7C:  MOVF   78,W
0A7D:  MOVWF  70
0A7E:  MOVWF  7C
0A7F:  MOVLW  0C
0A80:  MOVWF  7D
0A81:  MOVLW  05
0A82:  MOVWF  7E
0A83:  BCF    0A.3
0A84:  CALL   27A
0A85:  BSF    0A.3
....................             BREAK; 
0A86:  GOTO   2D6
....................             case 'I': IF(DEBUG) 
0A87:  BTFSS  07.2
0A88:  GOTO   29A
....................             { 
....................                 fputs("\r > Inicializar", RS232); 
0A89:  MOVLW  98
0A8A:  BSF    03.6
0A8B:  MOVWF  0D
0A8C:  MOVLW  04
0A8D:  MOVWF  0F
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   117
0A91:  BSF    0A.3
0A92:  MOVLW  0D
0A93:  BTFSS  0C.4
0A94:  GOTO   293
0A95:  MOVWF  19
0A96:  MOVLW  0A
0A97:  BTFSS  0C.4
0A98:  GOTO   297
0A99:  MOVWF  19
....................             } 
....................             setScoreL(char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0A9A:  MOVF   68,W
0A9B:  MOVWF  73
0A9C:  BCF    0A.3
0A9D:  CALL   169
0A9E:  BSF    0A.3
0A9F:  MOVF   78,W
0AA0:  MOVWF  70
0AA1:  MOVF   69,W
0AA2:  MOVWF  73
0AA3:  BCF    0A.3
0AA4:  CALL   169
0AA5:  BSF    0A.3
0AA6:  MOVF   78,W
0AA7:  MOVWF  71
0AA8:  MOVF   6A,W
0AA9:  MOVWF  73
0AAA:  BCF    0A.3
0AAB:  CALL   169
0AAC:  BSF    0A.3
0AAD:  MOVF   78,W
0AAE:  MOVWF  72
0AAF:  MOVF   70,W
0AB0:  MOVWF  73
0AB1:  MOVF   71,W
0AB2:  MOVWF  74
0AB3:  MOVF   72,W
0AB4:  MOVWF  75
0AB5:  BCF    0A.3
0AB6:  CALL   29D
0AB7:  BSF    0A.3
....................             BREAK; 
0AB8:  GOTO   2D6
....................             case 'P': IF(DEBUG) 
0AB9:  BTFSS  07.2
0ABA:  GOTO   2CC
....................             { 
....................                 fputs("\r > Asignar posicion", RS232); 
0ABB:  MOVLW  A0
0ABC:  BSF    03.6
0ABD:  MOVWF  0D
0ABE:  MOVLW  04
0ABF:  MOVWF  0F
0AC0:  BCF    0A.3
0AC1:  BCF    03.6
0AC2:  CALL   117
0AC3:  BSF    0A.3
0AC4:  MOVLW  0D
0AC5:  BTFSS  0C.4
0AC6:  GOTO   2C5
0AC7:  MOVWF  19
0AC8:  MOVLW  0A
0AC9:  BTFSS  0C.4
0ACA:  GOTO   2C9
0ACB:  MOVWF  19
....................             } 
....................             i2c_send(I2C_SCORE, I2C_CMD_POSL); 
0ACC:  MOVLW  0C
0ACD:  BSF    03.5
0ACE:  MOVWF  21
0ACF:  MOVLW  71
0AD0:  MOVWF  22
0AD1:  BCF    0A.3
0AD2:  BCF    03.5
0AD3:  CALL   267
0AD4:  BSF    0A.3
....................             BREAK; 
0AD5:  GOTO   2D6
....................         } 
....................         BREAK; 
0AD6:  GOTO   691
....................         case 'P': IF(DEBUG) 
0AD7:  BTFSS  07.2
0AD8:  GOTO   2EA
....................         { 
....................             fputs("\r > Pausar tiempo", RS232); 
0AD9:  MOVLW  AB
0ADA:  BSF    03.6
0ADB:  MOVWF  0D
0ADC:  MOVLW  04
0ADD:  MOVWF  0F
0ADE:  BCF    0A.3
0ADF:  BCF    03.6
0AE0:  CALL   117
0AE1:  BSF    0A.3
0AE2:  MOVLW  0D
0AE3:  BTFSS  0C.4
0AE4:  GOTO   2E3
0AE5:  MOVWF  19
0AE6:  MOVLW  0A
0AE7:  BTFSS  0C.4
0AE8:  GOTO   2E7
0AE9:  MOVWF  19
....................         } 
....................         BREAK; 
0AEA:  GOTO   691
....................         case 'Q': IF(DEBUG) 
0AEB:  BTFSS  07.2
0AEC:  GOTO   2FE
....................         { 
....................             fputs("\r > Renudar tiempo", RS232); 
0AED:  MOVLW  B4
0AEE:  BSF    03.6
0AEF:  MOVWF  0D
0AF0:  MOVLW  04
0AF1:  MOVWF  0F
0AF2:  BCF    0A.3
0AF3:  BCF    03.6
0AF4:  CALL   117
0AF5:  BSF    0A.3
0AF6:  MOVLW  0D
0AF7:  BTFSS  0C.4
0AF8:  GOTO   2F7
0AF9:  MOVWF  19
0AFA:  MOVLW  0A
0AFB:  BTFSS  0C.4
0AFC:  GOTO   2FB
0AFD:  MOVWF  19
....................         } 
....................         BREAK; 
0AFE:  GOTO   691
....................  
....................         CASE 'R' : 
....................                 SWITCH(c[1]) { 
0AFF:  MOVLW  30
0B00:  SUBWF  67,W
0B01:  ADDLW  FB
0B02:  BTFSC  03.0
0B03:  GOTO   397
0B04:  ADDLW  05
0B05:  GOTO   69C
....................             case '0': IF(DEBUG) 
0B06:  BTFSS  07.2
0B07:  GOTO   319
....................             { 
....................                 fputs("\r > Apagar Periodos", RS232); 
0B08:  MOVLW  BE
0B09:  BSF    03.6
0B0A:  MOVWF  0D
0B0B:  MOVLW  04
0B0C:  MOVWF  0F
0B0D:  BCF    0A.3
0B0E:  BCF    03.6
0B0F:  CALL   117
0B10:  BSF    0A.3
0B11:  MOVLW  0D
0B12:  BTFSS  0C.4
0B13:  GOTO   312
0B14:  MOVWF  19
0B15:  MOVLW  0A
0B16:  BTFSS  0C.4
0B17:  GOTO   316
0B18:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER0); 
0B19:  MOVLW  0A
0B1A:  BSF    03.5
0B1B:  MOVWF  21
0B1C:  MOVLW  70
0B1D:  MOVWF  22
0B1E:  BCF    0A.3
0B1F:  BCF    03.5
0B20:  CALL   267
0B21:  BSF    0A.3
....................             BREAK; 
0B22:  GOTO   397
....................             case '1': IF(DEBUG) 
0B23:  BTFSS  07.2
0B24:  GOTO   336
....................             { 
....................                 fputs("\r > Periodo 1", RS232); 
0B25:  MOVLW  C8
0B26:  BSF    03.6
0B27:  MOVWF  0D
0B28:  MOVLW  04
0B29:  MOVWF  0F
0B2A:  BCF    0A.3
0B2B:  BCF    03.6
0B2C:  CALL   117
0B2D:  BSF    0A.3
0B2E:  MOVLW  0D
0B2F:  BTFSS  0C.4
0B30:  GOTO   32F
0B31:  MOVWF  19
0B32:  MOVLW  0A
0B33:  BTFSS  0C.4
0B34:  GOTO   333
0B35:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER1); 
0B36:  MOVLW  0A
0B37:  BSF    03.5
0B38:  MOVWF  21
0B39:  MOVLW  71
0B3A:  MOVWF  22
0B3B:  BCF    0A.3
0B3C:  BCF    03.5
0B3D:  CALL   267
0B3E:  BSF    0A.3
....................             BREAK; 
0B3F:  GOTO   397
....................             case '2': IF(DEBUG) 
0B40:  BTFSS  07.2
0B41:  GOTO   353
....................             { 
....................                 fputs("\r > Periodo 2", RS232); 
0B42:  MOVLW  CF
0B43:  BSF    03.6
0B44:  MOVWF  0D
0B45:  MOVLW  04
0B46:  MOVWF  0F
0B47:  BCF    0A.3
0B48:  BCF    03.6
0B49:  CALL   117
0B4A:  BSF    0A.3
0B4B:  MOVLW  0D
0B4C:  BTFSS  0C.4
0B4D:  GOTO   34C
0B4E:  MOVWF  19
0B4F:  MOVLW  0A
0B50:  BTFSS  0C.4
0B51:  GOTO   350
0B52:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER2); 
0B53:  MOVLW  0A
0B54:  BSF    03.5
0B55:  MOVWF  21
0B56:  MOVLW  72
0B57:  MOVWF  22
0B58:  BCF    0A.3
0B59:  BCF    03.5
0B5A:  CALL   267
0B5B:  BSF    0A.3
....................             BREAK; 
0B5C:  GOTO   397
....................             case '3': IF(DEBUG) 
0B5D:  BTFSS  07.2
0B5E:  GOTO   370
....................             { 
....................                 fputs("\r > Periodo 3", RS232); 
0B5F:  MOVLW  D6
0B60:  BSF    03.6
0B61:  MOVWF  0D
0B62:  MOVLW  04
0B63:  MOVWF  0F
0B64:  BCF    0A.3
0B65:  BCF    03.6
0B66:  CALL   117
0B67:  BSF    0A.3
0B68:  MOVLW  0D
0B69:  BTFSS  0C.4
0B6A:  GOTO   369
0B6B:  MOVWF  19
0B6C:  MOVLW  0A
0B6D:  BTFSS  0C.4
0B6E:  GOTO   36D
0B6F:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER3); 
0B70:  MOVLW  0A
0B71:  BSF    03.5
0B72:  MOVWF  21
0B73:  MOVLW  73
0B74:  MOVWF  22
0B75:  BCF    0A.3
0B76:  BCF    03.5
0B77:  CALL   267
0B78:  BSF    0A.3
....................             BREAK; 
0B79:  GOTO   397
....................             case '4': IF(DEBUG) 
0B7A:  BTFSS  07.2
0B7B:  GOTO   38D
....................             { 
....................                 fputs("\r > Periodo 4", RS232); 
0B7C:  MOVLW  DD
0B7D:  BSF    03.6
0B7E:  MOVWF  0D
0B7F:  MOVLW  04
0B80:  MOVWF  0F
0B81:  BCF    0A.3
0B82:  BCF    03.6
0B83:  CALL   117
0B84:  BSF    0A.3
0B85:  MOVLW  0D
0B86:  BTFSS  0C.4
0B87:  GOTO   386
0B88:  MOVWF  19
0B89:  MOVLW  0A
0B8A:  BTFSS  0C.4
0B8B:  GOTO   38A
0B8C:  MOVWF  19
....................             } 
....................             i2c_send(I2C_TIMER, I2C_CMD_PER4); 
0B8D:  MOVLW  0A
0B8E:  BSF    03.5
0B8F:  MOVWF  21
0B90:  MOVLW  74
0B91:  MOVWF  22
0B92:  BCF    0A.3
0B93:  BCF    03.5
0B94:  CALL   267
0B95:  BSF    0A.3
....................             BREAK; 
0B96:  GOTO   397
....................         } 
....................         delay_ms(I2CWAIT); 
0B97:  MOVLW  32
0B98:  MOVWF  7C
0B99:  BCF    0A.3
0B9A:  CALL   289
0B9B:  BSF    0A.3
....................         BREAK; 
0B9C:  GOTO   691
....................         case 'V': 
....................         SWITCH(c[1]) 
0B9D:  MOVF   67,W
0B9E:  XORLW  30
0B9F:  BTFSC  03.2
0BA0:  GOTO   3B7
0BA1:  XORLW  01
0BA2:  BTFSC  03.2
0BA3:  GOTO   3D1
0BA4:  XORLW  03
0BA5:  BTFSC  03.2
0BA6:  GOTO   3EA
0BA7:  XORLW  01
0BA8:  BTFSC  03.2
0BA9:  GOTO   403
0BAA:  XORLW  77
0BAB:  BTFSC  03.2
0BAC:  GOTO   41C
0BAD:  XORLW  02
0BAE:  BTFSC  03.2
0BAF:  GOTO   488
0BB0:  XORLW  0F
0BB1:  BTFSC  03.2
0BB2:  GOTO   4AB
0BB3:  XORLW  19
0BB4:  BTFSC  03.2
0BB5:  GOTO   4DD
0BB6:  GOTO   4FA
....................         { 
....................             case '0': IF(DEBUG) 
0BB7:  BTFSS  07.2
0BB8:  GOTO   3CA
....................             { 
....................                 fputs("\r > Resetea a 0", RS232); 
0BB9:  MOVLW  E4
0BBA:  BSF    03.6
0BBB:  MOVWF  0D
0BBC:  MOVLW  04
0BBD:  MOVWF  0F
0BBE:  BCF    0A.3
0BBF:  BCF    03.6
0BC0:  CALL   117
0BC1:  BSF    0A.3
0BC2:  MOVLW  0D
0BC3:  BTFSS  0C.4
0BC4:  GOTO   3C3
0BC5:  MOVWF  19
0BC6:  MOVLW  0A
0BC7:  BTFSS  0C.4
0BC8:  GOTO   3C7
0BC9:  MOVWF  19
....................             } 
....................             setScoreV(0, 0, 0); 
0BCA:  CLRF   73
0BCB:  CLRF   74
0BCC:  CLRF   75
0BCD:  BCF    0A.3
0BCE:  CALL   31A
0BCF:  BSF    0A.3
....................             BREAK; 
0BD0:  GOTO   4FA
....................             case '1': IF(DEBUG) 
0BD1:  BTFSS  07.2
0BD2:  GOTO   3E4
....................             { 
....................                 fputs("\r > Incrementar por 1", RS232); 
0BD3:  MOVLW  EC
0BD4:  BSF    03.6
0BD5:  MOVWF  0D
0BD6:  MOVLW  04
0BD7:  MOVWF  0F
0BD8:  BCF    0A.3
0BD9:  BCF    03.6
0BDA:  CALL   117
0BDB:  BSF    0A.3
0BDC:  MOVLW  0D
0BDD:  BTFSS  0C.4
0BDE:  GOTO   3DD
0BDF:  MOVWF  19
0BE0:  MOVLW  0A
0BE1:  BTFSS  0C.4
0BE2:  GOTO   3E1
0BE3:  MOVWF  19
....................             } 
....................             addScoreV(1); 
0BE4:  MOVLW  01
0BE5:  MOVWF  70
0BE6:  BCF    0A.3
0BE7:  CALL   34A
0BE8:  BSF    0A.3
....................             BREAK; 
0BE9:  GOTO   4FA
....................             case '2': IF(DEBUG) 
0BEA:  BTFSS  07.2
0BEB:  GOTO   3FD
....................             { 
....................                 fputs("\r > Incrementar por 2", RS232); 
0BEC:  MOVLW  F7
0BED:  BSF    03.6
0BEE:  MOVWF  0D
0BEF:  MOVLW  04
0BF0:  MOVWF  0F
0BF1:  BCF    0A.3
0BF2:  BCF    03.6
0BF3:  CALL   117
0BF4:  BSF    0A.3
0BF5:  MOVLW  0D
0BF6:  BTFSS  0C.4
0BF7:  GOTO   3F6
0BF8:  MOVWF  19
0BF9:  MOVLW  0A
0BFA:  BTFSS  0C.4
0BFB:  GOTO   3FA
0BFC:  MOVWF  19
....................             } 
....................             addScoreV(2); 
0BFD:  MOVLW  02
0BFE:  MOVWF  70
0BFF:  BCF    0A.3
0C00:  CALL   34A
0C01:  BSF    0A.3
....................             BREAK; 
0C02:  GOTO   4FA
....................             case '3': IF(DEBUG) 
0C03:  BTFSS  07.2
0C04:  GOTO   416
....................             { 
....................                 fputs("\r > Incrementar por 3", RS232); 
0C05:  MOVLW  02
0C06:  BSF    03.6
0C07:  MOVWF  0D
0C08:  MOVLW  05
0C09:  MOVWF  0F
0C0A:  BCF    0A.3
0C0B:  BCF    03.6
0C0C:  CALL   117
0C0D:  BSF    0A.3
0C0E:  MOVLW  0D
0C0F:  BTFSS  0C.4
0C10:  GOTO   40F
0C11:  MOVWF  19
0C12:  MOVLW  0A
0C13:  BTFSS  0C.4
0C14:  GOTO   413
0C15:  MOVWF  19
....................             } 
....................             addScoreV(3); 
0C16:  MOVLW  03
0C17:  MOVWF  70
0C18:  BCF    0A.3
0C19:  CALL   34A
0C1A:  BSF    0A.3
....................             BREAK; 
0C1B:  GOTO   4FA
....................             case 'D': IF(DEBUG) 
0C1C:  BTFSS  07.2
0C1D:  GOTO   42F
....................             { 
....................                 fputs("\r > Decrementar por 1", RS232); 
0C1E:  MOVLW  0D
0C1F:  BSF    03.6
0C20:  MOVWF  0D
0C21:  MOVLW  05
0C22:  MOVWF  0F
0C23:  BCF    0A.3
0C24:  BCF    03.6
0C25:  CALL   117
0C26:  BSF    0A.3
0C27:  MOVLW  0D
0C28:  BTFSS  0C.4
0C29:  GOTO   428
0C2A:  MOVWF  19
0C2B:  MOVLW  0A
0C2C:  BTFSS  0C.4
0C2D:  GOTO   42C
0C2E:  MOVWF  19
....................             } 
....................             resScoreV(); 
....................             BREAK; 
*
0C87:  GOTO   4FA
....................             case 'F': IF(DEBUG) 
0C88:  BTFSS  07.2
0C89:  GOTO   49B
....................             { 
....................                 fputs("\r > Asignar faltas", RS232); 
0C8A:  MOVLW  18
0C8B:  BSF    03.6
0C8C:  MOVWF  0D
0C8D:  MOVLW  05
0C8E:  MOVWF  0F
0C8F:  BCF    0A.3
0C90:  BCF    03.6
0C91:  CALL   117
0C92:  BSF    0A.3
0C93:  MOVLW  0D
0C94:  BTFSS  0C.4
0C95:  GOTO   494
0C96:  MOVWF  19
0C97:  MOVLW  0A
0C98:  BTFSS  0C.4
0C99:  GOTO   498
0C9A:  MOVWF  19
....................             } 
....................             sendN2Port(char2int(c[2]), I2C_SCORE, PuertoF); 
0C9B:  MOVF   68,W
0C9C:  MOVWF  73
0C9D:  BCF    0A.3
0C9E:  CALL   169
0C9F:  BSF    0A.3
0CA0:  MOVF   78,W
0CA1:  MOVWF  70
0CA2:  MOVWF  7C
0CA3:  MOVLW  0C
0CA4:  MOVWF  7D
0CA5:  MOVLW  06
0CA6:  MOVWF  7E
0CA7:  BCF    0A.3
0CA8:  CALL   27A
0CA9:  BSF    0A.3
....................             BREAK; 
0CAA:  GOTO   4FA
....................             case 'I': IF(DEBUG) 
0CAB:  BTFSS  07.2
0CAC:  GOTO   4BE
....................             { 
....................                 fputs("\r > Inicializar", RS232); 
0CAD:  MOVLW  22
0CAE:  BSF    03.6
0CAF:  MOVWF  0D
0CB0:  MOVLW  05
0CB1:  MOVWF  0F
0CB2:  BCF    0A.3
0CB3:  BCF    03.6
0CB4:  CALL   117
0CB5:  BSF    0A.3
0CB6:  MOVLW  0D
0CB7:  BTFSS  0C.4
0CB8:  GOTO   4B7
0CB9:  MOVWF  19
0CBA:  MOVLW  0A
0CBB:  BTFSS  0C.4
0CBC:  GOTO   4BB
0CBD:  MOVWF  19
....................             } 
....................             setScoreV(char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0CBE:  MOVF   68,W
0CBF:  MOVWF  73
0CC0:  BCF    0A.3
0CC1:  CALL   169
0CC2:  BSF    0A.3
0CC3:  MOVF   78,W
0CC4:  MOVWF  70
0CC5:  MOVF   69,W
0CC6:  MOVWF  73
0CC7:  BCF    0A.3
0CC8:  CALL   169
0CC9:  BSF    0A.3
0CCA:  MOVF   78,W
0CCB:  MOVWF  71
0CCC:  MOVF   6A,W
0CCD:  MOVWF  73
0CCE:  BCF    0A.3
0CCF:  CALL   169
0CD0:  BSF    0A.3
0CD1:  MOVF   78,W
0CD2:  MOVWF  72
0CD3:  MOVF   70,W
0CD4:  MOVWF  73
0CD5:  MOVF   71,W
0CD6:  MOVWF  74
0CD7:  MOVF   72,W
0CD8:  MOVWF  75
0CD9:  BCF    0A.3
0CDA:  CALL   31A
0CDB:  BSF    0A.3
....................             BREAK; 
0CDC:  GOTO   4FA
....................             case 'P': IF(DEBUG) 
0CDD:  BTFSS  07.2
0CDE:  GOTO   4F0
....................             { 
....................                 fputs("\r > Asignar posicion", RS232); 
0CDF:  MOVLW  2A
0CE0:  BSF    03.6
0CE1:  MOVWF  0D
0CE2:  MOVLW  05
0CE3:  MOVWF  0F
0CE4:  BCF    0A.3
0CE5:  BCF    03.6
0CE6:  CALL   117
0CE7:  BSF    0A.3
0CE8:  MOVLW  0D
0CE9:  BTFSS  0C.4
0CEA:  GOTO   4E9
0CEB:  MOVWF  19
0CEC:  MOVLW  0A
0CED:  BTFSS  0C.4
0CEE:  GOTO   4ED
0CEF:  MOVWF  19
....................             } 
....................             i2c_send(I2C_SCORE, I2C_CMD_POSV); 
0CF0:  MOVLW  0C
0CF1:  BSF    03.5
0CF2:  MOVWF  21
0CF3:  MOVLW  72
0CF4:  MOVWF  22
0CF5:  BCF    0A.3
0CF6:  BCF    03.5
0CF7:  CALL   267
0CF8:  BSF    0A.3
....................             BREAK; 
0CF9:  GOTO   4FA
....................         } 
....................         BREAK; 
0CFA:  GOTO   691
....................         CASE 'X' : doTest(); //Rutina de prueba 
....................         BREAK; 
*
0D99:  GOTO   691
....................         case 'Z': IF(DEBUG) 
0D9A:  BTFSS  07.2
0D9B:  GOTO   5AD
....................         { 
....................             fputs("\r > Reseteo general... ! ", RS232); 
0D9C:  MOVLW  35
0D9D:  BSF    03.6
0D9E:  MOVWF  0D
0D9F:  MOVLW  05
0DA0:  MOVWF  0F
0DA1:  BCF    0A.3
0DA2:  BCF    03.6
0DA3:  CALL   117
0DA4:  BSF    0A.3
0DA5:  MOVLW  0D
0DA6:  BTFSS  0C.4
0DA7:  GOTO   5A6
0DA8:  MOVWF  19
0DA9:  MOVLW  0A
0DAA:  BTFSS  0C.4
0DAB:  GOTO   5AA
0DAC:  MOVWF  19
....................         } 
....................         delay_ms(500); 
0DAD:  MOVLW  02
0DAE:  MOVWF  70
0DAF:  MOVLW  FA
0DB0:  MOVWF  7C
0DB1:  BCF    0A.3
0DB2:  CALL   289
0DB3:  BSF    0A.3
0DB4:  DECFSZ 70,F
0DB5:  GOTO   5AF
....................         doReset(); 
....................         BREAK; 
*
0DCF:  GOTO   691
....................         case 'S': IF(DEBUG) 
0DD0:  BTFSS  07.2
0DD1:  GOTO   5E3
....................         { 
....................             fputs("\r > Configuracion de tiro", RS232); 
0DD2:  MOVLW  42
0DD3:  BSF    03.6
0DD4:  MOVWF  0D
0DD5:  MOVLW  05
0DD6:  MOVWF  0F
0DD7:  BCF    0A.3
0DD8:  BCF    03.6
0DD9:  CALL   117
0DDA:  BSF    0A.3
0DDB:  MOVLW  0D
0DDC:  BTFSS  0C.4
0DDD:  GOTO   5DC
0DDE:  MOVWF  19
0DDF:  MOVLW  0A
0DE0:  BTFSS  0C.4
0DE1:  GOTO   5E0
0DE2:  MOVWF  19
....................         } 
....................         shotSet(char2int(c[1]), char2int(c[2])); 
0DE3:  MOVF   67,W
0DE4:  MOVWF  73
0DE5:  BCF    0A.3
0DE6:  CALL   169
0DE7:  BSF    0A.3
0DE8:  MOVF   78,W
0DE9:  MOVWF  70
0DEA:  MOVF   68,W
0DEB:  MOVWF  73
0DEC:  BCF    0A.3
0DED:  CALL   169
0DEE:  BSF    0A.3
0DEF:  MOVF   78,W
0DF0:  MOVWF  71
0DF1:  MOVF   70,W
0DF2:  MOVWF  72
0DF3:  MOVF   71,W
0DF4:  MOVWF  73
....................         BREAK; 
*
0E10:  GOTO   691
....................         case 'T': IF(DEBUG) 
0E11:  BTFSS  07.2
0E12:  GOTO   624
....................         { 
....................             fputs("\r > Configuracion de tiempo", RS232); 
0E13:  MOVLW  4F
0E14:  BSF    03.6
0E15:  MOVWF  0D
0E16:  MOVLW  05
0E17:  MOVWF  0F
0E18:  BCF    0A.3
0E19:  BCF    03.6
0E1A:  CALL   117
0E1B:  BSF    0A.3
0E1C:  MOVLW  0D
0E1D:  BTFSS  0C.4
0E1E:  GOTO   61D
0E1F:  MOVWF  19
0E20:  MOVLW  0A
0E21:  BTFSS  0C.4
0E22:  GOTO   621
0E23:  MOVWF  19
....................         } 
....................         timeSet(char2int(c[1]), char2int(c[2]), char2int(c[3]), char2int(c[4])); 
0E24:  MOVF   67,W
0E25:  MOVWF  73
0E26:  BCF    0A.3
0E27:  CALL   169
0E28:  BSF    0A.3
0E29:  MOVF   78,W
0E2A:  MOVWF  70
0E2B:  MOVF   68,W
0E2C:  MOVWF  73
0E2D:  BCF    0A.3
0E2E:  CALL   169
0E2F:  BSF    0A.3
0E30:  MOVF   78,W
0E31:  MOVWF  71
0E32:  MOVF   69,W
0E33:  MOVWF  73
0E34:  BCF    0A.3
0E35:  CALL   169
0E36:  BSF    0A.3
0E37:  MOVF   78,W
0E38:  MOVWF  72
0E39:  MOVF   6A,W
0E3A:  MOVWF  73
0E3B:  BCF    0A.3
0E3C:  CALL   169
0E3D:  BSF    0A.3
0E3E:  MOVF   78,W
0E3F:  MOVWF  73
0E40:  MOVF   70,W
0E41:  MOVWF  74
0E42:  MOVF   71,W
0E43:  MOVWF  75
0E44:  MOVF   72,W
0E45:  MOVWF  76
0E46:  MOVF   73,W
0E47:  MOVWF  7B
....................         BREAK; 
*
0E90:  GOTO   691
....................     } 
0E91:  BCF    0A.3
0E92:  BCF    0A.4
0E93:  GOTO   3C2 (RETURN)
.................... } 
....................  
.................... void setScoreL(int8 c, int8 d, int8 u) { 
....................     //TODO: Codigo para mostrar puntos 
....................     scoreLU = u; 
*
029D:  MOVF   75,W
029E:  MOVWF  58
....................     scoreLD = d; 
029F:  MOVF   74,W
02A0:  MOVWF  59
....................     if (c > 0) 
02A1:  MOVF   73,F
02A2:  BTFSC  03.2
02A3:  GOTO   2A6
....................         scoreLC = true; 
02A4:  BSF    41.1
02A5:  GOTO   2A7
....................     else 
....................         scoreLC = false; 
02A6:  BCF    41.1
....................  
....................     sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
02A7:  MOVF   58,W
02A8:  MOVWF  7C
02A9:  MOVLW  0C
02AA:  MOVWF  7D
02AB:  MOVLW  01
02AC:  MOVWF  7E
02AD:  CALL   27A
....................     delay_ms(I2CWAIT); 
02AE:  MOVLW  32
02AF:  MOVWF  7C
02B0:  CALL   289
....................     sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
02B1:  MOVF   59,W
02B2:  MOVWF  7C
02B3:  MOVLW  0C
02B4:  MOVWF  7D
02B5:  MOVLW  02
02B6:  MOVWF  7E
02B7:  CALL   27A
....................     delay_ms(I2CWAIT); 
02B8:  MOVLW  32
02B9:  MOVWF  7C
02BA:  CALL   289
....................     if (scoreLC) 
02BB:  BTFSS  41.1
02BC:  GOTO   2C5
....................         i2c_send(I2C_SCORE, I2C_CMD_CLON); 
02BD:  MOVLW  0C
02BE:  BSF    03.5
02BF:  MOVWF  21
02C0:  MOVLW  73
02C1:  MOVWF  22
02C2:  BCF    03.5
02C3:  CALL   267
02C4:  GOTO   2CC
....................     else 
....................         i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
02C5:  MOVLW  0C
02C6:  BSF    03.5
02C7:  MOVWF  21
02C8:  MOVLW  74
02C9:  MOVWF  22
02CA:  BCF    03.5
02CB:  CALL   267
02CC:  RETURN
.................... } 
....................  
.................... void setScoreV(int8 c, int8 d, int8 u) { 
....................     //TODO: Codigo para mostrar puntos 
....................     scoreVU = u; 
*
031A:  MOVF   75,W
031B:  MOVWF  5A
....................     scoreVD = d; 
031C:  MOVF   74,W
031D:  MOVWF  5B
....................     if (c > 0) 
031E:  MOVF   73,F
031F:  BTFSC  03.2
0320:  GOTO   323
....................         scoreVC = true; 
0321:  BSF    41.2
0322:  GOTO   324
....................     else 
....................         scoreVC = false; 
0323:  BCF    41.2
....................  
....................     sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0324:  MOVF   5A,W
0325:  MOVWF  7C
0326:  MOVLW  0C
0327:  MOVWF  7D
0328:  MOVLW  04
0329:  MOVWF  7E
032A:  CALL   27A
....................     delay_ms(I2CWAIT); 
032B:  MOVLW  32
032C:  MOVWF  7C
032D:  CALL   289
....................     sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
032E:  MOVF   5B,W
032F:  MOVWF  7C
0330:  MOVLW  0C
0331:  MOVWF  7D
0332:  MOVLW  03
0333:  MOVWF  7E
0334:  CALL   27A
....................     delay_ms(I2CWAIT); 
0335:  MOVLW  32
0336:  MOVWF  7C
0337:  CALL   289
....................  
....................     if (scoreVC) 
0338:  BTFSS  41.2
0339:  GOTO   342
....................         i2c_send(I2C_SCORE, I2C_CMD_CVON); 
033A:  MOVLW  0C
033B:  BSF    03.5
033C:  MOVWF  21
033D:  MOVLW  75
033E:  MOVWF  22
033F:  BCF    03.5
0340:  CALL   267
0341:  GOTO   349
....................     else 
....................         i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
0342:  MOVLW  0C
0343:  BSF    03.5
0344:  MOVWF  21
0345:  MOVLW  76
0346:  MOVWF  22
0347:  BCF    03.5
0348:  CALL   267
0349:  RETURN
....................  
.................... } 
....................  
.................... void addScoreV(int8 a) { 
034A:  BCF    71.0
034B:  BTFSC  41.2
034C:  BSF    71.0
034D:  MOVF   5B,W
034E:  MOVWF  72
034F:  MOVF   5A,W
0350:  MOVWF  73
....................     int1 tc = scoreVC; 
....................     int8 td = scoreVD; 
....................     int8 tu = scoreVU; 
....................  
....................     scoreVU += a; 
0351:  MOVF   70,W
0352:  ADDWF  5A,F
....................  
....................     if (scoreVU > 10) { 
0353:  MOVF   5A,W
0354:  SUBLW  0A
0355:  BTFSC  03.0
0356:  GOTO   35A
....................         scoreVD++; 
0357:  INCF   5B,F
....................         scoreVU -= 10; 
0358:  MOVLW  0A
0359:  SUBWF  5A,F
....................     } 
....................     if (scoreVD > 10) { 
035A:  MOVF   5B,W
035B:  SUBLW  0A
035C:  BTFSC  03.0
035D:  GOTO   361
....................         scoreVC = true; 
035E:  BSF    41.2
....................         scoreVD -= 10; 
035F:  MOVLW  0A
0360:  SUBWF  5B,F
....................     } 
....................  
....................     if (scoreVC != tc) { 
0361:  CLRF   77
0362:  BTFSC  71.0
0363:  BSF    77.2
0364:  MOVF   41,W
0365:  XORWF  77,W
0366:  ANDLW  04
0367:  BTFSC  03.2
0368:  GOTO   37A
....................         if (scoreVC) 
0369:  BTFSS  41.2
036A:  GOTO   373
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
036B:  MOVLW  0C
036C:  BSF    03.5
036D:  MOVWF  21
036E:  MOVLW  73
036F:  MOVWF  22
0370:  BCF    03.5
0371:  CALL   267
0372:  GOTO   37A
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0373:  MOVLW  0C
0374:  BSF    03.5
0375:  MOVWF  21
0376:  MOVLW  74
0377:  MOVWF  22
0378:  BCF    03.5
0379:  CALL   267
....................     } 
....................  
....................     delay_ms(I2CWAIT); 
037A:  MOVLW  32
037B:  MOVWF  7C
037C:  CALL   289
....................     if (scoreVD != td) 
037D:  MOVF   72,W
037E:  SUBWF  5B,W
037F:  BTFSC  03.2
0380:  GOTO   388
....................         sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0381:  MOVF   5B,W
0382:  MOVWF  7C
0383:  MOVLW  0C
0384:  MOVWF  7D
0385:  MOVLW  03
0386:  MOVWF  7E
0387:  CALL   27A
....................     delay_ms(I2CWAIT); 
0388:  MOVLW  32
0389:  MOVWF  7C
038A:  CALL   289
....................     if (scoreVU != tu) 
038B:  MOVF   73,W
038C:  SUBWF  5A,W
038D:  BTFSC  03.2
038E:  GOTO   396
....................         sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
038F:  MOVF   5A,W
0390:  MOVWF  7C
0391:  MOVLW  0C
0392:  MOVWF  7D
0393:  MOVLW  04
0394:  MOVWF  7E
0395:  CALL   27A
0396:  RETURN
.................... } 
....................  
.................... void resScoreV() { 
*
0C2F:  BCF    70.0
0C30:  BTFSC  41.2
0C31:  BSF    70.0
0C32:  MOVF   5B,W
0C33:  MOVWF  71
0C34:  MOVF   5A,W
0C35:  MOVWF  72
....................     int1 tc = scoreVC; 
....................     int8 td = scoreVD; 
....................     int8 tu = scoreVU; 
....................  
....................     if (scoreVU > 0) 
0C36:  MOVF   5A,F
0C37:  BTFSC  03.2
0C38:  GOTO   43B
....................         scoreVU--; 
0C39:  DECF   5A,F
0C3A:  GOTO   446
....................     else { 
....................         if (scoreVD > 0) { 
0C3B:  MOVF   5B,F
0C3C:  BTFSC  03.2
0C3D:  GOTO   442
....................             scoreVD--; 
0C3E:  DECF   5B,F
....................             scoreVU = 9; 
0C3F:  MOVLW  09
0C40:  MOVWF  5A
....................         } else { 
0C41:  GOTO   446
....................             scoreVC = false; 
0C42:  BCF    41.2
....................             scoreVD = 9; 
0C43:  MOVLW  09
0C44:  MOVWF  5B
....................             scoreVU = 9; 
0C45:  MOVWF  5A
....................         } 
....................     } 
....................  
....................     if (scoreVC != tc) { 
0C46:  CLRF   77
0C47:  BTFSC  70.0
0C48:  BSF    77.2
0C49:  MOVF   41,W
0C4A:  XORWF  77,W
0C4B:  ANDLW  04
0C4C:  BTFSC  03.2
0C4D:  GOTO   463
....................         if (scoreVC) 
0C4E:  BTFSS  41.2
0C4F:  GOTO   45A
....................             i2c_send(I2C_SCORE, I2C_CMD_CVON); 
0C50:  MOVLW  0C
0C51:  BSF    03.5
0C52:  MOVWF  21
0C53:  MOVLW  75
0C54:  MOVWF  22
0C55:  BCF    0A.3
0C56:  BCF    03.5
0C57:  CALL   267
0C58:  BSF    0A.3
0C59:  GOTO   463
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CVOF); 
0C5A:  MOVLW  0C
0C5B:  BSF    03.5
0C5C:  MOVWF  21
0C5D:  MOVLW  76
0C5E:  MOVWF  22
0C5F:  BCF    0A.3
0C60:  BCF    03.5
0C61:  CALL   267
0C62:  BSF    0A.3
....................     } 
....................     delay_ms(I2CWAIT); 
0C63:  MOVLW  32
0C64:  MOVWF  7C
0C65:  BCF    0A.3
0C66:  CALL   289
0C67:  BSF    0A.3
....................     if (scoreVD != td) 
0C68:  MOVF   71,W
0C69:  SUBWF  5B,W
0C6A:  BTFSC  03.2
0C6B:  GOTO   475
....................         sendN2Port(scoreVD, I2C_SCORE, PuertoC); 
0C6C:  MOVF   5B,W
0C6D:  MOVWF  7C
0C6E:  MOVLW  0C
0C6F:  MOVWF  7D
0C70:  MOVLW  03
0C71:  MOVWF  7E
0C72:  BCF    0A.3
0C73:  CALL   27A
0C74:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0C75:  MOVLW  32
0C76:  MOVWF  7C
0C77:  BCF    0A.3
0C78:  CALL   289
0C79:  BSF    0A.3
....................     if (scoreVU != tu) 
0C7A:  MOVF   72,W
0C7B:  SUBWF  5A,W
0C7C:  BTFSC  03.2
0C7D:  GOTO   487
....................         sendN2Port(scoreVU, I2C_SCORE, PuertoD); 
0C7E:  MOVF   5A,W
0C7F:  MOVWF  7C
0C80:  MOVLW  0C
0C81:  MOVWF  7D
0C82:  MOVLW  04
0C83:  MOVWF  7E
0C84:  BCF    0A.3
0C85:  CALL   27A
0C86:  BSF    0A.3
.................... } 
....................  
.................... void addScoreL(int8 a) { 
*
02CD:  BCF    71.0
02CE:  BTFSC  41.1
02CF:  BSF    71.0
02D0:  MOVF   59,W
02D1:  MOVWF  72
02D2:  MOVF   58,W
02D3:  MOVWF  73
....................     int1 tc = scoreLC; 
....................     int8 td = scoreLD; 
....................     int8 tu = scoreLU; 
....................  
....................     scoreLU += a; 
02D4:  MOVF   70,W
02D5:  ADDWF  58,F
....................  
....................     if (scoreLU > 10) { 
02D6:  MOVF   58,W
02D7:  SUBLW  0A
02D8:  BTFSC  03.0
02D9:  GOTO   2DD
....................         scoreLD++; 
02DA:  INCF   59,F
....................         scoreLU -= 10; 
02DB:  MOVLW  0A
02DC:  SUBWF  58,F
....................     } 
....................     if (scoreLD > 10) { 
02DD:  MOVF   59,W
02DE:  SUBLW  0A
02DF:  BTFSC  03.0
02E0:  GOTO   2E4
....................         scoreLC = true; 
02E1:  BSF    41.1
....................         scoreLD -= 10; 
02E2:  MOVLW  0A
02E3:  SUBWF  59,F
....................     } 
....................  
....................     if (scoreLC != tc) { 
02E4:  CLRF   77
02E5:  BTFSC  71.0
02E6:  BSF    77.1
02E7:  MOVF   41,W
02E8:  XORWF  77,W
02E9:  ANDLW  02
02EA:  BTFSC  03.2
02EB:  GOTO   2FD
....................         if (scoreLC) 
02EC:  BTFSS  41.1
02ED:  GOTO   2F6
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
02EE:  MOVLW  0C
02EF:  BSF    03.5
02F0:  MOVWF  21
02F1:  MOVLW  73
02F2:  MOVWF  22
02F3:  BCF    03.5
02F4:  CALL   267
02F5:  GOTO   2FD
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
02F6:  MOVLW  0C
02F7:  BSF    03.5
02F8:  MOVWF  21
02F9:  MOVLW  74
02FA:  MOVWF  22
02FB:  BCF    03.5
02FC:  CALL   267
....................     } 
....................     delay_ms(I2CWAIT); 
02FD:  MOVLW  32
02FE:  MOVWF  7C
02FF:  CALL   289
....................     if (scoreLD != td) 
0300:  MOVF   72,W
0301:  SUBWF  59,W
0302:  BTFSC  03.2
0303:  GOTO   30B
....................         sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0304:  MOVF   59,W
0305:  MOVWF  7C
0306:  MOVLW  0C
0307:  MOVWF  7D
0308:  MOVLW  02
0309:  MOVWF  7E
030A:  CALL   27A
....................     delay_ms(I2CWAIT); 
030B:  MOVLW  32
030C:  MOVWF  7C
030D:  CALL   289
....................     if (scoreLU != tu) 
030E:  MOVF   73,W
030F:  SUBWF  58,W
0310:  BTFSC  03.2
0311:  GOTO   319
....................         sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0312:  MOVF   58,W
0313:  MOVWF  7C
0314:  MOVLW  0C
0315:  MOVWF  7D
0316:  MOVLW  01
0317:  MOVWF  7E
0318:  CALL   27A
0319:  RETURN
.................... } 
....................  
.................... void resScoreL() { 
*
0A0B:  BCF    70.0
0A0C:  BTFSC  41.1
0A0D:  BSF    70.0
0A0E:  MOVF   59,W
0A0F:  MOVWF  71
0A10:  MOVF   58,W
0A11:  MOVWF  72
....................     int1 tc = scoreLC; 
....................     int8 td = scoreLD; 
....................     int8 tu = scoreLU; 
....................  
....................     if (scoreLU > 0) 
0A12:  MOVF   58,F
0A13:  BTFSC  03.2
0A14:  GOTO   217
....................         scoreLU--; 
0A15:  DECF   58,F
0A16:  GOTO   222
....................     else { 
....................         if (scoreLD > 0) { 
0A17:  MOVF   59,F
0A18:  BTFSC  03.2
0A19:  GOTO   21E
....................             scoreLD--; 
0A1A:  DECF   59,F
....................             scoreLU = 9; 
0A1B:  MOVLW  09
0A1C:  MOVWF  58
....................         } else { 
0A1D:  GOTO   222
....................             scoreLC = false; 
0A1E:  BCF    41.1
....................             scoreLD = 9; 
0A1F:  MOVLW  09
0A20:  MOVWF  59
....................             scoreLU = 9; 
0A21:  MOVWF  58
....................         } 
....................     } 
....................  
....................     if (scoreLC != tc) { 
0A22:  CLRF   77
0A23:  BTFSC  70.0
0A24:  BSF    77.1
0A25:  MOVF   41,W
0A26:  XORWF  77,W
0A27:  ANDLW  02
0A28:  BTFSC  03.2
0A29:  GOTO   23F
....................         if (scoreLC) 
0A2A:  BTFSS  41.1
0A2B:  GOTO   236
....................             i2c_send(I2C_SCORE, I2C_CMD_CLON); 
0A2C:  MOVLW  0C
0A2D:  BSF    03.5
0A2E:  MOVWF  21
0A2F:  MOVLW  73
0A30:  MOVWF  22
0A31:  BCF    0A.3
0A32:  BCF    03.5
0A33:  CALL   267
0A34:  BSF    0A.3
0A35:  GOTO   23F
....................         else 
....................             i2c_send(I2C_SCORE, I2C_CMD_CLOF); 
0A36:  MOVLW  0C
0A37:  BSF    03.5
0A38:  MOVWF  21
0A39:  MOVLW  74
0A3A:  MOVWF  22
0A3B:  BCF    0A.3
0A3C:  BCF    03.5
0A3D:  CALL   267
0A3E:  BSF    0A.3
....................     } 
....................     delay_ms(I2CWAIT); 
0A3F:  MOVLW  32
0A40:  MOVWF  7C
0A41:  BCF    0A.3
0A42:  CALL   289
0A43:  BSF    0A.3
....................     if (scoreLD != td) 
0A44:  MOVF   71,W
0A45:  SUBWF  59,W
0A46:  BTFSC  03.2
0A47:  GOTO   251
....................         sendN2Port(scoreLD, I2C_SCORE, PuertoB); 
0A48:  MOVF   59,W
0A49:  MOVWF  7C
0A4A:  MOVLW  0C
0A4B:  MOVWF  7D
0A4C:  MOVLW  02
0A4D:  MOVWF  7E
0A4E:  BCF    0A.3
0A4F:  CALL   27A
0A50:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0A51:  MOVLW  32
0A52:  MOVWF  7C
0A53:  BCF    0A.3
0A54:  CALL   289
0A55:  BSF    0A.3
....................     if (scoreLU != tu) 
0A56:  MOVF   72,W
0A57:  SUBWF  58,W
0A58:  BTFSC  03.2
0A59:  GOTO   263
....................         sendN2Port(scoreLU, I2C_SCORE, PuertoA); 
0A5A:  MOVF   58,W
0A5B:  MOVWF  7C
0A5C:  MOVLW  0C
0A5D:  MOVWF  7D
0A5E:  MOVLW  01
0A5F:  MOVWF  7E
0A60:  BCF    0A.3
0A61:  CALL   27A
0A62:  BSF    0A.3
.................... } 
....................  
.................... void shotSet(int8 shd, int8 shu) { 
....................     sh_u = shu; 
*
0DF5:  MOVF   73,W
0DF6:  MOVWF  57
....................     sh_d = shd; 
0DF7:  MOVF   72,W
0DF8:  MOVWF  56
....................     sendN2Port(shd, I2C_TIMER, PuertoA); 
0DF9:  MOVF   72,W
0DFA:  MOVWF  7C
0DFB:  MOVLW  0A
0DFC:  MOVWF  7D
0DFD:  MOVLW  01
0DFE:  MOVWF  7E
0DFF:  BCF    0A.3
0E00:  CALL   27A
0E01:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0E02:  MOVLW  32
0E03:  MOVWF  7C
0E04:  BCF    0A.3
0E05:  CALL   289
0E06:  BSF    0A.3
....................     sendN2Port(shu, I2C_TIMER, PuertoB); 
0E07:  MOVF   73,W
0E08:  MOVWF  7C
0E09:  MOVLW  0A
0E0A:  MOVWF  7D
0E0B:  MOVLW  02
0E0C:  MOVWF  7E
0E0D:  BCF    0A.3
0E0E:  CALL   27A
0E0F:  BSF    0A.3
.................... } 
....................  
.................... void timeSet(INT8 md, int8 mu, int8 sd, int8 su) { 
....................     m_u = mu; 
*
0E48:  MOVF   75,W
0E49:  MOVWF  53
....................     m_d = md; 
0E4A:  MOVF   74,W
0E4B:  MOVWF  52
....................     s_d = sd; 
0E4C:  MOVF   76,W
0E4D:  MOVWF  54
....................     s_u = su; 
0E4E:  MOVF   7B,W
0E4F:  MOVWF  55
....................  
....................     sendN2Port(su, I2C_TIMER, PuertoD); 
0E50:  MOVF   7B,W
0E51:  MOVWF  7C
0E52:  MOVLW  0A
0E53:  MOVWF  7D
0E54:  MOVLW  04
0E55:  MOVWF  7E
0E56:  BCF    0A.3
0E57:  CALL   27A
0E58:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0E59:  MOVLW  32
0E5A:  MOVWF  7C
0E5B:  BCF    0A.3
0E5C:  CALL   289
0E5D:  BSF    0A.3
....................     sendN2Port(sd, I2C_TIMER, PuertoC); 
0E5E:  MOVF   76,W
0E5F:  MOVWF  7C
0E60:  MOVLW  0A
0E61:  MOVWF  7D
0E62:  MOVLW  03
0E63:  MOVWF  7E
0E64:  BCF    0A.3
0E65:  CALL   27A
0E66:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0E67:  MOVLW  32
0E68:  MOVWF  7C
0E69:  BCF    0A.3
0E6A:  CALL   289
0E6B:  BSF    0A.3
....................     sendN2Port(mu, I2C_TIMER, PuertoE); 
0E6C:  MOVF   75,W
0E6D:  MOVWF  7C
0E6E:  MOVLW  0A
0E6F:  MOVWF  7D
0E70:  MOVLW  05
0E71:  MOVWF  7E
0E72:  BCF    0A.3
0E73:  CALL   27A
0E74:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0E75:  MOVLW  32
0E76:  MOVWF  7C
0E77:  BCF    0A.3
0E78:  CALL   289
0E79:  BSF    0A.3
....................  
....................     IF(md != 0) { 
0E7A:  MOVF   74,F
0E7B:  BTFSC  03.2
0E7C:  GOTO   687
....................         i2c_send(I2C_TIMER, I2C_CMD_MDON); 
0E7D:  MOVLW  0A
0E7E:  BSF    03.5
0E7F:  MOVWF  21
0E80:  MOVLW  75
0E81:  MOVWF  22
0E82:  BCF    0A.3
0E83:  BCF    03.5
0E84:  CALL   267
0E85:  BSF    0A.3
....................     } 
0E86:  GOTO   690
....................  
....................     ELSE{ 
....................         i2c_send(I2C_TIMER, I2C_CMD_MDOF); 
0E87:  MOVLW  0A
0E88:  BSF    03.5
0E89:  MOVWF  21
0E8A:  MOVLW  76
0E8B:  MOVWF  22
0E8C:  BCF    0A.3
0E8D:  BCF    03.5
0E8E:  CALL   267
0E8F:  BSF    0A.3
....................     } 
....................  
.................... } 
....................  
.................... void showNumber(INT8 n, tPort p) { 
*
01C8:  BCF    76.0
01C9:  BCF    76.1
01CA:  BCF    76.2
01CB:  BCF    76.3
....................     INT1 a = 0, b = 0, c = 0, d = 0; 
....................  
....................     SWITCH(n) { 
01CC:  MOVLW  01
01CD:  SUBWF  71,W
01CE:  ADDLW  F7
01CF:  BTFSC  03.0
01D0:  GOTO   1EA
01D1:  ADDLW  09
01D2:  GOTO   233
....................         CASE 1 : a = 1; 
01D3:  BSF    76.0
....................         BREAK; 
01D4:  GOTO   1EA
....................         CASE 2 : b = 1; 
01D5:  BSF    76.1
....................         BREAK; 
01D6:  GOTO   1EA
....................         CASE 3 : a = 1; 
01D7:  BSF    76.0
....................         b = 1; 
01D8:  BSF    76.1
....................         BREAK; 
01D9:  GOTO   1EA
....................         CASE 4 : c = 1; 
01DA:  BSF    76.2
....................         BREAK; 
01DB:  GOTO   1EA
....................         CASE 5 : c = 1; 
01DC:  BSF    76.2
....................         a = 1; 
01DD:  BSF    76.0
....................         BREAK; 
01DE:  GOTO   1EA
....................         CASE 6 : c = 1; 
01DF:  BSF    76.2
....................         b = 1; 
01E0:  BSF    76.1
....................         BREAK; 
01E1:  GOTO   1EA
....................         CASE 7 : c = 1; 
01E2:  BSF    76.2
....................         b = 1; 
01E3:  BSF    76.1
....................         a = 1; 
01E4:  BSF    76.0
....................         BREAK; 
01E5:  GOTO   1EA
....................         CASE 8 : d = 1; 
01E6:  BSF    76.3
....................         BREAK; 
01E7:  GOTO   1EA
....................         CASE 9 : d = 1; 
01E8:  BSF    76.3
....................         a = 1; 
01E9:  BSF    76.0
....................         BREAK; 
....................     } 
....................  
....................     output_bit(p.a, a); 
01EA:  MOVLW  00
01EB:  BTFSC  76.0
01EC:  MOVLW  01
01ED:  MOVWF  77
01EE:  MOVF   72,W
01EF:  MOVWF  7B
01F0:  MOVF   77,W
01F1:  MOVWF  7C
01F2:  CLRF   7E
01F3:  CLRF   7D
01F4:  CALL   1A8
01F5:  MOVF   72,W
01F6:  MOVWF  7B
01F7:  CLRF   7C
01F8:  CLRF   7E
01F9:  MOVLW  80
01FA:  MOVWF  7D
01FB:  CALL   1A8
....................     output_bit(p.b, b); 
01FC:  MOVLW  00
01FD:  BTFSC  76.1
01FE:  MOVLW  01
01FF:  MOVWF  77
0200:  MOVF   73,W
0201:  MOVWF  7B
0202:  MOVF   77,W
0203:  MOVWF  7C
0204:  CLRF   7E
0205:  CLRF   7D
0206:  CALL   1A8
0207:  MOVF   73,W
0208:  MOVWF  7B
0209:  CLRF   7C
020A:  CLRF   7E
020B:  MOVLW  80
020C:  MOVWF  7D
020D:  CALL   1A8
....................     output_bit(p.c, c); 
020E:  MOVLW  00
020F:  BTFSC  76.2
0210:  MOVLW  01
0211:  MOVWF  77
0212:  MOVF   74,W
0213:  MOVWF  7B
0214:  MOVF   77,W
0215:  MOVWF  7C
0216:  CLRF   7E
0217:  CLRF   7D
0218:  CALL   1A8
0219:  MOVF   74,W
021A:  MOVWF  7B
021B:  CLRF   7C
021C:  CLRF   7E
021D:  MOVLW  80
021E:  MOVWF  7D
021F:  CALL   1A8
....................     output_bit(p.d, d); 
0220:  MOVLW  00
0221:  BTFSC  76.3
0222:  MOVLW  01
0223:  MOVWF  77
0224:  MOVF   75,W
0225:  MOVWF  7B
0226:  MOVF   77,W
0227:  MOVWF  7C
0228:  CLRF   7E
0229:  CLRF   7D
022A:  CALL   1A8
022B:  MOVF   75,W
022C:  MOVWF  7B
022D:  CLRF   7C
022E:  CLRF   7E
022F:  MOVLW  80
0230:  MOVWF  7D
0231:  CALL   1A8
0232:  RETURN
.................... } 
....................  
.................... int8 char2int(CHAR c) { 
....................  
....................     SWITCH(c) { 
*
0169:  MOVLW  30
016A:  SUBWF  73,W
016B:  ADDLW  F6
016C:  BTFSC  03.0
016D:  GOTO   197
016E:  ADDLW  0A
016F:  GOTO   19A
....................         case '0': RETURN 0; 
0170:  MOVLW  00
0171:  MOVWF  78
0172:  GOTO   199
....................         BREAK; 
0173:  GOTO   197
....................         case '1': RETURN 1; 
0174:  MOVLW  01
0175:  MOVWF  78
0176:  GOTO   199
....................         BREAK; 
0177:  GOTO   197
....................         case '2': RETURN 2; 
0178:  MOVLW  02
0179:  MOVWF  78
017A:  GOTO   199
....................         BREAK; 
017B:  GOTO   197
....................         case '3': RETURN 3; 
017C:  MOVLW  03
017D:  MOVWF  78
017E:  GOTO   199
....................         BREAK; 
017F:  GOTO   197
....................         case '4': RETURN 4; 
0180:  MOVLW  04
0181:  MOVWF  78
0182:  GOTO   199
....................         BREAK; 
0183:  GOTO   197
....................         case '5': RETURN 5; 
0184:  MOVLW  05
0185:  MOVWF  78
0186:  GOTO   199
....................         BREAK; 
0187:  GOTO   197
....................         case '6': RETURN 6; 
0188:  MOVLW  06
0189:  MOVWF  78
018A:  GOTO   199
....................         BREAK; 
018B:  GOTO   197
....................         case '7': RETURN 7; 
018C:  MOVLW  07
018D:  MOVWF  78
018E:  GOTO   199
....................         BREAK; 
018F:  GOTO   197
....................         case '8': RETURN 8; 
0190:  MOVLW  08
0191:  MOVWF  78
0192:  GOTO   199
....................         BREAK; 
0193:  GOTO   197
....................         case '9': RETURN 9; 
0194:  MOVLW  09
0195:  MOVWF  78
0196:  GOTO   199
....................         BREAK; 
....................     } 
....................  
....................     RETURN 0; 
0197:  MOVLW  00
0198:  MOVWF  78
0199:  RETURN
.................... } 
....................  
.................... void doReset(VOID) { 
....................     i2c_send(I2C_TIMER, I2C_CMD_RESET); 
*
0DB6:  MOVLW  0A
0DB7:  BSF    03.5
0DB8:  MOVWF  21
0DB9:  MOVLW  FD
0DBA:  MOVWF  22
0DBB:  BCF    0A.3
0DBC:  BCF    03.5
0DBD:  CALL   267
0DBE:  BSF    0A.3
....................     delay_ms(I2CWAIT); 
0DBF:  MOVLW  32
0DC0:  MOVWF  7C
0DC1:  BCF    0A.3
0DC2:  CALL   289
0DC3:  BSF    0A.3
....................     i2c_send(I2C_SCORE, I2C_CMD_RESET); 
0DC4:  MOVLW  0C
0DC5:  BSF    03.5
0DC6:  MOVWF  21
0DC7:  MOVLW  FD
0DC8:  MOVWF  22
0DC9:  BCF    0A.3
0DCA:  BCF    03.5
0DCB:  CALL   267
0DCC:  BSF    0A.3
....................     reset_cpu(); 
0DCD:  CLRF   0A
0DCE:  GOTO   000
.................... } 
....................  
.................... void sendN2Port(INT8 n, int8 a, int8 p) { 
*
027A:  SWAPF  7E,W
027B:  MOVWF  77
027C:  MOVLW  F0
027D:  ANDWF  77,F
027E:  MOVF   77,W
027F:  ADDWF  7C,W
0280:  BSF    03.5
0281:  MOVWF  20
....................     INT c = (p * 16) + n; 
....................     i2c_send(a, c); 
0282:  MOVF   7D,W
0283:  MOVWF  21
0284:  MOVF   20,W
0285:  MOVWF  22
0286:  BCF    03.5
0287:  CALL   267
0288:  RETURN
.................... } 
....................  
.................... void i2c_send(INT8 a, int8 c) { 
....................     i2c_start(); 
*
0267:  BSF    03.5
0268:  BSF    11.0
0269:  BTFSC  11.0
026A:  GOTO   269
....................     i2c_write(a); 
026B:  MOVF   21,W
026C:  MOVWF  23
026D:  BCF    03.5
026E:  CALL   240
....................     i2c_write(c); 
026F:  BSF    03.5
0270:  MOVF   22,W
0271:  MOVWF  23
0272:  BCF    03.5
0273:  CALL   240
....................     i2c_stop(); 
0274:  BSF    03.5
0275:  BSF    11.2
0276:  BTFSC  11.2
0277:  GOTO   276
0278:  BCF    03.5
0279:  RETURN
.................... } 

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT

CCS PCM C Compiler, Version 5.049, 5967               16-nov.-21 00:37

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mscore\mscore.lst

               ROM used:   3407 words (42%)
                           Largest free fragment is 2048
               RAM used:   74 (20%) at main() level
                           107 (29%) worst case
               Stack used: 5 locations (1 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   4F7
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   5E0
0057:  BSF    0A.3
0058:  BCF    0A.4
0059:  GOTO   000
.................... #include <mscore.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 0D,00
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA A0,23
007D:  DATA F2,3A
007E:  DATA F0,37
007F:  DATA A0,20
0080:  DATA D0,26
0081:  DATA 20,14
0082:  DATA E3,14
0083:  DATA 20,19
0084:  DATA 30,19
0085:  DATA 30,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 0D,00
008A:  DATA BD,1E
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA 0D,00
009B:  DATA 42,36
009C:  DATA F5,32
009D:  DATA F4,37
009E:  DATA 6F,3A
009F:  DATA 68,10
00A0:  DATA C2,30
00A1:  DATA F3,35
00A2:  DATA 65,3A
00A3:  DATA E2,30
00A4:  DATA 6C,36
00A5:  DATA A0,29
00A6:  DATA E3,37
00A7:  DATA F2,32
00A8:  DATA 20,21
00A9:  DATA EF,30
00AA:  DATA 72,32
00AB:  DATA 0D,00
00AC:  DATA BD,1E
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA 0D,00
00BD:  DATA D6,32
00BE:  DATA F2,39
00BF:  DATA E9,37
00C0:  DATA 6E,10
00C1:  DATA A5,39
00C2:  DATA A0,16
00C3:  DATA 20,39
00C4:  DATA 65,3B
00C5:  DATA A0,12
00C6:  DATA 73,10
00C7:  DATA 0D,00
00C8:  DATA 32,17
00C9:  DATA 30,00
00CA:  DATA 46,00
00CB:  DATA 2A,15
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 0D,00
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA C4,22
00E0:  DATA D0,2A
00E1:  DATA D2,20
00E2:  DATA C3,24
00E3:  DATA 4F,27
00E4:  DATA 20,1D
00E5:  DATA 3A,10
00E6:  DATA D0,2A
00E7:  DATA 4E,2A
00E8:  DATA CF,29
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 20,10
00EC:  DATA 0D,00
00ED:  DATA 3E,10
00EE:  DATA C8,30
00EF:  DATA E2,34
00F0:  DATA EC,34
00F1:  DATA F4,30
00F2:  DATA E3,34
00F3:  DATA 6F,37
00F4:  DATA 20,32
00F5:  DATA 65,10
00F6:  DATA 49,19
00F7:  DATA 43,00
00F8:  DATA 3E,10
00F9:  DATA C3,37
00FA:  DATA 6E,33
00FB:  DATA E9,33
00FC:  DATA 75,39
00FD:  DATA E1,31
00FE:  DATA E9,37
00FF:  DATA 6E,10
0100:  DATA E4,32
0101:  DATA 20,28
0102:  DATA F5,32
0103:  DATA 72,3A
0104:  DATA EF,39
0105:  DATA 00,01
0106:  DATA 3E,10
0107:  DATA C8,30
0108:  DATA E2,34
0109:  DATA EC,34
010A:  DATA F4,30
010B:  DATA E3,34
010C:  DATA 6F,37
010D:  DATA 20,32
010E:  DATA 65,10
010F:  DATA E4,34
0110:  DATA 73,38
0111:  DATA EC,30
0112:  DATA F9,39
0113:  DATA 00,01
0114:  DATA 3E,10
0115:  DATA C8,30
0116:  DATA E2,34
0117:  DATA EC,34
0118:  DATA F4,30
0119:  DATA E3,34
011A:  DATA 6F,37
011B:  DATA 20,32
011C:  DATA 65,10
011D:  DATA 69,37
011E:  DATA F4,32
011F:  DATA 72,39
0120:  DATA 75,38
0121:  DATA E3,34
0122:  DATA 6F,37
0123:  DATA E5,39
0124:  DATA 00,00
0125:  MOVF   0B,W
0126:  BSF    03.5
0127:  MOVWF  21
0128:  BCF    03.5
0129:  BCF    0B.7
012A:  BSF    03.5
012B:  BSF    03.6
012C:  BSF    0C.7
012D:  BSF    0C.0
012E:  NOP
012F:  NOP
0130:  BCF    03.6
0131:  BTFSS  21.7
0132:  GOTO   136
0133:  BCF    03.5
0134:  BSF    0B.7
0135:  BSF    03.5
0136:  BCF    03.5
0137:  BSF    03.6
0138:  MOVF   0C,W
0139:  ANDLW  7F
013A:  BTFSC  03.2
013B:  GOTO   199
013C:  BSF    03.5
013D:  BCF    03.6
013E:  MOVWF  21
013F:  BCF    03.5
0140:  BSF    03.6
0141:  MOVF   0D,W
0142:  BSF    03.5
0143:  BCF    03.6
0144:  MOVWF  22
0145:  BCF    03.5
0146:  BSF    03.6
0147:  MOVF   0F,W
0148:  BSF    03.5
0149:  BCF    03.6
014A:  MOVWF  23
014B:  MOVF   21,W
014C:  BCF    03.5
014D:  BTFSS  0C.4
014E:  GOTO   14D
014F:  MOVWF  19
0150:  BSF    03.5
0151:  MOVF   22,W
0152:  BCF    03.5
0153:  BSF    03.6
0154:  MOVWF  0D
0155:  BSF    03.5
0156:  BCF    03.6
0157:  MOVF   23,W
0158:  BCF    03.5
0159:  BSF    03.6
015A:  MOVWF  0F
015B:  BCF    03.6
015C:  MOVF   0B,W
015D:  BSF    03.5
015E:  MOVWF  24
015F:  BCF    03.5
0160:  BCF    0B.7
0161:  BSF    03.5
0162:  BSF    03.6
0163:  BSF    0C.7
0164:  BSF    0C.0
0165:  NOP
0166:  NOP
0167:  BCF    03.6
0168:  BTFSS  24.7
0169:  GOTO   16D
016A:  BCF    03.5
016B:  BSF    0B.7
016C:  BSF    03.5
016D:  BCF    03.5
016E:  BSF    03.6
016F:  RLF    0C,W
0170:  RLF    0E,W
0171:  ANDLW  7F
0172:  BTFSC  03.2
0173:  GOTO   199
0174:  BSF    03.5
0175:  BCF    03.6
0176:  MOVWF  21
0177:  BCF    03.5
0178:  BSF    03.6
0179:  MOVF   0D,W
017A:  BSF    03.5
017B:  BCF    03.6
017C:  MOVWF  22
017D:  BCF    03.5
017E:  BSF    03.6
017F:  MOVF   0F,W
0180:  BSF    03.5
0181:  BCF    03.6
0182:  MOVWF  23
0183:  MOVF   21,W
0184:  BCF    03.5
0185:  BTFSS  0C.4
0186:  GOTO   185
0187:  MOVWF  19
0188:  BSF    03.5
0189:  MOVF   22,W
018A:  BCF    03.5
018B:  BSF    03.6
018C:  MOVWF  0D
018D:  BSF    03.5
018E:  BCF    03.6
018F:  MOVF   23,W
0190:  BCF    03.5
0191:  BSF    03.6
0192:  MOVWF  0F
0193:  INCF   0D,F
0194:  BTFSC  03.2
0195:  INCF   0F,F
0196:  BCF    03.6
0197:  GOTO   125
0198:  BSF    03.6
0199:  BCF    03.6
019A:  RETURN
*
01DB:  BSF    0A.0
01DC:  BCF    0A.1
01DD:  BCF    0A.2
01DE:  ADDWF  02,F
01DF:  GOTO   1A4
01E0:  GOTO   1A9
01E1:  GOTO   1AE
01E2:  GOTO   1B3
01E3:  GOTO   1B8
01E4:  GOTO   1BD
01E5:  GOTO   1C2
01E6:  GOTO   1C7
01E7:  GOTO   1CC
01E8:  GOTO   1D1
01E9:  BSF    03.5
01EA:  MOVF   27,W
01EB:  ANDLW  07
01EC:  MOVWF  77
01ED:  RRF    27,W
01EE:  MOVWF  78
01EF:  RRF    78,F
01F0:  RRF    78,F
01F1:  MOVLW  1F
01F2:  ANDWF  78,F
01F3:  MOVF   78,W
01F4:  ADDWF  29,W
01F5:  MOVWF  04
01F6:  BCF    03.7
01F7:  BTFSC  2A.0
01F8:  BSF    03.7
01F9:  CLRF   78
01FA:  INCF   78,F
01FB:  INCF   77,F
01FC:  GOTO   1FE
01FD:  RLF    78,F
01FE:  DECFSZ 77,F
01FF:  GOTO   1FD
0200:  MOVF   28,F
0201:  BTFSC  03.2
0202:  GOTO   206
0203:  MOVF   78,W
0204:  IORWF  00,F
0205:  GOTO   209
0206:  COMF   78,F
0207:  MOVF   78,W
0208:  ANDWF  00,F
0209:  BCF    03.5
020A:  RETURN
*
0292:  BCF    0A.0
0293:  BSF    0A.1
0294:  BCF    0A.2
0295:  ADDWF  02,F
0296:  GOTO   218
0297:  GOTO   21B
0298:  GOTO   21E
0299:  GOTO   222
029A:  GOTO   225
029B:  GOTO   229
029C:  GOTO   22D
029D:  GOTO   232
029E:  GOTO   235
*
05D6:  BSF    0A.0
05D7:  BCF    0A.1
05D8:  BSF    0A.2
05D9:  ADDWF  02,F
05DA:  GOTO   3E3
05DB:  GOTO   3FF
05DC:  GOTO   41B
05DD:  GOTO   437
05DE:  GOTO   453
05DF:  GOTO   46F
*
0630:  MOVF   0B,W
0631:  MOVWF  6D
0632:  BCF    0B.7
0633:  BSF    03.5
0634:  BSF    03.6
0635:  BSF    0C.7
0636:  BSF    0C.0
0637:  NOP
0638:  NOP
0639:  BCF    03.5
063A:  BCF    03.6
063B:  BTFSC  6D.7
063C:  BSF    0B.7
063D:  BTFSC  03.0
063E:  GOTO   66D
063F:  BSF    03.6
0640:  MOVF   0C,W
0641:  ANDLW  7F
0642:  BCF    03.6
0643:  MOVWF  6D
0644:  BSF    03.6
0645:  MOVF   0D,W
0646:  BCF    03.6
0647:  MOVWF  6E
0648:  BSF    03.6
0649:  MOVF   0F,W
064A:  BCF    03.6
064B:  MOVWF  6F
064C:  MOVF   6D,W
064D:  BTFSS  0C.4
064E:  GOTO   64D
064F:  MOVWF  19
0650:  MOVF   6E,W
0651:  BSF    03.6
0652:  MOVWF  0D
0653:  BCF    03.6
0654:  MOVF   6F,W
0655:  BSF    03.6
0656:  MOVWF  0F
0657:  BCF    03.6
0658:  MOVF   0B,W
0659:  MOVWF  70
065A:  BCF    0B.7
065B:  BSF    03.5
065C:  BSF    03.6
065D:  BSF    0C.7
065E:  BSF    0C.0
065F:  NOP
0660:  NOP
0661:  BTFSS  70.7
0662:  GOTO   668
0663:  BCF    03.5
0664:  BCF    03.6
0665:  BSF    0B.7
0666:  BSF    03.5
0667:  BSF    03.6
0668:  BCF    03.5
0669:  BCF    03.6
066A:  DECFSZ 6C,F
066B:  GOTO   66D
066C:  GOTO   68D
066D:  BSF    03.6
066E:  RLF    0C,W
066F:  RLF    0E,W
0670:  ANDLW  7F
0671:  BCF    03.6
0672:  MOVWF  6D
0673:  BSF    03.6
0674:  MOVF   0D,W
0675:  BCF    03.6
0676:  MOVWF  6E
0677:  BSF    03.6
0678:  MOVF   0F,W
0679:  BCF    03.6
067A:  MOVWF  6F
067B:  MOVF   6D,W
067C:  BTFSS  0C.4
067D:  GOTO   67C
067E:  MOVWF  19
067F:  MOVF   6E,W
0680:  BSF    03.6
0681:  MOVWF  0D
0682:  BCF    03.6
0683:  MOVF   6F,W
0684:  BSF    03.6
0685:  MOVWF  0F
0686:  INCF   0D,F
0687:  BTFSC  03.2
0688:  INCF   0F,F
0689:  BCF    03.0
068A:  BCF    03.6
068B:  DECFSZ 6C,F
068C:  GOTO   630
068D:  RETURN
068E:  BTFSC  6D.7
068F:  GOTO   6A1
0690:  MOVLW  0F
0691:  MOVWF  77
0692:  SWAPF  6C,W
0693:  ANDWF  77,F
0694:  MOVLW  0A
0695:  SUBWF  77,W
0696:  BTFSC  03.0
0697:  GOTO   69B
0698:  MOVLW  30
0699:  ADDWF  77,F
069A:  GOTO   69D
069B:  MOVF   6D,W
069C:  ADDWF  77,F
069D:  MOVF   77,W
069E:  BTFSS  0C.4
069F:  GOTO   69E
06A0:  MOVWF  19
06A1:  MOVLW  0F
06A2:  ANDWF  6C,F
06A3:  MOVLW  0A
06A4:  SUBWF  6C,W
06A5:  BTFSC  03.0
06A6:  GOTO   6A9
06A7:  MOVLW  30
06A8:  GOTO   6AB
06A9:  BCF    6D.7
06AA:  MOVF   6D,W
06AB:  ADDWF  6C,F
06AC:  MOVF   6C,W
06AD:  BTFSS  0C.4
06AE:  GOTO   6AD
06AF:  MOVWF  19
06B0:  RETURN
06B1:  DATA 3E,10
06B2:  DATA C3,37
06B3:  DATA ED,36
06B4:  DATA 61,37
06B5:  DATA E4,37
06B6:  DATA 3A,10
06B7:  DATA 25,2C
06B8:  DATA A0,16
06B9:  DATA A0,12
06BA:  DATA D8,06
06BB:  DATA 80,37
06BC:  DATA 3E,10
06BD:  DATA C4,34
06BE:  DATA F2,32
06BF:  DATA E3,31
06C0:  DATA E9,37
06C1:  DATA 6E,10
06C2:  DATA D4,24
06C3:  DATA CD,22
06C4:  DATA 52,00
06C5:  DATA 3E,10
06C6:  DATA C4,34
06C7:  DATA F2,32
06C8:  DATA E3,31
06C9:  DATA E9,37
06CA:  DATA 6E,10
06CB:  DATA D3,21
06CC:  DATA 4F,29
06CD:  DATA 45,00
06CE:  DATA 3E,10
06CF:  DATA 41,38
06D0:  DATA E1,33
06D1:  DATA 61,39
06D2:  DATA 20,28
06D3:  DATA EF,39
06D4:  DATA E9,31
06D5:  DATA E9,37
06D6:  DATA 6E,00
06D7:  DATA 3E,10
06D8:  DATA C1,31
06D9:  DATA F4,34
06DA:  DATA F6,30
06DB:  DATA 72,10
06DC:  DATA D0,37
06DD:  DATA F3,34
06DE:  DATA E3,34
06DF:  DATA 6F,37
06E0:  DATA 20,26
06E1:  DATA EF,31
06E2:  DATA 61,36
06E3:  DATA 00,01
06E4:  DATA 3E,10
06E5:  DATA C1,31
06E6:  DATA F4,34
06E7:  DATA F6,30
06E8:  DATA 72,10
06E9:  DATA D0,37
06EA:  DATA F3,34
06EB:  DATA E3,34
06EC:  DATA 6F,37
06ED:  DATA 20,2B
06EE:  DATA E9,39
06EF:  DATA 69,3A
06F0:  DATA 61,00
06F1:  DATA 3E,10
06F2:  DATA C1,31
06F3:  DATA F4,34
06F4:  DATA F6,30
06F5:  DATA 72,10
06F6:  DATA C3,32
06F7:  DATA 6E,3A
06F8:  DATA 65,37
06F9:  DATA 61,10
06FA:  DATA CC,37
06FB:  DATA E3,30
06FC:  DATA 6C,00
06FD:  DATA 3E,10
06FE:  DATA C4,32
06FF:  DATA F3,30
0700:  DATA 63,3A
0701:  DATA 69,3B
0702:  DATA 61,39
0703:  DATA A0,21
0704:  DATA 65,37
0705:  DATA F4,32
0706:  DATA EE,30
0707:  DATA 20,26
0708:  DATA EF,31
0709:  DATA 61,36
070A:  DATA 00,01
070B:  DATA 3E,10
070C:  DATA C1,31
070D:  DATA F4,34
070E:  DATA F6,30
070F:  DATA 72,10
0710:  DATA C3,32
0711:  DATA 6E,3A
0712:  DATA 65,37
0713:  DATA 61,10
0714:  DATA D6,34
0715:  DATA F3,34
0716:  DATA F4,30
0717:  DATA 00,01
0718:  DATA 3E,10
0719:  DATA C4,32
071A:  DATA F3,30
071B:  DATA 63,3A
071C:  DATA 69,3B
071D:  DATA 61,39
071E:  DATA A0,21
071F:  DATA 65,37
0720:  DATA F4,32
0721:  DATA EE,30
0722:  DATA 20,2B
0723:  DATA E9,39
0724:  DATA 69,3A
0725:  DATA 61,00
0726:  DATA 3E,10
0727:  DATA C1,39
0728:  DATA E9,33
0729:  DATA EE,30
072A:  DATA E3,34
072B:  DATA 6F,37
072C:  DATA 20,28
072D:  DATA F5,32
072E:  DATA 72,3A
072F:  DATA 6F,10
0730:  DATA 31,00
0731:  DATA 3E,10
0732:  DATA C1,39
0733:  DATA E9,33
0734:  DATA EE,30
0735:  DATA E3,34
0736:  DATA 6F,37
0737:  DATA 20,28
0738:  DATA F5,32
0739:  DATA 72,3A
073A:  DATA 6F,10
073B:  DATA 32,00
073C:  DATA 3E,10
073D:  DATA C1,39
073E:  DATA E9,33
073F:  DATA EE,30
0740:  DATA E3,34
0741:  DATA 6F,37
0742:  DATA 20,28
0743:  DATA F5,32
0744:  DATA 72,3A
0745:  DATA 6F,10
0746:  DATA 33,00
0747:  DATA 3E,10
0748:  DATA C1,39
0749:  DATA E9,33
074A:  DATA EE,30
074B:  DATA E3,34
074C:  DATA 6F,37
074D:  DATA 20,28
074E:  DATA F5,32
074F:  DATA 72,3A
0750:  DATA 6F,10
0751:  DATA 34,00
0752:  DATA 3E,10
0753:  DATA C1,39
0754:  DATA E9,33
0755:  DATA EE,30
0756:  DATA E3,34
0757:  DATA 6F,37
0758:  DATA 20,28
0759:  DATA F5,32
075A:  DATA 72,3A
075B:  DATA 6F,10
075C:  DATA 35,00
075D:  DATA 3E,10
075E:  DATA C1,39
075F:  DATA E9,33
0760:  DATA EE,30
0761:  DATA E3,34
0762:  DATA 6F,37
0763:  DATA 20,28
0764:  DATA F5,32
0765:  DATA 72,3A
0766:  DATA 6F,10
0767:  DATA 36,00
0768:  DATA 3E,10
0769:  DATA D2,3A
076A:  DATA F4,34
076B:  DATA EE,30
076C:  DATA 20,32
076D:  DATA 65,10
076E:  DATA 70,39
076F:  DATA F5,32
0770:  DATA E2,30
0771:  DATA 00,00
0772:  DATA 0D,1F
0773:  DATA A0,20
0774:  DATA 63,3A
0775:  DATA 69,3B
0776:  DATA E1,31
0777:  DATA E9,37
0778:  DATA 6E,10
0779:  DATA ED,30
077A:  DATA EE,3A
077B:  DATA 61,36
077C:  DATA 20,32
077D:  DATA 65,10
077E:  DATA F0,3A
077F:  DATA 65,39
0780:  DATA F4,37
0781:  DATA 00,01
0782:  DATA 3E,10
0783:  DATA 41,38
0784:  DATA E1,33
0785:  DATA 61,39
0786:  DATA 20,28
0787:  DATA EF,39
0788:  DATA E9,31
0789:  DATA E9,37
078A:  DATA 6E,00
078B:  DATA 3E,10
078C:  DATA C1,31
078D:  DATA F4,34
078E:  DATA F6,30
078F:  DATA 72,10
0790:  DATA D0,37
0791:  DATA F3,34
0792:  DATA E3,34
0793:  DATA 6F,37
0794:  DATA 20,26
0795:  DATA EF,31
0796:  DATA 61,36
0797:  DATA 00,01
0798:  DATA 3E,10
0799:  DATA C1,31
079A:  DATA F4,34
079B:  DATA F6,30
079C:  DATA 72,10
079D:  DATA D0,37
079E:  DATA F3,34
079F:  DATA E3,34
07A0:  DATA 6F,37
07A1:  DATA 20,2B
07A2:  DATA E9,39
07A3:  DATA 69,3A
07A4:  DATA 61,00
07A5:  DATA 3E,10
07A6:  DATA C1,31
07A7:  DATA F4,34
07A8:  DATA F6,30
07A9:  DATA 72,10
07AA:  DATA C3,32
07AB:  DATA 6E,3A
07AC:  DATA 65,37
07AD:  DATA 61,10
07AE:  DATA CC,37
07AF:  DATA E3,30
07B0:  DATA 6C,00
07B1:  DATA 3E,10
07B2:  DATA C4,32
07B3:  DATA F3,30
07B4:  DATA 63,3A
07B5:  DATA 69,3B
07B6:  DATA 61,39
07B7:  DATA A0,21
07B8:  DATA 65,37
07B9:  DATA F4,32
07BA:  DATA EE,30
07BB:  DATA 20,26
07BC:  DATA EF,31
07BD:  DATA 61,36
07BE:  DATA 00,01
07BF:  DATA 3E,10
07C0:  DATA C1,31
07C1:  DATA F4,34
07C2:  DATA F6,30
07C3:  DATA 72,10
07C4:  DATA C3,32
07C5:  DATA 6E,3A
07C6:  DATA 65,37
07C7:  DATA 61,10
07C8:  DATA D6,34
07C9:  DATA F3,34
07CA:  DATA F4,30
07CB:  DATA 00,01
07CC:  DATA 3E,10
07CD:  DATA C4,32
07CE:  DATA F3,30
07CF:  DATA 63,3A
07D0:  DATA 69,3B
07D1:  DATA 61,39
07D2:  DATA A0,21
07D3:  DATA 65,37
07D4:  DATA F4,32
07D5:  DATA EE,30
07D6:  DATA 20,2B
07D7:  DATA E9,39
07D8:  DATA 69,3A
07D9:  DATA 61,00
07DA:  DATA 0D,1F
07DB:  DATA 20,29
07DC:  DATA E5,39
07DD:  DATA 65,3A
07DE:  DATA E5,37
07DF:  DATA A0,33
07E0:  DATA 65,37
07E1:  DATA 65,39
07E2:  DATA 61,36
07E3:  DATA 2E,17
07E4:  DATA AE,10
07E5:  DATA 00,01
07E6:  DATA 0D,1F
07E7:  DATA 20,14
07E8:  DATA B5,14
07E9:  DATA 00,01
07EA:  DATA 0D,1F
07EB:  DATA 20,14
07EC:  DATA B4,14
07ED:  DATA 00,01
07EE:  DATA 0D,1F
07EF:  DATA 20,14
07F0:  DATA B3,14
07F1:  DATA 00,01
07F2:  DATA 0D,1F
07F3:  DATA 20,14
07F4:  DATA B2,14
07F5:  DATA 00,01
07F6:  DATA 0D,1F
07F7:  DATA 20,14
07F8:  DATA B1,14
07F9:  DATA 00,01
07FA:  DATA 0D,1F
07FB:  DATA 20,14
07FC:  DATA B0,14
07FD:  DATA 00,00
*
0AC3:  DATA 3E,10
0AC4:  DATA D2,32
0AC5:  DATA F3,32
0AC6:  DATA F4,32
0AC7:  DATA 61,37
0AC8:  DATA E4,37
0AC9:  DATA 2E,17
0ACA:  DATA 2E,00
0ACB:  MOVF   0B,W
0ACC:  MOVWF  65
0ACD:  BCF    0B.7
0ACE:  BSF    03.5
0ACF:  BSF    03.6
0AD0:  BSF    0C.7
0AD1:  BSF    0C.0
0AD2:  NOP
0AD3:  NOP
0AD4:  BCF    03.5
0AD5:  BCF    03.6
0AD6:  BTFSC  65.7
0AD7:  BSF    0B.7
0AD8:  BSF    03.6
0AD9:  MOVF   0C,W
0ADA:  ANDLW  7F
0ADB:  BTFSC  03.2
0ADC:  GOTO   321
0ADD:  BCF    03.6
0ADE:  MOVWF  65
0ADF:  BSF    03.6
0AE0:  MOVF   0D,W
0AE1:  BCF    03.6
0AE2:  MOVWF  66
0AE3:  BSF    03.6
0AE4:  MOVF   0F,W
0AE5:  BCF    03.6
0AE6:  MOVWF  67
0AE7:  MOVF   65,W
0AE8:  BTFSS  0C.4
0AE9:  GOTO   2E8
0AEA:  MOVWF  19
0AEB:  MOVF   66,W
0AEC:  BSF    03.6
0AED:  MOVWF  0D
0AEE:  BCF    03.6
0AEF:  MOVF   67,W
0AF0:  BSF    03.6
0AF1:  MOVWF  0F
0AF2:  BCF    03.6
0AF3:  MOVF   0B,W
0AF4:  MOVWF  68
0AF5:  BCF    0B.7
0AF6:  BSF    03.5
0AF7:  BSF    03.6
0AF8:  BSF    0C.7
0AF9:  BSF    0C.0
0AFA:  NOP
0AFB:  NOP
0AFC:  BCF    03.5
0AFD:  BCF    03.6
0AFE:  BTFSC  68.7
0AFF:  BSF    0B.7
0B00:  BSF    03.6
0B01:  RLF    0C,W
0B02:  RLF    0E,W
0B03:  ANDLW  7F
0B04:  BTFSC  03.2
0B05:  GOTO   321
0B06:  BCF    03.6
0B07:  MOVWF  65
0B08:  BSF    03.6
0B09:  MOVF   0D,W
0B0A:  BCF    03.6
0B0B:  MOVWF  66
0B0C:  BSF    03.6
0B0D:  MOVF   0F,W
0B0E:  BCF    03.6
0B0F:  MOVWF  67
0B10:  MOVF   65,W
0B11:  BTFSS  0C.4
0B12:  GOTO   311
0B13:  MOVWF  19
0B14:  MOVF   66,W
0B15:  BSF    03.6
0B16:  MOVWF  0D
0B17:  BCF    03.6
0B18:  MOVF   67,W
0B19:  BSF    03.6
0B1A:  MOVWF  0F
0B1B:  INCF   0D,F
0B1C:  BTFSC  03.2
0B1D:  INCF   0F,F
0B1E:  BCF    03.6
0B1F:  GOTO   2CB
0B20:  BSF    03.6
0B21:  BCF    03.6
0B22:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
029F:  MOVLW  A1
02A0:  MOVWF  04
02A1:  BCF    03.7
02A2:  MOVF   00,W
02A3:  BTFSC  03.2
02A4:  GOTO   2B2
02A5:  MOVLW  02
02A6:  MOVWF  78
02A7:  CLRF   77
02A8:  DECFSZ 77,F
02A9:  GOTO   2A8
02AA:  DECFSZ 78,F
02AB:  GOTO   2A7
02AC:  MOVLW  97
02AD:  MOVWF  77
02AE:  DECFSZ 77,F
02AF:  GOTO   2AE
02B0:  DECFSZ 00,F
02B1:  GOTO   2A5
02B2:  RETURN
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4,PIN_A2,PIN_A1,PIN_A0 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5, PIN_C2, PIN_C1, PIN_C0 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E3,PIN_E2,PIN_E1,PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_A3) 
.................... #define POSLOCAL  PIN_C1 
.................... #define CENLOCAL  PIN_C2 
.................... #define CENVISITA PIN_E2 
.................... #define POSVISITA PIN_E1 
....................  
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Slave,Fast,sda=I2C_SDA,scl=I2C_SCL, address = I2C_TIMER, FORCE_HW) 
*
0821:  MOVF   6B,W
0822:  MOVWF  13
0823:  BSF    14.4
0824:  BCF    0C.3
0825:  BSF    03.5
0826:  BTFSC  14.0
0827:  GOTO   026
0828:  CLRF   78
0829:  BCF    03.5
082A:  BTFSC  14.4
082B:  INCF   78,F
....................  
.................... //-- DEFINICIONES -- 
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
....................  
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       200 
....................  
.................... //-- DECLARACIONES -- 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
0D32:  BCF    03.6
0D33:  CLRF   2C
0D34:  CLRF   2D
0D35:  CLRF   2E
0D36:  CLRF   2F
0D37:  CLRF   30
0D38:  CLRF   31
0D39:  CLRF   32
0D3A:  CLRF   33
0D3B:  CLRF   34
0D3C:  CLRF   35
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
0D3D:  CLRF   36
0D3E:  CLRF   37
0D3F:  CLRF   38
0D40:  CLRF   39
0D41:  CLRF   3A
0D42:  CLRF   3B
0D43:  CLRF   3C
0D44:  CLRF   3D
0D45:  CLRF   3E
0D46:  CLRF   3F
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... int  icmd; 
.................... int  ircmd[5] = "\0\0\0\0"; 
0D47:  CLRF   43
0D48:  CLRF   44
0D49:  CLRF   45
0D4A:  CLRF   46
0D4B:  CLRF   47
....................  
.................... //Puertos de Displays 
.................... tPort pLocalU; 
.................... tPort pLocalD; 
.................... tPort pVisitaU; 
.................... tPort pVisitaD; 
.................... tPort pFLocal; 
.................... tPort pFVisita; 
....................  
....................  
.................... //-- PROTOTIPOS -- 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8  char2int(char);  
.................... void doReset(void); 
.................... void parseI2CCommand(void); 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
0D4C:  CLRF   60
0D4D:  CLRF   61
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
0B23:  MOVLW  08
0B24:  BSF    03.5
0B25:  MOVWF  05
0B26:  BCF    03.5
0B27:  CLRF   05
....................    output_b(0x00); 
0B28:  BSF    03.5
0B29:  CLRF   06
0B2A:  BCF    03.5
0B2B:  CLRF   06
....................    output_c(0x00); 
0B2C:  MOVLW  D8
0B2D:  BSF    03.5
0B2E:  MOVWF  07
0B2F:  BCF    03.5
0B30:  CLRF   07
....................    output_d(0x00); 
0B31:  BSF    03.5
0B32:  CLRF   08
0B33:  BCF    03.5
0B34:  CLRF   08
....................    output_e(0x00); 
0B35:  BSF    03.5
0B36:  BCF    09.0
0B37:  BCF    09.1
0B38:  BCF    09.2
0B39:  BCF    09.3
0B3A:  BCF    03.5
0B3B:  CLRF   09
0B3C:  CLRF   2B
0B3D:  BTFSC  0B.7
0B3E:  BSF    2B.7
0B3F:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0B40:  MOVLW  C8
0B41:  BSF    03.5
0B42:  MOVWF  21
0B43:  BCF    0A.3
0B44:  BCF    03.5
0B45:  CALL   29F
0B46:  BSF    0A.3
0B47:  BTFSC  2B.7
0B48:  BSF    0B.7
....................     
....................    if(DEBUG) 
0B49:  BTFSS  05.3
0B4A:  GOTO   3B6
....................    { 
....................       fprintf(RS232,"********************************\r"); 
0B4B:  MOVLW  68
0B4C:  BSF    03.6
0B4D:  MOVWF  0D
0B4E:  MOVLW  00
0B4F:  MOVWF  0F
0B50:  BCF    03.6
0B51:  CALL   2CB
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
0B52:  MOVLW  79
0B53:  BSF    03.6
0B54:  MOVWF  0D
0B55:  MOVLW  00
0B56:  MOVWF  0F
0B57:  BCF    03.6
0B58:  CALL   2CB
....................       fprintf(RS232,"================================\r"); 
0B59:  MOVLW  8A
0B5A:  BSF    03.6
0B5B:  MOVWF  0D
0B5C:  MOVLW  00
0B5D:  MOVWF  0F
0B5E:  BCF    03.6
0B5F:  CALL   2CB
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
0B60:  MOVLW  9B
0B61:  BSF    03.6
0B62:  MOVWF  0D
0B63:  MOVLW  00
0B64:  MOVWF  0F
0B65:  BCF    03.6
0B66:  CALL   2CB
....................       fprintf(RS232,"================================\r"); 
0B67:  MOVLW  AC
0B68:  BSF    03.6
0B69:  MOVWF  0D
0B6A:  MOVLW  00
0B6B:  MOVWF  0F
0B6C:  BCF    03.6
0B6D:  CALL   2CB
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
0B6E:  MOVLW  BD
0B6F:  BSF    03.6
0B70:  MOVWF  0D
0B71:  MOVLW  00
0B72:  MOVWF  0F
0B73:  BCF    03.0
0B74:  BCF    03.6
0B75:  CLRF   2B
0B76:  BTFSC  0B.7
0B77:  BSF    2B.7
0B78:  BCF    0B.7
0B79:  MOVLW  08
0B7A:  MOVWF  6C
0B7B:  BCF    0A.3
0B7C:  CALL   630
0B7D:  BSF    0A.3
0B7E:  BTFSC  2B.7
0B7F:  BSF    0B.7
0B80:  MOVLW  C8
0B81:  BSF    03.6
0B82:  MOVWF  0D
0B83:  MOVLW  00
0B84:  MOVWF  0F
0B85:  BCF    03.6
0B86:  CALL   2CB
0B87:  MOVLW  C2
0B88:  BSF    03.6
0B89:  MOVWF  0D
0B8A:  MOVLW  00
0B8B:  MOVWF  0F
0B8C:  BCF    03.0
0B8D:  BCF    03.6
0B8E:  CLRF   2B
0B8F:  BTFSC  0B.7
0B90:  BSF    2B.7
0B91:  BCF    0B.7
0B92:  MOVLW  07
0B93:  MOVWF  6C
0B94:  BCF    0A.3
0B95:  CALL   630
0B96:  BSF    0A.3
0B97:  BTFSC  2B.7
0B98:  BSF    0B.7
0B99:  MOVLW  CA
0B9A:  BSF    03.6
0B9B:  MOVWF  0D
0B9C:  MOVLW  00
0B9D:  MOVWF  0F
0B9E:  BCF    03.6
0B9F:  CALL   2CB
0BA0:  MOVLW  20
0BA1:  BTFSS  0C.4
0BA2:  GOTO   3A1
0BA3:  MOVWF  19
0BA4:  MOVLW  0D
0BA5:  BTFSS  0C.4
0BA6:  GOTO   3A5
0BA7:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0BA8:  MOVLW  CB
0BA9:  BSF    03.6
0BAA:  MOVWF  0D
0BAB:  MOVLW  00
0BAC:  MOVWF  0F
0BAD:  BCF    03.6
0BAE:  CALL   2CB
....................       fprintf(RS232,"      DEPURACION :: PUNTOS      \r"); 
0BAF:  MOVLW  DC
0BB0:  BSF    03.6
0BB1:  MOVWF  0D
0BB2:  MOVLW  00
0BB3:  MOVWF  0F
0BB4:  BCF    03.6
0BB5:  CALL   2CB
....................    } 
....................  
....................     
....................    if(DEBUG) {fputs("> Habilitacion de I2C",RS232);} 
0BB6:  BTFSS  05.3
0BB7:  GOTO   3CF
0BB8:  MOVLW  ED
0BB9:  BSF    03.6
0BBA:  MOVWF  0D
0BBB:  MOVLW  00
0BBC:  MOVWF  0F
0BBD:  BCF    03.6
0BBE:  CLRF   2B
0BBF:  BTFSC  0B.7
0BC0:  BSF    2B.7
0BC1:  BCF    0B.7
0BC2:  BCF    0A.3
0BC3:  CALL   125
0BC4:  BSF    0A.3
0BC5:  BTFSC  2B.7
0BC6:  BSF    0B.7
0BC7:  MOVLW  0D
0BC8:  BTFSS  0C.4
0BC9:  GOTO   3C8
0BCA:  MOVWF  19
0BCB:  MOVLW  0A
0BCC:  BTFSS  0C.4
0BCD:  GOTO   3CC
0BCE:  MOVWF  19
....................    i2c_slaveaddr(I2C_SCORE); 
0BCF:  MOVLW  0C
0BD0:  BSF    03.5
0BD1:  MOVWF  13
0BD2:  BCF    03.5
0BD3:  CLRF   2B
0BD4:  BTFSC  0B.7
0BD5:  BSF    2B.7
0BD6:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0BD7:  MOVLW  C8
0BD8:  BSF    03.5
0BD9:  MOVWF  21
0BDA:  BCF    0A.3
0BDB:  BCF    03.5
0BDC:  CALL   29F
0BDD:  BSF    0A.3
0BDE:  BTFSC  2B.7
0BDF:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
0BE0:  BTFSS  05.3
0BE1:  GOTO   3F9
0BE2:  MOVLW  F8
0BE3:  BSF    03.6
0BE4:  MOVWF  0D
0BE5:  MOVLW  00
0BE6:  MOVWF  0F
0BE7:  BCF    03.6
0BE8:  CLRF   2B
0BE9:  BTFSC  0B.7
0BEA:  BSF    2B.7
0BEB:  BCF    0B.7
0BEC:  BCF    0A.3
0BED:  CALL   125
0BEE:  BSF    0A.3
0BEF:  BTFSC  2B.7
0BF0:  BSF    0B.7
0BF1:  MOVLW  0D
0BF2:  BTFSS  0C.4
0BF3:  GOTO   3F2
0BF4:  MOVWF  19
0BF5:  MOVLW  0A
0BF6:  BTFSS  0C.4
0BF7:  GOTO   3F6
0BF8:  MOVWF  19
....................    //TODO: Activar puertos 
....................    pLocalU.a = PIN_B0; 
0BF9:  MOVLW  30
0BFA:  MOVWF  48
....................    pLocalU.b = PIN_B1; 
0BFB:  MOVLW  31
0BFC:  MOVWF  49
....................    pLocalU.c = PIN_B2; 
0BFD:  MOVLW  32
0BFE:  MOVWF  4A
....................    pLocalU.d = PIN_B3; 
0BFF:  MOVLW  33
0C00:  MOVWF  4B
....................     
....................    pLocalD.a = PIN_B4; 
0C01:  MOVLW  34
0C02:  MOVWF  4C
....................    pLocalD.b = PIN_B5; 
0C03:  MOVLW  35
0C04:  MOVWF  4D
....................    pLocalD.c = PIN_B6; 
0C05:  MOVLW  36
0C06:  MOVWF  4E
....................    pLocalD.d = PIN_B7; 
0C07:  MOVLW  37
0C08:  MOVWF  4F
....................     
....................    pVisitaU.a = PIN_D0; 
0C09:  MOVLW  40
0C0A:  MOVWF  50
....................    pVisitaU.b = PIN_D1; 
0C0B:  MOVLW  41
0C0C:  MOVWF  51
....................    pVisitaU.c = PIN_D2; 
0C0D:  MOVLW  42
0C0E:  MOVWF  52
....................    pVisitaU.d = PIN_D3; 
0C0F:  MOVLW  43
0C10:  MOVWF  53
....................     
....................    pVisitaD.a = PIN_D4; 
0C11:  MOVLW  44
0C12:  MOVWF  54
....................    pVisitaD.b = PIN_D5; 
0C13:  MOVLW  45
0C14:  MOVWF  55
....................    pVisitaD.c = PIN_D6; 
0C15:  MOVLW  46
0C16:  MOVWF  56
....................    pVisitaD.d = PIN_D7; 
0C17:  MOVLW  47
0C18:  MOVWF  57
....................     
....................    pFLocal.a = PIN_A4; 
0C19:  MOVLW  2C
0C1A:  MOVWF  58
....................    pFLocal.b = PIN_A5; 
0C1B:  MOVLW  2D
0C1C:  MOVWF  59
....................    pFLocal.c = PIN_A6; 
0C1D:  MOVLW  2E
0C1E:  MOVWF  5A
....................    pFLocal.d = PIN_A7; 
0C1F:  MOVLW  2F
0C20:  MOVWF  5B
....................     
....................    pFVisita.a = PIN_A0; 
0C21:  MOVLW  28
0C22:  MOVWF  5C
....................    pFVisita.b = PIN_A1; 
0C23:  MOVLW  29
0C24:  MOVWF  5D
....................    pFVisita.c = PIN_A2; 
0C25:  MOVLW  2A
0C26:  MOVWF  5E
....................    pFVisita.d = PIN_C0; 
0C27:  MOVLW  38
0C28:  MOVWF  5F
0C29:  CLRF   2B
0C2A:  BTFSC  0B.7
0C2B:  BSF    2B.7
0C2C:  BCF    0B.7
....................     
....................     
....................    delay_ms(DEFAULT_D); 
0C2D:  MOVLW  C8
0C2E:  BSF    03.5
0C2F:  MOVWF  21
0C30:  BCF    0A.3
0C31:  BCF    03.5
0C32:  CALL   29F
0C33:  BSF    0A.3
0C34:  BTFSC  2B.7
0C35:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de displays",RS232);} 
0C36:  BTFSS  05.3
0C37:  GOTO   44F
0C38:  MOVLW  06
0C39:  BSF    03.6
0C3A:  MOVWF  0D
0C3B:  MOVLW  01
0C3C:  MOVWF  0F
0C3D:  BCF    03.6
0C3E:  CLRF   2B
0C3F:  BTFSC  0B.7
0C40:  BSF    2B.7
0C41:  BCF    0B.7
0C42:  BCF    0A.3
0C43:  CALL   125
0C44:  BSF    0A.3
0C45:  BTFSC  2B.7
0C46:  BSF    0B.7
0C47:  MOVLW  0D
0C48:  BTFSS  0C.4
0C49:  GOTO   448
0C4A:  MOVWF  19
0C4B:  MOVLW  0A
0C4C:  BTFSS  0C.4
0C4D:  GOTO   44C
0C4E:  MOVWF  19
....................    output_bit(DISPLAY, ON);  
0C4F:  BSF    09.0
0C50:  MOVLW  E0
0C51:  BSF    03.5
0C52:  MOVWF  09
....................    output_bit(CENLOCAL, ON);  
0C53:  BCF    03.5
0C54:  BSF    07.2
0C55:  MOVLW  D8
0C56:  BSF    03.5
0C57:  MOVWF  07
....................    output_bit(CENVISITA, ON); 
0C58:  BCF    03.5
0C59:  BSF    09.2
0C5A:  MOVLW  E0
0C5B:  BSF    03.5
0C5C:  MOVWF  09
....................    output_bit(POSLOCAL, ON); 
0C5D:  BCF    03.5
0C5E:  BSF    07.1
0C5F:  MOVLW  D8
0C60:  BSF    03.5
0C61:  MOVWF  07
....................    output_bit(POSVISITA, ON); 
0C62:  BCF    03.5
0C63:  BSF    09.1
0C64:  MOVLW  E0
0C65:  BSF    03.5
0C66:  MOVWF  09
0C67:  BCF    03.5
0C68:  CLRF   2B
0C69:  BTFSC  0B.7
0C6A:  BSF    2B.7
0C6B:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C6C:  MOVLW  C8
0C6D:  BSF    03.5
0C6E:  MOVWF  21
0C6F:  BCF    0A.3
0C70:  BCF    03.5
0C71:  CALL   29F
0C72:  BSF    0A.3
0C73:  BTFSC  2B.7
0C74:  BSF    0B.7
....................    output_bit(DISPLAY, OFF); 
0C75:  BCF    09.0
0C76:  MOVLW  E0
0C77:  BSF    03.5
0C78:  MOVWF  09
....................    output_bit(CENLOCAL, OFF);  
0C79:  BCF    03.5
0C7A:  BCF    07.2
0C7B:  MOVLW  D8
0C7C:  BSF    03.5
0C7D:  MOVWF  07
....................    output_bit(CENVISITA, OFF); 
0C7E:  BCF    03.5
0C7F:  BCF    09.2
0C80:  MOVLW  E0
0C81:  BSF    03.5
0C82:  MOVWF  09
....................    output_bit(POSLOCAL, OFF); 
0C83:  BCF    03.5
0C84:  BCF    07.1
0C85:  MOVLW  D8
0C86:  BSF    03.5
0C87:  MOVWF  07
....................    output_bit(POSVISITA, OFF); 
0C88:  BCF    03.5
0C89:  BCF    09.1
0C8A:  MOVLW  E0
0C8B:  BSF    03.5
0C8C:  MOVWF  09
0C8D:  BCF    03.5
0C8E:  CLRF   2B
0C8F:  BTFSC  0B.7
0C90:  BSF    2B.7
0C91:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C92:  MOVLW  C8
0C93:  BSF    03.5
0C94:  MOVWF  21
0C95:  BCF    0A.3
0C96:  BCF    03.5
0C97:  CALL   29F
0C98:  BSF    0A.3
0C99:  BTFSC  2B.7
0C9A:  BSF    0B.7
....................    output_bit(DISPLAY, ON); 
0C9B:  BSF    09.0
0C9C:  MOVLW  E0
0C9D:  BSF    03.5
0C9E:  MOVWF  09
....................    output_bit(CENLOCAL, ON);  
0C9F:  BCF    03.5
0CA0:  BSF    07.2
0CA1:  MOVLW  D8
0CA2:  BSF    03.5
0CA3:  MOVWF  07
....................    output_bit(CENVISITA, ON); 
0CA4:  BCF    03.5
0CA5:  BSF    09.2
0CA6:  MOVLW  E0
0CA7:  BSF    03.5
0CA8:  MOVWF  09
....................    output_bit(POSLOCAL, ON); 
0CA9:  BCF    03.5
0CAA:  BSF    07.1
0CAB:  MOVLW  D8
0CAC:  BSF    03.5
0CAD:  MOVWF  07
....................    output_bit(POSVISITA, ON); 
0CAE:  BCF    03.5
0CAF:  BSF    09.1
0CB0:  MOVLW  E0
0CB1:  BSF    03.5
0CB2:  MOVWF  09
0CB3:  BCF    03.5
0CB4:  CLRF   2B
0CB5:  BTFSC  0B.7
0CB6:  BSF    2B.7
0CB7:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0CB8:  MOVLW  C8
0CB9:  BSF    03.5
0CBA:  MOVWF  21
0CBB:  BCF    0A.3
0CBC:  BCF    03.5
0CBD:  CALL   29F
0CBE:  BSF    0A.3
0CBF:  BTFSC  2B.7
0CC0:  BSF    0B.7
....................    output_bit(CENLOCAL, OFF);  
0CC1:  BCF    07.2
0CC2:  MOVLW  D8
0CC3:  BSF    03.5
0CC4:  MOVWF  07
....................    output_bit(CENVISITA, OFF); 
0CC5:  BCF    03.5
0CC6:  BCF    09.2
0CC7:  MOVLW  E0
0CC8:  BSF    03.5
0CC9:  MOVWF  09
....................    output_bit(POSLOCAL, OFF); 
0CCA:  BCF    03.5
0CCB:  BCF    07.1
0CCC:  MOVLW  D8
0CCD:  BSF    03.5
0CCE:  MOVWF  07
....................    output_bit(POSVISITA, OFF); 
0CCF:  BCF    03.5
0CD0:  BCF    09.1
0CD1:  MOVLW  E0
0CD2:  BSF    03.5
0CD3:  MOVWF  09
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
0CD4:  BCF    03.5
0CD5:  BTFSS  05.3
0CD6:  GOTO   4EE
0CD7:  MOVLW  14
0CD8:  BSF    03.6
0CD9:  MOVWF  0D
0CDA:  MOVLW  01
0CDB:  MOVWF  0F
0CDC:  BCF    03.6
0CDD:  CLRF   2B
0CDE:  BTFSC  0B.7
0CDF:  BSF    2B.7
0CE0:  BCF    0B.7
0CE1:  BCF    0A.3
0CE2:  CALL   125
0CE3:  BSF    0A.3
0CE4:  BTFSC  2B.7
0CE5:  BSF    0B.7
0CE6:  MOVLW  0D
0CE7:  BTFSS  0C.4
0CE8:  GOTO   4E7
0CE9:  MOVWF  19
0CEA:  MOVLW  0A
0CEB:  BTFSS  0C.4
0CEC:  GOTO   4EB
0CED:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
0CEE:  BSF    03.5
0CEF:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0CF0:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0CF1:  MOVLW  C0
0CF2:  BCF    03.5
0CF3:  IORWF  0B,F
0CF4:  BSF    0A.3
0CF5:  BCF    0A.4
0CF6:  GOTO   54F (RETURN)
.................... } 
....................  
.................... void main() 
0CF7:  MOVF   03,W
0CF8:  ANDLW  1F
0CF9:  MOVWF  03
0CFA:  MOVLW  71
0CFB:  BSF    03.5
0CFC:  MOVWF  0F
0CFD:  CLRF   10
0CFE:  MOVF   0F,W
0CFF:  BSF    03.6
0D00:  BCF    07.3
0D01:  MOVLW  0C
0D02:  BCF    03.6
0D03:  MOVWF  19
0D04:  MOVLW  A2
0D05:  MOVWF  18
0D06:  MOVLW  90
0D07:  BCF    03.5
0D08:  MOVWF  18
0D09:  MOVLW  D8
0D0A:  BSF    03.5
0D0B:  MOVWF  07
0D0C:  MOVLW  D8
0D0D:  MOVWF  07
0D0E:  MOVLW  0A
0D0F:  MOVWF  13
0D10:  MOVLW  09
0D11:  BCF    03.5
0D12:  MOVWF  14
0D13:  MOVLW  FF
0D14:  BSF    03.5
0D15:  MOVWF  13
0D16:  MOVLW  36
0D17:  BCF    03.5
0D18:  MOVWF  14
0D19:  BSF    03.5
0D1A:  BSF    11.0
0D1B:  BCF    03.5
0D1C:  CLRF   40
0D1D:  BCF    41.0
0D1E:  CLRF   63
0D1F:  CLRF   62
0D20:  MOVLW  03
0D21:  MOVWF  64
0D22:  BSF    03.5
0D23:  BSF    03.6
0D24:  MOVF   09,W
0D25:  ANDLW  C0
0D26:  MOVWF  09
0D27:  BCF    03.6
0D28:  BCF    1F.4
0D29:  BCF    1F.5
0D2A:  MOVLW  00
0D2B:  BSF    03.6
0D2C:  MOVWF  08
0D2D:  BCF    03.5
0D2E:  CLRF   07
0D2F:  CLRF   08
0D30:  CLRF   09
0D31:  BCF    03.7
.................... { 
....................    setup(); 
*
0D4E:  GOTO   323
....................  
....................    while(TRUE) 
....................    { 
0D4F:  GOTO   54F
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
0D50:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
05E0:  BTFSS  0C.5
05E1:  GOTO   5E0
05E2:  MOVF   1A,W
05E3:  MOVWF  6A
.................... if(cmdGet) 
05E4:  BTFSS  41.0
05E5:  GOTO   616
.................... { 
....................    if(c == '#' || c == '\r') 
05E6:  MOVF   6A,W
05E7:  SUBLW  23
05E8:  BTFSC  03.2
05E9:  GOTO   5EE
05EA:  MOVF   6A,W
05EB:  SUBLW  0D
05EC:  BTFSS  03.2
05ED:  GOTO   60B
....................    { 
....................       cmdGet = false; 
05EE:  BCF    41.0
....................       strcpy(cmd, rcmd); 
05EF:  CLRF   6E
05F0:  MOVLW  36
05F1:  MOVWF  6D
05F2:  CLRF   6C
05F3:  MOVLW  2C
05F4:  MOVWF  6B
05F5:  MOVF   6D,W
05F6:  MOVWF  04
05F7:  BCF    03.7
05F8:  BTFSC  6E.0
05F9:  BSF    03.7
05FA:  MOVF   00,W
05FB:  MOVWF  6F
05FC:  MOVF   6B,W
05FD:  MOVWF  04
05FE:  BCF    03.7
05FF:  BTFSC  6C.0
0600:  BSF    03.7
0601:  MOVF   6F,W
0602:  MOVWF  00
0603:  MOVF   00,F
0604:  BTFSC  03.2
0605:  GOTO   609
0606:  INCF   6B,F
0607:  INCF   6D,F
0608:  GOTO   5F5
....................       parseCommand(); 
0609:  GOTO   38F
....................    } 
060A:  GOTO   616
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
060B:  MOVF   40,W
060C:  SUBLW  08
060D:  BTFSS  03.0
060E:  GOTO   616
....................       { 
....................          rcmd[cmdIndex] = c; 
060F:  MOVLW  36
0610:  ADDWF  40,W
0611:  MOVWF  04
0612:  BCF    03.7
0613:  MOVF   6A,W
0614:  MOVWF  00
....................          cmdIndex++; 
0615:  INCF   40,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
0616:  MOVF   6A,W
0617:  SUBLW  2D
0618:  BTFSS  03.2
0619:  GOTO   62C
....................    { 
....................        cmdGet = true;  
061A:  BSF    41.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0"; 
061B:  CLRF   6B
061C:  CLRF   6C
061D:  MOVLW  36
061E:  MOVWF  04
061F:  BCF    03.7
0620:  MOVF   6B,W
0621:  ADDWF  04,F
0622:  MOVF   6C,W
0623:  CALL   05A
0624:  MOVWF  00
0625:  IORLW  00
0626:  BTFSC  03.2
0627:  GOTO   62B
0628:  INCF   6C,F
0629:  INCF   6B,F
062A:  GOTO   61D
....................        cmdIndex = 0; 
062B:  CLRF   40
....................    } 
.................... } 
....................  
062C:  BCF    0C.5
062D:  BCF    0A.3
062E:  BCF    0A.4
062F:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
*
0800:  BSF    03.5
0801:  BTFSC  14.5
0802:  GOTO   00B
0803:  BCF    03.5
0804:  CLRF   64
0805:  BSF    03.5
0806:  BTFSS  14.2
0807:  GOTO   00B
0808:  BCF    03.5
0809:  BSF    64.7
080A:  BSF    03.5
080B:  BCF    03.5
080C:  MOVF   64,W
080D:  INCF   64,F
080E:  MOVWF  6A
.................... { 
....................    int state = i2c_isr_state(); 
....................       if(state== 0 )  
080F:  MOVF   6A,F
0810:  BTFSS  03.2
0811:  GOTO   017
....................          i2c_read(); 
0812:  BCF    14.6
0813:  BTFSS  0C.3
0814:  GOTO   013
0815:  MOVF   13,W
0816:  BSF    14.4
....................       if(state == 0x80) 
0817:  MOVF   6A,W
0818:  SUBLW  80
0819:  BTFSC  03.2
081A:  GOTO   01B
....................          i2c_read(2); 
....................       if(state >= 0x80) 
081B:  MOVF   6A,W
081C:  SUBLW  7F
081D:  BTFSC  03.0
081E:  GOTO   02D
....................          i2c_write(0xFF); 
081F:  MOVLW  FF
0820:  MOVWF  6B
*
082C:  GOTO   2BF
....................       else if(state > 0) 
082D:  MOVF   6A,F
082E:  BTFSC  03.2
082F:  GOTO   2BF
....................       { 
....................          ircmd[state - 1] = i2c_read(); 
0830:  MOVLW  01
0831:  SUBWF  6A,W
0832:  ADDLW  43
0833:  MOVWF  04
0834:  BCF    03.7
0835:  BCF    14.6
0836:  BTFSS  0C.3
0837:  GOTO   036
0838:  MOVF   13,W
0839:  BSF    14.4
083A:  MOVWF  00
....................          if(DEBUG) {fprintf(RS232, "> Commando: %X - %X\r",state, ircmd[state - 1]);} 
083B:  BTFSS  05.3
083C:  GOTO   06E
083D:  MOVLW  01
083E:  SUBWF  6A,W
083F:  ADDLW  43
0840:  MOVWF  04
0841:  BCF    03.7
0842:  MOVF   00,W
0843:  MOVWF  6B
0844:  MOVLW  B1
0845:  BSF    03.6
0846:  MOVWF  0D
0847:  MOVLW  06
0848:  MOVWF  0F
0849:  BCF    03.0
084A:  MOVLW  0C
084B:  BCF    03.6
084C:  MOVWF  6C
084D:  BCF    0A.3
084E:  CALL   630
084F:  BSF    0A.3
0850:  MOVF   6A,W
0851:  MOVWF  6C
0852:  MOVLW  37
0853:  MOVWF  6D
0854:  BCF    0A.3
0855:  CALL   68E
0856:  BSF    0A.3
0857:  MOVLW  20
0858:  BTFSS  0C.4
0859:  GOTO   058
085A:  MOVWF  19
085B:  MOVLW  2D
085C:  BTFSS  0C.4
085D:  GOTO   05C
085E:  MOVWF  19
085F:  MOVLW  20
0860:  BTFSS  0C.4
0861:  GOTO   060
0862:  MOVWF  19
0863:  MOVF   6B,W
0864:  MOVWF  6C
0865:  MOVLW  37
0866:  MOVWF  6D
0867:  BCF    0A.3
0868:  CALL   68E
0869:  BSF    0A.3
086A:  MOVLW  0D
086B:  BTFSS  0C.4
086C:  GOTO   06B
086D:  MOVWF  19
....................          icmd = ircmd[state - 1]; 
086E:  MOVLW  01
086F:  SUBWF  6A,W
0870:  ADDLW  43
0871:  MOVWF  04
0872:  BCF    03.7
0873:  MOVF   00,W
0874:  MOVWF  42
....................          parseI2CCommand(); 
....................       } 
*
0ABF:  BCF    0C.3
0AC0:  BCF    0A.3
0AC1:  BCF    0A.4
0AC2:  GOTO   033
.................... } 
....................  
.................... void parseI2CCommand(void) 
*
0875:  MOVF   42,W
0876:  MOVWF  6B
.................... { 
....................    int c = icmd; 
....................    switch(c) 
0877:  MOVF   6B,W
0878:  XORLW  0A
0879:  BTFSC  03.2
087A:  GOTO   09A
087B:  XORLW  06
087C:  BTFSC  03.2
087D:  GOTO   0AE
087E:  XORLW  7C
087F:  BTFSC  03.2
0880:  GOTO   0C2
0881:  XORLW  01
0882:  BTFSC  03.2
0883:  GOTO   0E0
0884:  XORLW  03
0885:  BTFSC  03.2
0886:  GOTO   0FE
0887:  XORLW  01
0888:  BTFSC  03.2
0889:  GOTO   11C
088A:  XORLW  07
088B:  BTFSC  03.2
088C:  GOTO   135
088D:  XORLW  01
088E:  BTFSC  03.2
088F:  GOTO   14E
0890:  XORLW  03
0891:  BTFSC  03.2
0892:  GOTO   167
0893:  XORLW  89
0894:  BTFSC  03.2
0895:  GOTO   180
0896:  XORLW  02
0897:  BTFSC  03.2
0898:  GOTO   184
0899:  GOTO   187
....................    { 
....................       case I2C_TIMER:      if(DEBUG) {fputs("> Direccion TIMER",RS232);} 
089A:  BTFSS  05.3
089B:  GOTO   0AD
089C:  MOVLW  BC
089D:  BSF    03.6
089E:  MOVWF  0D
089F:  MOVLW  06
08A0:  MOVWF  0F
08A1:  BCF    0A.3
08A2:  BCF    03.6
08A3:  CALL   125
08A4:  BSF    0A.3
08A5:  MOVLW  0D
08A6:  BTFSS  0C.4
08A7:  GOTO   0A6
08A8:  MOVWF  19
08A9:  MOVLW  0A
08AA:  BTFSS  0C.4
08AB:  GOTO   0AA
08AC:  MOVWF  19
....................                            break; 
08AD:  GOTO   187
....................       case I2C_SCORE:      if(DEBUG) {fputs("> Direccion SCORE",RS232);} 
08AE:  BTFSS  05.3
08AF:  GOTO   0C1
08B0:  MOVLW  C5
08B1:  BSF    03.6
08B2:  MOVWF  0D
08B3:  MOVLW  06
08B4:  MOVWF  0F
08B5:  BCF    0A.3
08B6:  BCF    03.6
08B7:  CALL   125
08B8:  BSF    0A.3
08B9:  MOVLW  0D
08BA:  BTFSS  0C.4
08BB:  GOTO   0BA
08BC:  MOVWF  19
08BD:  MOVLW  0A
08BE:  BTFSS  0C.4
08BF:  GOTO   0BE
08C0:  MOVWF  19
....................                            break; 
08C1:  GOTO   187
....................       case I2C_CMD_POS0:   if(DEBUG) {fputs("> Apagar Posicion",RS232);} 
08C2:  BTFSS  05.3
08C3:  GOTO   0D5
08C4:  MOVLW  CE
08C5:  BSF    03.6
08C6:  MOVWF  0D
08C7:  MOVLW  06
08C8:  MOVWF  0F
08C9:  BCF    0A.3
08CA:  BCF    03.6
08CB:  CALL   125
08CC:  BSF    0A.3
08CD:  MOVLW  0D
08CE:  BTFSS  0C.4
08CF:  GOTO   0CE
08D0:  MOVWF  19
08D1:  MOVLW  0A
08D2:  BTFSS  0C.4
08D3:  GOTO   0D2
08D4:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, OFF); 
08D5:  BCF    07.1
08D6:  MOVLW  D8
08D7:  BSF    03.5
08D8:  MOVWF  07
08D9:  BCF    03.5
08DA:  BCF    09.1
08DB:  MOVLW  E0
08DC:  BSF    03.5
08DD:  MOVWF  09
....................                            break; 
08DE:  BCF    03.5
08DF:  GOTO   187
....................       case I2C_CMD_POSL:   if(DEBUG) {fputs("> Activar Posicion Local",RS232);} 
08E0:  BTFSS  05.3
08E1:  GOTO   0F3
08E2:  MOVLW  D7
08E3:  BSF    03.6
08E4:  MOVWF  0D
08E5:  MOVLW  06
08E6:  MOVWF  0F
08E7:  BCF    0A.3
08E8:  BCF    03.6
08E9:  CALL   125
08EA:  BSF    0A.3
08EB:  MOVLW  0D
08EC:  BTFSS  0C.4
08ED:  GOTO   0EC
08EE:  MOVWF  19
08EF:  MOVLW  0A
08F0:  BTFSS  0C.4
08F1:  GOTO   0F0
08F2:  MOVWF  19
....................                            output_bit(POSLOCAL, ON); output_bit(POSVISITA, OFF); 
08F3:  BSF    07.1
08F4:  MOVLW  D8
08F5:  BSF    03.5
08F6:  MOVWF  07
08F7:  BCF    03.5
08F8:  BCF    09.1
08F9:  MOVLW  E0
08FA:  BSF    03.5
08FB:  MOVWF  09
....................                            break; 
08FC:  BCF    03.5
08FD:  GOTO   187
....................       case I2C_CMD_POSV:   if(DEBUG) {fputs("> Activar Posicion Visita",RS232);} 
08FE:  BTFSS  05.3
08FF:  GOTO   111
0900:  MOVLW  E4
0901:  BSF    03.6
0902:  MOVWF  0D
0903:  MOVLW  06
0904:  MOVWF  0F
0905:  BCF    0A.3
0906:  BCF    03.6
0907:  CALL   125
0908:  BSF    0A.3
0909:  MOVLW  0D
090A:  BTFSS  0C.4
090B:  GOTO   10A
090C:  MOVWF  19
090D:  MOVLW  0A
090E:  BTFSS  0C.4
090F:  GOTO   10E
0910:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, ON); 
0911:  BCF    07.1
0912:  MOVLW  D8
0913:  BSF    03.5
0914:  MOVWF  07
0915:  BCF    03.5
0916:  BSF    09.1
0917:  MOVLW  E0
0918:  BSF    03.5
0919:  MOVWF  09
....................                            break; 
091A:  BCF    03.5
091B:  GOTO   187
....................       case I2C_CMD_CLON:   if(DEBUG) {fputs("> Activar Centena Local",RS232);} 
091C:  BTFSS  05.3
091D:  GOTO   12F
091E:  MOVLW  F1
091F:  BSF    03.6
0920:  MOVWF  0D
0921:  MOVLW  06
0922:  MOVWF  0F
0923:  BCF    0A.3
0924:  BCF    03.6
0925:  CALL   125
0926:  BSF    0A.3
0927:  MOVLW  0D
0928:  BTFSS  0C.4
0929:  GOTO   128
092A:  MOVWF  19
092B:  MOVLW  0A
092C:  BTFSS  0C.4
092D:  GOTO   12C
092E:  MOVWF  19
....................                            output_bit(CENLOCAL, ON); 
092F:  BSF    07.2
0930:  MOVLW  D8
0931:  BSF    03.5
0932:  MOVWF  07
....................                            break; 
0933:  BCF    03.5
0934:  GOTO   187
....................       case I2C_CMD_CLOF:   if(DEBUG) {fputs("> Desactivar Centena Local",RS232);} 
0935:  BTFSS  05.3
0936:  GOTO   148
0937:  MOVLW  FD
0938:  BSF    03.6
0939:  MOVWF  0D
093A:  MOVLW  06
093B:  MOVWF  0F
093C:  BCF    0A.3
093D:  BCF    03.6
093E:  CALL   125
093F:  BSF    0A.3
0940:  MOVLW  0D
0941:  BTFSS  0C.4
0942:  GOTO   141
0943:  MOVWF  19
0944:  MOVLW  0A
0945:  BTFSS  0C.4
0946:  GOTO   145
0947:  MOVWF  19
....................                            output_bit(CENLOCAL, OFF); 
0948:  BCF    07.2
0949:  MOVLW  D8
094A:  BSF    03.5
094B:  MOVWF  07
....................                            break; 
094C:  BCF    03.5
094D:  GOTO   187
....................       case I2C_CMD_CVON:   if(DEBUG) {fputs("> Activar Centena Visita",RS232);} 
094E:  BTFSS  05.3
094F:  GOTO   161
0950:  MOVLW  0B
0951:  BSF    03.6
0952:  MOVWF  0D
0953:  MOVLW  07
0954:  MOVWF  0F
0955:  BCF    0A.3
0956:  BCF    03.6
0957:  CALL   125
0958:  BSF    0A.3
0959:  MOVLW  0D
095A:  BTFSS  0C.4
095B:  GOTO   15A
095C:  MOVWF  19
095D:  MOVLW  0A
095E:  BTFSS  0C.4
095F:  GOTO   15E
0960:  MOVWF  19
....................                            output_bit(CENVISITA, ON);; 
0961:  BSF    09.2
0962:  MOVLW  E0
0963:  BSF    03.5
0964:  MOVWF  09
....................                            break; 
0965:  BCF    03.5
0966:  GOTO   187
....................       case I2C_CMD_CVOF:   if(DEBUG) {fputs("> Desactivar Centena Visita",RS232);} 
0967:  BTFSS  05.3
0968:  GOTO   17A
0969:  MOVLW  18
096A:  BSF    03.6
096B:  MOVWF  0D
096C:  MOVLW  07
096D:  MOVWF  0F
096E:  BCF    0A.3
096F:  BCF    03.6
0970:  CALL   125
0971:  BSF    0A.3
0972:  MOVLW  0D
0973:  BTFSS  0C.4
0974:  GOTO   173
0975:  MOVWF  19
0976:  MOVLW  0A
0977:  BTFSS  0C.4
0978:  GOTO   177
0979:  MOVWF  19
....................                            output_bit(CENVISITA, OFF); 
097A:  BCF    09.2
097B:  MOVLW  E0
097C:  BSF    03.5
097D:  MOVWF  09
....................                            break; 
097E:  BCF    03.5
097F:  GOTO   187
....................       case I2C_CMD_TEST:   doTest();    
0980:  BCF    0A.3
0981:  CALL   2B3
0982:  BSF    0A.3
....................                            break; 
0983:  GOTO   187
....................       case I2C_CMD_RESET:  doReset(); 
0984:  BCF    0A.3
0985:  CALL   37B
0986:  BSF    0A.3
....................                            break; 
....................    } 
....................     
....................    if(c > 0x0F && c < 0x1A) //0x10 - 0x19 
0987:  MOVF   6B,W
0988:  SUBLW  0F
0989:  BTFSC  03.0
098A:  GOTO   1BB
098B:  MOVF   6B,W
098C:  SUBLW  19
098D:  BTFSS  03.0
098E:  GOTO   1BB
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 1",RS232);} 
098F:  BTFSS  05.3
0990:  GOTO   1A2
0991:  MOVLW  26
0992:  BSF    03.6
0993:  MOVWF  0D
0994:  MOVLW  07
0995:  MOVWF  0F
0996:  BCF    0A.3
0997:  BCF    03.6
0998:  CALL   125
0999:  BSF    0A.3
099A:  MOVLW  0D
099B:  BTFSS  0C.4
099C:  GOTO   19B
099D:  MOVWF  19
099E:  MOVLW  0A
099F:  BTFSS  0C.4
09A0:  GOTO   19F
09A1:  MOVWF  19
....................       showNumber(c - 0x10, pLocalU);    
09A2:  MOVLW  10
09A3:  SUBWF  6B,W
09A4:  MOVWF  6C
09A5:  BSF    03.5
09A6:  MOVWF  21
09A7:  BCF    03.5
09A8:  MOVF   4B,W
09A9:  BSF    03.5
09AA:  MOVWF  25
09AB:  BCF    03.5
09AC:  MOVF   4A,W
09AD:  BSF    03.5
09AE:  MOVWF  24
09AF:  BCF    03.5
09B0:  MOVF   49,W
09B1:  BSF    03.5
09B2:  MOVWF  23
09B3:  BCF    03.5
09B4:  MOVF   48,W
09B5:  BSF    03.5
09B6:  MOVWF  22
09B7:  BCF    0A.3
09B8:  BCF    03.5
09B9:  CALL   20B
09BA:  BSF    0A.3
....................    } 
....................    if(c > 0x1F && c < 0x2A) //0x20 - 0x29 
09BB:  MOVF   6B,W
09BC:  SUBLW  1F
09BD:  BTFSC  03.0
09BE:  GOTO   1EF
09BF:  MOVF   6B,W
09C0:  SUBLW  29
09C1:  BTFSS  03.0
09C2:  GOTO   1EF
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 2",RS232);} 
09C3:  BTFSS  05.3
09C4:  GOTO   1D6
09C5:  MOVLW  31
09C6:  BSF    03.6
09C7:  MOVWF  0D
09C8:  MOVLW  07
09C9:  MOVWF  0F
09CA:  BCF    0A.3
09CB:  BCF    03.6
09CC:  CALL   125
09CD:  BSF    0A.3
09CE:  MOVLW  0D
09CF:  BTFSS  0C.4
09D0:  GOTO   1CF
09D1:  MOVWF  19
09D2:  MOVLW  0A
09D3:  BTFSS  0C.4
09D4:  GOTO   1D3
09D5:  MOVWF  19
....................       showNumber(c - 0x20, pLocalD);    
09D6:  MOVLW  20
09D7:  SUBWF  6B,W
09D8:  MOVWF  6C
09D9:  BSF    03.5
09DA:  MOVWF  21
09DB:  BCF    03.5
09DC:  MOVF   4F,W
09DD:  BSF    03.5
09DE:  MOVWF  25
09DF:  BCF    03.5
09E0:  MOVF   4E,W
09E1:  BSF    03.5
09E2:  MOVWF  24
09E3:  BCF    03.5
09E4:  MOVF   4D,W
09E5:  BSF    03.5
09E6:  MOVWF  23
09E7:  BCF    03.5
09E8:  MOVF   4C,W
09E9:  BSF    03.5
09EA:  MOVWF  22
09EB:  BCF    0A.3
09EC:  BCF    03.5
09ED:  CALL   20B
09EE:  BSF    0A.3
....................    } 
....................    if(c > 0x2F && c < 0x3A) //0x30 - 0x39 
09EF:  MOVF   6B,W
09F0:  SUBLW  2F
09F1:  BTFSC  03.0
09F2:  GOTO   223
09F3:  MOVF   6B,W
09F4:  SUBLW  39
09F5:  BTFSS  03.0
09F6:  GOTO   223
....................    { 
....................    if(DEBUG) {fputs("> Asignacion Puerto 3",RS232);} 
09F7:  BTFSS  05.3
09F8:  GOTO   20A
09F9:  MOVLW  3C
09FA:  BSF    03.6
09FB:  MOVWF  0D
09FC:  MOVLW  07
09FD:  MOVWF  0F
09FE:  BCF    0A.3
09FF:  BCF    03.6
0A00:  CALL   125
0A01:  BSF    0A.3
0A02:  MOVLW  0D
0A03:  BTFSS  0C.4
0A04:  GOTO   203
0A05:  MOVWF  19
0A06:  MOVLW  0A
0A07:  BTFSS  0C.4
0A08:  GOTO   207
0A09:  MOVWF  19
....................       showNumber(c - 0x30, pVisitaD);    
0A0A:  MOVLW  30
0A0B:  SUBWF  6B,W
0A0C:  MOVWF  6C
0A0D:  BSF    03.5
0A0E:  MOVWF  21
0A0F:  BCF    03.5
0A10:  MOVF   57,W
0A11:  BSF    03.5
0A12:  MOVWF  25
0A13:  BCF    03.5
0A14:  MOVF   56,W
0A15:  BSF    03.5
0A16:  MOVWF  24
0A17:  BCF    03.5
0A18:  MOVF   55,W
0A19:  BSF    03.5
0A1A:  MOVWF  23
0A1B:  BCF    03.5
0A1C:  MOVF   54,W
0A1D:  BSF    03.5
0A1E:  MOVWF  22
0A1F:  BCF    0A.3
0A20:  BCF    03.5
0A21:  CALL   20B
0A22:  BSF    0A.3
....................    } 
....................    if(c > 0x3F && c < 0x4A) //0x40 - 0x49 
0A23:  MOVF   6B,W
0A24:  SUBLW  3F
0A25:  BTFSC  03.0
0A26:  GOTO   257
0A27:  MOVF   6B,W
0A28:  SUBLW  49
0A29:  BTFSS  03.0
0A2A:  GOTO   257
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 4",RS232);} 
0A2B:  BTFSS  05.3
0A2C:  GOTO   23E
0A2D:  MOVLW  47
0A2E:  BSF    03.6
0A2F:  MOVWF  0D
0A30:  MOVLW  07
0A31:  MOVWF  0F
0A32:  BCF    0A.3
0A33:  BCF    03.6
0A34:  CALL   125
0A35:  BSF    0A.3
0A36:  MOVLW  0D
0A37:  BTFSS  0C.4
0A38:  GOTO   237
0A39:  MOVWF  19
0A3A:  MOVLW  0A
0A3B:  BTFSS  0C.4
0A3C:  GOTO   23B
0A3D:  MOVWF  19
....................       showNumber(c - 0x40, pVisitaU);    
0A3E:  MOVLW  40
0A3F:  SUBWF  6B,W
0A40:  MOVWF  6C
0A41:  BSF    03.5
0A42:  MOVWF  21
0A43:  BCF    03.5
0A44:  MOVF   53,W
0A45:  BSF    03.5
0A46:  MOVWF  25
0A47:  BCF    03.5
0A48:  MOVF   52,W
0A49:  BSF    03.5
0A4A:  MOVWF  24
0A4B:  BCF    03.5
0A4C:  MOVF   51,W
0A4D:  BSF    03.5
0A4E:  MOVWF  23
0A4F:  BCF    03.5
0A50:  MOVF   50,W
0A51:  BSF    03.5
0A52:  MOVWF  22
0A53:  BCF    0A.3
0A54:  BCF    03.5
0A55:  CALL   20B
0A56:  BSF    0A.3
....................    } 
....................    if(c > 0x4F && c < 0x5A) //0x50 - 0x59 
0A57:  MOVF   6B,W
0A58:  SUBLW  4F
0A59:  BTFSC  03.0
0A5A:  GOTO   28B
0A5B:  MOVF   6B,W
0A5C:  SUBLW  59
0A5D:  BTFSS  03.0
0A5E:  GOTO   28B
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 5",RS232);} 
0A5F:  BTFSS  05.3
0A60:  GOTO   272
0A61:  MOVLW  52
0A62:  BSF    03.6
0A63:  MOVWF  0D
0A64:  MOVLW  07
0A65:  MOVWF  0F
0A66:  BCF    0A.3
0A67:  BCF    03.6
0A68:  CALL   125
0A69:  BSF    0A.3
0A6A:  MOVLW  0D
0A6B:  BTFSS  0C.4
0A6C:  GOTO   26B
0A6D:  MOVWF  19
0A6E:  MOVLW  0A
0A6F:  BTFSS  0C.4
0A70:  GOTO   26F
0A71:  MOVWF  19
....................       showNumber(c - 0x50, pFLocal);    
0A72:  MOVLW  50
0A73:  SUBWF  6B,W
0A74:  MOVWF  6C
0A75:  BSF    03.5
0A76:  MOVWF  21
0A77:  BCF    03.5
0A78:  MOVF   5B,W
0A79:  BSF    03.5
0A7A:  MOVWF  25
0A7B:  BCF    03.5
0A7C:  MOVF   5A,W
0A7D:  BSF    03.5
0A7E:  MOVWF  24
0A7F:  BCF    03.5
0A80:  MOVF   59,W
0A81:  BSF    03.5
0A82:  MOVWF  23
0A83:  BCF    03.5
0A84:  MOVF   58,W
0A85:  BSF    03.5
0A86:  MOVWF  22
0A87:  BCF    0A.3
0A88:  BCF    03.5
0A89:  CALL   20B
0A8A:  BSF    0A.3
....................    } 
....................    if(c > 0x5F && c < 0x6A) //0x60 - 0x69 
0A8B:  MOVF   6B,W
0A8C:  SUBLW  5F
0A8D:  BTFSC  03.0
0A8E:  GOTO   2BF
0A8F:  MOVF   6B,W
0A90:  SUBLW  69
0A91:  BTFSS  03.0
0A92:  GOTO   2BF
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 6",RS232);} 
0A93:  BTFSS  05.3
0A94:  GOTO   2A6
0A95:  MOVLW  5D
0A96:  BSF    03.6
0A97:  MOVWF  0D
0A98:  MOVLW  07
0A99:  MOVWF  0F
0A9A:  BCF    0A.3
0A9B:  BCF    03.6
0A9C:  CALL   125
0A9D:  BSF    0A.3
0A9E:  MOVLW  0D
0A9F:  BTFSS  0C.4
0AA0:  GOTO   29F
0AA1:  MOVWF  19
0AA2:  MOVLW  0A
0AA3:  BTFSS  0C.4
0AA4:  GOTO   2A3
0AA5:  MOVWF  19
....................       showNumber(c - 0x60, pFVisita);    
0AA6:  MOVLW  60
0AA7:  SUBWF  6B,W
0AA8:  MOVWF  6C
0AA9:  BSF    03.5
0AAA:  MOVWF  21
0AAB:  BCF    03.5
0AAC:  MOVF   5F,W
0AAD:  BSF    03.5
0AAE:  MOVWF  25
0AAF:  BCF    03.5
0AB0:  MOVF   5E,W
0AB1:  BSF    03.5
0AB2:  MOVWF  24
0AB3:  BCF    03.5
0AB4:  MOVF   5D,W
0AB5:  BSF    03.5
0AB6:  MOVWF  23
0AB7:  BCF    03.5
0AB8:  MOVF   5C,W
0AB9:  BSF    03.5
0ABA:  MOVWF  22
0ABB:  BCF    0A.3
0ABC:  BCF    03.5
0ABD:  CALL   20B
0ABE:  BSF    0A.3
....................    } 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
02B3:  BTFSS  05.3
02B4:  GOTO   2C4
02B5:  MOVLW  68
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  MOVLW  07
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  CALL   125
02BC:  MOVLW  0D
02BD:  BTFSS  0C.4
02BE:  GOTO   2BD
02BF:  MOVWF  19
02C0:  MOVLW  0A
02C1:  BTFSS  0C.4
02C2:  GOTO   2C1
02C3:  MOVWF  19
....................    output_bit(CENLOCAL, OFF); 
02C4:  BCF    07.2
02C5:  MOVLW  D8
02C6:  BSF    03.5
02C7:  MOVWF  07
....................    output_bit(CENVISITA, OFF); 
02C8:  BCF    03.5
02C9:  BCF    09.2
02CA:  MOVLW  E0
02CB:  BSF    03.5
02CC:  MOVWF  09
....................    output_bit(POSLOCAL, OFF); 
02CD:  BCF    03.5
02CE:  BCF    07.1
02CF:  MOVLW  D8
02D0:  BSF    03.5
02D1:  MOVWF  07
....................    output_bit(POSVISITA, OFF); 
02D2:  BCF    03.5
02D3:  BCF    09.1
02D4:  MOVLW  E0
02D5:  BSF    03.5
02D6:  MOVWF  09
....................     
....................    for(int i=0; i<10; i++) 
02D7:  CLRF   20
02D8:  MOVF   20,W
02D9:  SUBLW  09
02DA:  BTFSS  03.0
02DB:  GOTO   379
....................    { 
....................       showNumber(i, pLocalD); 
02DC:  MOVF   20,W
02DD:  MOVWF  21
02DE:  BCF    03.5
02DF:  MOVF   4F,W
02E0:  BSF    03.5
02E1:  MOVWF  25
02E2:  BCF    03.5
02E3:  MOVF   4E,W
02E4:  BSF    03.5
02E5:  MOVWF  24
02E6:  BCF    03.5
02E7:  MOVF   4D,W
02E8:  BSF    03.5
02E9:  MOVWF  23
02EA:  BCF    03.5
02EB:  MOVF   4C,W
02EC:  BSF    03.5
02ED:  MOVWF  22
02EE:  BCF    03.5
02EF:  CALL   20B
....................       showNumber(i, pLocalU); 
02F0:  BSF    03.5
02F1:  MOVF   20,W
02F2:  MOVWF  21
02F3:  BCF    03.5
02F4:  MOVF   4B,W
02F5:  BSF    03.5
02F6:  MOVWF  25
02F7:  BCF    03.5
02F8:  MOVF   4A,W
02F9:  BSF    03.5
02FA:  MOVWF  24
02FB:  BCF    03.5
02FC:  MOVF   49,W
02FD:  BSF    03.5
02FE:  MOVWF  23
02FF:  BCF    03.5
0300:  MOVF   48,W
0301:  BSF    03.5
0302:  MOVWF  22
0303:  BCF    03.5
0304:  CALL   20B
....................       showNumber(i, pVisitaD); 
0305:  BSF    03.5
0306:  MOVF   20,W
0307:  MOVWF  21
0308:  BCF    03.5
0309:  MOVF   57,W
030A:  BSF    03.5
030B:  MOVWF  25
030C:  BCF    03.5
030D:  MOVF   56,W
030E:  BSF    03.5
030F:  MOVWF  24
0310:  BCF    03.5
0311:  MOVF   55,W
0312:  BSF    03.5
0313:  MOVWF  23
0314:  BCF    03.5
0315:  MOVF   54,W
0316:  BSF    03.5
0317:  MOVWF  22
0318:  BCF    03.5
0319:  CALL   20B
....................       showNumber(i, pVisitaU); 
031A:  BSF    03.5
031B:  MOVF   20,W
031C:  MOVWF  21
031D:  BCF    03.5
031E:  MOVF   53,W
031F:  BSF    03.5
0320:  MOVWF  25
0321:  BCF    03.5
0322:  MOVF   52,W
0323:  BSF    03.5
0324:  MOVWF  24
0325:  BCF    03.5
0326:  MOVF   51,W
0327:  BSF    03.5
0328:  MOVWF  23
0329:  BCF    03.5
032A:  MOVF   50,W
032B:  BSF    03.5
032C:  MOVWF  22
032D:  BCF    03.5
032E:  CALL   20B
....................       showNumber(i, pFLocal); 
032F:  BSF    03.5
0330:  MOVF   20,W
0331:  MOVWF  21
0332:  BCF    03.5
0333:  MOVF   5B,W
0334:  BSF    03.5
0335:  MOVWF  25
0336:  BCF    03.5
0337:  MOVF   5A,W
0338:  BSF    03.5
0339:  MOVWF  24
033A:  BCF    03.5
033B:  MOVF   59,W
033C:  BSF    03.5
033D:  MOVWF  23
033E:  BCF    03.5
033F:  MOVF   58,W
0340:  BSF    03.5
0341:  MOVWF  22
0342:  BCF    03.5
0343:  CALL   20B
....................       showNumber(i, pFVisita); 
0344:  BSF    03.5
0345:  MOVF   20,W
0346:  MOVWF  21
0347:  BCF    03.5
0348:  MOVF   5F,W
0349:  BSF    03.5
034A:  MOVWF  25
034B:  BCF    03.5
034C:  MOVF   5E,W
034D:  BSF    03.5
034E:  MOVWF  24
034F:  BCF    03.5
0350:  MOVF   5D,W
0351:  BSF    03.5
0352:  MOVWF  23
0353:  BCF    03.5
0354:  MOVF   5C,W
0355:  BSF    03.5
0356:  MOVWF  22
0357:  BCF    03.5
0358:  CALL   20B
....................       output_toggle(POSLOCAL); 
0359:  MOVLW  D8
035A:  BSF    03.5
035B:  MOVWF  07
035C:  MOVLW  02
035D:  BCF    03.5
035E:  XORWF  07,F
....................       output_toggle(POSVISITA); 
035F:  MOVLW  E0
0360:  BSF    03.5
0361:  MOVWF  09
0362:  MOVLW  02
0363:  BCF    03.5
0364:  XORWF  09,F
....................       output_toggle(CENLOCAL); 
0365:  MOVLW  D8
0366:  BSF    03.5
0367:  MOVWF  07
0368:  MOVLW  04
0369:  BCF    03.5
036A:  XORWF  07,F
....................       output_toggle(CENVISITA); 
036B:  MOVLW  E0
036C:  BSF    03.5
036D:  MOVWF  09
036E:  MOVLW  04
036F:  BCF    03.5
0370:  XORWF  09,F
....................       delay_ms(DEFAULT_D); 
0371:  MOVLW  C8
0372:  BSF    03.5
0373:  MOVWF  21
0374:  BCF    03.5
0375:  CALL   29F
0376:  BSF    03.5
0377:  INCF   20,F
0378:  GOTO   2D8
....................    } 
0379:  BCF    03.5
037A:  RETURN
.................... } 
....................  
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
038F:  BSF    03.5
0390:  CLRF   23
0391:  MOVLW  2C
0392:  MOVWF  22
0393:  CLRF   21
0394:  MOVLW  6B
0395:  MOVWF  20
0396:  MOVF   22,W
0397:  MOVWF  04
0398:  BCF    03.7
0399:  BTFSC  23.0
039A:  BSF    03.7
039B:  MOVF   00,W
039C:  MOVWF  24
039D:  MOVF   20,W
039E:  MOVWF  04
039F:  BCF    03.7
03A0:  BTFSC  21.0
03A1:  BSF    03.7
03A2:  MOVF   24,W
03A3:  MOVWF  00
03A4:  MOVF   00,F
03A5:  BTFSC  03.2
03A6:  GOTO   3AA
03A7:  INCF   20,F
03A8:  INCF   22,F
03A9:  GOTO   396
....................    switch(c[0]) 
03AA:  BCF    03.5
03AB:  MOVF   6B,W
03AC:  XORLW  30
03AD:  BTFSC  03.2
03AE:  GOTO   3CB
03AF:  XORLW  71
03B0:  BTFSC  03.2
03B1:  GOTO   48B
03B2:  XORLW  03
03B3:  BTFSC  03.2
03B4:  GOTO   4A7
03B5:  XORLW  01
03B6:  BTFSC  03.2
03B7:  GOTO   4C3
03B8:  XORLW  07
03B9:  BTFSC  03.2
03BA:  GOTO   4DF
03BB:  XORLW  01
03BC:  BTFSC  03.2
03BD:  GOTO   4F6
03BE:  XORLW  03
03BF:  BTFSC  03.2
03C0:  GOTO   50D
03C1:  XORLW  01
03C2:  BTFSC  03.2
03C3:  GOTO   524
03C4:  XORLW  1F
03C5:  BTFSC  03.2
03C6:  GOTO   53B
03C7:  XORLW  02
03C8:  BTFSC  03.2
03C9:  GOTO   53D
03CA:  GOTO   5D3
....................    { 
....................       case '0':   if(DEBUG) {fputs("\r> Activacion manual de puerto",RS232);} 
03CB:  BTFSS  05.3
03CC:  GOTO   3DC
03CD:  MOVLW  72
03CE:  BSF    03.6
03CF:  MOVWF  0D
03D0:  MOVLW  07
03D1:  MOVWF  0F
03D2:  BCF    03.6
03D3:  CALL   125
03D4:  MOVLW  0D
03D5:  BTFSS  0C.4
03D6:  GOTO   3D5
03D7:  MOVWF  19
03D8:  MOVLW  0A
03D9:  BTFSS  0C.4
03DA:  GOTO   3D9
03DB:  MOVWF  19
....................                   switch(c[2]) 
03DC:  MOVLW  31
03DD:  SUBWF  6D,W
03DE:  ADDLW  FA
03DF:  BTFSC  03.0
03E0:  GOTO   48A
03E1:  ADDLW  06
03E2:  GOTO   5D6
....................                   { 
....................                      case '1':   showNumber(char2int(c[3]), pLocalU); 
03E3:  MOVF   6E,W
03E4:  BSF    03.5
03E5:  MOVWF  20
03E6:  BCF    03.5
03E7:  CALL   19B
03E8:  MOVF   78,W
03E9:  BSF    03.5
03EA:  MOVWF  20
03EB:  MOVWF  21
03EC:  BCF    03.5
03ED:  MOVF   4B,W
03EE:  BSF    03.5
03EF:  MOVWF  25
03F0:  BCF    03.5
03F1:  MOVF   4A,W
03F2:  BSF    03.5
03F3:  MOVWF  24
03F4:  BCF    03.5
03F5:  MOVF   49,W
03F6:  BSF    03.5
03F7:  MOVWF  23
03F8:  BCF    03.5
03F9:  MOVF   48,W
03FA:  BSF    03.5
03FB:  MOVWF  22
03FC:  BCF    03.5
03FD:  CALL   20B
....................                                  break; 
03FE:  GOTO   48A
....................                      case '2':   showNumber(char2int(c[3]), pLocalD); 
03FF:  MOVF   6E,W
0400:  BSF    03.5
0401:  MOVWF  20
0402:  BCF    03.5
0403:  CALL   19B
0404:  MOVF   78,W
0405:  BSF    03.5
0406:  MOVWF  20
0407:  MOVWF  21
0408:  BCF    03.5
0409:  MOVF   4F,W
040A:  BSF    03.5
040B:  MOVWF  25
040C:  BCF    03.5
040D:  MOVF   4E,W
040E:  BSF    03.5
040F:  MOVWF  24
0410:  BCF    03.5
0411:  MOVF   4D,W
0412:  BSF    03.5
0413:  MOVWF  23
0414:  BCF    03.5
0415:  MOVF   4C,W
0416:  BSF    03.5
0417:  MOVWF  22
0418:  BCF    03.5
0419:  CALL   20B
....................                                  break; 
041A:  GOTO   48A
....................                      case '3':   showNumber(char2int(c[3]), pVisitaD); 
041B:  MOVF   6E,W
041C:  BSF    03.5
041D:  MOVWF  20
041E:  BCF    03.5
041F:  CALL   19B
0420:  MOVF   78,W
0421:  BSF    03.5
0422:  MOVWF  20
0423:  MOVWF  21
0424:  BCF    03.5
0425:  MOVF   57,W
0426:  BSF    03.5
0427:  MOVWF  25
0428:  BCF    03.5
0429:  MOVF   56,W
042A:  BSF    03.5
042B:  MOVWF  24
042C:  BCF    03.5
042D:  MOVF   55,W
042E:  BSF    03.5
042F:  MOVWF  23
0430:  BCF    03.5
0431:  MOVF   54,W
0432:  BSF    03.5
0433:  MOVWF  22
0434:  BCF    03.5
0435:  CALL   20B
....................                                  break; 
0436:  GOTO   48A
....................                      case '4':   showNumber(char2int(c[3]), pVisitaU); 
0437:  MOVF   6E,W
0438:  BSF    03.5
0439:  MOVWF  20
043A:  BCF    03.5
043B:  CALL   19B
043C:  MOVF   78,W
043D:  BSF    03.5
043E:  MOVWF  20
043F:  MOVWF  21
0440:  BCF    03.5
0441:  MOVF   53,W
0442:  BSF    03.5
0443:  MOVWF  25
0444:  BCF    03.5
0445:  MOVF   52,W
0446:  BSF    03.5
0447:  MOVWF  24
0448:  BCF    03.5
0449:  MOVF   51,W
044A:  BSF    03.5
044B:  MOVWF  23
044C:  BCF    03.5
044D:  MOVF   50,W
044E:  BSF    03.5
044F:  MOVWF  22
0450:  BCF    03.5
0451:  CALL   20B
....................                                  break; 
0452:  GOTO   48A
....................                      case '5':   showNumber(char2int(c[3]), pFLocal); 
0453:  MOVF   6E,W
0454:  BSF    03.5
0455:  MOVWF  20
0456:  BCF    03.5
0457:  CALL   19B
0458:  MOVF   78,W
0459:  BSF    03.5
045A:  MOVWF  20
045B:  MOVWF  21
045C:  BCF    03.5
045D:  MOVF   5B,W
045E:  BSF    03.5
045F:  MOVWF  25
0460:  BCF    03.5
0461:  MOVF   5A,W
0462:  BSF    03.5
0463:  MOVWF  24
0464:  BCF    03.5
0465:  MOVF   59,W
0466:  BSF    03.5
0467:  MOVWF  23
0468:  BCF    03.5
0469:  MOVF   58,W
046A:  BSF    03.5
046B:  MOVWF  22
046C:  BCF    03.5
046D:  CALL   20B
....................                                  break; 
046E:  GOTO   48A
....................                      case '6':   showNumber(char2int(c[3]), pFVisita); 
046F:  MOVF   6E,W
0470:  BSF    03.5
0471:  MOVWF  20
0472:  BCF    03.5
0473:  CALL   19B
0474:  MOVF   78,W
0475:  BSF    03.5
0476:  MOVWF  20
0477:  MOVWF  21
0478:  BCF    03.5
0479:  MOVF   5F,W
047A:  BSF    03.5
047B:  MOVWF  25
047C:  BCF    03.5
047D:  MOVF   5E,W
047E:  BSF    03.5
047F:  MOVWF  24
0480:  BCF    03.5
0481:  MOVF   5D,W
0482:  BSF    03.5
0483:  MOVWF  23
0484:  BCF    03.5
0485:  MOVF   5C,W
0486:  BSF    03.5
0487:  MOVWF  22
0488:  BCF    03.5
0489:  CALL   20B
....................                                  break; 
....................                   } 
....................                   break; 
048A:  GOTO   5D3
....................       case 'A':   if(DEBUG) {fputs("> Apagar Posicion",RS232);} 
048B:  BTFSS  05.3
048C:  GOTO   49C
048D:  MOVLW  82
048E:  BSF    03.6
048F:  MOVWF  0D
0490:  MOVLW  07
0491:  MOVWF  0F
0492:  BCF    03.6
0493:  CALL   125
0494:  MOVLW  0D
0495:  BTFSS  0C.4
0496:  GOTO   495
0497:  MOVWF  19
0498:  MOVLW  0A
0499:  BTFSS  0C.4
049A:  GOTO   499
049B:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, OFF); 
049C:  BCF    07.1
049D:  MOVLW  D8
049E:  BSF    03.5
049F:  MOVWF  07
04A0:  BCF    03.5
04A1:  BCF    09.1
04A2:  MOVLW  E0
04A3:  BSF    03.5
04A4:  MOVWF  09
....................                            break; 
04A5:  BCF    03.5
04A6:  GOTO   5D3
....................       case 'B':   if(DEBUG) {fputs("> Activar Posicion Local",RS232);} 
04A7:  BTFSS  05.3
04A8:  GOTO   4B8
04A9:  MOVLW  8B
04AA:  BSF    03.6
04AB:  MOVWF  0D
04AC:  MOVLW  07
04AD:  MOVWF  0F
04AE:  BCF    03.6
04AF:  CALL   125
04B0:  MOVLW  0D
04B1:  BTFSS  0C.4
04B2:  GOTO   4B1
04B3:  MOVWF  19
04B4:  MOVLW  0A
04B5:  BTFSS  0C.4
04B6:  GOTO   4B5
04B7:  MOVWF  19
....................                            output_bit(POSLOCAL, ON); output_bit(POSVISITA, OFF); 
04B8:  BSF    07.1
04B9:  MOVLW  D8
04BA:  BSF    03.5
04BB:  MOVWF  07
04BC:  BCF    03.5
04BD:  BCF    09.1
04BE:  MOVLW  E0
04BF:  BSF    03.5
04C0:  MOVWF  09
....................                            break; 
04C1:  BCF    03.5
04C2:  GOTO   5D3
....................       case 'C':   if(DEBUG) {fputs("> Activar Posicion Visita",RS232);} 
04C3:  BTFSS  05.3
04C4:  GOTO   4D4
04C5:  MOVLW  98
04C6:  BSF    03.6
04C7:  MOVWF  0D
04C8:  MOVLW  07
04C9:  MOVWF  0F
04CA:  BCF    03.6
04CB:  CALL   125
04CC:  MOVLW  0D
04CD:  BTFSS  0C.4
04CE:  GOTO   4CD
04CF:  MOVWF  19
04D0:  MOVLW  0A
04D1:  BTFSS  0C.4
04D2:  GOTO   4D1
04D3:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, ON); 
04D4:  BCF    07.1
04D5:  MOVLW  D8
04D6:  BSF    03.5
04D7:  MOVWF  07
04D8:  BCF    03.5
04D9:  BSF    09.1
04DA:  MOVLW  E0
04DB:  BSF    03.5
04DC:  MOVWF  09
....................                            break; 
04DD:  BCF    03.5
04DE:  GOTO   5D3
....................       case 'D':   if(DEBUG) {fputs("> Activar Centena Local",RS232);} 
04DF:  BTFSS  05.3
04E0:  GOTO   4F0
04E1:  MOVLW  A5
04E2:  BSF    03.6
04E3:  MOVWF  0D
04E4:  MOVLW  07
04E5:  MOVWF  0F
04E6:  BCF    03.6
04E7:  CALL   125
04E8:  MOVLW  0D
04E9:  BTFSS  0C.4
04EA:  GOTO   4E9
04EB:  MOVWF  19
04EC:  MOVLW  0A
04ED:  BTFSS  0C.4
04EE:  GOTO   4ED
04EF:  MOVWF  19
....................                            output_bit(CENLOCAL, ON); 
04F0:  BSF    07.2
04F1:  MOVLW  D8
04F2:  BSF    03.5
04F3:  MOVWF  07
....................                            break; 
04F4:  BCF    03.5
04F5:  GOTO   5D3
....................       case 'E':   if(DEBUG) {fputs("> Desactivar Centena Local",RS232);} 
04F6:  BTFSS  05.3
04F7:  GOTO   507
04F8:  MOVLW  B1
04F9:  BSF    03.6
04FA:  MOVWF  0D
04FB:  MOVLW  07
04FC:  MOVWF  0F
04FD:  BCF    03.6
04FE:  CALL   125
04FF:  MOVLW  0D
0500:  BTFSS  0C.4
0501:  GOTO   500
0502:  MOVWF  19
0503:  MOVLW  0A
0504:  BTFSS  0C.4
0505:  GOTO   504
0506:  MOVWF  19
....................                            output_bit(CENLOCAL, OFF); 
0507:  BCF    07.2
0508:  MOVLW  D8
0509:  BSF    03.5
050A:  MOVWF  07
....................                            break; 
050B:  BCF    03.5
050C:  GOTO   5D3
....................       case 'F':   if(DEBUG) {fputs("> Activar Centena Visita",RS232);} 
050D:  BTFSS  05.3
050E:  GOTO   51E
050F:  MOVLW  BF
0510:  BSF    03.6
0511:  MOVWF  0D
0512:  MOVLW  07
0513:  MOVWF  0F
0514:  BCF    03.6
0515:  CALL   125
0516:  MOVLW  0D
0517:  BTFSS  0C.4
0518:  GOTO   517
0519:  MOVWF  19
051A:  MOVLW  0A
051B:  BTFSS  0C.4
051C:  GOTO   51B
051D:  MOVWF  19
....................                            output_bit(CENVISITA, ON); 
051E:  BSF    09.2
051F:  MOVLW  E0
0520:  BSF    03.5
0521:  MOVWF  09
....................                            break; 
0522:  BCF    03.5
0523:  GOTO   5D3
....................       case 'G':   if(DEBUG) {fputs("> Desactivar Centena Visita",RS232);} 
0524:  BTFSS  05.3
0525:  GOTO   535
0526:  MOVLW  CC
0527:  BSF    03.6
0528:  MOVWF  0D
0529:  MOVLW  07
052A:  MOVWF  0F
052B:  BCF    03.6
052C:  CALL   125
052D:  MOVLW  0D
052E:  BTFSS  0C.4
052F:  GOTO   52E
0530:  MOVWF  19
0531:  MOVLW  0A
0532:  BTFSS  0C.4
0533:  GOTO   532
0534:  MOVWF  19
....................                            output_bit(CENVISITA, OFF); 
0535:  BCF    09.2
0536:  MOVLW  E0
0537:  BSF    03.5
0538:  MOVWF  09
....................                            break;             
0539:  BCF    03.5
053A:  GOTO   5D3
....................       case 'X':   doTest(); //Rutina de prueba 
053B:  CALL   2B3
....................                   break; 
053C:  GOTO   5D3
....................       case 'Z':   if(DEBUG) {fputs("\r> Reseteo general...!",RS232);} 
053D:  BTFSS  05.3
053E:  GOTO   54E
053F:  MOVLW  DA
0540:  BSF    03.6
0541:  MOVWF  0D
0542:  MOVLW  07
0543:  MOVWF  0F
0544:  BCF    03.6
0545:  CALL   125
0546:  MOVLW  0D
0547:  BTFSS  0C.4
0548:  GOTO   547
0549:  MOVWF  19
054A:  MOVLW  0A
054B:  BTFSS  0C.4
054C:  GOTO   54B
054D:  MOVWF  19
....................                   delay_ms(100); 
054E:  MOVLW  64
054F:  BSF    03.5
0550:  MOVWF  21
0551:  BCF    03.5
0552:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (5)",RS232);} 
0553:  BTFSS  05.3
0554:  GOTO   564
0555:  MOVLW  E6
0556:  BSF    03.6
0557:  MOVWF  0D
0558:  MOVLW  07
0559:  MOVWF  0F
055A:  BCF    03.6
055B:  CALL   125
055C:  MOVLW  0D
055D:  BTFSS  0C.4
055E:  GOTO   55D
055F:  MOVWF  19
0560:  MOVLW  0A
0561:  BTFSS  0C.4
0562:  GOTO   561
0563:  MOVWF  19
....................                   delay_ms(100); 
0564:  MOVLW  64
0565:  BSF    03.5
0566:  MOVWF  21
0567:  BCF    03.5
0568:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (4)",RS232);} 
0569:  BTFSS  05.3
056A:  GOTO   57A
056B:  MOVLW  EA
056C:  BSF    03.6
056D:  MOVWF  0D
056E:  MOVLW  07
056F:  MOVWF  0F
0570:  BCF    03.6
0571:  CALL   125
0572:  MOVLW  0D
0573:  BTFSS  0C.4
0574:  GOTO   573
0575:  MOVWF  19
0576:  MOVLW  0A
0577:  BTFSS  0C.4
0578:  GOTO   577
0579:  MOVWF  19
....................                   delay_ms(100); 
057A:  MOVLW  64
057B:  BSF    03.5
057C:  MOVWF  21
057D:  BCF    03.5
057E:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (3)",RS232);} 
057F:  BTFSS  05.3
0580:  GOTO   590
0581:  MOVLW  EE
0582:  BSF    03.6
0583:  MOVWF  0D
0584:  MOVLW  07
0585:  MOVWF  0F
0586:  BCF    03.6
0587:  CALL   125
0588:  MOVLW  0D
0589:  BTFSS  0C.4
058A:  GOTO   589
058B:  MOVWF  19
058C:  MOVLW  0A
058D:  BTFSS  0C.4
058E:  GOTO   58D
058F:  MOVWF  19
....................                   delay_ms(100); 
0590:  MOVLW  64
0591:  BSF    03.5
0592:  MOVWF  21
0593:  BCF    03.5
0594:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (2)",RS232);} 
0595:  BTFSS  05.3
0596:  GOTO   5A6
0597:  MOVLW  F2
0598:  BSF    03.6
0599:  MOVWF  0D
059A:  MOVLW  07
059B:  MOVWF  0F
059C:  BCF    03.6
059D:  CALL   125
059E:  MOVLW  0D
059F:  BTFSS  0C.4
05A0:  GOTO   59F
05A1:  MOVWF  19
05A2:  MOVLW  0A
05A3:  BTFSS  0C.4
05A4:  GOTO   5A3
05A5:  MOVWF  19
....................                   delay_ms(100); 
05A6:  MOVLW  64
05A7:  BSF    03.5
05A8:  MOVWF  21
05A9:  BCF    03.5
05AA:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (1)",RS232);} 
05AB:  BTFSS  05.3
05AC:  GOTO   5BC
05AD:  MOVLW  F6
05AE:  BSF    03.6
05AF:  MOVWF  0D
05B0:  MOVLW  07
05B1:  MOVWF  0F
05B2:  BCF    03.6
05B3:  CALL   125
05B4:  MOVLW  0D
05B5:  BTFSS  0C.4
05B6:  GOTO   5B5
05B7:  MOVWF  19
05B8:  MOVLW  0A
05B9:  BTFSS  0C.4
05BA:  GOTO   5B9
05BB:  MOVWF  19
....................                   delay_ms(100); 
05BC:  MOVLW  64
05BD:  BSF    03.5
05BE:  MOVWF  21
05BF:  BCF    03.5
05C0:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (0)",RS232);} 
05C1:  BTFSS  05.3
05C2:  GOTO   5D2
05C3:  MOVLW  FA
05C4:  BSF    03.6
05C5:  MOVWF  0D
05C6:  MOVLW  07
05C7:  MOVWF  0F
05C8:  BCF    03.6
05C9:  CALL   125
05CA:  MOVLW  0D
05CB:  BTFSS  0C.4
05CC:  GOTO   5CB
05CD:  MOVWF  19
05CE:  MOVLW  0A
05CF:  BTFSS  0C.4
05D0:  GOTO   5CF
05D1:  MOVWF  19
....................                   doReset(); 
05D2:  CALL   37B
....................                    
....................    } 
05D3:  BCF    0A.3
05D4:  BCF    0A.4
05D5:  GOTO   60A (RETURN)
.................... } 
....................  
.................... void showNumber(int8 n, tPort p) 
*
020B:  BSF    03.5
020C:  BCF    26.0
020D:  BCF    26.1
020E:  BCF    26.2
020F:  BCF    26.3
.................... { 
....................    int1 a=0, b=0, c=0, d=0; 
....................    switch(n) 
0210:  MOVLW  01
0211:  SUBWF  21,W
0212:  ADDLW  F7
0213:  BTFSC  03.0
0214:  GOTO   23A
0215:  ADDLW  09
0216:  BCF    03.5
0217:  GOTO   292
....................    { 
....................       case 1:  a=1; 
0218:  BSF    03.5
0219:  BSF    26.0
....................                break; 
021A:  GOTO   23A
....................       case 2:  b=1; 
021B:  BSF    03.5
021C:  BSF    26.1
....................                break; 
021D:  GOTO   23A
....................       case 3:  a=1; b=1; 
021E:  BSF    03.5
021F:  BSF    26.0
0220:  BSF    26.1
....................                break; 
0221:  GOTO   23A
....................       case 4:  c=1; 
0222:  BSF    03.5
0223:  BSF    26.2
....................                break; 
0224:  GOTO   23A
....................       case 5:  c=1; a=1; 
0225:  BSF    03.5
0226:  BSF    26.2
0227:  BSF    26.0
....................                break; 
0228:  GOTO   23A
....................       case 6:  c=1; b=1; 
0229:  BSF    03.5
022A:  BSF    26.2
022B:  BSF    26.1
....................                break; 
022C:  GOTO   23A
....................       case 7:  c=1; b=1; a=1; 
022D:  BSF    03.5
022E:  BSF    26.2
022F:  BSF    26.1
0230:  BSF    26.0
....................                break; 
0231:  GOTO   23A
....................       case 8:  d=1; 
0232:  BSF    03.5
0233:  BSF    26.3
....................                break; 
0234:  GOTO   23A
....................       case 9:  d=1; a=1; 
0235:  BSF    03.5
0236:  BSF    26.3
0237:  BSF    26.0
....................                break; 
0238:  GOTO   23A
0239:  BSF    03.5
....................    } 
....................    output_bit(p.a, a); 
023A:  MOVLW  00
023B:  BTFSC  26.0
023C:  MOVLW  01
023D:  MOVWF  77
023E:  MOVF   22,W
023F:  MOVWF  27
0240:  MOVF   77,W
0241:  MOVWF  28
0242:  CLRF   2A
0243:  CLRF   29
0244:  BCF    03.5
0245:  CALL   1E9
0246:  BSF    03.5
0247:  MOVF   22,W
0248:  MOVWF  27
0249:  CLRF   28
024A:  CLRF   2A
024B:  MOVLW  80
024C:  MOVWF  29
024D:  BCF    03.5
024E:  CALL   1E9
....................    output_bit(p.b, b); 
024F:  MOVLW  00
0250:  BSF    03.5
0251:  BTFSC  26.1
0252:  MOVLW  01
0253:  MOVWF  77
0254:  MOVF   23,W
0255:  MOVWF  27
0256:  MOVF   77,W
0257:  MOVWF  28
0258:  CLRF   2A
0259:  CLRF   29
025A:  BCF    03.5
025B:  CALL   1E9
025C:  BSF    03.5
025D:  MOVF   23,W
025E:  MOVWF  27
025F:  CLRF   28
0260:  CLRF   2A
0261:  MOVLW  80
0262:  MOVWF  29
0263:  BCF    03.5
0264:  CALL   1E9
....................    output_bit(p.c, c); 
0265:  MOVLW  00
0266:  BSF    03.5
0267:  BTFSC  26.2
0268:  MOVLW  01
0269:  MOVWF  77
026A:  MOVF   24,W
026B:  MOVWF  27
026C:  MOVF   77,W
026D:  MOVWF  28
026E:  CLRF   2A
026F:  CLRF   29
0270:  BCF    03.5
0271:  CALL   1E9
0272:  BSF    03.5
0273:  MOVF   24,W
0274:  MOVWF  27
0275:  CLRF   28
0276:  CLRF   2A
0277:  MOVLW  80
0278:  MOVWF  29
0279:  BCF    03.5
027A:  CALL   1E9
....................    output_bit(p.d, d); 
027B:  MOVLW  00
027C:  BSF    03.5
027D:  BTFSC  26.3
027E:  MOVLW  01
027F:  MOVWF  77
0280:  MOVF   25,W
0281:  MOVWF  27
0282:  MOVF   77,W
0283:  MOVWF  28
0284:  CLRF   2A
0285:  CLRF   29
0286:  BCF    03.5
0287:  CALL   1E9
0288:  BSF    03.5
0289:  MOVF   25,W
028A:  MOVWF  27
028B:  CLRF   28
028C:  CLRF   2A
028D:  MOVLW  80
028E:  MOVWF  29
028F:  BCF    03.5
0290:  CALL   1E9
0291:  RETURN
.................... } 
....................  
.................... int8 char2int(char c) 
.................... { 
....................    switch(c) 
*
019B:  MOVLW  30
019C:  BSF    03.5
019D:  SUBWF  20,W
019E:  ADDLW  F6
019F:  BTFSC  03.0
01A0:  GOTO   1D7
01A1:  ADDLW  0A
01A2:  BCF    03.5
01A3:  GOTO   1DB
....................    { 
....................       case '0':   return 0; 
01A4:  MOVLW  00
01A5:  MOVWF  78
01A6:  GOTO   1DA
....................                   break; 
01A7:  BSF    03.5
01A8:  GOTO   1D7
....................       case '1':   return 1; 
01A9:  MOVLW  01
01AA:  MOVWF  78
01AB:  GOTO   1DA
....................                   break; 
01AC:  BSF    03.5
01AD:  GOTO   1D7
....................       case '2':   return 2; 
01AE:  MOVLW  02
01AF:  MOVWF  78
01B0:  GOTO   1DA
....................                   break; 
01B1:  BSF    03.5
01B2:  GOTO   1D7
....................       case '3':   return 3; 
01B3:  MOVLW  03
01B4:  MOVWF  78
01B5:  GOTO   1DA
....................                   break; 
01B6:  BSF    03.5
01B7:  GOTO   1D7
....................       case '4':   return 4; 
01B8:  MOVLW  04
01B9:  MOVWF  78
01BA:  GOTO   1DA
....................                   break; 
01BB:  BSF    03.5
01BC:  GOTO   1D7
....................       case '5':   return 5; 
01BD:  MOVLW  05
01BE:  MOVWF  78
01BF:  GOTO   1DA
....................                   break; 
01C0:  BSF    03.5
01C1:  GOTO   1D7
....................       case '6':   return 6; 
01C2:  MOVLW  06
01C3:  MOVWF  78
01C4:  GOTO   1DA
....................                   break; 
01C5:  BSF    03.5
01C6:  GOTO   1D7
....................       case '7':   return 7; 
01C7:  MOVLW  07
01C8:  MOVWF  78
01C9:  GOTO   1DA
....................                   break; 
01CA:  BSF    03.5
01CB:  GOTO   1D7
....................       case '8':   return 8; 
01CC:  MOVLW  08
01CD:  MOVWF  78
01CE:  GOTO   1DA
....................                   break; 
01CF:  BSF    03.5
01D0:  GOTO   1D7
....................       case '9':   return 9; 
01D1:  MOVLW  09
01D2:  MOVWF  78
01D3:  GOTO   1DA
....................                   break; 
01D4:  BSF    03.5
01D5:  GOTO   1D7
01D6:  BSF    03.5
....................    } 
....................    return 0; 
01D7:  MOVLW  00
01D8:  MOVWF  78
01D9:  BCF    03.5
01DA:  RETURN
.................... } 
....................  
.................... void doReset(void) 
.................... { 
....................    if(DEBUG) {fputs("> Reseteando...",RS232);} 
*
037B:  BTFSS  05.3
037C:  GOTO   38C
037D:  MOVLW  C3
037E:  BSF    03.6
037F:  MOVWF  0D
0380:  MOVLW  0A
0381:  MOVWF  0F
0382:  BCF    03.6
0383:  CALL   125
0384:  MOVLW  0D
0385:  BTFSS  0C.4
0386:  GOTO   385
0387:  MOVWF  19
0388:  MOVLW  0A
0389:  BTFSS  0C.4
038A:  GOTO   389
038B:  MOVWF  19
....................    reset_cpu(); 
038C:  CLRF   0A
038D:  GOTO   000
038E:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 0700   BORV40 NOWRT

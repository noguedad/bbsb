CCS PCM C Compiler, Version 5.076, 56587               11-mar.-20 22:16

               Filename:   C:\Users\nogue\Documents\GitHub\bbsb\mscore\mscore.lst

               ROM used:   3415 words (42%)
                           Largest free fragment is 2048
               RAM used:   74 (20%) at main() level
                           107 (29%) worst case
               Stack used: 5 locations (1 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   4FE
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.3
0030:  GOTO   033
0031:  BTFSC  0C.3
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   5E0
0057:  BSF    0A.3
0058:  BCF    0A.4
0059:  GOTO   000
.................... #include <mscore.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  00
005F:  RETLW  00
0060:  RETLW  00
0061:  RETLW  00
0062:  RETLW  00
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  00
0068:  DATA 2A,15
0069:  DATA 2A,15
006A:  DATA 2A,15
006B:  DATA 2A,15
006C:  DATA 2A,15
006D:  DATA 2A,15
006E:  DATA 2A,15
006F:  DATA 2A,15
0070:  DATA 2A,15
0071:  DATA 2A,15
0072:  DATA 2A,15
0073:  DATA 2A,15
0074:  DATA 2A,15
0075:  DATA 2A,15
0076:  DATA 2A,15
0077:  DATA 2A,15
0078:  DATA 0D,00
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA A0,23
007D:  DATA F2,3A
007E:  DATA F0,37
007F:  DATA A0,20
0080:  DATA D0,26
0081:  DATA 20,14
0082:  DATA E3,14
0083:  DATA 20,19
0084:  DATA 30,19
0085:  DATA 30,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 0D,00
008A:  DATA BD,1E
008B:  DATA BD,1E
008C:  DATA BD,1E
008D:  DATA BD,1E
008E:  DATA BD,1E
008F:  DATA BD,1E
0090:  DATA BD,1E
0091:  DATA BD,1E
0092:  DATA BD,1E
0093:  DATA BD,1E
0094:  DATA BD,1E
0095:  DATA BD,1E
0096:  DATA BD,1E
0097:  DATA BD,1E
0098:  DATA BD,1E
0099:  DATA BD,1E
009A:  DATA 0D,00
009B:  DATA 42,36
009C:  DATA F5,32
009D:  DATA F4,37
009E:  DATA 6F,3A
009F:  DATA 68,10
00A0:  DATA C2,30
00A1:  DATA F3,35
00A2:  DATA 65,3A
00A3:  DATA E2,30
00A4:  DATA 6C,36
00A5:  DATA A0,29
00A6:  DATA E3,37
00A7:  DATA F2,32
00A8:  DATA 20,21
00A9:  DATA EF,30
00AA:  DATA 72,32
00AB:  DATA 0D,00
00AC:  DATA BD,1E
00AD:  DATA BD,1E
00AE:  DATA BD,1E
00AF:  DATA BD,1E
00B0:  DATA BD,1E
00B1:  DATA BD,1E
00B2:  DATA BD,1E
00B3:  DATA BD,1E
00B4:  DATA BD,1E
00B5:  DATA BD,1E
00B6:  DATA BD,1E
00B7:  DATA BD,1E
00B8:  DATA BD,1E
00B9:  DATA BD,1E
00BA:  DATA BD,1E
00BB:  DATA BD,1E
00BC:  DATA 0D,00
00BD:  DATA D6,32
00BE:  DATA F2,39
00BF:  DATA E9,37
00C0:  DATA 6E,10
00C1:  DATA A5,39
00C2:  DATA A0,16
00C3:  DATA 20,39
00C4:  DATA 65,3B
00C5:  DATA A0,12
00C6:  DATA 73,10
00C7:  DATA 0D,00
00C8:  DATA 32,17
00C9:  DATA 30,00
00CA:  DATA 46,00
00CB:  DATA 2A,15
00CC:  DATA 2A,15
00CD:  DATA 2A,15
00CE:  DATA 2A,15
00CF:  DATA 2A,15
00D0:  DATA 2A,15
00D1:  DATA 2A,15
00D2:  DATA 2A,15
00D3:  DATA 2A,15
00D4:  DATA 2A,15
00D5:  DATA 2A,15
00D6:  DATA 2A,15
00D7:  DATA 2A,15
00D8:  DATA 2A,15
00D9:  DATA 2A,15
00DA:  DATA 2A,15
00DB:  DATA 0D,00
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA C4,22
00E0:  DATA D0,2A
00E1:  DATA D2,20
00E2:  DATA C3,24
00E3:  DATA 4F,27
00E4:  DATA 20,1D
00E5:  DATA 3A,10
00E6:  DATA D0,2A
00E7:  DATA 4E,2A
00E8:  DATA CF,29
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 20,10
00EC:  DATA 0D,00
00ED:  DATA 3E,10
00EE:  DATA C8,30
00EF:  DATA E2,34
00F0:  DATA EC,34
00F1:  DATA F4,30
00F2:  DATA E3,34
00F3:  DATA 6F,37
00F4:  DATA 20,32
00F5:  DATA 65,10
00F6:  DATA 49,19
00F7:  DATA 43,00
00F8:  DATA 3E,10
00F9:  DATA C3,37
00FA:  DATA 6E,33
00FB:  DATA E9,33
00FC:  DATA 75,39
00FD:  DATA E1,31
00FE:  DATA E9,37
00FF:  DATA 6E,10
0100:  DATA E4,32
0101:  DATA 20,28
0102:  DATA F5,32
0103:  DATA 72,3A
0104:  DATA EF,39
0105:  DATA 00,01
0106:  DATA 3E,10
0107:  DATA C8,30
0108:  DATA E2,34
0109:  DATA EC,34
010A:  DATA F4,30
010B:  DATA E3,34
010C:  DATA 6F,37
010D:  DATA 20,32
010E:  DATA 65,10
010F:  DATA E4,34
0110:  DATA 73,38
0111:  DATA EC,30
0112:  DATA F9,39
0113:  DATA 00,01
0114:  DATA 3E,10
0115:  DATA C8,30
0116:  DATA E2,34
0117:  DATA EC,34
0118:  DATA F4,30
0119:  DATA E3,34
011A:  DATA 6F,37
011B:  DATA 20,32
011C:  DATA 65,10
011D:  DATA 69,37
011E:  DATA F4,32
011F:  DATA 72,39
0120:  DATA 75,38
0121:  DATA E3,34
0122:  DATA 6F,37
0123:  DATA E5,39
0124:  DATA 00,00
0125:  MOVF   0B,W
0126:  BSF    03.5
0127:  MOVWF  21
0128:  BCF    03.5
0129:  BCF    0B.7
012A:  BSF    03.5
012B:  BSF    03.6
012C:  BSF    0C.7
012D:  BSF    0C.0
012E:  NOP
012F:  NOP
0130:  BCF    03.6
0131:  BTFSS  21.7
0132:  GOTO   136
0133:  BCF    03.5
0134:  BSF    0B.7
0135:  BSF    03.5
0136:  BCF    03.5
0137:  BSF    03.6
0138:  MOVF   0C,W
0139:  ANDLW  7F
013A:  BTFSC  03.2
013B:  GOTO   199
013C:  BSF    03.5
013D:  BCF    03.6
013E:  MOVWF  21
013F:  BCF    03.5
0140:  BSF    03.6
0141:  MOVF   0D,W
0142:  BSF    03.5
0143:  BCF    03.6
0144:  MOVWF  22
0145:  BCF    03.5
0146:  BSF    03.6
0147:  MOVF   0F,W
0148:  BSF    03.5
0149:  BCF    03.6
014A:  MOVWF  23
014B:  MOVF   21,W
014C:  BCF    03.5
014D:  BTFSS  0C.4
014E:  GOTO   14D
014F:  MOVWF  19
0150:  BSF    03.5
0151:  MOVF   22,W
0152:  BCF    03.5
0153:  BSF    03.6
0154:  MOVWF  0D
0155:  BSF    03.5
0156:  BCF    03.6
0157:  MOVF   23,W
0158:  BCF    03.5
0159:  BSF    03.6
015A:  MOVWF  0F
015B:  BCF    03.6
015C:  MOVF   0B,W
015D:  BSF    03.5
015E:  MOVWF  24
015F:  BCF    03.5
0160:  BCF    0B.7
0161:  BSF    03.5
0162:  BSF    03.6
0163:  BSF    0C.7
0164:  BSF    0C.0
0165:  NOP
0166:  NOP
0167:  BCF    03.6
0168:  BTFSS  24.7
0169:  GOTO   16D
016A:  BCF    03.5
016B:  BSF    0B.7
016C:  BSF    03.5
016D:  BCF    03.5
016E:  BSF    03.6
016F:  RLF    0C,W
0170:  RLF    0E,W
0171:  ANDLW  7F
0172:  BTFSC  03.2
0173:  GOTO   199
0174:  BSF    03.5
0175:  BCF    03.6
0176:  MOVWF  21
0177:  BCF    03.5
0178:  BSF    03.6
0179:  MOVF   0D,W
017A:  BSF    03.5
017B:  BCF    03.6
017C:  MOVWF  22
017D:  BCF    03.5
017E:  BSF    03.6
017F:  MOVF   0F,W
0180:  BSF    03.5
0181:  BCF    03.6
0182:  MOVWF  23
0183:  MOVF   21,W
0184:  BCF    03.5
0185:  BTFSS  0C.4
0186:  GOTO   185
0187:  MOVWF  19
0188:  BSF    03.5
0189:  MOVF   22,W
018A:  BCF    03.5
018B:  BSF    03.6
018C:  MOVWF  0D
018D:  BSF    03.5
018E:  BCF    03.6
018F:  MOVF   23,W
0190:  BCF    03.5
0191:  BSF    03.6
0192:  MOVWF  0F
0193:  INCF   0D,F
0194:  BTFSC  03.2
0195:  INCF   0F,F
0196:  BCF    03.6
0197:  GOTO   125
0198:  BSF    03.6
0199:  BCF    03.6
019A:  RETURN
*
01DB:  BSF    0A.0
01DC:  BCF    0A.1
01DD:  BCF    0A.2
01DE:  ADDWF  02,F
01DF:  GOTO   1A4
01E0:  GOTO   1A9
01E1:  GOTO   1AE
01E2:  GOTO   1B3
01E3:  GOTO   1B8
01E4:  GOTO   1BD
01E5:  GOTO   1C2
01E6:  GOTO   1C7
01E7:  GOTO   1CC
01E8:  GOTO   1D1
01E9:  BSF    03.5
01EA:  MOVF   27,W
01EB:  ANDLW  07
01EC:  MOVWF  77
01ED:  RRF    27,W
01EE:  MOVWF  78
01EF:  RRF    78,F
01F0:  RRF    78,F
01F1:  MOVLW  1F
01F2:  ANDWF  78,F
01F3:  MOVF   78,W
01F4:  ADDWF  29,W
01F5:  MOVWF  04
01F6:  BCF    03.7
01F7:  BTFSC  2A.0
01F8:  BSF    03.7
01F9:  CLRF   78
01FA:  INCF   78,F
01FB:  INCF   77,F
01FC:  GOTO   1FE
01FD:  RLF    78,F
01FE:  DECFSZ 77,F
01FF:  GOTO   1FD
0200:  MOVF   28,F
0201:  BTFSC  03.2
0202:  GOTO   206
0203:  MOVF   78,W
0204:  IORWF  00,F
0205:  GOTO   209
0206:  COMF   78,F
0207:  MOVF   78,W
0208:  ANDWF  00,F
0209:  BCF    03.5
020A:  RETURN
*
0292:  BCF    0A.0
0293:  BSF    0A.1
0294:  BCF    0A.2
0295:  ADDWF  02,F
0296:  GOTO   218
0297:  GOTO   21B
0298:  GOTO   21E
0299:  GOTO   222
029A:  GOTO   225
029B:  GOTO   229
029C:  GOTO   22D
029D:  GOTO   232
029E:  GOTO   235
*
05D6:  BSF    0A.0
05D7:  BCF    0A.1
05D8:  BSF    0A.2
05D9:  ADDWF  02,F
05DA:  GOTO   3E3
05DB:  GOTO   3FF
05DC:  GOTO   41B
05DD:  GOTO   437
05DE:  GOTO   453
05DF:  GOTO   46F
*
0630:  MOVF   0B,W
0631:  MOVWF  6D
0632:  BCF    0B.7
0633:  BSF    03.5
0634:  BSF    03.6
0635:  BSF    0C.7
0636:  BSF    0C.0
0637:  NOP
0638:  NOP
0639:  BCF    03.5
063A:  BCF    03.6
063B:  BTFSC  6D.7
063C:  BSF    0B.7
063D:  BTFSC  03.0
063E:  GOTO   66D
063F:  BSF    03.6
0640:  MOVF   0C,W
0641:  ANDLW  7F
0642:  BCF    03.6
0643:  MOVWF  6D
0644:  BSF    03.6
0645:  MOVF   0D,W
0646:  BCF    03.6
0647:  MOVWF  6E
0648:  BSF    03.6
0649:  MOVF   0F,W
064A:  BCF    03.6
064B:  MOVWF  6F
064C:  MOVF   6D,W
064D:  BTFSS  0C.4
064E:  GOTO   64D
064F:  MOVWF  19
0650:  MOVF   6E,W
0651:  BSF    03.6
0652:  MOVWF  0D
0653:  BCF    03.6
0654:  MOVF   6F,W
0655:  BSF    03.6
0656:  MOVWF  0F
0657:  BCF    03.6
0658:  MOVF   0B,W
0659:  MOVWF  70
065A:  BCF    0B.7
065B:  BSF    03.5
065C:  BSF    03.6
065D:  BSF    0C.7
065E:  BSF    0C.0
065F:  NOP
0660:  NOP
0661:  BTFSS  70.7
0662:  GOTO   668
0663:  BCF    03.5
0664:  BCF    03.6
0665:  BSF    0B.7
0666:  BSF    03.5
0667:  BSF    03.6
0668:  BCF    03.5
0669:  BCF    03.6
066A:  DECFSZ 6C,F
066B:  GOTO   66D
066C:  GOTO   68D
066D:  BSF    03.6
066E:  RLF    0C,W
066F:  RLF    0E,W
0670:  ANDLW  7F
0671:  BCF    03.6
0672:  MOVWF  6D
0673:  BSF    03.6
0674:  MOVF   0D,W
0675:  BCF    03.6
0676:  MOVWF  6E
0677:  BSF    03.6
0678:  MOVF   0F,W
0679:  BCF    03.6
067A:  MOVWF  6F
067B:  MOVF   6D,W
067C:  BTFSS  0C.4
067D:  GOTO   67C
067E:  MOVWF  19
067F:  MOVF   6E,W
0680:  BSF    03.6
0681:  MOVWF  0D
0682:  BCF    03.6
0683:  MOVF   6F,W
0684:  BSF    03.6
0685:  MOVWF  0F
0686:  INCF   0D,F
0687:  BTFSC  03.2
0688:  INCF   0F,F
0689:  BCF    03.0
068A:  BCF    03.6
068B:  DECFSZ 6C,F
068C:  GOTO   630
068D:  RETURN
068E:  BTFSC  6D.7
068F:  GOTO   6A1
0690:  MOVLW  0F
0691:  MOVWF  77
0692:  SWAPF  6C,W
0693:  ANDWF  77,F
0694:  MOVLW  0A
0695:  SUBWF  77,W
0696:  BTFSC  03.0
0697:  GOTO   69B
0698:  MOVLW  30
0699:  ADDWF  77,F
069A:  GOTO   69D
069B:  MOVF   6D,W
069C:  ADDWF  77,F
069D:  MOVF   77,W
069E:  BTFSS  0C.4
069F:  GOTO   69E
06A0:  MOVWF  19
06A1:  MOVLW  0F
06A2:  ANDWF  6C,F
06A3:  MOVLW  0A
06A4:  SUBWF  6C,W
06A5:  BTFSC  03.0
06A6:  GOTO   6A9
06A7:  MOVLW  30
06A8:  GOTO   6AB
06A9:  BCF    6D.7
06AA:  MOVF   6D,W
06AB:  ADDWF  6C,F
06AC:  MOVF   6C,W
06AD:  BTFSS  0C.4
06AE:  GOTO   6AD
06AF:  MOVWF  19
06B0:  RETURN
06B1:  DATA 3E,10
06B2:  DATA C3,37
06B3:  DATA ED,36
06B4:  DATA 61,37
06B5:  DATA E4,37
06B6:  DATA 3A,10
06B7:  DATA 25,2C
06B8:  DATA A0,16
06B9:  DATA A0,12
06BA:  DATA D8,06
06BB:  DATA 80,37
06BC:  DATA 3E,10
06BD:  DATA C4,34
06BE:  DATA F2,32
06BF:  DATA E3,31
06C0:  DATA E9,37
06C1:  DATA 6E,10
06C2:  DATA D4,24
06C3:  DATA CD,22
06C4:  DATA 52,00
06C5:  DATA 3E,10
06C6:  DATA C4,34
06C7:  DATA F2,32
06C8:  DATA E3,31
06C9:  DATA E9,37
06CA:  DATA 6E,10
06CB:  DATA D3,21
06CC:  DATA 4F,29
06CD:  DATA 45,00
06CE:  DATA 3E,10
06CF:  DATA 41,38
06D0:  DATA E1,33
06D1:  DATA 61,39
06D2:  DATA 20,28
06D3:  DATA EF,39
06D4:  DATA E9,31
06D5:  DATA E9,37
06D6:  DATA 6E,00
06D7:  DATA 3E,10
06D8:  DATA C1,31
06D9:  DATA F4,34
06DA:  DATA F6,30
06DB:  DATA 72,10
06DC:  DATA D0,37
06DD:  DATA F3,34
06DE:  DATA E3,34
06DF:  DATA 6F,37
06E0:  DATA 20,26
06E1:  DATA EF,31
06E2:  DATA 61,36
06E3:  DATA 00,01
06E4:  DATA 3E,10
06E5:  DATA C1,31
06E6:  DATA F4,34
06E7:  DATA F6,30
06E8:  DATA 72,10
06E9:  DATA D0,37
06EA:  DATA F3,34
06EB:  DATA E3,34
06EC:  DATA 6F,37
06ED:  DATA 20,2B
06EE:  DATA E9,39
06EF:  DATA 69,3A
06F0:  DATA 61,00
06F1:  DATA 3E,10
06F2:  DATA C1,31
06F3:  DATA F4,34
06F4:  DATA F6,30
06F5:  DATA 72,10
06F6:  DATA C3,32
06F7:  DATA 6E,3A
06F8:  DATA 65,37
06F9:  DATA 61,10
06FA:  DATA CC,37
06FB:  DATA E3,30
06FC:  DATA 6C,00
06FD:  DATA 3E,10
06FE:  DATA C4,32
06FF:  DATA F3,30
0700:  DATA 63,3A
0701:  DATA 69,3B
0702:  DATA 61,39
0703:  DATA A0,21
0704:  DATA 65,37
0705:  DATA F4,32
0706:  DATA EE,30
0707:  DATA 20,26
0708:  DATA EF,31
0709:  DATA 61,36
070A:  DATA 00,01
070B:  DATA 3E,10
070C:  DATA C1,31
070D:  DATA F4,34
070E:  DATA F6,30
070F:  DATA 72,10
0710:  DATA C3,32
0711:  DATA 6E,3A
0712:  DATA 65,37
0713:  DATA 61,10
0714:  DATA D6,34
0715:  DATA F3,34
0716:  DATA F4,30
0717:  DATA 00,01
0718:  DATA 3E,10
0719:  DATA C4,32
071A:  DATA F3,30
071B:  DATA 63,3A
071C:  DATA 69,3B
071D:  DATA 61,39
071E:  DATA A0,21
071F:  DATA 65,37
0720:  DATA F4,32
0721:  DATA EE,30
0722:  DATA 20,2B
0723:  DATA E9,39
0724:  DATA 69,3A
0725:  DATA 61,00
0726:  DATA 3E,10
0727:  DATA C1,39
0728:  DATA E9,33
0729:  DATA EE,30
072A:  DATA E3,34
072B:  DATA 6F,37
072C:  DATA 20,28
072D:  DATA F5,32
072E:  DATA 72,3A
072F:  DATA 6F,10
0730:  DATA 31,00
0731:  DATA 3E,10
0732:  DATA C1,39
0733:  DATA E9,33
0734:  DATA EE,30
0735:  DATA E3,34
0736:  DATA 6F,37
0737:  DATA 20,28
0738:  DATA F5,32
0739:  DATA 72,3A
073A:  DATA 6F,10
073B:  DATA 32,00
073C:  DATA 3E,10
073D:  DATA C1,39
073E:  DATA E9,33
073F:  DATA EE,30
0740:  DATA E3,34
0741:  DATA 6F,37
0742:  DATA 20,28
0743:  DATA F5,32
0744:  DATA 72,3A
0745:  DATA 6F,10
0746:  DATA 33,00
0747:  DATA 3E,10
0748:  DATA C1,39
0749:  DATA E9,33
074A:  DATA EE,30
074B:  DATA E3,34
074C:  DATA 6F,37
074D:  DATA 20,28
074E:  DATA F5,32
074F:  DATA 72,3A
0750:  DATA 6F,10
0751:  DATA 34,00
0752:  DATA 3E,10
0753:  DATA C1,39
0754:  DATA E9,33
0755:  DATA EE,30
0756:  DATA E3,34
0757:  DATA 6F,37
0758:  DATA 20,28
0759:  DATA F5,32
075A:  DATA 72,3A
075B:  DATA 6F,10
075C:  DATA 35,00
075D:  DATA 3E,10
075E:  DATA C1,39
075F:  DATA E9,33
0760:  DATA EE,30
0761:  DATA E3,34
0762:  DATA 6F,37
0763:  DATA 20,28
0764:  DATA F5,32
0765:  DATA 72,3A
0766:  DATA 6F,10
0767:  DATA 36,00
0768:  DATA 3E,10
0769:  DATA D2,3A
076A:  DATA F4,34
076B:  DATA EE,30
076C:  DATA 20,32
076D:  DATA 65,10
076E:  DATA 70,39
076F:  DATA F5,32
0770:  DATA E2,30
0771:  DATA 00,00
0772:  DATA 0D,1F
0773:  DATA A0,20
0774:  DATA 63,3A
0775:  DATA 69,3B
0776:  DATA E1,31
0777:  DATA E9,37
0778:  DATA 6E,10
0779:  DATA ED,30
077A:  DATA EE,3A
077B:  DATA 61,36
077C:  DATA 20,32
077D:  DATA 65,10
077E:  DATA F0,3A
077F:  DATA 65,39
0780:  DATA F4,37
0781:  DATA 00,01
0782:  DATA 3E,10
0783:  DATA 41,38
0784:  DATA E1,33
0785:  DATA 61,39
0786:  DATA 20,28
0787:  DATA EF,39
0788:  DATA E9,31
0789:  DATA E9,37
078A:  DATA 6E,00
078B:  DATA 3E,10
078C:  DATA C1,31
078D:  DATA F4,34
078E:  DATA F6,30
078F:  DATA 72,10
0790:  DATA D0,37
0791:  DATA F3,34
0792:  DATA E3,34
0793:  DATA 6F,37
0794:  DATA 20,26
0795:  DATA EF,31
0796:  DATA 61,36
0797:  DATA 00,01
0798:  DATA 3E,10
0799:  DATA C1,31
079A:  DATA F4,34
079B:  DATA F6,30
079C:  DATA 72,10
079D:  DATA D0,37
079E:  DATA F3,34
079F:  DATA E3,34
07A0:  DATA 6F,37
07A1:  DATA 20,2B
07A2:  DATA E9,39
07A3:  DATA 69,3A
07A4:  DATA 61,00
07A5:  DATA 3E,10
07A6:  DATA C1,31
07A7:  DATA F4,34
07A8:  DATA F6,30
07A9:  DATA 72,10
07AA:  DATA C3,32
07AB:  DATA 6E,3A
07AC:  DATA 65,37
07AD:  DATA 61,10
07AE:  DATA CC,37
07AF:  DATA E3,30
07B0:  DATA 6C,00
07B1:  DATA 3E,10
07B2:  DATA C4,32
07B3:  DATA F3,30
07B4:  DATA 63,3A
07B5:  DATA 69,3B
07B6:  DATA 61,39
07B7:  DATA A0,21
07B8:  DATA 65,37
07B9:  DATA F4,32
07BA:  DATA EE,30
07BB:  DATA 20,26
07BC:  DATA EF,31
07BD:  DATA 61,36
07BE:  DATA 00,01
07BF:  DATA 3E,10
07C0:  DATA C1,31
07C1:  DATA F4,34
07C2:  DATA F6,30
07C3:  DATA 72,10
07C4:  DATA C3,32
07C5:  DATA 6E,3A
07C6:  DATA 65,37
07C7:  DATA 61,10
07C8:  DATA D6,34
07C9:  DATA F3,34
07CA:  DATA F4,30
07CB:  DATA 00,01
07CC:  DATA 3E,10
07CD:  DATA C4,32
07CE:  DATA F3,30
07CF:  DATA 63,3A
07D0:  DATA 69,3B
07D1:  DATA 61,39
07D2:  DATA A0,21
07D3:  DATA 65,37
07D4:  DATA F4,32
07D5:  DATA EE,30
07D6:  DATA 20,2B
07D7:  DATA E9,39
07D8:  DATA 69,3A
07D9:  DATA 61,00
07DA:  DATA 0D,1F
07DB:  DATA 20,29
07DC:  DATA E5,39
07DD:  DATA 65,3A
07DE:  DATA E5,37
07DF:  DATA A0,33
07E0:  DATA 65,37
07E1:  DATA 65,39
07E2:  DATA 61,36
07E3:  DATA 2E,17
07E4:  DATA AE,10
07E5:  DATA 00,01
07E6:  DATA 0D,1F
07E7:  DATA 20,14
07E8:  DATA B5,14
07E9:  DATA 00,01
07EA:  DATA 0D,1F
07EB:  DATA 20,14
07EC:  DATA B4,14
07ED:  DATA 00,01
07EE:  DATA 0D,1F
07EF:  DATA 20,14
07F0:  DATA B3,14
07F1:  DATA 00,01
07F2:  DATA 0D,1F
07F3:  DATA 20,14
07F4:  DATA B2,14
07F5:  DATA 00,01
07F6:  DATA 0D,1F
07F7:  DATA 20,14
07F8:  DATA B1,14
07F9:  DATA 00,01
07FA:  DATA 0D,1F
07FB:  DATA 20,14
07FC:  DATA B0,14
07FD:  DATA 00,00
*
0ACA:  DATA 3E,10
0ACB:  DATA D2,32
0ACC:  DATA F3,32
0ACD:  DATA F4,32
0ACE:  DATA 61,37
0ACF:  DATA E4,37
0AD0:  DATA 2E,17
0AD1:  DATA 2E,00
0AD2:  MOVF   0B,W
0AD3:  MOVWF  65
0AD4:  BCF    0B.7
0AD5:  BSF    03.5
0AD6:  BSF    03.6
0AD7:  BSF    0C.7
0AD8:  BSF    0C.0
0AD9:  NOP
0ADA:  NOP
0ADB:  BCF    03.5
0ADC:  BCF    03.6
0ADD:  BTFSC  65.7
0ADE:  BSF    0B.7
0ADF:  BSF    03.6
0AE0:  MOVF   0C,W
0AE1:  ANDLW  7F
0AE2:  BTFSC  03.2
0AE3:  GOTO   328
0AE4:  BCF    03.6
0AE5:  MOVWF  65
0AE6:  BSF    03.6
0AE7:  MOVF   0D,W
0AE8:  BCF    03.6
0AE9:  MOVWF  66
0AEA:  BSF    03.6
0AEB:  MOVF   0F,W
0AEC:  BCF    03.6
0AED:  MOVWF  67
0AEE:  MOVF   65,W
0AEF:  BTFSS  0C.4
0AF0:  GOTO   2EF
0AF1:  MOVWF  19
0AF2:  MOVF   66,W
0AF3:  BSF    03.6
0AF4:  MOVWF  0D
0AF5:  BCF    03.6
0AF6:  MOVF   67,W
0AF7:  BSF    03.6
0AF8:  MOVWF  0F
0AF9:  BCF    03.6
0AFA:  MOVF   0B,W
0AFB:  MOVWF  68
0AFC:  BCF    0B.7
0AFD:  BSF    03.5
0AFE:  BSF    03.6
0AFF:  BSF    0C.7
0B00:  BSF    0C.0
0B01:  NOP
0B02:  NOP
0B03:  BCF    03.5
0B04:  BCF    03.6
0B05:  BTFSC  68.7
0B06:  BSF    0B.7
0B07:  BSF    03.6
0B08:  RLF    0C,W
0B09:  RLF    0E,W
0B0A:  ANDLW  7F
0B0B:  BTFSC  03.2
0B0C:  GOTO   328
0B0D:  BCF    03.6
0B0E:  MOVWF  65
0B0F:  BSF    03.6
0B10:  MOVF   0D,W
0B11:  BCF    03.6
0B12:  MOVWF  66
0B13:  BSF    03.6
0B14:  MOVF   0F,W
0B15:  BCF    03.6
0B16:  MOVWF  67
0B17:  MOVF   65,W
0B18:  BTFSS  0C.4
0B19:  GOTO   318
0B1A:  MOVWF  19
0B1B:  MOVF   66,W
0B1C:  BSF    03.6
0B1D:  MOVWF  0D
0B1E:  BCF    03.6
0B1F:  MOVF   67,W
0B20:  BSF    03.6
0B21:  MOVWF  0F
0B22:  INCF   0D,F
0B23:  BTFSC  03.2
0B24:  INCF   0F,F
0B25:  BCF    03.6
0B26:  GOTO   2D2
0B27:  BSF    03.6
0B28:  BCF    03.6
0B29:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #define FW_VERSION   "2.0" 
.................... #define FW_REVISION  "F" 
....................  
.................... //-- CONFIGURACION DE PIC -- 
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(internal=8MHz) 
*
029F:  MOVLW  A1
02A0:  MOVWF  04
02A1:  BCF    03.7
02A2:  MOVF   00,W
02A3:  BTFSC  03.2
02A4:  GOTO   2B2
02A5:  MOVLW  02
02A6:  MOVWF  78
02A7:  CLRF   77
02A8:  DECFSZ 77,F
02A9:  GOTO   2A8
02AA:  DECFSZ 78,F
02AB:  GOTO   2A7
02AC:  MOVLW  97
02AD:  MOVWF  77
02AE:  DECFSZ 77,F
02AF:  GOTO   2AE
02B0:  DECFSZ 00,F
02B1:  GOTO   2A5
02B2:  RETURN
....................  
.................... //-- CONFIGURACION DE IO -- 
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4,PIN_A2,PIN_A1,PIN_A0 ) 
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B2,PIN_B1,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C5, PIN_C2, PIN_C1, PIN_C0 ) 
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0 ) 
.................... #use FIXED_IO( E_outputs=PIN_E3,PIN_E2,PIN_E1,PIN_E0 ) 
....................  
.................... //-- DEFINICION DE PINES -- 
.................... #define I2C_SCL   PIN_C3 
.................... #define I2C_SDA   PIN_C4 
.................... #define RS232_TX  PIN_C6 
.................... #define RS232_RX  PIN_C7 
.................... #define DISPLAY   PIN_E0 
.................... #define DEBUG     input_state(PIN_A3) 
.................... #define POSLOCAL  PIN_C1 
.................... #define CENLOCAL  PIN_C2 
.................... #define CENVISITA PIN_E2 
.................... #define POSVISITA PIN_E1 
....................  
.................... #define I2C_TIMER       0x0A 
.................... #define I2C_SCORE       0x0C 
....................  
.................... //-- CONFIGURACION DE PUERTOS Y TIMERS -- 
.................... #use rs232  (baud=9600,parity=N,xmit=RS232_TX,rcv=RS232_RX,bits=8,stream=RS232) 
.................... #use i2c    (Slave,Fast,sda=I2C_SDA,scl=I2C_SCL, address = I2C_TIMER, FORCE_HW) 
*
0823:  MOVF   6B,W
0824:  MOVWF  13
0825:  BSF    14.4
0826:  BCF    0C.3
0827:  BSF    03.5
0828:  BTFSC  14.0
0829:  GOTO   028
082A:  CLRF   78
082B:  BTFSS  11.6
082C:  INCF   78,F
....................  
.................... //-- DEFINICIONES -- 
.................... #define I2C_CMD_INIT    0xF0 
.................... #define I2C_CMD_TEST    0xFF 
.................... #define I2C_CMD_RESET   0xFD 
....................  
.................... #define I2C_CMD_POS0    0x70 
.................... #define I2C_CMD_POSL    0x71 
.................... #define I2C_CMD_POSV    0x72 
.................... #define I2C_CMD_CLON    0x73 
.................... #define I2C_CMD_CLOF    0x74 
.................... #define I2C_CMD_CVON    0x75 
.................... #define I2C_CMD_CVOF    0x76 
....................  
.................... #define ON              1 
.................... #define OFF             0 
.................... #define DEFAULT_D       200 
....................  
.................... //-- DECLARACIONES -- 
.................... //Estructura para el puerto 
.................... typedef struct sPort     
.................... { 
....................    int a; 
....................    int b; 
....................    int c; 
....................    int d; 
.................... } tPort; 
....................  
.................... //Datos para la captura de comandos del RS232 
.................... char  cmd[10]  = "\0\0\0\0\0\0\0\0\0"; 
*
0D3A:  BCF    03.6
0D3B:  CLRF   2C
0D3C:  CLRF   2D
0D3D:  CLRF   2E
0D3E:  CLRF   2F
0D3F:  CLRF   30
0D40:  CLRF   31
0D41:  CLRF   32
0D42:  CLRF   33
0D43:  CLRF   34
0D44:  CLRF   35
.................... char  rcmd[10] = "\0\0\0\0\0\0\0\0\0"; 
0D45:  CLRF   36
0D46:  CLRF   37
0D47:  CLRF   38
0D48:  CLRF   39
0D49:  CLRF   3A
0D4A:  CLRF   3B
0D4B:  CLRF   3C
0D4C:  CLRF   3D
0D4D:  CLRF   3E
0D4E:  CLRF   3F
.................... int8  cmdIndex = 0; 
.................... int1  cmdGet   = false; 
....................  
.................... int  icmd; 
.................... int  ircmd[5] = "\0\0\0\0"; 
0D4F:  CLRF   43
0D50:  CLRF   44
0D51:  CLRF   45
0D52:  CLRF   46
0D53:  CLRF   47
....................  
.................... //Puertos de Displays 
.................... tPort pLocalU; 
.................... tPort pLocalD; 
.................... tPort pVisitaU; 
.................... tPort pVisitaD; 
.................... tPort pFLocal; 
.................... tPort pFVisita; 
....................  
....................  
.................... //-- PROTOTIPOS -- 
.................... void RDA_isr(void); 
.................... void SSP_isr(void); 
.................... void parseCommand(void); 
.................... void doTest(void); 
.................... void showNumber(int8, tPort); 
.................... int8  char2int(char);  
.................... void doReset(void); 
.................... void parseI2CCommand(void); 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
0D54:  CLRF   60
0D55:  CLRF   61
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... void setup() 
.................... { 
....................    output_a(0x00); 
*
0B2A:  MOVLW  08
0B2B:  BSF    03.5
0B2C:  MOVWF  05
0B2D:  BCF    03.5
0B2E:  CLRF   05
....................    output_b(0x00); 
0B2F:  BSF    03.5
0B30:  CLRF   06
0B31:  BCF    03.5
0B32:  CLRF   06
....................    output_c(0x00); 
0B33:  MOVLW  D8
0B34:  BSF    03.5
0B35:  MOVWF  07
0B36:  BCF    03.5
0B37:  CLRF   07
....................    output_d(0x00); 
0B38:  BSF    03.5
0B39:  CLRF   08
0B3A:  BCF    03.5
0B3B:  CLRF   08
....................    output_e(0x00); 
0B3C:  BSF    03.5
0B3D:  BCF    09.0
0B3E:  BCF    09.1
0B3F:  BCF    09.2
0B40:  BCF    09.3
0B41:  BCF    03.5
0B42:  CLRF   09
0B43:  CLRF   2B
0B44:  BTFSC  0B.7
0B45:  BSF    2B.7
0B46:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0B47:  MOVLW  C8
0B48:  BSF    03.5
0B49:  MOVWF  21
0B4A:  BCF    0A.3
0B4B:  BCF    03.5
0B4C:  CALL   29F
0B4D:  BSF    0A.3
0B4E:  BTFSC  2B.7
0B4F:  BSF    0B.7
....................     
....................    if(DEBUG) 
0B50:  BTFSS  05.3
0B51:  GOTO   3BD
....................    { 
....................       fprintf(RS232,"********************************\r"); 
0B52:  MOVLW  68
0B53:  BSF    03.6
0B54:  MOVWF  0D
0B55:  MOVLW  00
0B56:  MOVWF  0F
0B57:  BCF    03.6
0B58:  CALL   2D2
....................       fprintf(RS232,"       Grupo APM (c) 2020       \r"); 
0B59:  MOVLW  79
0B5A:  BSF    03.6
0B5B:  MOVWF  0D
0B5C:  MOVLW  00
0B5D:  MOVWF  0F
0B5E:  BCF    03.6
0B5F:  CALL   2D2
....................       fprintf(RS232,"================================\r"); 
0B60:  MOVLW  8A
0B61:  BSF    03.6
0B62:  MOVWF  0D
0B63:  MOVLW  00
0B64:  MOVWF  0F
0B65:  BCF    03.6
0B66:  CALL   2D2
....................       fprintf(RS232,"Bluetooth Basketball Score Board\r"); 
0B67:  MOVLW  9B
0B68:  BSF    03.6
0B69:  MOVWF  0D
0B6A:  MOVLW  00
0B6B:  MOVWF  0F
0B6C:  BCF    03.6
0B6D:  CALL   2D2
....................       fprintf(RS232,"================================\r"); 
0B6E:  MOVLW  AC
0B6F:  BSF    03.6
0B70:  MOVWF  0D
0B71:  MOVLW  00
0B72:  MOVWF  0F
0B73:  BCF    03.6
0B74:  CALL   2D2
....................       fprintf(RS232, "Version %s - rev %s \r", FW_VERSION, FW_REVISION); 
0B75:  MOVLW  BD
0B76:  BSF    03.6
0B77:  MOVWF  0D
0B78:  MOVLW  00
0B79:  MOVWF  0F
0B7A:  BCF    03.0
0B7B:  BCF    03.6
0B7C:  CLRF   2B
0B7D:  BTFSC  0B.7
0B7E:  BSF    2B.7
0B7F:  BCF    0B.7
0B80:  MOVLW  08
0B81:  MOVWF  6C
0B82:  BCF    0A.3
0B83:  CALL   630
0B84:  BSF    0A.3
0B85:  BTFSC  2B.7
0B86:  BSF    0B.7
0B87:  MOVLW  C8
0B88:  BSF    03.6
0B89:  MOVWF  0D
0B8A:  MOVLW  00
0B8B:  MOVWF  0F
0B8C:  BCF    03.6
0B8D:  CALL   2D2
0B8E:  MOVLW  C2
0B8F:  BSF    03.6
0B90:  MOVWF  0D
0B91:  MOVLW  00
0B92:  MOVWF  0F
0B93:  BCF    03.0
0B94:  BCF    03.6
0B95:  CLRF   2B
0B96:  BTFSC  0B.7
0B97:  BSF    2B.7
0B98:  BCF    0B.7
0B99:  MOVLW  07
0B9A:  MOVWF  6C
0B9B:  BCF    0A.3
0B9C:  CALL   630
0B9D:  BSF    0A.3
0B9E:  BTFSC  2B.7
0B9F:  BSF    0B.7
0BA0:  MOVLW  CA
0BA1:  BSF    03.6
0BA2:  MOVWF  0D
0BA3:  MOVLW  00
0BA4:  MOVWF  0F
0BA5:  BCF    03.6
0BA6:  CALL   2D2
0BA7:  MOVLW  20
0BA8:  BTFSS  0C.4
0BA9:  GOTO   3A8
0BAA:  MOVWF  19
0BAB:  MOVLW  0D
0BAC:  BTFSS  0C.4
0BAD:  GOTO   3AC
0BAE:  MOVWF  19
....................       fprintf(RS232,"********************************\r"); 
0BAF:  MOVLW  CB
0BB0:  BSF    03.6
0BB1:  MOVWF  0D
0BB2:  MOVLW  00
0BB3:  MOVWF  0F
0BB4:  BCF    03.6
0BB5:  CALL   2D2
....................       fprintf(RS232,"      DEPURACION :: PUNTOS      \r"); 
0BB6:  MOVLW  DC
0BB7:  BSF    03.6
0BB8:  MOVWF  0D
0BB9:  MOVLW  00
0BBA:  MOVWF  0F
0BBB:  BCF    03.6
0BBC:  CALL   2D2
....................    } 
....................  
....................     
....................    if(DEBUG) {fputs("> Habilitacion de I2C",RS232);} 
0BBD:  BTFSS  05.3
0BBE:  GOTO   3D6
0BBF:  MOVLW  ED
0BC0:  BSF    03.6
0BC1:  MOVWF  0D
0BC2:  MOVLW  00
0BC3:  MOVWF  0F
0BC4:  BCF    03.6
0BC5:  CLRF   2B
0BC6:  BTFSC  0B.7
0BC7:  BSF    2B.7
0BC8:  BCF    0B.7
0BC9:  BCF    0A.3
0BCA:  CALL   125
0BCB:  BSF    0A.3
0BCC:  BTFSC  2B.7
0BCD:  BSF    0B.7
0BCE:  MOVLW  0D
0BCF:  BTFSS  0C.4
0BD0:  GOTO   3CF
0BD1:  MOVWF  19
0BD2:  MOVLW  0A
0BD3:  BTFSS  0C.4
0BD4:  GOTO   3D3
0BD5:  MOVWF  19
....................    i2c_slaveaddr(I2C_SCORE); 
0BD6:  MOVLW  0C
0BD7:  BSF    03.5
0BD8:  MOVWF  13
0BD9:  BCF    03.5
0BDA:  CLRF   2B
0BDB:  BTFSC  0B.7
0BDC:  BSF    2B.7
0BDD:  BCF    0B.7
....................     
....................    delay_ms(DEFAULT_D); 
0BDE:  MOVLW  C8
0BDF:  BSF    03.5
0BE0:  MOVWF  21
0BE1:  BCF    0A.3
0BE2:  BCF    03.5
0BE3:  CALL   29F
0BE4:  BSF    0A.3
0BE5:  BTFSC  2B.7
0BE6:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Configuracion de Puertos",RS232);} 
0BE7:  BTFSS  05.3
0BE8:  GOTO   400
0BE9:  MOVLW  F8
0BEA:  BSF    03.6
0BEB:  MOVWF  0D
0BEC:  MOVLW  00
0BED:  MOVWF  0F
0BEE:  BCF    03.6
0BEF:  CLRF   2B
0BF0:  BTFSC  0B.7
0BF1:  BSF    2B.7
0BF2:  BCF    0B.7
0BF3:  BCF    0A.3
0BF4:  CALL   125
0BF5:  BSF    0A.3
0BF6:  BTFSC  2B.7
0BF7:  BSF    0B.7
0BF8:  MOVLW  0D
0BF9:  BTFSS  0C.4
0BFA:  GOTO   3F9
0BFB:  MOVWF  19
0BFC:  MOVLW  0A
0BFD:  BTFSS  0C.4
0BFE:  GOTO   3FD
0BFF:  MOVWF  19
....................    //TODO: Activar puertos 
....................    pLocalU.a = PIN_B0; 
0C00:  MOVLW  30
0C01:  MOVWF  48
....................    pLocalU.b = PIN_B1; 
0C02:  MOVLW  31
0C03:  MOVWF  49
....................    pLocalU.c = PIN_B2; 
0C04:  MOVLW  32
0C05:  MOVWF  4A
....................    pLocalU.d = PIN_B3; 
0C06:  MOVLW  33
0C07:  MOVWF  4B
....................     
....................    pLocalD.a = PIN_B4; 
0C08:  MOVLW  34
0C09:  MOVWF  4C
....................    pLocalD.b = PIN_B5; 
0C0A:  MOVLW  35
0C0B:  MOVWF  4D
....................    pLocalD.c = PIN_B6; 
0C0C:  MOVLW  36
0C0D:  MOVWF  4E
....................    pLocalD.d = PIN_B7; 
0C0E:  MOVLW  37
0C0F:  MOVWF  4F
....................     
....................    pVisitaU.a = PIN_D0; 
0C10:  MOVLW  40
0C11:  MOVWF  50
....................    pVisitaU.b = PIN_D1; 
0C12:  MOVLW  41
0C13:  MOVWF  51
....................    pVisitaU.c = PIN_D2; 
0C14:  MOVLW  42
0C15:  MOVWF  52
....................    pVisitaU.d = PIN_D3; 
0C16:  MOVLW  43
0C17:  MOVWF  53
....................     
....................    pVisitaD.a = PIN_D4; 
0C18:  MOVLW  44
0C19:  MOVWF  54
....................    pVisitaD.b = PIN_D5; 
0C1A:  MOVLW  45
0C1B:  MOVWF  55
....................    pVisitaD.c = PIN_D6; 
0C1C:  MOVLW  46
0C1D:  MOVWF  56
....................    pVisitaD.d = PIN_D7; 
0C1E:  MOVLW  47
0C1F:  MOVWF  57
....................     
....................    pFLocal.a = PIN_A4; 
0C20:  MOVLW  2C
0C21:  MOVWF  58
....................    pFLocal.b = PIN_A5; 
0C22:  MOVLW  2D
0C23:  MOVWF  59
....................    pFLocal.c = PIN_A6; 
0C24:  MOVLW  2E
0C25:  MOVWF  5A
....................    pFLocal.d = PIN_A7; 
0C26:  MOVLW  2F
0C27:  MOVWF  5B
....................     
....................    pFVisita.a = PIN_A0; 
0C28:  MOVLW  28
0C29:  MOVWF  5C
....................    pFVisita.b = PIN_A1; 
0C2A:  MOVLW  29
0C2B:  MOVWF  5D
....................    pFVisita.c = PIN_A2; 
0C2C:  MOVLW  2A
0C2D:  MOVWF  5E
....................    pFVisita.d = PIN_C0; 
0C2E:  MOVLW  38
0C2F:  MOVWF  5F
0C30:  CLRF   2B
0C31:  BTFSC  0B.7
0C32:  BSF    2B.7
0C33:  BCF    0B.7
....................     
....................     
....................    delay_ms(DEFAULT_D); 
0C34:  MOVLW  C8
0C35:  BSF    03.5
0C36:  MOVWF  21
0C37:  BCF    0A.3
0C38:  BCF    03.5
0C39:  CALL   29F
0C3A:  BSF    0A.3
0C3B:  BTFSC  2B.7
0C3C:  BSF    0B.7
....................     
....................    if(DEBUG) {fputs("> Habilitacion de displays",RS232);} 
0C3D:  BTFSS  05.3
0C3E:  GOTO   456
0C3F:  MOVLW  06
0C40:  BSF    03.6
0C41:  MOVWF  0D
0C42:  MOVLW  01
0C43:  MOVWF  0F
0C44:  BCF    03.6
0C45:  CLRF   2B
0C46:  BTFSC  0B.7
0C47:  BSF    2B.7
0C48:  BCF    0B.7
0C49:  BCF    0A.3
0C4A:  CALL   125
0C4B:  BSF    0A.3
0C4C:  BTFSC  2B.7
0C4D:  BSF    0B.7
0C4E:  MOVLW  0D
0C4F:  BTFSS  0C.4
0C50:  GOTO   44F
0C51:  MOVWF  19
0C52:  MOVLW  0A
0C53:  BTFSS  0C.4
0C54:  GOTO   453
0C55:  MOVWF  19
....................    output_bit(DISPLAY, ON);  
0C56:  BSF    09.0
0C57:  MOVLW  E0
0C58:  BSF    03.5
0C59:  MOVWF  09
....................    output_bit(CENLOCAL, ON);  
0C5A:  BCF    03.5
0C5B:  BSF    07.2
0C5C:  MOVLW  D8
0C5D:  BSF    03.5
0C5E:  MOVWF  07
....................    output_bit(CENVISITA, ON); 
0C5F:  BCF    03.5
0C60:  BSF    09.2
0C61:  MOVLW  E0
0C62:  BSF    03.5
0C63:  MOVWF  09
....................    output_bit(POSLOCAL, ON); 
0C64:  BCF    03.5
0C65:  BSF    07.1
0C66:  MOVLW  D8
0C67:  BSF    03.5
0C68:  MOVWF  07
....................    output_bit(POSVISITA, ON); 
0C69:  BCF    03.5
0C6A:  BSF    09.1
0C6B:  MOVLW  E0
0C6C:  BSF    03.5
0C6D:  MOVWF  09
0C6E:  BCF    03.5
0C6F:  CLRF   2B
0C70:  BTFSC  0B.7
0C71:  BSF    2B.7
0C72:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C73:  MOVLW  C8
0C74:  BSF    03.5
0C75:  MOVWF  21
0C76:  BCF    0A.3
0C77:  BCF    03.5
0C78:  CALL   29F
0C79:  BSF    0A.3
0C7A:  BTFSC  2B.7
0C7B:  BSF    0B.7
....................    output_bit(DISPLAY, OFF); 
0C7C:  BCF    09.0
0C7D:  MOVLW  E0
0C7E:  BSF    03.5
0C7F:  MOVWF  09
....................    output_bit(CENLOCAL, OFF);  
0C80:  BCF    03.5
0C81:  BCF    07.2
0C82:  MOVLW  D8
0C83:  BSF    03.5
0C84:  MOVWF  07
....................    output_bit(CENVISITA, OFF); 
0C85:  BCF    03.5
0C86:  BCF    09.2
0C87:  MOVLW  E0
0C88:  BSF    03.5
0C89:  MOVWF  09
....................    output_bit(POSLOCAL, OFF); 
0C8A:  BCF    03.5
0C8B:  BCF    07.1
0C8C:  MOVLW  D8
0C8D:  BSF    03.5
0C8E:  MOVWF  07
....................    output_bit(POSVISITA, OFF); 
0C8F:  BCF    03.5
0C90:  BCF    09.1
0C91:  MOVLW  E0
0C92:  BSF    03.5
0C93:  MOVWF  09
0C94:  BCF    03.5
0C95:  CLRF   2B
0C96:  BTFSC  0B.7
0C97:  BSF    2B.7
0C98:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0C99:  MOVLW  C8
0C9A:  BSF    03.5
0C9B:  MOVWF  21
0C9C:  BCF    0A.3
0C9D:  BCF    03.5
0C9E:  CALL   29F
0C9F:  BSF    0A.3
0CA0:  BTFSC  2B.7
0CA1:  BSF    0B.7
....................    output_bit(DISPLAY, ON); 
0CA2:  BSF    09.0
0CA3:  MOVLW  E0
0CA4:  BSF    03.5
0CA5:  MOVWF  09
....................    output_bit(CENLOCAL, ON);  
0CA6:  BCF    03.5
0CA7:  BSF    07.2
0CA8:  MOVLW  D8
0CA9:  BSF    03.5
0CAA:  MOVWF  07
....................    output_bit(CENVISITA, ON); 
0CAB:  BCF    03.5
0CAC:  BSF    09.2
0CAD:  MOVLW  E0
0CAE:  BSF    03.5
0CAF:  MOVWF  09
....................    output_bit(POSLOCAL, ON); 
0CB0:  BCF    03.5
0CB1:  BSF    07.1
0CB2:  MOVLW  D8
0CB3:  BSF    03.5
0CB4:  MOVWF  07
....................    output_bit(POSVISITA, ON); 
0CB5:  BCF    03.5
0CB6:  BSF    09.1
0CB7:  MOVLW  E0
0CB8:  BSF    03.5
0CB9:  MOVWF  09
0CBA:  BCF    03.5
0CBB:  CLRF   2B
0CBC:  BTFSC  0B.7
0CBD:  BSF    2B.7
0CBE:  BCF    0B.7
....................    delay_ms(DEFAULT_D); 
0CBF:  MOVLW  C8
0CC0:  BSF    03.5
0CC1:  MOVWF  21
0CC2:  BCF    0A.3
0CC3:  BCF    03.5
0CC4:  CALL   29F
0CC5:  BSF    0A.3
0CC6:  BTFSC  2B.7
0CC7:  BSF    0B.7
....................    output_bit(CENLOCAL, OFF);  
0CC8:  BCF    07.2
0CC9:  MOVLW  D8
0CCA:  BSF    03.5
0CCB:  MOVWF  07
....................    output_bit(CENVISITA, OFF); 
0CCC:  BCF    03.5
0CCD:  BCF    09.2
0CCE:  MOVLW  E0
0CCF:  BSF    03.5
0CD0:  MOVWF  09
....................    output_bit(POSLOCAL, OFF); 
0CD1:  BCF    03.5
0CD2:  BCF    07.1
0CD3:  MOVLW  D8
0CD4:  BSF    03.5
0CD5:  MOVWF  07
....................    output_bit(POSVISITA, OFF); 
0CD6:  BCF    03.5
0CD7:  BCF    09.1
0CD8:  MOVLW  E0
0CD9:  BSF    03.5
0CDA:  MOVWF  09
....................     
....................    if(DEBUG) {fputs("> Habilitacion de interrupciones",RS232);} 
0CDB:  BCF    03.5
0CDC:  BTFSS  05.3
0CDD:  GOTO   4F5
0CDE:  MOVLW  14
0CDF:  BSF    03.6
0CE0:  MOVWF  0D
0CE1:  MOVLW  01
0CE2:  MOVWF  0F
0CE3:  BCF    03.6
0CE4:  CLRF   2B
0CE5:  BTFSC  0B.7
0CE6:  BSF    2B.7
0CE7:  BCF    0B.7
0CE8:  BCF    0A.3
0CE9:  CALL   125
0CEA:  BSF    0A.3
0CEB:  BTFSC  2B.7
0CEC:  BSF    0B.7
0CED:  MOVLW  0D
0CEE:  BTFSS  0C.4
0CEF:  GOTO   4EE
0CF0:  MOVWF  19
0CF1:  MOVLW  0A
0CF2:  BTFSS  0C.4
0CF3:  GOTO   4F2
0CF4:  MOVWF  19
....................    enable_interrupts(INT_RDA); 
0CF5:  BSF    03.5
0CF6:  BSF    0C.5
....................    enable_interrupts(INT_SSP); 
0CF7:  BSF    0C.3
....................    enable_interrupts(GLOBAL); 
0CF8:  MOVLW  C0
0CF9:  BCF    03.5
0CFA:  IORWF  0B,F
0CFB:  BSF    0A.3
0CFC:  BCF    0A.4
0CFD:  GOTO   557 (RETURN)
.................... } 
....................  
.................... void main() 
0CFE:  MOVF   03,W
0CFF:  ANDLW  1F
0D00:  MOVWF  03
0D01:  MOVLW  71
0D02:  BSF    03.5
0D03:  MOVWF  0F
0D04:  CLRF   10
0D05:  MOVF   0F,W
0D06:  BSF    03.6
0D07:  BCF    07.3
0D08:  MOVLW  0C
0D09:  BCF    03.6
0D0A:  MOVWF  19
0D0B:  MOVLW  A2
0D0C:  MOVWF  18
0D0D:  MOVLW  90
0D0E:  BCF    03.5
0D0F:  MOVWF  18
0D10:  MOVLW  D8
0D11:  BSF    03.5
0D12:  MOVWF  07
0D13:  MOVLW  D8
0D14:  MOVWF  07
0D15:  MOVLW  0A
0D16:  MOVWF  13
0D17:  MOVLW  09
0D18:  BCF    03.5
0D19:  MOVWF  14
0D1A:  MOVLW  FF
0D1B:  BSF    03.5
0D1C:  MOVWF  13
0D1D:  MOVLW  36
0D1E:  BCF    03.5
0D1F:  MOVWF  14
0D20:  BSF    03.5
0D21:  BSF    11.0
0D22:  BSF    11.7
0D23:  BCF    03.5
0D24:  CLRF   40
0D25:  BCF    41.0
0D26:  CLRF   63
0D27:  CLRF   62
0D28:  MOVLW  03
0D29:  MOVWF  64
0D2A:  BSF    03.5
0D2B:  BSF    03.6
0D2C:  MOVF   09,W
0D2D:  ANDLW  C0
0D2E:  MOVWF  09
0D2F:  BCF    03.6
0D30:  BCF    1F.4
0D31:  BCF    1F.5
0D32:  MOVLW  00
0D33:  BSF    03.6
0D34:  MOVWF  08
0D35:  BCF    03.5
0D36:  CLRF   07
0D37:  CLRF   08
0D38:  CLRF   09
0D39:  BCF    03.7
.................... { 
....................    setup(); 
*
0D56:  GOTO   32A
....................  
....................    while(TRUE) 
....................    { 
0D57:  GOTO   557
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
0D58:  SLEEP
.................... { 
....................    char c; 
....................    c = fgetc(RS232); 
*
05E0:  BTFSS  0C.5
05E1:  GOTO   5E0
05E2:  MOVF   1A,W
05E3:  MOVWF  6A
.................... if(cmdGet) 
05E4:  BTFSS  41.0
05E5:  GOTO   616
.................... { 
....................    if(c == '#' || c == '\r') 
05E6:  MOVF   6A,W
05E7:  SUBLW  23
05E8:  BTFSC  03.2
05E9:  GOTO   5EE
05EA:  MOVF   6A,W
05EB:  SUBLW  0D
05EC:  BTFSS  03.2
05ED:  GOTO   60B
....................    { 
....................       cmdGet = false; 
05EE:  BCF    41.0
....................       strcpy(cmd, rcmd); 
05EF:  CLRF   6E
05F0:  MOVLW  36
05F1:  MOVWF  6D
05F2:  CLRF   6C
05F3:  MOVLW  2C
05F4:  MOVWF  6B
05F5:  MOVF   6D,W
05F6:  MOVWF  04
05F7:  BCF    03.7
05F8:  BTFSC  6E.0
05F9:  BSF    03.7
05FA:  MOVF   00,W
05FB:  MOVWF  6F
05FC:  MOVF   6B,W
05FD:  MOVWF  04
05FE:  BCF    03.7
05FF:  BTFSC  6C.0
0600:  BSF    03.7
0601:  MOVF   6F,W
0602:  MOVWF  00
0603:  MOVF   00,F
0604:  BTFSC  03.2
0605:  GOTO   609
0606:  INCF   6B,F
0607:  INCF   6D,F
0608:  GOTO   5F5
....................       parseCommand(); 
0609:  GOTO   38F
....................    } 
060A:  GOTO   616
....................    else 
....................    { 
....................    if(cmdIndex < 9) 
060B:  MOVF   40,W
060C:  SUBLW  08
060D:  BTFSS  03.0
060E:  GOTO   616
....................       { 
....................          rcmd[cmdIndex] = c; 
060F:  MOVLW  36
0610:  ADDWF  40,W
0611:  MOVWF  04
0612:  BCF    03.7
0613:  MOVF   6A,W
0614:  MOVWF  00
....................          cmdIndex++; 
0615:  INCF   40,F
....................       } 
....................    } 
.................... } 
....................       if(c == '-') 
0616:  MOVF   6A,W
0617:  SUBLW  2D
0618:  BTFSS  03.2
0619:  GOTO   62C
....................    { 
....................        cmdGet = true;  
061A:  BSF    41.0
....................        rcmd = "\0\0\0\0\0\0\0\0\0"; 
061B:  CLRF   6B
061C:  CLRF   6C
061D:  MOVLW  36
061E:  MOVWF  04
061F:  BCF    03.7
0620:  MOVF   6B,W
0621:  ADDWF  04,F
0622:  MOVF   6C,W
0623:  CALL   05A
0624:  MOVWF  00
0625:  IORLW  00
0626:  BTFSC  03.2
0627:  GOTO   62B
0628:  INCF   6C,F
0629:  INCF   6B,F
062A:  GOTO   61D
....................        cmdIndex = 0; 
062B:  CLRF   40
....................    } 
.................... } 
....................  
062C:  BCF    0C.5
062D:  BCF    0A.3
062E:  BCF    0A.4
062F:  GOTO   033
.................... #INT_SSP 
.................... void  SSP_isr(void)  
*
0800:  BSF    03.5
0801:  BTFSC  14.5
0802:  GOTO   00B
0803:  BCF    03.5
0804:  CLRF   64
0805:  BSF    03.5
0806:  BTFSS  14.2
0807:  GOTO   00B
0808:  BCF    03.5
0809:  BSF    64.7
080A:  BSF    03.5
080B:  BCF    03.5
080C:  MOVF   64,W
080D:  INCF   64,F
080E:  MOVWF  6A
.................... { 
....................    int state = i2c_isr_state(); 
....................       if(state== 0 )  
080F:  MOVF   6A,F
0810:  BTFSS  03.2
0811:  GOTO   019
....................          i2c_read(); 
0812:  BCF    14.6
0813:  BSF    03.5
0814:  BTFSS  14.0
0815:  GOTO   014
0816:  BCF    03.5
0817:  MOVF   13,W
0818:  BSF    14.4
....................       if(state == 0x80) 
0819:  MOVF   6A,W
081A:  SUBLW  80
081B:  BTFSC  03.2
081C:  GOTO   01D
....................          i2c_read(2); 
....................       if(state >= 0x80) 
081D:  MOVF   6A,W
081E:  SUBLW  7F
081F:  BTFSC  03.0
0820:  GOTO   02F
....................          i2c_write(0xFF); 
0821:  MOVLW  FF
0822:  MOVWF  6B
*
082D:  GOTO   2C5
082E:  BCF    03.5
....................       else if(state > 0) 
082F:  MOVF   6A,F
0830:  BTFSC  03.2
0831:  GOTO   2C4
....................       { 
....................          ircmd[state - 1] = i2c_read(); 
0832:  MOVLW  01
0833:  SUBWF  6A,W
0834:  ADDLW  43
0835:  MOVWF  04
0836:  BCF    03.7
0837:  BCF    14.6
0838:  BSF    03.5
0839:  BTFSS  14.0
083A:  GOTO   039
083B:  BCF    03.5
083C:  MOVF   13,W
083D:  BSF    14.4
083E:  MOVWF  00
....................          if(DEBUG) {fprintf(RS232, "> Commando: %X - %X\r",state, ircmd[state - 1]);} 
083F:  BTFSS  05.3
0840:  GOTO   072
0841:  MOVLW  01
0842:  SUBWF  6A,W
0843:  ADDLW  43
0844:  MOVWF  04
0845:  BCF    03.7
0846:  MOVF   00,W
0847:  MOVWF  6B
0848:  MOVLW  B1
0849:  BSF    03.6
084A:  MOVWF  0D
084B:  MOVLW  06
084C:  MOVWF  0F
084D:  BCF    03.0
084E:  MOVLW  0C
084F:  BCF    03.6
0850:  MOVWF  6C
0851:  BCF    0A.3
0852:  CALL   630
0853:  BSF    0A.3
0854:  MOVF   6A,W
0855:  MOVWF  6C
0856:  MOVLW  37
0857:  MOVWF  6D
0858:  BCF    0A.3
0859:  CALL   68E
085A:  BSF    0A.3
085B:  MOVLW  20
085C:  BTFSS  0C.4
085D:  GOTO   05C
085E:  MOVWF  19
085F:  MOVLW  2D
0860:  BTFSS  0C.4
0861:  GOTO   060
0862:  MOVWF  19
0863:  MOVLW  20
0864:  BTFSS  0C.4
0865:  GOTO   064
0866:  MOVWF  19
0867:  MOVF   6B,W
0868:  MOVWF  6C
0869:  MOVLW  37
086A:  MOVWF  6D
086B:  BCF    0A.3
086C:  CALL   68E
086D:  BSF    0A.3
086E:  MOVLW  0D
086F:  BTFSS  0C.4
0870:  GOTO   06F
0871:  MOVWF  19
....................          icmd = ircmd[state - 1]; 
0872:  MOVLW  01
0873:  SUBWF  6A,W
0874:  ADDLW  43
0875:  MOVWF  04
0876:  BCF    03.7
0877:  MOVF   00,W
0878:  MOVWF  42
....................          parseI2CCommand(); 
....................       } 
*
0AC5:  BCF    03.5
0AC6:  BCF    0C.3
0AC7:  BCF    0A.3
0AC8:  BCF    0A.4
0AC9:  GOTO   033
.................... } 
....................  
.................... void parseI2CCommand(void) 
*
0879:  MOVF   42,W
087A:  MOVWF  6B
.................... { 
....................    int c = icmd; 
....................    switch(c) 
087B:  MOVF   6B,W
087C:  XORLW  0A
087D:  BTFSC  03.2
087E:  GOTO   09E
087F:  XORLW  06
0880:  BTFSC  03.2
0881:  GOTO   0B2
0882:  XORLW  7C
0883:  BTFSC  03.2
0884:  GOTO   0C6
0885:  XORLW  01
0886:  BTFSC  03.2
0887:  GOTO   0E4
0888:  XORLW  03
0889:  BTFSC  03.2
088A:  GOTO   102
088B:  XORLW  01
088C:  BTFSC  03.2
088D:  GOTO   120
088E:  XORLW  07
088F:  BTFSC  03.2
0890:  GOTO   139
0891:  XORLW  01
0892:  BTFSC  03.2
0893:  GOTO   152
0894:  XORLW  03
0895:  BTFSC  03.2
0896:  GOTO   16B
0897:  XORLW  89
0898:  BTFSC  03.2
0899:  GOTO   184
089A:  XORLW  02
089B:  BTFSC  03.2
089C:  GOTO   188
089D:  GOTO   18C
....................    { 
....................       case I2C_TIMER:      if(DEBUG) {fputs("> Direccion TIMER",RS232);} 
089E:  BTFSS  05.3
089F:  GOTO   0B1
08A0:  MOVLW  BC
08A1:  BSF    03.6
08A2:  MOVWF  0D
08A3:  MOVLW  06
08A4:  MOVWF  0F
08A5:  BCF    0A.3
08A6:  BCF    03.6
08A7:  CALL   125
08A8:  BSF    0A.3
08A9:  MOVLW  0D
08AA:  BTFSS  0C.4
08AB:  GOTO   0AA
08AC:  MOVWF  19
08AD:  MOVLW  0A
08AE:  BTFSS  0C.4
08AF:  GOTO   0AE
08B0:  MOVWF  19
....................                            break; 
08B1:  GOTO   18C
....................       case I2C_SCORE:      if(DEBUG) {fputs("> Direccion SCORE",RS232);} 
08B2:  BTFSS  05.3
08B3:  GOTO   0C5
08B4:  MOVLW  C5
08B5:  BSF    03.6
08B6:  MOVWF  0D
08B7:  MOVLW  06
08B8:  MOVWF  0F
08B9:  BCF    0A.3
08BA:  BCF    03.6
08BB:  CALL   125
08BC:  BSF    0A.3
08BD:  MOVLW  0D
08BE:  BTFSS  0C.4
08BF:  GOTO   0BE
08C0:  MOVWF  19
08C1:  MOVLW  0A
08C2:  BTFSS  0C.4
08C3:  GOTO   0C2
08C4:  MOVWF  19
....................                            break; 
08C5:  GOTO   18C
....................       case I2C_CMD_POS0:   if(DEBUG) {fputs("> Apagar Posicion",RS232);} 
08C6:  BTFSS  05.3
08C7:  GOTO   0D9
08C8:  MOVLW  CE
08C9:  BSF    03.6
08CA:  MOVWF  0D
08CB:  MOVLW  06
08CC:  MOVWF  0F
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   125
08D0:  BSF    0A.3
08D1:  MOVLW  0D
08D2:  BTFSS  0C.4
08D3:  GOTO   0D2
08D4:  MOVWF  19
08D5:  MOVLW  0A
08D6:  BTFSS  0C.4
08D7:  GOTO   0D6
08D8:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, OFF); 
08D9:  BCF    07.1
08DA:  MOVLW  D8
08DB:  BSF    03.5
08DC:  MOVWF  07
08DD:  BCF    03.5
08DE:  BCF    09.1
08DF:  MOVLW  E0
08E0:  BSF    03.5
08E1:  MOVWF  09
....................                            break; 
08E2:  BCF    03.5
08E3:  GOTO   18C
....................       case I2C_CMD_POSL:   if(DEBUG) {fputs("> Activar Posicion Local",RS232);} 
08E4:  BTFSS  05.3
08E5:  GOTO   0F7
08E6:  MOVLW  D7
08E7:  BSF    03.6
08E8:  MOVWF  0D
08E9:  MOVLW  06
08EA:  MOVWF  0F
08EB:  BCF    0A.3
08EC:  BCF    03.6
08ED:  CALL   125
08EE:  BSF    0A.3
08EF:  MOVLW  0D
08F0:  BTFSS  0C.4
08F1:  GOTO   0F0
08F2:  MOVWF  19
08F3:  MOVLW  0A
08F4:  BTFSS  0C.4
08F5:  GOTO   0F4
08F6:  MOVWF  19
....................                            output_bit(POSLOCAL, ON); output_bit(POSVISITA, OFF); 
08F7:  BSF    07.1
08F8:  MOVLW  D8
08F9:  BSF    03.5
08FA:  MOVWF  07
08FB:  BCF    03.5
08FC:  BCF    09.1
08FD:  MOVLW  E0
08FE:  BSF    03.5
08FF:  MOVWF  09
....................                            break; 
0900:  BCF    03.5
0901:  GOTO   18C
....................       case I2C_CMD_POSV:   if(DEBUG) {fputs("> Activar Posicion Visita",RS232);} 
0902:  BTFSS  05.3
0903:  GOTO   115
0904:  MOVLW  E4
0905:  BSF    03.6
0906:  MOVWF  0D
0907:  MOVLW  06
0908:  MOVWF  0F
0909:  BCF    0A.3
090A:  BCF    03.6
090B:  CALL   125
090C:  BSF    0A.3
090D:  MOVLW  0D
090E:  BTFSS  0C.4
090F:  GOTO   10E
0910:  MOVWF  19
0911:  MOVLW  0A
0912:  BTFSS  0C.4
0913:  GOTO   112
0914:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, ON); 
0915:  BCF    07.1
0916:  MOVLW  D8
0917:  BSF    03.5
0918:  MOVWF  07
0919:  BCF    03.5
091A:  BSF    09.1
091B:  MOVLW  E0
091C:  BSF    03.5
091D:  MOVWF  09
....................                            break; 
091E:  BCF    03.5
091F:  GOTO   18C
....................       case I2C_CMD_CLON:   if(DEBUG) {fputs("> Activar Centena Local",RS232);} 
0920:  BTFSS  05.3
0921:  GOTO   133
0922:  MOVLW  F1
0923:  BSF    03.6
0924:  MOVWF  0D
0925:  MOVLW  06
0926:  MOVWF  0F
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   125
092A:  BSF    0A.3
092B:  MOVLW  0D
092C:  BTFSS  0C.4
092D:  GOTO   12C
092E:  MOVWF  19
092F:  MOVLW  0A
0930:  BTFSS  0C.4
0931:  GOTO   130
0932:  MOVWF  19
....................                            output_bit(CENLOCAL, ON); 
0933:  BSF    07.2
0934:  MOVLW  D8
0935:  BSF    03.5
0936:  MOVWF  07
....................                            break; 
0937:  BCF    03.5
0938:  GOTO   18C
....................       case I2C_CMD_CLOF:   if(DEBUG) {fputs("> Desactivar Centena Local",RS232);} 
0939:  BTFSS  05.3
093A:  GOTO   14C
093B:  MOVLW  FD
093C:  BSF    03.6
093D:  MOVWF  0D
093E:  MOVLW  06
093F:  MOVWF  0F
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   125
0943:  BSF    0A.3
0944:  MOVLW  0D
0945:  BTFSS  0C.4
0946:  GOTO   145
0947:  MOVWF  19
0948:  MOVLW  0A
0949:  BTFSS  0C.4
094A:  GOTO   149
094B:  MOVWF  19
....................                            output_bit(CENLOCAL, OFF); 
094C:  BCF    07.2
094D:  MOVLW  D8
094E:  BSF    03.5
094F:  MOVWF  07
....................                            break; 
0950:  BCF    03.5
0951:  GOTO   18C
....................       case I2C_CMD_CVON:   if(DEBUG) {fputs("> Activar Centena Visita",RS232);} 
0952:  BTFSS  05.3
0953:  GOTO   165
0954:  MOVLW  0B
0955:  BSF    03.6
0956:  MOVWF  0D
0957:  MOVLW  07
0958:  MOVWF  0F
0959:  BCF    0A.3
095A:  BCF    03.6
095B:  CALL   125
095C:  BSF    0A.3
095D:  MOVLW  0D
095E:  BTFSS  0C.4
095F:  GOTO   15E
0960:  MOVWF  19
0961:  MOVLW  0A
0962:  BTFSS  0C.4
0963:  GOTO   162
0964:  MOVWF  19
....................                            output_bit(CENVISITA, ON);; 
0965:  BSF    09.2
0966:  MOVLW  E0
0967:  BSF    03.5
0968:  MOVWF  09
....................                            break; 
0969:  BCF    03.5
096A:  GOTO   18C
....................       case I2C_CMD_CVOF:   if(DEBUG) {fputs("> Desactivar Centena Visita",RS232);} 
096B:  BTFSS  05.3
096C:  GOTO   17E
096D:  MOVLW  18
096E:  BSF    03.6
096F:  MOVWF  0D
0970:  MOVLW  07
0971:  MOVWF  0F
0972:  BCF    0A.3
0973:  BCF    03.6
0974:  CALL   125
0975:  BSF    0A.3
0976:  MOVLW  0D
0977:  BTFSS  0C.4
0978:  GOTO   177
0979:  MOVWF  19
097A:  MOVLW  0A
097B:  BTFSS  0C.4
097C:  GOTO   17B
097D:  MOVWF  19
....................                            output_bit(CENVISITA, OFF); 
097E:  BCF    09.2
097F:  MOVLW  E0
0980:  BSF    03.5
0981:  MOVWF  09
....................                            break; 
0982:  BCF    03.5
0983:  GOTO   18C
....................       case I2C_CMD_TEST:   doTest();    
0984:  BCF    0A.3
0985:  CALL   2B3
0986:  BSF    0A.3
....................                            break; 
0987:  GOTO   18C
....................       case I2C_CMD_RESET:  doReset(); 
0988:  BCF    0A.3
0989:  CALL   37B
098A:  BSF    0A.3
....................                            break; 
098B:  GOTO   18C
....................    } 
....................     
....................    if(c > 0x0F && c < 0x1A) //0x10 - 0x19 
098C:  MOVF   6B,W
098D:  SUBLW  0F
098E:  BTFSC  03.0
098F:  GOTO   1C0
0990:  MOVF   6B,W
0991:  SUBLW  19
0992:  BTFSS  03.0
0993:  GOTO   1C0
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 1",RS232);} 
0994:  BTFSS  05.3
0995:  GOTO   1A7
0996:  MOVLW  26
0997:  BSF    03.6
0998:  MOVWF  0D
0999:  MOVLW  07
099A:  MOVWF  0F
099B:  BCF    0A.3
099C:  BCF    03.6
099D:  CALL   125
099E:  BSF    0A.3
099F:  MOVLW  0D
09A0:  BTFSS  0C.4
09A1:  GOTO   1A0
09A2:  MOVWF  19
09A3:  MOVLW  0A
09A4:  BTFSS  0C.4
09A5:  GOTO   1A4
09A6:  MOVWF  19
....................       showNumber(c - 0x10, pLocalU);    
09A7:  MOVLW  10
09A8:  SUBWF  6B,W
09A9:  MOVWF  6C
09AA:  BSF    03.5
09AB:  MOVWF  21
09AC:  BCF    03.5
09AD:  MOVF   4B,W
09AE:  BSF    03.5
09AF:  MOVWF  25
09B0:  BCF    03.5
09B1:  MOVF   4A,W
09B2:  BSF    03.5
09B3:  MOVWF  24
09B4:  BCF    03.5
09B5:  MOVF   49,W
09B6:  BSF    03.5
09B7:  MOVWF  23
09B8:  BCF    03.5
09B9:  MOVF   48,W
09BA:  BSF    03.5
09BB:  MOVWF  22
09BC:  BCF    0A.3
09BD:  BCF    03.5
09BE:  CALL   20B
09BF:  BSF    0A.3
....................    } 
....................    if(c > 0x1F && c < 0x2A) //0x20 - 0x29 
09C0:  MOVF   6B,W
09C1:  SUBLW  1F
09C2:  BTFSC  03.0
09C3:  GOTO   1F4
09C4:  MOVF   6B,W
09C5:  SUBLW  29
09C6:  BTFSS  03.0
09C7:  GOTO   1F4
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 2",RS232);} 
09C8:  BTFSS  05.3
09C9:  GOTO   1DB
09CA:  MOVLW  31
09CB:  BSF    03.6
09CC:  MOVWF  0D
09CD:  MOVLW  07
09CE:  MOVWF  0F
09CF:  BCF    0A.3
09D0:  BCF    03.6
09D1:  CALL   125
09D2:  BSF    0A.3
09D3:  MOVLW  0D
09D4:  BTFSS  0C.4
09D5:  GOTO   1D4
09D6:  MOVWF  19
09D7:  MOVLW  0A
09D8:  BTFSS  0C.4
09D9:  GOTO   1D8
09DA:  MOVWF  19
....................       showNumber(c - 0x20, pLocalD);    
09DB:  MOVLW  20
09DC:  SUBWF  6B,W
09DD:  MOVWF  6C
09DE:  BSF    03.5
09DF:  MOVWF  21
09E0:  BCF    03.5
09E1:  MOVF   4F,W
09E2:  BSF    03.5
09E3:  MOVWF  25
09E4:  BCF    03.5
09E5:  MOVF   4E,W
09E6:  BSF    03.5
09E7:  MOVWF  24
09E8:  BCF    03.5
09E9:  MOVF   4D,W
09EA:  BSF    03.5
09EB:  MOVWF  23
09EC:  BCF    03.5
09ED:  MOVF   4C,W
09EE:  BSF    03.5
09EF:  MOVWF  22
09F0:  BCF    0A.3
09F1:  BCF    03.5
09F2:  CALL   20B
09F3:  BSF    0A.3
....................    } 
....................    if(c > 0x2F && c < 0x3A) //0x30 - 0x39 
09F4:  MOVF   6B,W
09F5:  SUBLW  2F
09F6:  BTFSC  03.0
09F7:  GOTO   228
09F8:  MOVF   6B,W
09F9:  SUBLW  39
09FA:  BTFSS  03.0
09FB:  GOTO   228
....................    { 
....................    if(DEBUG) {fputs("> Asignacion Puerto 3",RS232);} 
09FC:  BTFSS  05.3
09FD:  GOTO   20F
09FE:  MOVLW  3C
09FF:  BSF    03.6
0A00:  MOVWF  0D
0A01:  MOVLW  07
0A02:  MOVWF  0F
0A03:  BCF    0A.3
0A04:  BCF    03.6
0A05:  CALL   125
0A06:  BSF    0A.3
0A07:  MOVLW  0D
0A08:  BTFSS  0C.4
0A09:  GOTO   208
0A0A:  MOVWF  19
0A0B:  MOVLW  0A
0A0C:  BTFSS  0C.4
0A0D:  GOTO   20C
0A0E:  MOVWF  19
....................       showNumber(c - 0x30, pVisitaD);    
0A0F:  MOVLW  30
0A10:  SUBWF  6B,W
0A11:  MOVWF  6C
0A12:  BSF    03.5
0A13:  MOVWF  21
0A14:  BCF    03.5
0A15:  MOVF   57,W
0A16:  BSF    03.5
0A17:  MOVWF  25
0A18:  BCF    03.5
0A19:  MOVF   56,W
0A1A:  BSF    03.5
0A1B:  MOVWF  24
0A1C:  BCF    03.5
0A1D:  MOVF   55,W
0A1E:  BSF    03.5
0A1F:  MOVWF  23
0A20:  BCF    03.5
0A21:  MOVF   54,W
0A22:  BSF    03.5
0A23:  MOVWF  22
0A24:  BCF    0A.3
0A25:  BCF    03.5
0A26:  CALL   20B
0A27:  BSF    0A.3
....................    } 
....................    if(c > 0x3F && c < 0x4A) //0x40 - 0x49 
0A28:  MOVF   6B,W
0A29:  SUBLW  3F
0A2A:  BTFSC  03.0
0A2B:  GOTO   25C
0A2C:  MOVF   6B,W
0A2D:  SUBLW  49
0A2E:  BTFSS  03.0
0A2F:  GOTO   25C
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 4",RS232);} 
0A30:  BTFSS  05.3
0A31:  GOTO   243
0A32:  MOVLW  47
0A33:  BSF    03.6
0A34:  MOVWF  0D
0A35:  MOVLW  07
0A36:  MOVWF  0F
0A37:  BCF    0A.3
0A38:  BCF    03.6
0A39:  CALL   125
0A3A:  BSF    0A.3
0A3B:  MOVLW  0D
0A3C:  BTFSS  0C.4
0A3D:  GOTO   23C
0A3E:  MOVWF  19
0A3F:  MOVLW  0A
0A40:  BTFSS  0C.4
0A41:  GOTO   240
0A42:  MOVWF  19
....................       showNumber(c - 0x40, pVisitaU);    
0A43:  MOVLW  40
0A44:  SUBWF  6B,W
0A45:  MOVWF  6C
0A46:  BSF    03.5
0A47:  MOVWF  21
0A48:  BCF    03.5
0A49:  MOVF   53,W
0A4A:  BSF    03.5
0A4B:  MOVWF  25
0A4C:  BCF    03.5
0A4D:  MOVF   52,W
0A4E:  BSF    03.5
0A4F:  MOVWF  24
0A50:  BCF    03.5
0A51:  MOVF   51,W
0A52:  BSF    03.5
0A53:  MOVWF  23
0A54:  BCF    03.5
0A55:  MOVF   50,W
0A56:  BSF    03.5
0A57:  MOVWF  22
0A58:  BCF    0A.3
0A59:  BCF    03.5
0A5A:  CALL   20B
0A5B:  BSF    0A.3
....................    } 
....................    if(c > 0x4F && c < 0x5A) //0x50 - 0x59 
0A5C:  MOVF   6B,W
0A5D:  SUBLW  4F
0A5E:  BTFSC  03.0
0A5F:  GOTO   290
0A60:  MOVF   6B,W
0A61:  SUBLW  59
0A62:  BTFSS  03.0
0A63:  GOTO   290
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 5",RS232);} 
0A64:  BTFSS  05.3
0A65:  GOTO   277
0A66:  MOVLW  52
0A67:  BSF    03.6
0A68:  MOVWF  0D
0A69:  MOVLW  07
0A6A:  MOVWF  0F
0A6B:  BCF    0A.3
0A6C:  BCF    03.6
0A6D:  CALL   125
0A6E:  BSF    0A.3
0A6F:  MOVLW  0D
0A70:  BTFSS  0C.4
0A71:  GOTO   270
0A72:  MOVWF  19
0A73:  MOVLW  0A
0A74:  BTFSS  0C.4
0A75:  GOTO   274
0A76:  MOVWF  19
....................       showNumber(c - 0x50, pFLocal);    
0A77:  MOVLW  50
0A78:  SUBWF  6B,W
0A79:  MOVWF  6C
0A7A:  BSF    03.5
0A7B:  MOVWF  21
0A7C:  BCF    03.5
0A7D:  MOVF   5B,W
0A7E:  BSF    03.5
0A7F:  MOVWF  25
0A80:  BCF    03.5
0A81:  MOVF   5A,W
0A82:  BSF    03.5
0A83:  MOVWF  24
0A84:  BCF    03.5
0A85:  MOVF   59,W
0A86:  BSF    03.5
0A87:  MOVWF  23
0A88:  BCF    03.5
0A89:  MOVF   58,W
0A8A:  BSF    03.5
0A8B:  MOVWF  22
0A8C:  BCF    0A.3
0A8D:  BCF    03.5
0A8E:  CALL   20B
0A8F:  BSF    0A.3
....................    } 
....................    if(c > 0x5F && c < 0x6A) //0x60 - 0x69 
0A90:  MOVF   6B,W
0A91:  SUBLW  5F
0A92:  BTFSC  03.0
0A93:  GOTO   2C4
0A94:  MOVF   6B,W
0A95:  SUBLW  69
0A96:  BTFSS  03.0
0A97:  GOTO   2C4
....................    { 
....................       if(DEBUG) {fputs("> Asignacion Puerto 6",RS232);} 
0A98:  BTFSS  05.3
0A99:  GOTO   2AB
0A9A:  MOVLW  5D
0A9B:  BSF    03.6
0A9C:  MOVWF  0D
0A9D:  MOVLW  07
0A9E:  MOVWF  0F
0A9F:  BCF    0A.3
0AA0:  BCF    03.6
0AA1:  CALL   125
0AA2:  BSF    0A.3
0AA3:  MOVLW  0D
0AA4:  BTFSS  0C.4
0AA5:  GOTO   2A4
0AA6:  MOVWF  19
0AA7:  MOVLW  0A
0AA8:  BTFSS  0C.4
0AA9:  GOTO   2A8
0AAA:  MOVWF  19
....................       showNumber(c - 0x60, pFVisita);    
0AAB:  MOVLW  60
0AAC:  SUBWF  6B,W
0AAD:  MOVWF  6C
0AAE:  BSF    03.5
0AAF:  MOVWF  21
0AB0:  BCF    03.5
0AB1:  MOVF   5F,W
0AB2:  BSF    03.5
0AB3:  MOVWF  25
0AB4:  BCF    03.5
0AB5:  MOVF   5E,W
0AB6:  BSF    03.5
0AB7:  MOVWF  24
0AB8:  BCF    03.5
0AB9:  MOVF   5D,W
0ABA:  BSF    03.5
0ABB:  MOVWF  23
0ABC:  BCF    03.5
0ABD:  MOVF   5C,W
0ABE:  BSF    03.5
0ABF:  MOVWF  22
0AC0:  BCF    0A.3
0AC1:  BCF    03.5
0AC2:  CALL   20B
0AC3:  BSF    0A.3
0AC4:  BSF    03.5
....................    } 
.................... } 
....................  
.................... void doTest(void) 
.................... { 
....................    if(DEBUG) {fputs("> Rutina de prueba",RS232);} 
*
02B3:  BTFSS  05.3
02B4:  GOTO   2C4
02B5:  MOVLW  68
02B6:  BSF    03.6
02B7:  MOVWF  0D
02B8:  MOVLW  07
02B9:  MOVWF  0F
02BA:  BCF    03.6
02BB:  CALL   125
02BC:  MOVLW  0D
02BD:  BTFSS  0C.4
02BE:  GOTO   2BD
02BF:  MOVWF  19
02C0:  MOVLW  0A
02C1:  BTFSS  0C.4
02C2:  GOTO   2C1
02C3:  MOVWF  19
....................    output_bit(CENLOCAL, OFF); 
02C4:  BCF    07.2
02C5:  MOVLW  D8
02C6:  BSF    03.5
02C7:  MOVWF  07
....................    output_bit(CENVISITA, OFF); 
02C8:  BCF    03.5
02C9:  BCF    09.2
02CA:  MOVLW  E0
02CB:  BSF    03.5
02CC:  MOVWF  09
....................    output_bit(POSLOCAL, OFF); 
02CD:  BCF    03.5
02CE:  BCF    07.1
02CF:  MOVLW  D8
02D0:  BSF    03.5
02D1:  MOVWF  07
....................    output_bit(POSVISITA, OFF); 
02D2:  BCF    03.5
02D3:  BCF    09.1
02D4:  MOVLW  E0
02D5:  BSF    03.5
02D6:  MOVWF  09
....................     
....................    for(int i=0; i<10; i++) 
02D7:  CLRF   20
02D8:  MOVF   20,W
02D9:  SUBLW  09
02DA:  BTFSS  03.0
02DB:  GOTO   379
....................    { 
....................       showNumber(i, pLocalD); 
02DC:  MOVF   20,W
02DD:  MOVWF  21
02DE:  BCF    03.5
02DF:  MOVF   4F,W
02E0:  BSF    03.5
02E1:  MOVWF  25
02E2:  BCF    03.5
02E3:  MOVF   4E,W
02E4:  BSF    03.5
02E5:  MOVWF  24
02E6:  BCF    03.5
02E7:  MOVF   4D,W
02E8:  BSF    03.5
02E9:  MOVWF  23
02EA:  BCF    03.5
02EB:  MOVF   4C,W
02EC:  BSF    03.5
02ED:  MOVWF  22
02EE:  BCF    03.5
02EF:  CALL   20B
....................       showNumber(i, pLocalU); 
02F0:  BSF    03.5
02F1:  MOVF   20,W
02F2:  MOVWF  21
02F3:  BCF    03.5
02F4:  MOVF   4B,W
02F5:  BSF    03.5
02F6:  MOVWF  25
02F7:  BCF    03.5
02F8:  MOVF   4A,W
02F9:  BSF    03.5
02FA:  MOVWF  24
02FB:  BCF    03.5
02FC:  MOVF   49,W
02FD:  BSF    03.5
02FE:  MOVWF  23
02FF:  BCF    03.5
0300:  MOVF   48,W
0301:  BSF    03.5
0302:  MOVWF  22
0303:  BCF    03.5
0304:  CALL   20B
....................       showNumber(i, pVisitaD); 
0305:  BSF    03.5
0306:  MOVF   20,W
0307:  MOVWF  21
0308:  BCF    03.5
0309:  MOVF   57,W
030A:  BSF    03.5
030B:  MOVWF  25
030C:  BCF    03.5
030D:  MOVF   56,W
030E:  BSF    03.5
030F:  MOVWF  24
0310:  BCF    03.5
0311:  MOVF   55,W
0312:  BSF    03.5
0313:  MOVWF  23
0314:  BCF    03.5
0315:  MOVF   54,W
0316:  BSF    03.5
0317:  MOVWF  22
0318:  BCF    03.5
0319:  CALL   20B
....................       showNumber(i, pVisitaU); 
031A:  BSF    03.5
031B:  MOVF   20,W
031C:  MOVWF  21
031D:  BCF    03.5
031E:  MOVF   53,W
031F:  BSF    03.5
0320:  MOVWF  25
0321:  BCF    03.5
0322:  MOVF   52,W
0323:  BSF    03.5
0324:  MOVWF  24
0325:  BCF    03.5
0326:  MOVF   51,W
0327:  BSF    03.5
0328:  MOVWF  23
0329:  BCF    03.5
032A:  MOVF   50,W
032B:  BSF    03.5
032C:  MOVWF  22
032D:  BCF    03.5
032E:  CALL   20B
....................       showNumber(i, pFLocal); 
032F:  BSF    03.5
0330:  MOVF   20,W
0331:  MOVWF  21
0332:  BCF    03.5
0333:  MOVF   5B,W
0334:  BSF    03.5
0335:  MOVWF  25
0336:  BCF    03.5
0337:  MOVF   5A,W
0338:  BSF    03.5
0339:  MOVWF  24
033A:  BCF    03.5
033B:  MOVF   59,W
033C:  BSF    03.5
033D:  MOVWF  23
033E:  BCF    03.5
033F:  MOVF   58,W
0340:  BSF    03.5
0341:  MOVWF  22
0342:  BCF    03.5
0343:  CALL   20B
....................       showNumber(i, pFVisita); 
0344:  BSF    03.5
0345:  MOVF   20,W
0346:  MOVWF  21
0347:  BCF    03.5
0348:  MOVF   5F,W
0349:  BSF    03.5
034A:  MOVWF  25
034B:  BCF    03.5
034C:  MOVF   5E,W
034D:  BSF    03.5
034E:  MOVWF  24
034F:  BCF    03.5
0350:  MOVF   5D,W
0351:  BSF    03.5
0352:  MOVWF  23
0353:  BCF    03.5
0354:  MOVF   5C,W
0355:  BSF    03.5
0356:  MOVWF  22
0357:  BCF    03.5
0358:  CALL   20B
....................       output_toggle(POSLOCAL); 
0359:  MOVLW  D8
035A:  BSF    03.5
035B:  MOVWF  07
035C:  MOVLW  02
035D:  BCF    03.5
035E:  XORWF  07,F
....................       output_toggle(POSVISITA); 
035F:  MOVLW  E0
0360:  BSF    03.5
0361:  MOVWF  09
0362:  MOVLW  02
0363:  BCF    03.5
0364:  XORWF  09,F
....................       output_toggle(CENLOCAL); 
0365:  MOVLW  D8
0366:  BSF    03.5
0367:  MOVWF  07
0368:  MOVLW  04
0369:  BCF    03.5
036A:  XORWF  07,F
....................       output_toggle(CENVISITA); 
036B:  MOVLW  E0
036C:  BSF    03.5
036D:  MOVWF  09
036E:  MOVLW  04
036F:  BCF    03.5
0370:  XORWF  09,F
....................       delay_ms(DEFAULT_D); 
0371:  MOVLW  C8
0372:  BSF    03.5
0373:  MOVWF  21
0374:  BCF    03.5
0375:  CALL   29F
0376:  BSF    03.5
0377:  INCF   20,F
0378:  GOTO   2D8
....................    } 
0379:  BCF    03.5
037A:  RETURN
.................... } 
....................  
.................... void parseCommand(void) 
.................... { 
....................    char c[10]; 
....................    strcpy(c, cmd); 
*
038F:  BSF    03.5
0390:  CLRF   23
0391:  MOVLW  2C
0392:  MOVWF  22
0393:  CLRF   21
0394:  MOVLW  6B
0395:  MOVWF  20
0396:  MOVF   22,W
0397:  MOVWF  04
0398:  BCF    03.7
0399:  BTFSC  23.0
039A:  BSF    03.7
039B:  MOVF   00,W
039C:  MOVWF  24
039D:  MOVF   20,W
039E:  MOVWF  04
039F:  BCF    03.7
03A0:  BTFSC  21.0
03A1:  BSF    03.7
03A2:  MOVF   24,W
03A3:  MOVWF  00
03A4:  MOVF   00,F
03A5:  BTFSC  03.2
03A6:  GOTO   3AA
03A7:  INCF   20,F
03A8:  INCF   22,F
03A9:  GOTO   396
....................    switch(c[0]) 
03AA:  BCF    03.5
03AB:  MOVF   6B,W
03AC:  XORLW  30
03AD:  BTFSC  03.2
03AE:  GOTO   3CB
03AF:  XORLW  71
03B0:  BTFSC  03.2
03B1:  GOTO   48B
03B2:  XORLW  03
03B3:  BTFSC  03.2
03B4:  GOTO   4A7
03B5:  XORLW  01
03B6:  BTFSC  03.2
03B7:  GOTO   4C3
03B8:  XORLW  07
03B9:  BTFSC  03.2
03BA:  GOTO   4DF
03BB:  XORLW  01
03BC:  BTFSC  03.2
03BD:  GOTO   4F6
03BE:  XORLW  03
03BF:  BTFSC  03.2
03C0:  GOTO   50D
03C1:  XORLW  01
03C2:  BTFSC  03.2
03C3:  GOTO   524
03C4:  XORLW  1F
03C5:  BTFSC  03.2
03C6:  GOTO   53B
03C7:  XORLW  02
03C8:  BTFSC  03.2
03C9:  GOTO   53D
03CA:  GOTO   5D3
....................    { 
....................       case '0':   if(DEBUG) {fputs("\r> Activacion manual de puerto",RS232);} 
03CB:  BTFSS  05.3
03CC:  GOTO   3DC
03CD:  MOVLW  72
03CE:  BSF    03.6
03CF:  MOVWF  0D
03D0:  MOVLW  07
03D1:  MOVWF  0F
03D2:  BCF    03.6
03D3:  CALL   125
03D4:  MOVLW  0D
03D5:  BTFSS  0C.4
03D6:  GOTO   3D5
03D7:  MOVWF  19
03D8:  MOVLW  0A
03D9:  BTFSS  0C.4
03DA:  GOTO   3D9
03DB:  MOVWF  19
....................                   switch(c[2]) 
03DC:  MOVLW  31
03DD:  SUBWF  6D,W
03DE:  ADDLW  FA
03DF:  BTFSC  03.0
03E0:  GOTO   48A
03E1:  ADDLW  06
03E2:  GOTO   5D6
....................                   { 
....................                      case '1':   showNumber(char2int(c[3]), pLocalU); 
03E3:  MOVF   6E,W
03E4:  BSF    03.5
03E5:  MOVWF  20
03E6:  BCF    03.5
03E7:  CALL   19B
03E8:  MOVF   78,W
03E9:  BSF    03.5
03EA:  MOVWF  20
03EB:  MOVWF  21
03EC:  BCF    03.5
03ED:  MOVF   4B,W
03EE:  BSF    03.5
03EF:  MOVWF  25
03F0:  BCF    03.5
03F1:  MOVF   4A,W
03F2:  BSF    03.5
03F3:  MOVWF  24
03F4:  BCF    03.5
03F5:  MOVF   49,W
03F6:  BSF    03.5
03F7:  MOVWF  23
03F8:  BCF    03.5
03F9:  MOVF   48,W
03FA:  BSF    03.5
03FB:  MOVWF  22
03FC:  BCF    03.5
03FD:  CALL   20B
....................                                  break; 
03FE:  GOTO   48A
....................                      case '2':   showNumber(char2int(c[3]), pLocalD); 
03FF:  MOVF   6E,W
0400:  BSF    03.5
0401:  MOVWF  20
0402:  BCF    03.5
0403:  CALL   19B
0404:  MOVF   78,W
0405:  BSF    03.5
0406:  MOVWF  20
0407:  MOVWF  21
0408:  BCF    03.5
0409:  MOVF   4F,W
040A:  BSF    03.5
040B:  MOVWF  25
040C:  BCF    03.5
040D:  MOVF   4E,W
040E:  BSF    03.5
040F:  MOVWF  24
0410:  BCF    03.5
0411:  MOVF   4D,W
0412:  BSF    03.5
0413:  MOVWF  23
0414:  BCF    03.5
0415:  MOVF   4C,W
0416:  BSF    03.5
0417:  MOVWF  22
0418:  BCF    03.5
0419:  CALL   20B
....................                                  break; 
041A:  GOTO   48A
....................                      case '3':   showNumber(char2int(c[3]), pVisitaD); 
041B:  MOVF   6E,W
041C:  BSF    03.5
041D:  MOVWF  20
041E:  BCF    03.5
041F:  CALL   19B
0420:  MOVF   78,W
0421:  BSF    03.5
0422:  MOVWF  20
0423:  MOVWF  21
0424:  BCF    03.5
0425:  MOVF   57,W
0426:  BSF    03.5
0427:  MOVWF  25
0428:  BCF    03.5
0429:  MOVF   56,W
042A:  BSF    03.5
042B:  MOVWF  24
042C:  BCF    03.5
042D:  MOVF   55,W
042E:  BSF    03.5
042F:  MOVWF  23
0430:  BCF    03.5
0431:  MOVF   54,W
0432:  BSF    03.5
0433:  MOVWF  22
0434:  BCF    03.5
0435:  CALL   20B
....................                                  break; 
0436:  GOTO   48A
....................                      case '4':   showNumber(char2int(c[3]), pVisitaU); 
0437:  MOVF   6E,W
0438:  BSF    03.5
0439:  MOVWF  20
043A:  BCF    03.5
043B:  CALL   19B
043C:  MOVF   78,W
043D:  BSF    03.5
043E:  MOVWF  20
043F:  MOVWF  21
0440:  BCF    03.5
0441:  MOVF   53,W
0442:  BSF    03.5
0443:  MOVWF  25
0444:  BCF    03.5
0445:  MOVF   52,W
0446:  BSF    03.5
0447:  MOVWF  24
0448:  BCF    03.5
0449:  MOVF   51,W
044A:  BSF    03.5
044B:  MOVWF  23
044C:  BCF    03.5
044D:  MOVF   50,W
044E:  BSF    03.5
044F:  MOVWF  22
0450:  BCF    03.5
0451:  CALL   20B
....................                                  break; 
0452:  GOTO   48A
....................                      case '5':   showNumber(char2int(c[3]), pFLocal); 
0453:  MOVF   6E,W
0454:  BSF    03.5
0455:  MOVWF  20
0456:  BCF    03.5
0457:  CALL   19B
0458:  MOVF   78,W
0459:  BSF    03.5
045A:  MOVWF  20
045B:  MOVWF  21
045C:  BCF    03.5
045D:  MOVF   5B,W
045E:  BSF    03.5
045F:  MOVWF  25
0460:  BCF    03.5
0461:  MOVF   5A,W
0462:  BSF    03.5
0463:  MOVWF  24
0464:  BCF    03.5
0465:  MOVF   59,W
0466:  BSF    03.5
0467:  MOVWF  23
0468:  BCF    03.5
0469:  MOVF   58,W
046A:  BSF    03.5
046B:  MOVWF  22
046C:  BCF    03.5
046D:  CALL   20B
....................                                  break; 
046E:  GOTO   48A
....................                      case '6':   showNumber(char2int(c[3]), pFVisita); 
046F:  MOVF   6E,W
0470:  BSF    03.5
0471:  MOVWF  20
0472:  BCF    03.5
0473:  CALL   19B
0474:  MOVF   78,W
0475:  BSF    03.5
0476:  MOVWF  20
0477:  MOVWF  21
0478:  BCF    03.5
0479:  MOVF   5F,W
047A:  BSF    03.5
047B:  MOVWF  25
047C:  BCF    03.5
047D:  MOVF   5E,W
047E:  BSF    03.5
047F:  MOVWF  24
0480:  BCF    03.5
0481:  MOVF   5D,W
0482:  BSF    03.5
0483:  MOVWF  23
0484:  BCF    03.5
0485:  MOVF   5C,W
0486:  BSF    03.5
0487:  MOVWF  22
0488:  BCF    03.5
0489:  CALL   20B
....................                                  break; 
....................                   } 
....................                   break; 
048A:  GOTO   5D3
....................       case 'A':   if(DEBUG) {fputs("> Apagar Posicion",RS232);} 
048B:  BTFSS  05.3
048C:  GOTO   49C
048D:  MOVLW  82
048E:  BSF    03.6
048F:  MOVWF  0D
0490:  MOVLW  07
0491:  MOVWF  0F
0492:  BCF    03.6
0493:  CALL   125
0494:  MOVLW  0D
0495:  BTFSS  0C.4
0496:  GOTO   495
0497:  MOVWF  19
0498:  MOVLW  0A
0499:  BTFSS  0C.4
049A:  GOTO   499
049B:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, OFF); 
049C:  BCF    07.1
049D:  MOVLW  D8
049E:  BSF    03.5
049F:  MOVWF  07
04A0:  BCF    03.5
04A1:  BCF    09.1
04A2:  MOVLW  E0
04A3:  BSF    03.5
04A4:  MOVWF  09
....................                            break; 
04A5:  BCF    03.5
04A6:  GOTO   5D3
....................       case 'B':   if(DEBUG) {fputs("> Activar Posicion Local",RS232);} 
04A7:  BTFSS  05.3
04A8:  GOTO   4B8
04A9:  MOVLW  8B
04AA:  BSF    03.6
04AB:  MOVWF  0D
04AC:  MOVLW  07
04AD:  MOVWF  0F
04AE:  BCF    03.6
04AF:  CALL   125
04B0:  MOVLW  0D
04B1:  BTFSS  0C.4
04B2:  GOTO   4B1
04B3:  MOVWF  19
04B4:  MOVLW  0A
04B5:  BTFSS  0C.4
04B6:  GOTO   4B5
04B7:  MOVWF  19
....................                            output_bit(POSLOCAL, ON); output_bit(POSVISITA, OFF); 
04B8:  BSF    07.1
04B9:  MOVLW  D8
04BA:  BSF    03.5
04BB:  MOVWF  07
04BC:  BCF    03.5
04BD:  BCF    09.1
04BE:  MOVLW  E0
04BF:  BSF    03.5
04C0:  MOVWF  09
....................                            break; 
04C1:  BCF    03.5
04C2:  GOTO   5D3
....................       case 'C':   if(DEBUG) {fputs("> Activar Posicion Visita",RS232);} 
04C3:  BTFSS  05.3
04C4:  GOTO   4D4
04C5:  MOVLW  98
04C6:  BSF    03.6
04C7:  MOVWF  0D
04C8:  MOVLW  07
04C9:  MOVWF  0F
04CA:  BCF    03.6
04CB:  CALL   125
04CC:  MOVLW  0D
04CD:  BTFSS  0C.4
04CE:  GOTO   4CD
04CF:  MOVWF  19
04D0:  MOVLW  0A
04D1:  BTFSS  0C.4
04D2:  GOTO   4D1
04D3:  MOVWF  19
....................                            output_bit(POSLOCAL, OFF); output_bit(POSVISITA, ON); 
04D4:  BCF    07.1
04D5:  MOVLW  D8
04D6:  BSF    03.5
04D7:  MOVWF  07
04D8:  BCF    03.5
04D9:  BSF    09.1
04DA:  MOVLW  E0
04DB:  BSF    03.5
04DC:  MOVWF  09
....................                            break; 
04DD:  BCF    03.5
04DE:  GOTO   5D3
....................       case 'D':   if(DEBUG) {fputs("> Activar Centena Local",RS232);} 
04DF:  BTFSS  05.3
04E0:  GOTO   4F0
04E1:  MOVLW  A5
04E2:  BSF    03.6
04E3:  MOVWF  0D
04E4:  MOVLW  07
04E5:  MOVWF  0F
04E6:  BCF    03.6
04E7:  CALL   125
04E8:  MOVLW  0D
04E9:  BTFSS  0C.4
04EA:  GOTO   4E9
04EB:  MOVWF  19
04EC:  MOVLW  0A
04ED:  BTFSS  0C.4
04EE:  GOTO   4ED
04EF:  MOVWF  19
....................                            output_bit(CENLOCAL, ON); 
04F0:  BSF    07.2
04F1:  MOVLW  D8
04F2:  BSF    03.5
04F3:  MOVWF  07
....................                            break; 
04F4:  BCF    03.5
04F5:  GOTO   5D3
....................       case 'E':   if(DEBUG) {fputs("> Desactivar Centena Local",RS232);} 
04F6:  BTFSS  05.3
04F7:  GOTO   507
04F8:  MOVLW  B1
04F9:  BSF    03.6
04FA:  MOVWF  0D
04FB:  MOVLW  07
04FC:  MOVWF  0F
04FD:  BCF    03.6
04FE:  CALL   125
04FF:  MOVLW  0D
0500:  BTFSS  0C.4
0501:  GOTO   500
0502:  MOVWF  19
0503:  MOVLW  0A
0504:  BTFSS  0C.4
0505:  GOTO   504
0506:  MOVWF  19
....................                            output_bit(CENLOCAL, OFF); 
0507:  BCF    07.2
0508:  MOVLW  D8
0509:  BSF    03.5
050A:  MOVWF  07
....................                            break; 
050B:  BCF    03.5
050C:  GOTO   5D3
....................       case 'F':   if(DEBUG) {fputs("> Activar Centena Visita",RS232);} 
050D:  BTFSS  05.3
050E:  GOTO   51E
050F:  MOVLW  BF
0510:  BSF    03.6
0511:  MOVWF  0D
0512:  MOVLW  07
0513:  MOVWF  0F
0514:  BCF    03.6
0515:  CALL   125
0516:  MOVLW  0D
0517:  BTFSS  0C.4
0518:  GOTO   517
0519:  MOVWF  19
051A:  MOVLW  0A
051B:  BTFSS  0C.4
051C:  GOTO   51B
051D:  MOVWF  19
....................                            output_bit(CENVISITA, ON); 
051E:  BSF    09.2
051F:  MOVLW  E0
0520:  BSF    03.5
0521:  MOVWF  09
....................                            break; 
0522:  BCF    03.5
0523:  GOTO   5D3
....................       case 'G':   if(DEBUG) {fputs("> Desactivar Centena Visita",RS232);} 
0524:  BTFSS  05.3
0525:  GOTO   535
0526:  MOVLW  CC
0527:  BSF    03.6
0528:  MOVWF  0D
0529:  MOVLW  07
052A:  MOVWF  0F
052B:  BCF    03.6
052C:  CALL   125
052D:  MOVLW  0D
052E:  BTFSS  0C.4
052F:  GOTO   52E
0530:  MOVWF  19
0531:  MOVLW  0A
0532:  BTFSS  0C.4
0533:  GOTO   532
0534:  MOVWF  19
....................                            output_bit(CENVISITA, OFF); 
0535:  BCF    09.2
0536:  MOVLW  E0
0537:  BSF    03.5
0538:  MOVWF  09
....................                            break;             
0539:  BCF    03.5
053A:  GOTO   5D3
....................       case 'X':   doTest(); //Rutina de prueba 
053B:  CALL   2B3
....................                   break; 
053C:  GOTO   5D3
....................       case 'Z':   if(DEBUG) {fputs("\r> Reseteo general...!",RS232);} 
053D:  BTFSS  05.3
053E:  GOTO   54E
053F:  MOVLW  DA
0540:  BSF    03.6
0541:  MOVWF  0D
0542:  MOVLW  07
0543:  MOVWF  0F
0544:  BCF    03.6
0545:  CALL   125
0546:  MOVLW  0D
0547:  BTFSS  0C.4
0548:  GOTO   547
0549:  MOVWF  19
054A:  MOVLW  0A
054B:  BTFSS  0C.4
054C:  GOTO   54B
054D:  MOVWF  19
....................                   delay_ms(100); 
054E:  MOVLW  64
054F:  BSF    03.5
0550:  MOVWF  21
0551:  BCF    03.5
0552:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (5)",RS232);} 
0553:  BTFSS  05.3
0554:  GOTO   564
0555:  MOVLW  E6
0556:  BSF    03.6
0557:  MOVWF  0D
0558:  MOVLW  07
0559:  MOVWF  0F
055A:  BCF    03.6
055B:  CALL   125
055C:  MOVLW  0D
055D:  BTFSS  0C.4
055E:  GOTO   55D
055F:  MOVWF  19
0560:  MOVLW  0A
0561:  BTFSS  0C.4
0562:  GOTO   561
0563:  MOVWF  19
....................                   delay_ms(100); 
0564:  MOVLW  64
0565:  BSF    03.5
0566:  MOVWF  21
0567:  BCF    03.5
0568:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (4)",RS232);} 
0569:  BTFSS  05.3
056A:  GOTO   57A
056B:  MOVLW  EA
056C:  BSF    03.6
056D:  MOVWF  0D
056E:  MOVLW  07
056F:  MOVWF  0F
0570:  BCF    03.6
0571:  CALL   125
0572:  MOVLW  0D
0573:  BTFSS  0C.4
0574:  GOTO   573
0575:  MOVWF  19
0576:  MOVLW  0A
0577:  BTFSS  0C.4
0578:  GOTO   577
0579:  MOVWF  19
....................                   delay_ms(100); 
057A:  MOVLW  64
057B:  BSF    03.5
057C:  MOVWF  21
057D:  BCF    03.5
057E:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (3)",RS232);} 
057F:  BTFSS  05.3
0580:  GOTO   590
0581:  MOVLW  EE
0582:  BSF    03.6
0583:  MOVWF  0D
0584:  MOVLW  07
0585:  MOVWF  0F
0586:  BCF    03.6
0587:  CALL   125
0588:  MOVLW  0D
0589:  BTFSS  0C.4
058A:  GOTO   589
058B:  MOVWF  19
058C:  MOVLW  0A
058D:  BTFSS  0C.4
058E:  GOTO   58D
058F:  MOVWF  19
....................                   delay_ms(100); 
0590:  MOVLW  64
0591:  BSF    03.5
0592:  MOVWF  21
0593:  BCF    03.5
0594:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (2)",RS232);} 
0595:  BTFSS  05.3
0596:  GOTO   5A6
0597:  MOVLW  F2
0598:  BSF    03.6
0599:  MOVWF  0D
059A:  MOVLW  07
059B:  MOVWF  0F
059C:  BCF    03.6
059D:  CALL   125
059E:  MOVLW  0D
059F:  BTFSS  0C.4
05A0:  GOTO   59F
05A1:  MOVWF  19
05A2:  MOVLW  0A
05A3:  BTFSS  0C.4
05A4:  GOTO   5A3
05A5:  MOVWF  19
....................                   delay_ms(100); 
05A6:  MOVLW  64
05A7:  BSF    03.5
05A8:  MOVWF  21
05A9:  BCF    03.5
05AA:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (1)",RS232);} 
05AB:  BTFSS  05.3
05AC:  GOTO   5BC
05AD:  MOVLW  F6
05AE:  BSF    03.6
05AF:  MOVWF  0D
05B0:  MOVLW  07
05B1:  MOVWF  0F
05B2:  BCF    03.6
05B3:  CALL   125
05B4:  MOVLW  0D
05B5:  BTFSS  0C.4
05B6:  GOTO   5B5
05B7:  MOVWF  19
05B8:  MOVLW  0A
05B9:  BTFSS  0C.4
05BA:  GOTO   5B9
05BB:  MOVWF  19
....................                   delay_ms(100); 
05BC:  MOVLW  64
05BD:  BSF    03.5
05BE:  MOVWF  21
05BF:  BCF    03.5
05C0:  CALL   29F
....................                   if(DEBUG) {fputs("\r> (0)",RS232);} 
05C1:  BTFSS  05.3
05C2:  GOTO   5D2
05C3:  MOVLW  FA
05C4:  BSF    03.6
05C5:  MOVWF  0D
05C6:  MOVLW  07
05C7:  MOVWF  0F
05C8:  BCF    03.6
05C9:  CALL   125
05CA:  MOVLW  0D
05CB:  BTFSS  0C.4
05CC:  GOTO   5CB
05CD:  MOVWF  19
05CE:  MOVLW  0A
05CF:  BTFSS  0C.4
05D0:  GOTO   5CF
05D1:  MOVWF  19
....................                   doReset(); 
05D2:  CALL   37B
....................                    
....................    } 
05D3:  BCF    0A.3
05D4:  BCF    0A.4
05D5:  GOTO   60A (RETURN)
.................... } 
....................  
.................... void showNumber(int8 n, tPort p) 
*
020B:  BSF    03.5
020C:  BCF    26.0
020D:  BCF    26.1
020E:  BCF    26.2
020F:  BCF    26.3
.................... { 
....................    int1 a=0, b=0, c=0, d=0; 
....................    switch(n) 
0210:  MOVLW  01
0211:  SUBWF  21,W
0212:  ADDLW  F7
0213:  BTFSC  03.0
0214:  GOTO   23A
0215:  ADDLW  09
0216:  BCF    03.5
0217:  GOTO   292
....................    { 
....................       case 1:  a=1; 
0218:  BSF    03.5
0219:  BSF    26.0
....................                break; 
021A:  GOTO   23A
....................       case 2:  b=1; 
021B:  BSF    03.5
021C:  BSF    26.1
....................                break; 
021D:  GOTO   23A
....................       case 3:  a=1; b=1; 
021E:  BSF    03.5
021F:  BSF    26.0
0220:  BSF    26.1
....................                break; 
0221:  GOTO   23A
....................       case 4:  c=1; 
0222:  BSF    03.5
0223:  BSF    26.2
....................                break; 
0224:  GOTO   23A
....................       case 5:  c=1; a=1; 
0225:  BSF    03.5
0226:  BSF    26.2
0227:  BSF    26.0
....................                break; 
0228:  GOTO   23A
....................       case 6:  c=1; b=1; 
0229:  BSF    03.5
022A:  BSF    26.2
022B:  BSF    26.1
....................                break; 
022C:  GOTO   23A
....................       case 7:  c=1; b=1; a=1; 
022D:  BSF    03.5
022E:  BSF    26.2
022F:  BSF    26.1
0230:  BSF    26.0
....................                break; 
0231:  GOTO   23A
....................       case 8:  d=1; 
0232:  BSF    03.5
0233:  BSF    26.3
....................                break; 
0234:  GOTO   23A
....................       case 9:  d=1; a=1; 
0235:  BSF    03.5
0236:  BSF    26.3
0237:  BSF    26.0
....................                break; 
0238:  GOTO   23A
0239:  BSF    03.5
....................    } 
....................    output_bit(p.a, a); 
023A:  MOVLW  00
023B:  BTFSC  26.0
023C:  MOVLW  01
023D:  MOVWF  77
023E:  MOVF   22,W
023F:  MOVWF  27
0240:  MOVF   77,W
0241:  MOVWF  28
0242:  CLRF   2A
0243:  CLRF   29
0244:  BCF    03.5
0245:  CALL   1E9
0246:  BSF    03.5
0247:  MOVF   22,W
0248:  MOVWF  27
0249:  CLRF   28
024A:  CLRF   2A
024B:  MOVLW  80
024C:  MOVWF  29
024D:  BCF    03.5
024E:  CALL   1E9
....................    output_bit(p.b, b); 
024F:  MOVLW  00
0250:  BSF    03.5
0251:  BTFSC  26.1
0252:  MOVLW  01
0253:  MOVWF  77
0254:  MOVF   23,W
0255:  MOVWF  27
0256:  MOVF   77,W
0257:  MOVWF  28
0258:  CLRF   2A
0259:  CLRF   29
025A:  BCF    03.5
025B:  CALL   1E9
025C:  BSF    03.5
025D:  MOVF   23,W
025E:  MOVWF  27
025F:  CLRF   28
0260:  CLRF   2A
0261:  MOVLW  80
0262:  MOVWF  29
0263:  BCF    03.5
0264:  CALL   1E9
....................    output_bit(p.c, c); 
0265:  MOVLW  00
0266:  BSF    03.5
0267:  BTFSC  26.2
0268:  MOVLW  01
0269:  MOVWF  77
026A:  MOVF   24,W
026B:  MOVWF  27
026C:  MOVF   77,W
026D:  MOVWF  28
026E:  CLRF   2A
026F:  CLRF   29
0270:  BCF    03.5
0271:  CALL   1E9
0272:  BSF    03.5
0273:  MOVF   24,W
0274:  MOVWF  27
0275:  CLRF   28
0276:  CLRF   2A
0277:  MOVLW  80
0278:  MOVWF  29
0279:  BCF    03.5
027A:  CALL   1E9
....................    output_bit(p.d, d); 
027B:  MOVLW  00
027C:  BSF    03.5
027D:  BTFSC  26.3
027E:  MOVLW  01
027F:  MOVWF  77
0280:  MOVF   25,W
0281:  MOVWF  27
0282:  MOVF   77,W
0283:  MOVWF  28
0284:  CLRF   2A
0285:  CLRF   29
0286:  BCF    03.5
0287:  CALL   1E9
0288:  BSF    03.5
0289:  MOVF   25,W
028A:  MOVWF  27
028B:  CLRF   28
028C:  CLRF   2A
028D:  MOVLW  80
028E:  MOVWF  29
028F:  BCF    03.5
0290:  CALL   1E9
0291:  RETURN
.................... } 
....................  
.................... int8 char2int(char c) 
.................... { 
....................    switch(c) 
*
019B:  MOVLW  30
019C:  BSF    03.5
019D:  SUBWF  20,W
019E:  ADDLW  F6
019F:  BTFSC  03.0
01A0:  GOTO   1D7
01A1:  ADDLW  0A
01A2:  BCF    03.5
01A3:  GOTO   1DB
....................    { 
....................       case '0':   return 0; 
01A4:  MOVLW  00
01A5:  MOVWF  78
01A6:  GOTO   1DA
....................                   break; 
01A7:  BSF    03.5
01A8:  GOTO   1D7
....................       case '1':   return 1; 
01A9:  MOVLW  01
01AA:  MOVWF  78
01AB:  GOTO   1DA
....................                   break; 
01AC:  BSF    03.5
01AD:  GOTO   1D7
....................       case '2':   return 2; 
01AE:  MOVLW  02
01AF:  MOVWF  78
01B0:  GOTO   1DA
....................                   break; 
01B1:  BSF    03.5
01B2:  GOTO   1D7
....................       case '3':   return 3; 
01B3:  MOVLW  03
01B4:  MOVWF  78
01B5:  GOTO   1DA
....................                   break; 
01B6:  BSF    03.5
01B7:  GOTO   1D7
....................       case '4':   return 4; 
01B8:  MOVLW  04
01B9:  MOVWF  78
01BA:  GOTO   1DA
....................                   break; 
01BB:  BSF    03.5
01BC:  GOTO   1D7
....................       case '5':   return 5; 
01BD:  MOVLW  05
01BE:  MOVWF  78
01BF:  GOTO   1DA
....................                   break; 
01C0:  BSF    03.5
01C1:  GOTO   1D7
....................       case '6':   return 6; 
01C2:  MOVLW  06
01C3:  MOVWF  78
01C4:  GOTO   1DA
....................                   break; 
01C5:  BSF    03.5
01C6:  GOTO   1D7
....................       case '7':   return 7; 
01C7:  MOVLW  07
01C8:  MOVWF  78
01C9:  GOTO   1DA
....................                   break; 
01CA:  BSF    03.5
01CB:  GOTO   1D7
....................       case '8':   return 8; 
01CC:  MOVLW  08
01CD:  MOVWF  78
01CE:  GOTO   1DA
....................                   break; 
01CF:  BSF    03.5
01D0:  GOTO   1D7
....................       case '9':   return 9; 
01D1:  MOVLW  09
01D2:  MOVWF  78
01D3:  GOTO   1DA
....................                   break; 
01D4:  BSF    03.5
01D5:  GOTO   1D7
01D6:  BSF    03.5
....................    } 
....................    return 0; 
01D7:  MOVLW  00
01D8:  MOVWF  78
01D9:  BCF    03.5
01DA:  RETURN
.................... } 
....................  
.................... void doReset(void) 
.................... { 
....................    if(DEBUG) {fputs("> Reseteando...",RS232);} 
*
037B:  BTFSS  05.3
037C:  GOTO   38C
037D:  MOVLW  CA
037E:  BSF    03.6
037F:  MOVWF  0D
0380:  MOVLW  0A
0381:  MOVWF  0F
0382:  BCF    03.6
0383:  CALL   125
0384:  MOVLW  0D
0385:  BTFSS  0C.4
0386:  GOTO   385
0387:  MOVWF  19
0388:  MOVLW  0A
0389:  BTFSS  0C.4
038A:  GOTO   389
038B:  MOVWF  19
....................    reset_cpu(); 
038C:  CLRF   0A
038D:  GOTO   000
038E:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 2CD4   INTRC_IO NOWDT NOPUT NOMCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
